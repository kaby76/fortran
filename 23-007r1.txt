WD 1539-1
    J3/23-007r1
  (Draft Fortran 2023)
        <b>13th</b> <b>June</b> <b>2023</b> <b>16:07</b>
    This is an internal working document of INCITS/Fortran and
          ISO/IEC JTC1/SC22/WG5.
          <b>NOTE:</b> This Working Draft is only available as a PDF file.
                This page intentionally left nonblank.
<b>Contents</b>
Foreword . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xii
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xiii
1 Scope . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
2 Normative references . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
3 Terms and definitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
4 Notation, conformance, and compatibility . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
 4.1 Notation, symbols and abbreviated terms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
    4.1.1 Syntax rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
    4.1.2 Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
    4.1.3 Assumed syntax rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
    4.1.4 Syntax conventions and characteristics . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
    4.1.5 Text conventions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
 4.2 Conformance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
 4.3 Compatibility . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
    4.3.1 Previous Fortran standards . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
    4.3.2 New intrinsic procedures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
    4.3.3 Fortran 2018 compatibility . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
    4.3.4 Fortran 2008 compatibility . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
    4.3.5 Fortran 2003 compatibility . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
    4.3.6 Fortran 95 compatibility . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
    4.3.7 Fortran 90 compatibility . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
    4.3.8 FORTRAN 77 compatibility . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
 4.4 Deleted and obsolescent features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
    4.4.1 General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
    4.4.2 Nature of deleted features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
    4.4.3 Nature of obsolescent features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
5 Fortran concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
 5.1 High level syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
 5.2 Program unit concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
    5.2.1 Program units and scoping units . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
    5.2.2 Program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
    5.2.3 Procedure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
    5.2.4 Module . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
    5.2.5 Submodule . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
 5.3 Execution concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
    5.3.1 Statement classification . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
    5.3.2 Statement order . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
    5.3.3 The END statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
    5.3.4 Program execution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
    5.3.5 Execution sequence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
    5.3.6 Image execution states . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
    5.3.7 Termination of execution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
 5.4 Data concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
    5.4.1 Type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
    5.4.2 Data value . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
    5.4.3 Data entity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
    5.4.4 Definition of objects and pointers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
    5.4.5 Reference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
    5.4.6 Array . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
    5.4.7 Coarray . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
    5.4.8 Established coarrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
    5.4.9 Pointer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
    5.4.10 Allocatable variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
    5.4.11 Storage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
 5.5 Fundamental concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
    5.5.1 Names and designators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
    5.5.2 Statement keyword . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
    5.5.3 Other keywords . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
    5.5.4 Association . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
    5.5.5 Intrinsic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
    5.5.6 Operator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
    5.5.7 Companion processors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
6 Lexical tokens and source form . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
 6.1 Processor character set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
    6.1.1 Characters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
    6.1.2 Letters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
    6.1.3 Digits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
    6.1.4 Underscore . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
    6.1.5 Special characters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
    6.1.6 Other characters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
 6.2 Low-level syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
    6.2.1 Tokens . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
    6.2.2 Names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
    6.2.3 Constants . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
    6.2.4 Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
    6.2.5 Statement labels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55
    6.2.6 Delimiters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55
 6.3 Source form . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
    6.3.1 Program units, statements, and lines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
    6.3.2 Free source form . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
    6.3.3 Fixed source form . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
 6.4 Including source text . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
7 Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
 7.1 Characteristics of types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
    7.1.1 The concept of type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
    7.1.2 Type classification . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
    7.1.3 Set of values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
    7.1.4 Constants . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
    7.1.5 Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
 7.2 Type parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61
 7.3 Types, type specifiers, and values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62
    7.3.1 Relationship of types and values to objects . . . . . . . . . . . . . . . . . . . . . . . . . . 62
    7.3.2 Type specifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62
    7.3.3 Type compatibility . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
 7.4 Intrinsic types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
    7.4.1 Classification and specification . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
    7.4.2 Intrinsic operations on intrinsic types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
    7.4.3 Numeric intrinsic types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
    7.4.4 Character type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
    7.4.5 Logical type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
 7.5 Derived types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
    7.5.1 Derived type concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
    7.5.2 Derived-type definition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73
    7.5.3 Derived-type parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
    7.5.4 Components . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78
    7.5.5 Type-bound procedures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
    7.5.6 Final subroutines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87
    7.5.7 Type extension . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
    7.5.8 Derived-type values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91
    7.5.9 Derived-type specifier . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91
    7.5.10 Construction of derived-type values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91
    7.5.11 Derived-type operations and assignment . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
 7.6 Other nonintrinsic types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
    7.6.1 Interoperable enumerations and enum types . . . . . . . . . . . . . . . . . . . . . . . . . 94
    7.6.2 Enumeration types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96
 7.7 Binary, octal, and hexadecimal literal constants . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98
 7.8 Construction of array values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99
8 Attribute declarations and specifications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
 8.1 Attributes of procedures and data objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
 8.2 Type declaration statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
 8.3 Automatic data objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104
 8.4 Initialization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104
 8.5 Attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104
    8.5.1 Attribute specification . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104
    8.5.2 Accessibility attribute . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
    8.5.3 ALLOCATABLE attribute . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
    8.5.4 ASYNCHRONOUS attribute . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
    8.5.5 BIND attribute for data entities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106
    8.5.6 CODIMENSION attribute . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106
    8.5.7 CONTIGUOUS attribute . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108
    8.5.8 DIMENSION attribute . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
    8.5.9 EXTERNAL attribute . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
    8.5.10 INTENT attribute . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
    8.5.11 INTRINSIC attribute . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
    8.5.12 OPTIONAL attribute . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
    8.5.13 PARAMETER attribute . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
    8.5.14 POINTER attribute . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
    8.5.15 PROTECTED attribute . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
    8.5.16 SAVE attribute . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
    8.5.17 RANK clause . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
    8.5.18 TARGET attribute . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118
    8.5.19 VALUE attribute . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118
    8.5.20 VOLATILE attribute . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118
 8.6 Attribute specification statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119
    8.6.1 Accessibility statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119
    8.6.2 ALLOCATABLE statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120
    8.6.3 ASYNCHRONOUS statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120
    8.6.4 BIND statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120
    8.6.5 CODIMENSION statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121
    8.6.6 CONTIGUOUS statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121
    8.6.7 DATA statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121
    8.6.8 DIMENSION statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
    8.6.9 INTENT statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124
    8.6.10 OPTIONAL statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124
    8.6.11 PARAMETER statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124
    8.6.12 POINTER statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124
    8.6.13 PROTECTED statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
    8.6.14 SAVE statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
    8.6.15 TARGET statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
    8.6.16 VALUE statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
    8.6.17 VOLATILE statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126
 8.7 IMPLICIT statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126
 8.8 IMPORT statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128
 8.9 NAMELIST statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
 8.10 Storage association of data objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
    8.10.1 EQUIVALENCE statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
    8.10.2 COMMON statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
    8.10.3 Restrictions on common and equivalence . . . . . . . . . . . . . . . . . . . . . . . . . . . 134
9 Use of data objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
 9.1 Designator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
 9.2 Variable . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
 9.3 Constants . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136
 9.4 Scalars . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136
    9.4.1 Substrings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136
    9.4.2 Structure components . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136
    9.4.3 Coindexed named objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138
    9.4.4 Complex parts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138
    9.4.5 Type parameter inquiry . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138
 9.5 Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139
    9.5.1 Order of reference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139
    9.5.2 Whole arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139
    9.5.3 Array elements and array sections . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139
    9.5.4 Simply contiguous array designators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143
 9.6 Image selectors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143
 9.7 Dynamic association . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145
    9.7.1 ALLOCATE statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145
    9.7.2 NULLIFY statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149
    9.7.3 DEALLOCATE statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149
    9.7.4 STAT= specifier . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151
    9.7.5 ERRMSG= specifier . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152
10 Expressions and assignment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
 10.1 Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
    10.1.1 Expression semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
    10.1.2 Form of an expression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
    10.1.3 Precedence of operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157
    10.1.4 Evaluation of operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159
    10.1.5 Intrinsic operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
    10.1.6 Defined operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 166
    10.1.7 Evaluation of operands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167
    10.1.8 Integrity of parentheses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168
    10.1.9 Type, type parameters, and shape of an expression . . . . . . . . . . . . . . . . . . . . . 168
    10.1.10 Conformability rules for elemental operations . . . . . . . . . . . . . . . . . . . . . . . . 170
    10.1.11 Specification expression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 170
    10.1.12 Constant expression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 172
 10.2 Assignment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173
    10.2.1 Assignment statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173
    10.2.2 Pointer assignment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178
    10.2.3 Masked array assignment - WHERE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 182
    10.2.4 FORALL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185
11 Execution control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188
 11.1 Executable constructs containing blocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188
    11.1.1 Blocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188
    11.1.2 Rules governing blocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188
    11.1.3 ASSOCIATE construct . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 189
    11.1.4 BLOCK construct . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 190
    11.1.5 CHANGE TEAM construct . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 192
    11.1.6 CRITICAL construct . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194
    11.1.7 DO construct . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195
    11.1.8 IF construct and statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203
    11.1.9 SELECT CASE construct . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 204
    11.1.10 SELECT RANK construct . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 207
    11.1.11 SELECT TYPE construct . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 209
    11.1.12 EXIT statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212
 11.2 Branching . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212
    11.2.1 Branch concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212
    11.2.2 GO TO statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212
    11.2.3 Computed GO TO statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213
 11.3 CONTINUE statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213
 11.4 STOP and ERROR STOP statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213
 11.5 FAIL IMAGE statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 214
 11.6 NOTIFY WAIT statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 214
 11.7 Image execution control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 215
    11.7.1 Image control statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 215
    11.7.2 Segments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 216
    11.7.3 SYNC ALL statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217
    11.7.4 SYNC IMAGES statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 218
    11.7.5 SYNC MEMORY statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 219
    11.7.6 SYNC TEAM statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 220
    11.7.7 EVENT POST statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 221
    11.7.8 EVENT WAIT statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 221
    11.7.9 FORM TEAM statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 221
    11.7.10 LOCK and UNLOCK statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 222
    11.7.11 STAT= and ERRMSG= specifiers in image control statements . . . . . . . . . . . . . . . 224
12 Input/output statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 227
 12.1 Input/output concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 227
 12.2 Records . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 227
    12.2.1 Definition of a record . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 227
    12.2.2 Formatted record . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 227
    12.2.3 Unformatted record . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 227
    12.2.4 Endfile record . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 228
 12.3 External files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 228
    12.3.1 External file concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 228
    12.3.2 File existence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 228
    12.3.3 File access . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 229
    12.3.4 File position . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 231
    12.3.5 File storage units . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232
 12.4 Internal files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 233
 12.5 File connection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 233
    12.5.1 Referring to a file . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 233
    12.5.2 Connection modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 234
    12.5.3 Unit existence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 235
    12.5.4 Connection of a file to a unit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 235
    12.5.5 Preconnection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 236
    12.5.6 OPEN statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 236
    12.5.7 CLOSE statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240
 12.6 Data transfer statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 242
    12.6.1 Form of input and output statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 242
    12.6.2 Control information list . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 242
    12.6.3 Data transfer input/output list . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 247
    12.6.4 Execution of a data transfer input/output statement . . . . . . . . . . . . . . . . . . . . 249
    12.6.5 Termination of data transfer statements . . . . . . . . . . . . . . . . . . . . . . . . . . . 260
 12.7 Waiting on pending data transfer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 260
    12.7.1 Wait operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 260
    12.7.2 WAIT statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 260
 12.8 File positioning statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 261
    12.8.1 Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 261
    12.8.2 BACKSPACE statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 262
    12.8.3 ENDFILE statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 262
    12.8.4 REWIND statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 262
 12.9 FLUSH statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 263
 12.10 File inquiry statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 263
    12.10.1 Forms of the INQUIRE statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 263
    12.10.2 Inquiry specifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264
    12.10.3 Inquire by output list . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270
 12.11 Error, end-of-record, and end-of-file conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270
    12.11.1 Occurrence of input/output conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270
    12.11.2 Error conditions and the ERR= specifier . . . . . . . . . . . . . . . . . . . . . . . . . . . 271
    12.11.3 End-of-file condition and the END= specifier . . . . . . . . . . . . . . . . . . . . . . . . . 271
    12.11.4 End-of-record condition and the EOR= specifier . . . . . . . . . . . . . . . . . . . . . . . 272
    12.11.5 IOSTAT= specifier . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 272
    12.11.6 IOMSG= specifier . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273
 12.12 Restrictions on input/output statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273
13 Input/output editing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 274
 13.1 Format specifications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 274
 13.2 Explicit format specification methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 274
    13.2.1 FORMAT statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 274
    13.2.2 Character format specification . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 274
 13.3 Form of a format item list . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 275
    13.3.1 Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 275
    13.3.2 Edit descriptors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 275
    13.3.3 Fields . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 277
 13.4 Interaction between input/output list and format . . . . . . . . . . . . . . . . . . . . . . . . . . . 277
 13.5 Positioning by format control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 279
 13.6 Decimal symbol . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 279
 13.7 Data edit descriptors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 279
    13.7.1 Purpose of data edit descriptors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 279
    13.7.2 Numeric editing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280
    13.7.3 Logical editing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 287
    13.7.4 Character editing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 287
    13.7.5 Generalized editing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 288
    13.7.6 User-defined derived-type editing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 289
 13.8 Control edit descriptors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 289
    13.8.1 Position edit descriptors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 289
    13.8.2 Slash editing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 290
    13.8.3 Colon editing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 291
    13.8.4 SS, SP, and S editing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 291
    13.8.5 LZS, LZP and LZ editing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 291
    13.8.6 P editing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 291
    13.8.7 BN and BZ editing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 292
    13.8.8 RU, RD, RZ, RN, RC, and RP editing . . . . . . . . . . . . . . . . . . . . . . . . . . . . 292
    13.8.9 DC and DP editing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 292
 13.9 Character string edit descriptors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 292
 13.10 List-directed formatting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 293
    13.10.1 Purpose of list-directed formatting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 293
    13.10.2 Values and value separators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 293
    13.10.3 List-directed input . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 293
    13.10.4 List-directed output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 295
 13.11 Namelist formatting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 297
    13.11.1 Purpose of namelist formatting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 297
    13.11.2 Name-value subsequences . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 297
    13.11.3 Namelist input . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 297
    13.11.4 Namelist output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 300
14 Program units . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 302
 14.1 Main program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 302
 14.2 Modules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 302
    14.2.1 Module syntax and semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 302
    14.2.2 The USE statement and use association . . . . . . . . . . . . . . . . . . . . . . . . . . . . 303
    14.2.3 Submodules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 306
 14.3 Block data program units . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 306
15 Procedures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 308
 15.1 Concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 308
 15.2 Procedure classifications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 308
    15.2.1 Procedure classification by reference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 308
    15.2.2 Procedure classification by means of definition . . . . . . . . . . . . . . . . . . . . . . . . 308
 15.3 Characteristics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 309
    15.3.1 Characteristics of procedures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 309
    15.3.2 Characteristics of dummy arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 309
    15.3.3 Characteristics of function results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 309
 15.4 Procedure interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 310
    15.4.1 Interface and abstract interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 310
    15.4.2 Implicit and explicit interfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 310
    15.4.3 Specification of the procedure interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . 311
 15.5 Procedure reference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 320
    15.5.1 Syntax of a procedure reference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 320
    15.5.2 Actual arguments, dummy arguments, and argument association . . . . . . . . . . . . . . 322
    15.5.3 Function reference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 334
    15.5.4 Subroutine reference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 334
    15.5.5 Resolving named procedure references . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 335
    15.5.6 Resolving type-bound procedure references . . . . . . . . . . . . . . . . . . . . . . . . . . 337
 15.6 Procedure definition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 337
    15.6.1 Intrinsic procedure definition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 337
    15.6.2 Procedures defined by subprograms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 337
    15.6.3 Definition and invocation of procedures by means other than Fortran . . . . . . . . . . . 343
    15.6.4 Statement function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 343
 15.7 Pure procedures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 344
 15.8 Simple procedures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 346
 15.9 Elemental procedures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 347
    15.9.1 Elemental procedure declaration and interface . . . . . . . . . . . . . . . . . . . . . . . . 347
    15.9.2 Elemental function actual arguments and results . . . . . . . . . . . . . . . . . . . . . . . 347
    15.9.3 Elemental subroutine actual arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . 348
16 Intrinsic procedures and modules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 349
 16.1 Classes of intrinsic procedures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 349
 16.2 Arguments to intrinsic procedures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 349
    16.2.1 General rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 349
    16.2.2 The shape of array arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 350
    16.2.3 Mask arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 350
    16.2.4 DIM arguments and reduction functions . . . . . . . . . . . . . . . . . . . . . . . . . . . 350
 16.3 Bit model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 350
    16.3.1 General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 350
    16.3.2 Bit sequence comparisons . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 351
    16.3.3 Bit sequences as arguments to INT and REAL . . . . . . . . . . . . . . . . . . . . . . . . 351
 16.4 Numeric models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 351
 16.5 Atomic subroutines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 352
 16.6 Collective subroutines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 353
 16.7 Standard generic intrinsic procedures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 354
 16.8 Specific names for standard intrinsic functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 359
 16.9 Specifications of the standard intrinsic procedures . . . . . . . . . . . . . . . . . . . . . . . . . . . 361
    16.9.1 General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361
 16.10 Standard intrinsic modules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 456
    16.10.1 General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 456
    16.10.2 The ISO_FORTRAN_ENV intrinsic module . . . . . . . . . . . . . . . . . . . . . . . . 457
17 Exceptions and IEEE arithmetic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 464
 17.1 Overview of IEEE arithmetic support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 464
 17.2 Derived types, constants, and operators defined in the modules . . . . . . . . . . . . . . . . . . . 465
 17.3 The exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 465
 17.4 The rounding modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 468
 17.5 Underflow mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 468
 17.6 Halting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 469
 17.7 The floating-point modes and status . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 469
 17.8 Exceptional values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 469
 17.9 IEEE arithmetic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 469
 17.10 Summary of the procedures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 470
 17.11 Specifications of the procedures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 472
    17.11.1 General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 472
 17.12 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 498
18 Interoperability with C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 501
 18.1 General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 501
 18.2 The ISO_C_BINDING intrinsic module . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 501
    18.2.1 Summary of contents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 501
    18.2.2 Named constants and derived types in the module . . . . . . . . . . . . . . . . . . . . . . 501
    18.2.3 Procedures in the module . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 502
 18.3 Interoperability between Fortran and C entities . . . . . . . . . . . . . . . . . . . . . . . . . . . . 510
    18.3.1 Interoperability of intrinsic types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 510
    18.3.2 Interoperability with C pointer types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 511
    18.3.3 Interoperability of enum types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 511
    18.3.4 Interoperability of derived types and C structure types . . . . . . . . . . . . . . . . . . . 511
    18.3.5 Interoperability of scalar variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 512
    18.3.6 Interoperability of array variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 513
    18.3.7 Interoperability of procedures and procedure interfaces . . . . . . . . . . . . . . . . . . . 513
 18.4 C descriptors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 516
 18.5 The source file ISO_Fortran_binding.h . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 516
    18.5.1 Summary of contents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 516
    18.5.2 The CFI_dim_t structure type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 516
    18.5.3 The CFI_cdesc_t structure type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 517
    18.5.4 Macros and typedefs in ISO_Fortran_binding.h . . . . . . . . . . . . . . . . . . . . . . . 518
    18.5.5 Functions declared in ISO_Fortran_binding.h . . . . . . . . . . . . . . . . . . . . . . . . 520
 18.6 Restrictions on C descriptors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 528
 18.7 Restrictions on formal parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 528
 18.8 Restrictions on lifetimes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 528
 18.9 Interoperation with C global variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 529
    18.9.1 General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 529
    18.9.2 Binding labels for common blocks and variables . . . . . . . . . . . . . . . . . . . . . . . 530
 18.10 Interoperation with C functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 530
    18.10.1 Definition and reference of interoperable procedures . . . . . . . . . . . . . . . . . . . . . 530
    18.10.2 Binding labels for procedures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 531
    18.10.3 Exceptions and IEEE arithmetic procedures . . . . . . . . . . . . . . . . . . . . . . . . . 531
    18.10.4 Asynchronous communication . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 532
19 Scope, association, and definition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 533
 19.1 Scopes, identifiers, and entities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 533
 19.2 Global identifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 533
 19.3 Local identifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 534
    19.3.1 Classes of local identifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 534
    19.3.2 Local identifiers that are the same as common block names . . . . . . . . . . . . . . . . . 535
    19.3.3 Function results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 535
    19.3.4 Components, type parameters, and bindings . . . . . . . . . . . . . . . . . . . . . . . . . 535
    19.3.5 Argument keywords . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 535
 19.4 Statement and construct entities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 536
 19.5 Association . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 537
    19.5.1 Name association . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 537
    19.5.2 Pointer association . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 541
    19.5.3 Storage association . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 544
    19.5.4 Inheritance association . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 546
    19.5.5 Establishing associations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 546
 19.6 Definition and undefinition of variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 547
    19.6.1 Definition of objects and subobjects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 547
    19.6.2 Variables that are always defined . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 547
    19.6.3 Variables that are initially defined . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 547
    19.6.4 Variables that are initially undefined . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 548
    19.6.5 Events that cause variables to become defined . . . . . . . . . . . . . . . . . . . . . . . . 548
    19.6.6 Events that cause variables to become undefined . . . . . . . . . . . . . . . . . . . . . . . 550
    19.6.7 Variable definition context . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 552
    19.6.8 Pointer association context . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 553
Annex A (informative) Processor dependencies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 554
Annex B (informative) Deleted and obsolescent features . . . . . . . . . . . . . . . . . . . . . . . . . . . . 561
Annex C (informative) Extended notes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 565
Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 642
<b>Foreword</b>
ISO (the International Organization for Standardization) and IEC (the International Electrotechnical Commis-
sion) form the specialized system for worldwide standardization. National bodies that are members of ISO or
IEC participate in the development of International Standards through technical committees established by the
respective organization to deal with particular fields of technical activity. ISO and IEC technical committees
collaborate in fields of mutual interest. Other international organizations, governmental and non-governmental,
in liaison with ISO and IEC, also take part in the work.
The procedures used to develop this document and those intended for its further maintenance are described in
the ISO/IEC Directives, Part 1. In particular, the different approval criteria needed for the different types of
document should be noted. This document was drafted in accordance with the editorial rules of the ISO/IEC
Directives, Part 2 (see www.iso.org/directives or www.iec.ch/members_experts/refdocs).
Attention is drawn to the possibility that some of the elements of this document may be the subject of patent
rights. ISO and IEC shall not be held responsible for identifying any or all such patent rights. Details of any
patent rights identified during the development of the document will be in the Introduction and/or on the ISO
list of patent declarations received (see www.iso.org/patents) or the IEC list of patent declarations received
(see https://patents.iec.ch).
Any trade name used in this document is information given for the convenience of users and does not constitute
an endorsement.
For an explanation of the voluntary nature of standards, the meaning of ISO specific terms and expressions
related to conformity assessment, as well as information about ISO's adherence to the World Trade Organization
(WTO) principles in the Technical Barriers to Trade (TBT) see www.iso.org/iso/foreword.html. In the IEC,
see www.iec.ch/understanding-standards.
This document was prepared by Joint Technical Committee ISO/IEC JTC 1, <i>Information</i> <i>technology</i>, Subcom-
mittee SC 22, <i>Programming</i> <i>languages,</i> <i>their</i> <i>environments</i> <i>and</i> <i>system</i> <i>software</i> <i>interfaces</i>.
This fifth edition cancels and replaces the fourth edition (ISO/IEC 1539-1:2018), which has been technically
revised.
The main changes are as follows:
 - an array can have a coarray component;
 - additional forms of declaration;
 - additional edit descriptors;
 - additional intrinsic procedures;
 - conformance with ISO/IEC 60559:2020;
 - other changes listed in the Introduction.
A list of all parts in the ISO/IEC 1539 series can be found on the ISO and IEC websites.
Any feedback or questions on this document should be directed to the user's national standards body. A complete
listing of these bodies can be found at www.iso.org/members.html and www.iec.ch/national-committees.
<b>Introduction</b>
This document comprises the specification of the base Fortran language, informally known as Fortran 2023.
With the limitations noted in 4.3.3, the syntax and semantics of Fortran 2018 are contained entirely within
Fortran 2023. Therefore, any standard-conforming Fortran 2018 program not affected by such limitations is a
standard-conforming Fortran 2023 program. New features of Fortran 2023 can be compatibly incorporated into
such Fortran 2018 programs, with any exceptions indicated in the text of this document.
Fortran 2023 contains several extensions to Fortran 2018; these are listed below.
 Source form:
  The maximum length of a line in free form source has been increased. The maximum length of a statement
  has been increased. The limit on the number of continuation lines has been removed.
 Data declaration:
  A data object with a coarray component can be an array or allocatable. BIND(C) ENUM are now referred
  to as interoperable enumerations, and noninteroperable enumeration types are available. An interoperable
  enumeration can be given a type name. TYPEOF and CLASSOF type specifiers can be used to declare one
  or more entities to have the same type and type parameters as another entity. A PUBLIC namelist group
  can have a PRIVATE namelist group object. The DIMENSION attribute can be declared with a syntax
  that does not depend on the rank (8.5.8, 8.5.17).
 Data usage and computation:
  Binary, octal, and hexadecimal literal constants can be used in additional contexts. A deferred-length
  allocatable <i>errmsg-variable</i> is allocated by the processor to the length of the explanatory message. An
  ALLOCATE statement can specify the bounds of an array allocation with array expressions. A pointer
  assignment statement can specify lower bounds or rank remapping with array expressions. Arrays can be
  used to specify multiple subscripts or subscript triplets (9.5.3.2). Conditional expressions provide selective
  evaluation of subexpressions.
 Input/output:
  The AT edit descriptor provides output of character values with trailing blanks trimmed. The LEADING_-
  ZERO= specifier in the OPEN and WRITE statements, and the LZP, LZS and LZ control edit descriptors,
  provide control of optional leading zeros during formatted output. A deferred-length allocatable <i>iomsg-</i>
  <i>variable</i> isallocatedbytheprocessortothelengthoftheexplanatorymessage. Adeferred-lengthallocatable
  scalar <i>io-unit</i> in a WRITE statement is allocated by the processor to the length of the record to be written.
 Execution control:
  The REDUCE locality specifier for the DO CONCURRENT construct specifies reduction variables for the
  loop. The NOTIFY WAIT statement, NOTIFY= specifier on an image selector, and the NOTIFY_TYPE
  from the intrinsic module ISO_FORTRAN_ENV provide one-sided data-oriented synchronization between
  images.
 Intrinsic procedures:
  The intrinsic functions ACOSD, ASIND, ATAND, ATAN2D, COSD, SIND, and TAND are trigonometric
  functions in which angles are specified in degrees. The intrinsic functions ACOSPI, ASINPI, ATANPI,
  ATAN2PI, COSPI, SINPI, and TANPI are trigonometric functions in which angles are specified in half-
  revolutions (that is, as multiples of ). The intrinsic function SELECTED_LOGICAL_KIND returns kind
  type parameter values for type logical. The intrinsic subroutine SPLIT parses a string into tokens, one at
  a time. The intrinsic subroutine SYSTEM_CLOCK supports more than one system clock for an image.
  The intrinsic subroutine TOKENIZE parses a string into tokens. When a deferred-length allocatable actual
  argument of an intrinsic procedure is assigned character data, it is allocated by the processor to the length
  of the data. Execution of a collective subroutine can be successful on an image even when an error condition
  occurs for the corresponding execution on another image.
 Intrinsic modules:
  Additional named constants LOGICAL8, LOGICAL16, LOGICAL32, LOGICAL64, and REAL16 have
  been added to the intrinsic module ISO_FORTRAN_ENV. The subroutines IEEE_GET_ROUNDING_-
  MODE, IEEE_GET_UNDERFLOW_MODE, IEEE_SET_ROUNDING_MODE, and IEEE_SET_UN-
  DERFLOW_MODE, from the intrinsic module IEEE_ARITHMETIC, are now considered to be pure
  and simple. The subroutines IEEE_GET_MODES, IEEE_GET_STATUS, IEEE_SET_MODES, and
  IEEE_SET_STATUS, from the intrinsic module IEEE_EXCEPTIONS, are now considered to be pure
  and simple. The procedures C_F_STRPOINTER and F_C_STRING have been added to the intrinsic
  module ISO_C_BINDING to assist in the use of null-terminated strings. The subroutine C_F_POINTER
  in the intrinsic module ISO_C_BINDING has an extra optional dummy argument, LOWER, that specifies
  the lower bounds for FPTR.
 Changes to the intrinsic module IEEE_ARITHMETIC for conformance with ISO/IEC 60559:2020:
  The new functions IEEE_MAX, IEEE_MAX_MAG, IEEE_MIN, and IEEE_MIN_MAG perform the op-
  erations maximum, maximumMagnitude, minimum, and miminumMagnitude in ISO/IEC 60559:2020. The
  functions IEEE_MAX_NUM, IEEE_MAX_NUM_MAG, IEEE_MIN_NUM, and IEEE_MIN_NUM_-
  MAG now conform to the operations maximumNumber, maximumMagnitudeNumber, minimumNumber
  and minimumMagnitudeNumber in ISO/IEC 60559:2020; the changes affect the treatment of zeros and
  NaNs.
 Program units and procedures:
  A procedure can be specified to be a simple procedure; a simple procedure references or defines nonlocal
  variables only via its dummy arguments. Conditional arguments provide actual argument selection in a
  procedure reference.
This document is organized in 19 clauses, dealing with 8 conceptual areas. These 8 areas, and the clauses in
which they are treated, are:
            High/low level concepts Clauses 4, 5, 6
            Data concepts Clauses 7, 8, 9
            Computations Clauses 10, 16, 17
            Execution control Clause 11
            Input/output Clauses 12, 13
            Program units Clauses 14, 15
            Interoperability with C Clause 18
            Scoping and association rules Clause 19
It also contains the following nonnormative material:
            Processor dependencies Annex A
            Deleted and obsolescent features Annex B
            Extended notes Annex C
            Index Index
<b>Information</b> <b>technology</b> <b>-</b> <b>Programming</b> <b>languages</b> <b>-</b>
<b>Fortran</b> <b>-</b>
<b>Part</b> <b>1:</b>
Base language
<b>1</b> <b>Scope</b>
This document specifies the form and establishes the interpretation of programs expressed in the base Fortran
language. The purpose of this document is to promote portability, reliability, maintainability, and efficient
execution of Fortran programs for use on a variety of computing systems.
This document specifies
 the forms that a program written in the Fortran language can take,
 the rules for interpreting the meaning of a program and its data,
 the form of the input data to be processed by such a program, and
 the form of the output data resulting from the use of such a program.
Except where stated otherwise, requirements and prohibitions specified by this document apply to programs
rather than processors.
This document does not specify
 the mechanism by which programs are transformed for use on computing systems,
 the operations required for setup and control of the use of programs on computing systems,
 the method of transcription of programs or their input or output data to or from a storage medium,
 the program and processor behavior when this document fails to establish an interpretation except for the
  processor detection and reporting requirements in items (2) to (10) of 4.2,
 the maximum number of images, or the size or complexity of a program and its data that will exceed the
  capacity of any particular computing system or the capability of a particular processor,
 the mechanism for determining the number of images of a program,
 the physical properties of an image or the relationship between images and the computational elements of
  a computing system,
 the physical properties of the representation of quantities and the method of rounding, approximating, or
  computing numeric values on a particular processor, except by reference to ISO/IEC 60559:2020 under
  conditions specified in Clause 17,
 the physical properties of input/output records, files, and units, or
 the physical properties and implementation of storage.
<b>2</b> <b>Normative</b> <b>references</b>
The following documents are referred to in the text in such a way that some or all of their content constitutes
requirements of this document. For dated references, only the edition cited applies. For undated references, the
latest edition of the referenced document (including any amendments) applies.
ISO/IEC 646:1991, <i>Information</i> <i>technology-ISO</i> <i>7-bit</i> <i>coded</i> <i>character</i> <i>set</i> <i>for</i> <i>information</i> <i>interchange</i>
ISO/IEC 9899:2018, <i>Programming</i> <i>languages-C</i>
ISO/IEC 10646, <i>Information</i> <i>technology-Universal</i> <i>Multiple-Octet</i> <i>Coded</i> <i>Character</i> <i>Set</i> <i>(UCS)</i>
ISO/IEC/IEEE 60559:2020, <i>Information</i> <i>technology</i> <i>-</i> <i>Microprocessor</i> <i>Systems</i> <i>-</i> <i>Floating-Point</i> <i>arithmetic</i>
<b>3</b> <b>Terms</b> <b>and</b> <b>definitions</b>
For the purposes of this document, the following terms and definitions apply.
ISO and IEC maintain terminology databases for use in standardization at the following addresses:
<b>-</b> ISO Online browsing platform: available at https://www.iso.org/obp
<b>-</b> IEC Electropedia: available at https://www.electropedia.org/
<b>3.1</b>
<b>actual</b> <b>argument</b>
entity that determines argument association
Note 1 to entry: See 15.5.2.3 and 15.5.2.4.
Note 2 to entry: An <i>actual-arg</i>, <i>consequent-arg</i>, or <i>variable</i> in a defined assignment statement, are all examples
of actual arguments.
<b>3.2</b>
<b>allocatable</b>
having the ALLOCATABLE attribute
Note 1 to entry: See 8.5.3.
<b>3.3</b>
<b>array</b>
set of scalar data, all of the same type and type parameters, whose individual elements are arranged in a
rectangular pattern
Note 1 to entry: See 8.5.8 and 9.5.
<b>3.3.1</b>
<b>array</b> <b>element</b>
scalar subobject of an array that has the same type and type parameters as the array
Note 1 to entry: Array elements are described in 9.5.3.
<b>3.3.2</b>
<b>array</b> <b>pointer</b>
array with the POINTER attribute
Note 1 to entry: The POINTER attribute is described in 8.5.14.
<b>3.3.3</b>
<b>array</b> <b>section</b>
array <i>subobject</i> (3.138) designated by <i>array-section</i>, and which is itself an array
Note 1 to entry: Array sections are described in 9.5.3.4.
<b>3.3.4</b>
<b>assumed-shape</b> <b>array</b>
nonallocatable nonpointer <i>dummy</i> <i>argument</i> (3.59) array that takes its shape from its <i>effective</i> <i>argument</i> (3.60)
Note 1 to entry: Assumed-shape arrays are described in 8.5.8.3.
<b>3.3.5</b>
<b>assumed-size</b> <b>array</b>
<i>dummy</i> <i>argument</i> (3.59) array whose size is assumed from that of its <i>effective</i> <i>argument</i> (3.60)
Note 1 to entry: Assumed-size arrays are described in 8.5.8.5.
<b>3.3.6</b>
<b>deferred-shape</b> <b>array</b>
<i>allocatable</i> (3.2) array or <i>array</i> <i>pointer</i> (3.3.2)
Note 1 to entry: Deferred-shape arrays are described in 8.5.8.4.
<b>3.3.7</b>
<b>explicit-shape</b> <b>array</b>
array declared with an <i>explicit-shape-spec-list</i> or <i>explicit-shape-bounds-spec</i>, which specifies explicit values for the
<i>bounds</i> (3.17) in each dimension of the array
Note 1 to entry: Explicit-shape arrays are described in 8.5.8.2.
<b>3.4</b>
<b>ASCII</b> <b>character</b>
character whose representation method corresponds to ISO/IEC 646:1991 (International Reference Version)
<b>3.5</b>
<b>associate</b> <b>name</b>
nameof<i>construct</i> <i>entity</i> (3.35)associatedwithaselectorofanASSOCIATE,CHANGETEAM,SELECTRANK,
or SELECT TYPE construct
Note 1 to entry: See 11.1.3, 11.1.5, 11.1.10, and 11.1.11.
<b>3.6</b>
<b>associating</b> <b>entity</b>
entity that did not exist prior to a dynamically-established association
Note 1 to entry: Dynamically-established associations are described in 19.5.5.
<b>3.7</b>
<b>association</b>
<i>inheritance</i> <i>association</i> (3.7.4), <i>name</i> <i>association</i> (3.7.6), <i>pointer</i> <i>association</i> (3.7.7), or <i>storage</i> <i>association</i> (3.7.8)
<b>3.7.1</b>
<b>argument</b> <b>association</b>
association between an <i>effective</i> <i>argument</i> (3.60) and a <i>dummy</i> <i>argument</i> (3.59)
Note 1 to entry: Argument association is described in 15.5.2.
<b>3.7.2</b>
<b>construct</b> <b>association</b>
association between a selector and an <i>associate</i> <i>name</i> (3.5) in an ASSOCIATE, CHANGE TEAM, SELECT
RANK, or SELECT TYPE construct(11.1.3, 11.1.5, 11.1.10, 11.1.11, 19.5.1.6)
<b>3.7.3</b>
<b>host</b> <b>association</b>
name association, other than argument association, between entities in a submodule or contained <i>scoping</i> <i>unit</i>
(3.120) and entities in its host
Note 1 to entry: Host association is described in 19.5.1.4.
<b>3.7.4</b>
<b>inheritance</b> <b>association</b>
association between the inherited components of an <i>extended</i> <i>type</i> (3.144.5) and the components of its <i>parent</i>
<i>component</i> (3.30.2)
Note 1 to entry: Inheritance association is described in 19.5.4.
<b>3.7.5</b>
<b>linkage</b> <b>association</b>
association between a variable or common block with the BIND attribute and a C global variable
Note 1 to entry: Linkage association is described in 18.9 and 19.5.1.5.
<b>3.7.6</b>
<b>name</b> <b>association</b>
<i>argument</i> <i>association</i> (3.7.1), <i>construct</i> <i>association</i> (3.7.2), <i>host</i> <i>association</i> (3.7.3), <i>linkage</i> <i>association</i> (3.7.5), or
<i>use</i> <i>association</i> (3.7.9)
Note 1 to entry: Name association is described in 19.5.1.
<b>3.7.7</b>
<b>pointer</b> <b>association</b>
association between a <i>pointer</i> (3.104) and a procedure or a variable with the TARGET attribute
Note 1 to entry: Pointer association is described in 19.5.2.
<b>3.7.8</b>
<b>storage</b> <b>association</b>
association between storage sequences
Note 1 to entry: Storage association is described in 19.5.3.
<b>3.7.9</b>
<b>use</b> <b>association</b>
association between entities in a module and entities in a scoping unit or construct that references that module,
as specified by a USE statement
Note 1 to entry: Use association is described in 14.2.2.
<b>3.8</b>
<b>assumed-rank</b> <b>dummy</b> <b>data</b> <b>object</b>
<i>dummy</i> <i>data</i> <i>object</i> (3.59.1) that assumes the rank, shape, and size of its <i>effective</i> <i>argument</i> (3.60)
Note 1 to entry: Assumed-rank entities are described in 8.5.8.7.
<b>3.9</b>
<b>assumed-type</b>
declared with a TYPE(*) type specifier (7.3.2)
<b>3.10</b>
<b>attribute</b>
property of an entity that determines its uses
Note 1 to entry: Attributes of procedures and data objects are described in 8.1.
<b>3.11</b>
<b>automatic</b> <b>data</b> <b>object</b>
nondummy <i>data</i> <i>object</i> (3.42) with a <i>type</i> <i>parameter</i> (3.144.12) or <i>array</i> <i>bound</i> (3.17) that depends on the value
of a <i>specification</i> <i>expression</i> (3.128) that is not a <i>constant</i> <i>expression</i> (3.36)
Note 1 to entry: Automatic data objects are described in 8.3.
<b>3.12</b>
<b>base</b> <b>object</b>
object designated by the leftmost <i>part-name</i>
Note 1 to entry: Base objects are described in 9.4.2.
Note 2 to entry: This only applies to the <i>data-ref</i> syntax (R911).
<b>3.13</b>
<b>binding</b>
<i>type-bound</i> <i>procedure</i> (3.109.7) or <i>final</i> <i>subroutine</i> (3.69)
<b>3.14</b>
<b>binding</b> <b>name</b>
name given to a specific or generic <i>type-bound</i> <i>procedure</i> (3.109.7) in the type definition
Note 1 to entry: Type-bound procedures are described in 7.5.5.
<b>3.15</b>
<b>binding</b> <b>label</b>
default character value specifying the name by which a global entity with the BIND attribute is known to the
<i>companion</i> <i>processor</i> (3.29)
Note 1 to entry: Binding labels are described in 18.10.2 and 18.9.2.
<b>3.16</b>
<b>block</b>
sequence of executable constructs formed by the syntactic class <i>block</i>
Note 1 to entry: A block is treated as a unit by the executable constructs described in 11.1.
<b>3.17</b>
<b>bound</b>
<b>array</b> <b>bound</b>
limit of a dimension of an <i>array</i> (3.3)
<b>3.18</b>
<b>branch</b> <b>target</b> <b>statement</b>
statement whose <i>statement</i> <i>label</i> (3.132) appears as a <i>label</i> in a GO TO statement, computed GO TO statement,
<i>alt-return-spec</i>, END= specifier, EOR= specifier, or ERR= specifier
Note 1 to entry: A branch target statement shall be an <i>action-stmt</i>, <i>associate-stmt</i>, <i>end-associate-stmt</i>, <i>if-then-</i>
<i>stmt</i>, <i>end-if-stmt</i>, <i>select-case-stmt</i>, <i>end-select-stmt</i>, <i>select-rank-stmt</i>, <i>end-select-rank-stmt</i>, <i>select-type-stmt</i>, <i>end-</i>
<i>select-type-stmt</i>, <i>do-stmt</i>, <i>end-do-stmt</i>, <i>block-stmt</i>, <i>end-block-stmt</i>, <i>critical-stmt</i>, <i>end-critical-stmt</i>, <i>forall-construct-</i>
<i>stmt</i>, <i>where-construct-stmt</i>, <i>end-function-stmt</i>, <i>end-mp-subprogram-stmt</i>, <i>end-program-stmt</i>, or <i>end-subroutine-</i>
<i>stmt</i>. Branching is described in 11.2.1.
<b>3.19</b>
<b>C</b> <b>address</b>
value of type C_PTR or C_FUNPTR from the intrinsic module ISO_C_BINDING identifying the location
Note 1 to entry: This is the concept that ISO/IEC 9899:2018 calls the address, of a variable or procedure.
<b>3.20</b>
<b>C</b> <b>descriptor</b>
C structure of type CFI_cdesc_t defined in the source file ISO_Fortran_binding.h
Note 1 to entry: C descriptors and the source file ISO_Fortran_binding.h are described in 18.4 and 18.5.
<b>3.21</b>
<b>character</b> <b>context</b>
within a character literal constant or within a character string edit descriptor
Note 1 to entry: Character literal constants are described in 7.4.4. Character string edit descriptors are described
in 13.3.2.
<b>3.22</b>
<b>characteristics</b>
properties used to determine compatibility or consistency
Note 1 to entry: A <i>dummy</i> <i>argument</i> (3.59) has the characteristic of being a <i>dummy</i> <i>data</i> <i>object</i> (3.59.1),
<i>dummy</i> <i>procedure</i> (3.109.1), or an asterisk (alternate return indicator). A <i>dummy</i> <i>data</i> <i>object</i> (3.59.1) has the additional
characteristics listed in 15.3.2.2. A <i>dummy</i> <i>procedure</i> (3.109.1) has the additional characteristics listed in 15.3.2.3.
A function result has the characteristics listed in 15.3.3. A procedure has the characteristics listed in 15.3.1. The
characteristics of intrinsic procedures are listed in 16.9
<b>3.23</b>
<b>coarray</b>
<i>component</i> (3.30), or <i>variable</i> (3.151), that has nonzero <i>corank</i> (3.39)
<b>3.23.1</b>
<b>established</b> <b>coarray</b>
<i>coarray</i> (3.23) that is accessible using an <i>image-selector</i>
Note 1 to entry: Established coarray are described in 5.4.8.
<b>3.24</b>
<b>cobound</b>
bound (limit) of a <i>codimension</i> (3.25)
<b>3.25</b>
<b>codimension</b>
dimension of the pattern formed by a set of corresponding <i>coarrays</i> (3.23)
<b>3.26</b>
<b>coindexed</b> <b>object</b>
<i>data</i> <i>object</i> (3.42) whose <i>designator</i> (3.56) includes an <i>image-selector</i>
Note 1 to entry: Image selectors are described in 9.6.
<b>3.27</b>
<b>collating</b> <b>sequence</b>
one-to-one mapping from a character set into the nonnegative integers
Note 1 to entry: Collating sequences are described in 7.4.4.4.
<b>3.28</b>
<b>common</b> <b>block</b>
block of physical storage specified by a COMMON statement
Note 1 to entry: COMMON blocks are described in 8.10.2.
<b>3.28.1</b>
<b>blank</b> <b>common</b>
unnamed common block
<b>3.29</b>
<b>companion</b> <b>processor</b>
processor-dependent mechanism by which global data and procedures can be referenced or defined
Note 1 to entry: Companion processors are described in 5.5.7.
<b>3.30</b>
<b>component</b>
part of a derived type, or of an object of derived type, defined by a <i>component-def-stmt</i>
Note 1 to entry: Components are described in 7.5.4.
<b>3.30.1</b>
<b>direct</b> <b>component</b>
one of the components, or one of the direct components of a nonpointer nonallocatable component
Note 1 to entry: See 7.5.1.
<b>3.30.2</b>
<b>parent</b> <b>component</b>
component of an <i>extended</i> <i>type</i> (3.144.5) whose type is that of the <i>parent</i> <i>type</i> (3.144.10) and whose components
are <i>inheritance</i> <i>associated</i> (3.7.4) with the <i>inherited</i> (3.84) components of the parent type
Note 1 to entry: Inheritance and the parent component are described in 7.5.7.2.
<b>3.30.3</b>
<b>potential</b> <b>subobject</b> <b>component</b>
nonpointer component, or potential subobject component of a nonpointer component
Note 1 to entry: See 7.5.1.
<b>3.30.4</b>
<b>subcomponent</b>
?<i>structure</i> (3.136)? <i>direct</i> <i>component</i> (3.30.1) that is a <i>subobject</i> (3.138) of the structure
Note 1 to entry: See 9.4.2.
<b>3.30.5</b>
<b>ultimate</b> <b>component</b>
component that is of <i>intrinsic</i> <i>type</i> (3.144.8), a <i>pointer</i> (3.104), or <i>allocatable</i> (3.2); or an ultimate component of
a nonpointer nonallocatable component of derived type
<b>3.31</b>
<b>component</b> <b>order</b>
ordering of the nonparent components of a derived type that is used for <i>intrinsic</i> (3.90) formatted input/output
and, where component keywords are not used, <i>structure</i> <i>constructors</i> (3.136.2)
Note 1 to entry: Component order is described in 7.5.4.7.
<b>3.32</b>
<b>conformable</b>
having the same shape, or one being an array and the other being scalar
Note 1 to entry: This is a relationship between two data entities.
<b>3.33</b>
<b>connected</b>
relationship between a <i>unit</i> (3.148) and a file: each is connected if and only if the unit refers to the file
Note 1 to entry: See 12.5.4.
<b>3.34</b>
<b>constant</b>
<i>data</i> <i>object</i> (3.42) that has a value and which cannot be defined, redefined, or become undefined during execution
of a program
Note 1 to entry: See 6.2.3 and 9.3.
<b>3.34.1</b>
<b>literal</b> <b>constant</b>
constant that does not have a name
Note 1 to entry: A literal constant has the syntax <i>literal-constant</i> (R605), and are of intrinsic type (7.4).
<b>3.34.2</b>
<b>named</b> <b>constant</b>
named <i>data</i> <i>object</i> (3.42) with the PARAMETER attribute
<b>3.35</b>
<b>construct</b> <b>entity</b>
entity whose identifier has the scope of a construct
Note 1 to entry: The scoping of such entities is described in 19.1 and 19.4.
<b>3.36</b>
<b>constant</b> <b>expression</b>
expression satisfying requirements that ensure its value is constant
Note 1 to entry: A constant expression shall satisfy the requirements in 10.1.12.
<b>3.37</b>
<b>contiguous</b>
?array? whose array elements, in order, are not separated by other data objects
Note 1 to entry: The requirements for contiguous are defined in 8.5.7.
<b>3.38</b>
<b>contiguous</b>
?multi-part data object? whose parts, in order, are not separated by other data objects
<b>3.39</b>
<b>corank</b>
number of <i>codimensions</i> (3.25) of a <i>coarray</i> (3.23), or zero for objects that are not coarrays
Note 1 to entry: See 5.4.7 and 8.5.6.
<b>3.40</b>
<b>cosubscript</b>
scalar integer expression in an image selector
Note 1 to entry: The syntax of an image selector is specified by the BNF rule <i>image-selector</i>(R926). The syntax
of a cosubscript is specified by the BNF rule <i>cosubscript</i>(R927).
<b>3.41</b>
<b>data</b> <b>entity</b>
<i>data</i> <i>object</i> (3.42), result of the evaluation of an expression, or the result of the execution of a function reference
<b>3.42</b>
<b>data</b> <b>object</b>
<b>object</b>
constant, variable, or subobject of a constant
Note 1 to entry: See 7.1.4, 9.2, and 5.4.3.2.4.
<b>3.43</b>
<b>decimal</b> <b>symbol</b>
character that separates the whole and fractional parts in the decimal representation of a real number in a file
Note 1 to entry: See 13.6.
<b>3.44</b>
<b>declaration</b>
specification of attributes for various program entities Note 1 to entry: Often this involves specifying the type
of a named data object or specifying the shape of a named array object.
<b>3.45</b>
<b>default</b> <b>initialization</b>
mechanism for automatically initializing pointer components to have a defined pointer association status, and
nonpointer components to have a particular value
Note 1 to entry: Default initialization is described in 7.5.4.6.
<b>3.46</b>
<b>default-initialized</b>
?<i>subcomponent</i> (3.30.4)?subjecttoa<i>default</i> <i>initialization</i> (3.45)specifiedinthetypedefinitionforthatcomponent
<b>3.47</b>
<b>definable</b>
capable of <i>definition</i> (3.53) and permitted to become <i>defined</i> (3.48)
<b>3.48</b>
<b>defined</b>
?<i>data</i> <i>object</i> (3.42)? with a valid value
<b>3.49</b>
<b>defined</b>
?<i>pointer</i> (3.104)? whose pointer association status is associated or disassociated
Note 1 to entry: Pointer association is described in 19.5.2.2.
<b>3.50</b>
<b>defined</b> <b>assignment</b>
assignment defined by a procedure
Note 1 to entry: See 10.2.1.4 and 15.4.3.4.3.
<b>3.51</b>
<b>defined</b> <b>input/output</b>
input/output defined by a procedure and accessed via a <i>defined-io-generic-spec</i>
Note 1 to entry: See syntax rule R1509, and 12.6.4.8.
<b>3.52</b>
<b>defined</b> <b>operation</b>
operation defined by a procedure
Note 1 to entry: See 10.1.6.1 and 15.4.3.4.2.
<b>3.53</b>
<b>definition</b>
?<i>data</i> <i>object</i> (3.42)? process by which the data object becomes defined
Note 1 to entry: Such events are listed in 19.6.5.
<b>3.54</b>
<b>definition</b>
?derived type, interoperable enumeration, enumeration type, or procedure? specification of the type, enumeration,
or procedure
Note 1 to entry: See 7.5.2, 7.6.1, 7.6.2, and 15.6.
<b>3.55</b>
<b>descendant</b>
submodule that extends a module or submodule, or that extends another descendant thereof
Note 1 to entry: This is a relationship between a module or submodule and a submodule. Submodules are
described in 14.2.3.
<b>3.56</b>
<b>designator</b>
name followed by zero or more component selectors, complex part selectors, array section selectors, array element
selectors, image selectors, and substring selectors
Note 1 to entry: Designators are defined in 9.1.
<b>3.56.1</b>
<b>complex</b> <b>part</b> <b>designator</b>
designator that designates the real or imaginary part of a complex <i>data</i> <i>object</i> (3.42), independently of the other
part
Note 1 to entry: Complex parts are described in 9.4.4.
<b>3.56.2</b>
<b>object</b> <b>designator</b>
<b>data</b> <b>object</b> <b>designator</b>
<i>designator</i> (3.56) for a <i>data</i> <i>object</i> (3.42)
Note 1 to entry: An object name is a special case of an object designator.
<b>3.56.3</b>
<b>procedure</b> <b>designator</b>
<i>designator</i> (3.56) for a procedure
<b>3.57</b>
<b>disassociated</b>
?pointer association? pointer association status of not being associated with any target and not being undefined
Note 1 to entry: Pointer association status is described in 19.5.2.2.
<b>3.58</b>
<b>disassociated</b>
?pointer? whose pointer association status is disassociated
<b>3.59</b>
<b>dummy</b> <b>argument</b>
entity whose identifier appears in a dummy argument list (R1539) in a FUNCTION, SUBROUTINE, ENTRY,
or statement function statement, or whose name can be used as an <i>argument</i> <i>keyword</i> (3.94.1) in a reference to an
<i>intrinsic</i> (3.90) procedure or a procedure in an intrinsic module
<b>3.59.1</b>
<b>dummy</b> <b>data</b> <b>object</b>
<i>dummy</i> <i>argument</i> (3.59) that is a data object
<b>3.59.2</b>
<b>dummy</b> <b>function</b>
<i>dummy</i> <i>procedure</i> (3.109.1) that is a function
<b>3.60</b>
<b>effective</b> <b>argument</b>
entity that is argument-associated with a <i>dummy</i> <i>argument</i> (3.59)
Note 1 to entry: Argument association is described in 15.5.2.4.
<b>3.61</b>
<b>effective</b> <b>item</b>
scalar object treated as a single entity in input/output
Note 1 to entry: An effective item results from the application of the rules in 12.6.3 to an input/output list.
<b>3.62</b>
<b>elemental</b>
independent scalar application of an action or operation to elements of an array or corresponding elements of a
set of conformable arrays and scalars, or possessing the capability of elemental operation
Note 1 to entry: Combination of scalar and array operands or arguments combine the scalar operand(s) with
each element of the array operand(s).
<b>3.62.1</b>
<b>elemental</b> <b>assignment</b>
assignment that operates elementally
<b>3.62.2</b>
<b>elemental</b> <b>operation</b>
operation that operates elementally
<b>3.62.3</b>
<b>elemental</b> <b>operator</b>
operator in an elemental operation
<b>3.62.4</b>
<b>elemental</b> <b>procedure</b>
procedure that can be used elementally
Note 1 to entry: User-defined elemental procedures are described in 15.9.
<b>3.62.5</b>
<b>elemental</b> <b>reference</b>
reference to an elemental procedure with at least one array actual argument
<b>3.62.6</b>
<b>elemental</b> <b>subprogram</b>
subprogram with the ELEMENTAL prefix
Note 1 to entry: See 15.9.1.
<b>3.63</b>
<b>END</b> <b>statement</b>
<i>end-block-data-stmt</i>, <i>end-function-stmt</i>, <i>end-module-stmt</i>, <i>end-mp-subprogram-stmt</i>, <i>end-program-stmt</i>,
<i>end-submodule-stmt</i>, or <i>end-subroutine-stmt</i>
<b>3.64</b>
<b>explicit</b> <b>initialization</b>
initialization of a data object by a specification statement
Note 1 to entry: See 8.4 and 8.6.7.
<b>3.65</b>
<b>extent</b>
number of elements in a single dimension of an <i>array</i> (3.3)
<b>3.66</b>
<b>external</b> <b>file</b>
file that exists in a medium external to the program (12.3)
<b>3.67</b>
<b>external</b> <b>unit</b>
<b>external</b> <b>input/output</b> <b>unit</b>
entity that can be <i>connected</i> (3.33) to an <i>external</i> <i>file</i> (3.66)
Note 1 to entry: External units and their connection are described in 12.5.3 and 12.5.4.
<b>3.68</b>
<b>file</b> <b>storage</b> <b>unit</b>
unit of storage in a <i>stream</i> <i>file</i> (3.135) or an unformatted <i>record</i> <i>file</i> (3.116)
Note 1 to entry: File storage units are described in 12.3.5.
<b>3.69</b>
<b>final</b> <b>subroutine</b>
subroutine whose name appears in a FINAL statement in a type definition, and which can be automatically
invoked by the processor when an object of that type is finalized
Note 1 to entry: See 7.5.6.
<b>3.70</b>
<b>finalizable</b>
?type? has a final subroutine or a nonpointer nonallocatable component of finalizable type
<b>3.71</b>
<b>finalizable</b>
?nonpointer data entity? of finalizable type
<b>3.72</b>
<b>finalization</b>
process of calling final subroutines when certain events occur
Note 1 to entry: These events are listed in 7.5.6.3.
<b>3.73</b>
<b>function</b>
procedure that is invoked by an expression
<b>3.74</b>
<b>function</b> <b>result</b>
entity that returns the value of a function
Note 1 to entry: See 15.6.2.2.
<b>3.75</b>
<b>generic</b> <b>identifier</b>
sequence of tokens that identifies a generic set of procedures or operations
Note 1 to entry: See 15.4.3.4. In this context, an operation could be defined input/output or an assignment.
<b>3.76</b>
<b>host</b> <b>instance</b>
instance of the host procedure that supplies the host environment
Note 1 to entry: Instances are described in 15.6.2.4.
Note 2 to entry: This is only applicable to an <i>internal</i> <i>procedure</i> (3.109.3), or a <i>dummy</i> <i>procedure</i> (3.109.1) or
<i>procedure</i> <i>pointer</i> (3.104.2) that is associated with an <i>internal</i> <i>procedure</i> (3.109.3).
<b>3.77</b>
<b>host</b> <b>scoping</b> <b>unit</b>
<b>host</b>
<i>scoping</i> <i>unit</i> (3.120) immediately surrounding another scoping unit, or the scoping unit extended by a submodule
<b>3.78</b>
<b>IEEE</b> <b>infinity</b>
ISO/IEC/IEEE 60559:2020 conformant infinite floating-point value
<b>3.79</b>
<b>IEEE</b> <b>NaN</b>
<b>NaN</b>
ISO/IEC/IEEE 60559:2020 conformant floating-point datum that does not represent a number
<b>3.80</b>
<b>image</b>
instance of a Fortran program
Note 1 to entry: See 5.3.4.
<b>3.80.1</b>
<b>active</b> <b>image</b>
<i>image</i> (3.80) that has not failed or stopped
Note 1 to entry: Image execution states are described in 5.3.6.
<b>3.80.2</b>
<b>failed</b> <b>image</b>
<i>image</i> (3.80) that has not initiated termination but which has ceased to participate in program execution
<b>3.80.3</b>
<b>stopped</b> <b>image</b>
<i>image</i> (3.80) that has initiated normal termination
<b>3.81</b>
<b>image</b> <b>index</b>
integer value identifying an <i>image</i> (3.80) within a <i>team</i> (3.142)
<b>3.82</b>
<b>image</b> <b>control</b> <b>statement</b>
statement that affects the execution ordering between <i>images</i> (3.80)
Note 1 to entry: Image execution control is described in 11.7.
<b>3.83</b>
<b>inclusive</b> <b>scope</b>
nonblock <i>scoping</i> <i>unit</i> (3.120) plus every <i>block</i> <i>scoping</i> <i>unit</i> (3.120.1) whose <i>host</i> (3.77) is that scoping unit or
that is nested within such a block scoping unit
Note 1 to entry: That is, inclusive scope is the scope as if BLOCK constructs were not scoping units.
<b>3.84</b>
<b>inherit</b>
acquire entities (<i>components</i> (3.30), <i>type-bound</i> <i>procedures</i> (3.109.7), and <i>type</i> <i>parameters</i> (3.144.12)) through
type extension from the parent type
Note 1 to entry: Inheritance is described in 7.5.7.2.
<b>3.85</b>
<b>inquiry</b> <b>function</b>
<i>intrinsic</i> (3.90) function, or function in an intrinsic module, whose result depends on the properties of one or
more of its arguments instead of their values
<b>3.86</b>
<b>interface</b>
?procedure? name, procedure characteristics, dummy argument names, binding label, and generic identifiers
Note 1 to entry: See 15.4.1.
<b>3.86.1</b>
<b>abstract</b> <b>interface</b>
set of procedure characteristics with dummy argument names
<b>3.86.2</b>
<b>explicit</b> <b>interface</b>
interface of a procedure that includes all the characteristics of the procedure and names for its dummy arguments
except for asterisk dummy arguments
Note 1 to entry: See 15.4.2.
<b>3.86.3</b>
<b>generic</b> <b>interface</b>
set of procedure interfaces identified by a <i>generic</i> <i>identifier</i> (3.75)
<b>3.86.4</b>
<b>implicit</b> <b>interface</b>
interface of a procedure that is not an explicit interface
Note 1 to entry: See 15.4.2 and 15.4.3.8.
<b>3.86.5</b>
<b>specific</b> <b>interface</b>
<i>interface</i> (3.86) identified by a nongeneric name
<b>3.87</b>
<b>interface</b> <b>block</b>
<i>abstract</i> <i>interface</i> <i>block</i> (3.87.1), <i>generic</i> <i>interface</i> <i>block</i> (3.87.2), or <i>specific</i> <i>interface</i> <i>block</i> (3.87.3)
Note 1 to entry: Interface blocks are described in 15.4.3.2.
<b>3.87.1</b>
<b>abstract</b> <b>interface</b> <b>block</b>
interfaceblockwiththeABSTRACTkeyword; collectionofinterfacebodiesthatspecifynamed <i>abstract</i> <i>interfaces</i>
(3.86.1)
<b>3.87.2</b>
<b>generic</b> <b>interface</b> <b>block</b>
interface block with a <i>generic-spec</i>; collection of interface bodies and procedure statements that are being given
that generic identifier
<b>3.87.3</b>
<b>specific</b> <b>interface</b> <b>block</b>
interface block with no <i>generic-spec</i> or ABSTRACT keyword; collection of interface bodies that specify the
interfaces of procedures
<b>3.88</b>
<b>interoperable</b>
?Fortran entity? equivalent to an entity defined by or definable by the <i>companion</i> <i>processor</i> (3.29)
Note 1 to entry: Interoperability between Fortran and C entities is described in 18.3.
<b>3.89</b>
<b>interoperable</b>
?C entity? equivalent to an entity defined by or definable by the Fortran processor
<b>3.90</b>
<b>intrinsic</b>
type, procedure, module, assignment, operator, orinput/outputoperationdefinedinthisdocumentandaccessible
without further definition or specification, or a procedure or module provided by a processor but not defined in
this document
<b>3.90.1</b>
<b>standard</b> <b>intrinsic</b>
intrinsic, defined in this document
<b>3.91</b>
<b>internal</b> <b>file</b>
character variable that is <i>connected</i> (3.33) to an <i>internal</i> <i>unit</i> (3.92)
Note 1 to entry: Internal files are described in 12.4. File connection is described in 12.5.4.
<b>3.92</b>
<b>internal</b> <b>unit</b>
<i>input/output</i> <i>unit</i> (3.148) that is <i>connected</i> (3.33) to an <i>internal</i> <i>file</i> (3.91)
<b>3.93</b>
<b>ISO</b> <b>10646</b> <b>character</b>
character whose representation method corresponds to UCS-4 in ISO/IEC 10646
<b>3.94</b>
<b>keyword</b>
statement keyword, argument keyword, type parameter keyword, or component keyword
<b>3.94.1</b>
<b>argument</b> <b>keyword</b>
word that identifies the corresponding <i>dummy</i> <i>argument</i> (3.59) in an actual argument list
Note 1 to entry: Argument correspondence is described in 15.5.2.1.
<b>3.94.2</b>
<b>component</b> <b>keyword</b>
word that identifies a <i>component</i> (3.30) in a <i>structure</i> <i>constructor</i> (3.136.2)
<b>3.94.3</b>
<b>statement</b> <b>keyword</b>
word that is part of the syntax of a statement
Note 1 to entry: Statement keywords are described in 5.5.2.
<b>3.94.4</b>
<b>type</b> <b>parameter</b> <b>keyword</b>
word that identifies a <i>type</i> <i>parameter</i> (3.144.12) in a <i>type-param-spec</i>
<b>3.95</b>
<b>lexical</b> <b>token</b>
keyword, name, literal constant other than a complex literal constant, operator, label, delimiter, comma, =, =<i>></i>,
:, ::, ;, .., or %
Note 1 to entry: See 6.2.
<b>3.96</b>
<b>line</b>
sequence of zero or more characters
<b>3.97</b>
<b>main</b> <b>program</b>
<i>program</i> <i>unit</i> (3.113) that is not a <i>subprogram</i> (3.139), <i>module</i> (3.99), <i>submodule</i> (3.137), or block data program unit
Note 1 to entry: See 14.1.
<b>3.98</b>
<b>masked</b> <b>array</b> <b>assignment</b>
assignment statement in a WHERE statement or WHERE construct
Note 1 to entry: See 10.2.3.
<b>3.99</b>
<b>module</b>
<i>program</i> <i>unit</i> (3.113) that can contain, or access from another module, definitions that can be made accessible to
other program units
Note 1 to entry: Modules are described in 14.2.
<b>3.100</b>
<b>name</b>
identifier of a program constituent, beginning with an alphabetic character and containing only alphanumeric
characters and underscores
Note 1 to entry: The form of a name follows the rules given in 6.2.2.
<b>3.101</b>
<b>operand</b>
data value that is the subject of an operator
<b>3.102</b>
<b>operator</b>
<i>intrinsic-operator</i>, <i>defined-unary-op</i>, or <i>defined-binary-op</i>
Note 1 to entry: These are defined by the syntax rules R608, R1004, and R1024.
<b>3.103</b>
<b>passed-object</b> <b>dummy</b> <b>argument</b>
dummy argument of a <i>type-bound</i> <i>procedure</i> (3.109.7) or <i>procedure</i> <i>pointer</i> (3.104.2) component that becomes
associated with the object through which the procedure is invoked
Note 1 to entry: This is described in 7.5.4.5.
<b>3.104</b>
<b>pointer</b>
<i>data</i> <i>pointer</i> (3.104.1) or <i>procedure</i> <i>pointer</i> (3.104.2)
<b>3.104.1</b>
<b>data</b> <b>pointer</b>
<i>data</i> <i>entity</i> (3.41) with the POINTER attribute
Note 1 to entry: See 8.5.14.
<b>3.104.2</b>
<b>procedure</b> <b>pointer</b>
procedure with the POINTER attribute
<b>3.104.3</b>
<b>local</b> <b>procedure</b> <b>pointer</b>
<i>procedure</i> <i>pointer</i> (3.104.2) that is part of a <i>local</i> <i>variable</i> (3.151.2), or a named procedure pointer that is not a
<i>dummy</i> <i>argument</i> (3.59) or accessed by use or host association
<b>3.105</b>
<b>pointer</b> <b>assignment</b>
association of a pointer with a target, by execution of a pointer assignment statement or an intrinsic assignment
statement for a derived-type object that has the pointer as a subobject
Note 1 to entry: The pointer assignment statement is described in 10.2.2. Derived-type intrinsic assignment is
described in 10.2.1.2.
<b>3.106</b>
<b>polymorphic</b>
?data entity? able to be of differing <i>dynamic</i> <i>types</i> (3.144.4) during program execution
Note 1 to entry: Polymorphic data objects are declared with the CLASS type specifier (7.3.2.3).
<b>3.107</b>
<b>polymorphic</b>
?function? having a result that is a polymorphic data entity
<b>3.108</b>
<b>preconnected</b>
<i>connected</i> (3.33) at the beginning of execution of the program
Note 1 to entry: Preconnection is described in 12.5.5.
<b>3.109</b>
<b>procedure</b>
entity encapsulating an arbitrary sequence of actions that can be invoked directly during program execution
<b>3.109.1</b>
<b>dummy</b> <b>procedure</b>
<i>dummy</i> <i>argument</i> (3.59) that is a procedure
Note 1 to entry: See 15.2.2.3.
<b>3.109.2</b>
<b>external</b> <b>procedure</b>
procedure defined by an external subprogram or by means other than Fortran
Note 1 to entry: The syntax of an external subprogram is defined by R503. See also 15.6.3.
<b>3.109.3</b>
<b>internal</b> <b>procedure</b>
procedure defined by an internal subprogram
Note 1 to entry: The syntax of an internal subprogram is defined by R512.
<b>3.109.4</b>
<b>module</b> <b>procedure</b>
procedure defined by a module subprogram, or a specific procedure provided by an intrinsic module
Note 1 to entry: The syntax of a module subprogram is defined by R1408.
<b>3.109.5</b>
<b>pure</b> <b>procedure</b>
procedure declared or defined to be pure (15.7)
<b>3.109.6</b>
<b>simple</b> <b>procedure</b>
procedure declared or defined to be simple
Note 1 to entry: Simple procedures are described in 15.8.
<b>3.109.7</b>
<b>type-bound</b> <b>procedure</b>
procedure that is bound to a derived type and referenced via an object of that type
Note 1 to entry: Type-bound procedures are described in 7.5.5.
<b>3.110</b>
<b>processor</b>
combination of a computing system and mechanism by which programs are transformed for use on that computing
system
<b>3.111</b>
<b>processor</b> <b>dependent</b>
not completely specified in this document, having methods and semantics determined by the processor
Note 1 to entry: For example, the number of decimal digits displayed in list-directed output of a real value may
vary across processors.
<b>3.112</b>
<b>program</b>
set of Fortran <i>program</i> <i>units</i> (3.113) and entities defined by means other than Fortran that includes exactly one
<i>main</i> <i>program</i> (3.97)
<b>3.113</b>
<b>program</b> <b>unit</b>
<i>main</i> <i>program</i> (3.97), <i>external</i> <i>subprogram</i> (3.139.1), <i>module</i> (3.99), <i>submodule</i> (3.137), or block data program unit
Note 1 to entry: See 5.2.1.
<b>3.114</b>
<b>rank</b>
number of array dimensions of a <i>data</i> <i>entity</i> (3.41) that is an array, or zero for a scalar entity
<b>3.115</b>
<b>record</b>
sequence of values or characters in a file
Note 1 to entry: See 12.2.
<b>3.116</b>
<b>record</b> <b>file</b>
file composed of a sequence of records
Note 1 to entry: See 12.1.
<b>3.117</b>
<b>reference</b>
<i>data</i> <i>object</i> <i>reference</i> (3.117.1), <i>procedure</i> <i>reference</i> (3.117.4), or <i>module</i> <i>reference</i> (3.117.3)
<b>3.117.1</b>
<b>data</b> <b>object</b> <b>reference</b>
appearance of a <i>data</i> <i>object</i> <i>designator</i> (3.56.2) in a context requiring its value at that point during execution
<b>3.117.2</b>
<b>function</b> <b>reference</b>
appearance of the <i>procedure</i> <i>designator</i> (3.56.3) for a function, or operator symbol for a <i>defined</i> <i>operation</i> (3.52),
in a context requiring execution of the function during expression evaluation
Note 1 to entry: See 15.5.3.
<b>3.117.3</b>
<b>module</b> <b>reference</b>
appearance of a module name in a USE statement
Note 1 to entry: See 14.2.2.
<b>3.117.4</b>
<b>procedure</b> <b>reference</b>
appearance of a <i>procedure</i> <i>designator</i> (3.56.3), operator symbol, or assignment symbol in a context requiring
execution of the procedure at that point during execution; or occurrence of defined input/output or derived-type
<i>finalization</i> (3.72)
Note 1 to entry: Defined input/output is described in 12.6.4.8.
<b>3.118</b>
<b>saved</b>
having the SAVE attribute
Note 1 to entry: The SAVE attribute is described in 8.5.16.
<b>3.119</b>
<b>scalar</b>
<i>data</i> <i>entity</i> (3.41) that can be represented by a single value of the type and that is not an <i>array</i> (3.3)
<b>3.120</b>
<b>scoping</b> <b>unit</b>
BLOCK construct, derived-type definition, interface body, <i>program</i> <i>unit</i> (3.113), or subprogram, excluding all
nested scoping units in it
<b>3.120.1</b>
<b>block</b> <b>scoping</b> <b>unit</b>
scoping unit of a BLOCK construct
<b>3.121</b>
<b>segment</b>
maximal sequence of executions on an <i>image</i> (3.80) of statements other than <i>image</i> <i>control</i> <i>statements</i> (3.82)
Note 1 to entry: Segments are described in 11.7.2.
<b>3.122</b>
<b>sequence</b>
set of elements ordered by a one-to-one correspondence with the numbers 1, 2, to <i>n</i>
<b>3.123</b>
<b>sequence</b> <b>structure</b>
scalar <i>data</i> <i>object</i> (3.42) of a <i>sequence</i> <i>type</i> (3.124)
<b>3.124</b>
<b>sequence</b> <b>type</b>
derived type with the SEQUENCE attribute
Note 1 to entry: Sequence types are described in 7.5.2.3.
<b>3.124.1</b>
<b>character</b> <b>sequence</b> <b>type</b>
sequence type with no <i>allocatable</i> (3.2) or <i>pointer</i> (3.104) <i>components</i> (3.30), and whose components are all
default character or of another character sequence type
<b>3.124.2</b>
<b>numeric</b> <b>sequence</b> <b>type</b>
sequencetypewithno <i>allocatable</i> (3.2)or<i>pointer</i> (3.104)<i>components</i> (3.30), andwhosecomponentsarealldefault
complex, default integer, default logical, default real, double precision real, or of another numeric sequence type
<b>3.125</b>
<b>shape</b>
array dimensionality of a data entity, represented as a rank-one array whose size is the <i>rank</i> (3.114) of the data
entity and whose elements are the extents of the data entity
Note 1 to entry: Thus the shape of a scalar data entity is an array with rank one and size zero.
<b>3.126</b>
<b>simply</b> <b>contiguous</b>
satisfying requirements that ensure it is contiguous
Note 1 to entry: An entity that is simply contiguous shall satisfy the requirements specified in 9.5.4.
Note 2 to entry: These requirements are simple ones which make it clear that a designator or variable designates
a <i>contiguous</i> (3.37) array. Only an array designator or variable can be simply contiguous.
<b>3.127</b>
<b>size</b>
?array? total number of elements in the <i>array</i> (3.3)
<b>3.128</b>
<b>specification</b> <b>expression</b>
expression satisfying requirements that make it suitable for use in specifications
Note 1 to entry: A specification expression shall satisfy the requirements specified in 10.1.11.
<b>3.128.1</b>
<b>component</b> <b>specification</b> <b>expression</b>
specification expression satisfying additional requirements that make it suitable for use in specifications in a
component definition statement
Note 1 to entry: A component specification expression shall specify the additional requirements specified in
10.1.11.
<b>3.129</b>
<b>specific</b> <b>name</b>
name that is not a generic name
<b>3.130</b>
<b>statement</b>
sequence of one or more complete or partial lines satisfying a syntax rule that ends in <i>-stmt</i>
Note 1 to entry: See 6.3.
<b>3.130.1</b>
<b>executable</b> <b>statement</b>
<i>end-function-stmt</i>, <i>end-mp-subprogram-stmt</i>, <i>end-program-stmt</i>, <i>end-subroutine-stmt</i>, or statement that is a mem-
ber of the syntactic class <i>executable-construct</i>, excluding those in the <i>block-specification-part</i> of a BLOCK con-
struct
<b>3.130.2</b>
<b>nonexecutable</b> <b>statement</b>
statement that is not an <i>executable</i> <i>statement</i> (3.130.1)
<b>3.131</b>
<b>statement</b> <b>entity</b>
entity whose identifier has the scope of a statement or part of a statement
Note 1 to entry: See 19.1 and 19.4.
<b>3.132</b>
<b>statement</b> <b>label</b>
<b>label</b>
unsigned positive number of up to five digits that refers to an individual statement
Note 1 to entry: Statement labels are described in 6.2.5.
<b>3.133</b>
<b>storage</b> <b>sequence</b>
contiguous sequence of <i>storage</i> <i>units</i> (3.134)
<b>3.134</b>
<b>storage</b> <b>unit</b>
<i>character</i> <i>storage</i> <i>unit</i> (3.134.1), <i>numeric</i> <i>storage</i> <i>unit</i> (3.134.2), <i>file</i> <i>storage</i> <i>unit</i> (3.68), or <i>unspecified</i> <i>storage</i>
<i>unit</i> (3.134.3)
Note 1 to entry: Storage units are described in 19.5.3.2.
<b>3.134.1</b>
<b>character</b> <b>storage</b> <b>unit</b>
unit of storage that holds a default character value
<b>3.134.2</b>
<b>numeric</b> <b>storage</b> <b>unit</b>
unit of storage that holds a default real, default integer, or default logical value
<b>3.134.3</b>
<b>unspecified</b> <b>storage</b> <b>unit</b>
unit of storage that holds a value that is not default character, default real, double precision real, default integer,
default logical, or default complex
<b>3.135</b>
<b>stream</b> <b>file</b>
file composed of a sequence of file storage units
Note 1 to entry: See 12.1.
<b>3.136</b>
<b>structure</b>
scalar <i>data</i> <i>object</i> (3.42) of <i>derived</i> <i>type</i> (3.144.3)
<b>3.136.1</b>
<b>structure</b> <b>component</b>
<i>component</i> (3.30) of a structure
<b>3.136.2</b>
<b>structure</b> <b>constructor</b>
syntax that specifies a structure value or creates such a value
Note 1 to entry: The syntax of a structure constructor is defined by <i>structure-constructor</i> (R756, 7.5.10).
<b>3.137</b>
<b>submodule</b>
<i>program</i> <i>unit</i> (3.113) that extends a <i>module</i> (3.99) or another submodule
Note 1 to entry: Submodules are described in 14.2.3.
<b>3.138</b>
<b>subobject</b>
portion of <i>data</i> <i>object</i> (3.42) that can be referenced and, if it is a <i>variable</i> (3.151), defined, independently of any
other portion
Note 1 to entry: The conditions for a structure component being a subobject are specified in 9.4.2.
<b>3.139</b>
<b>subprogram</b>
<i>function-subprogram</i> (R1532) or <i>subroutine-subprogram</i> (R1537)
<b>3.139.1</b>
<b>external</b> <b>subprogram</b>
subprogram that is not contained in a <i>main</i> <i>program</i> (3.97), <i>module</i> (3.99), <i>submodule</i> (3.137), or another sub-
program
<b>3.139.2</b>
<b>internal</b> <b>subprogram</b>
subprogram that is contained in a <i>main</i> <i>program</i> (3.97) or another subprogram
<b>3.139.3</b>
<b>module</b> <b>subprogram</b>
subprogram that is contained in a <i>module</i> (3.99) or <i>submodule</i> (3.137) but is not an internal subprogram
<b>3.140</b>
<b>subroutine</b>
procedure invoked by a CALL statement, by <i>defined</i> <i>assignment</i> (3.50), or by some operations on derived-type
entities
<b>3.140.1</b>
<b>atomic</b> <b>subroutine</b>
intrinsic subroutine that performs an action on its ATOM argument atomically
Note 1 to entry: Atomic subroutines are described in 16.5.
<b>3.140.2</b>
<b>collective</b> <b>subroutine</b>
intrinsic subroutine that performs a calculation on a <i>team</i> (3.142) of images without requiring synchronization
Note 1 to entry: Collective subroutines are described in 16.6.
<b>3.141</b>
<b>target</b>
entity that is pointer associated with a <i>pointer</i> (3.104), entity on the right-hand-side of a pointer assignment
statement, or entity with the TARGET attribute
Note 1 to entry: Pointer association is described in 19.5.2.2. The pointer assignment statement is described in
10.2.2. The TARGET attribute is described in 8.5.18.
<b>3.142</b>
<b>team</b>
ordered set of <i>images</i> (3.80) created by execution of a FORM TEAM statement, or the initial ordered set of all
images
Note 1 to entry: The FORM TEAM statement is described in 11.7.9.
<b>3.142.1</b>
<b>current</b> <b>team</b>
teamspecifiedbythemostrecentlyexecutedCHANGETEAMstatementofaCHANGETEAMconstruct(11.1.5)
that has not completed execution, or initial team if no CHANGE TEAM construct is being executed
<b>3.142.2</b>
<b>initial</b> <b>team</b>
team existing at the beginning of program execution, consisting of all images
<b>3.142.3</b>
<b>parent</b> <b>team</b>
current team at time of execution of the FORM TEAM statement (11.7.9) that created the team
Note 1 to entry: The initial team does not have a parent team.
<b>3.142.4</b>
<b>sibling</b> <b>teams</b>
teams created by a single set of corresponding executions of the FORM TEAM statement
<b>3.142.5</b>
<b>team</b> <b>number</b>
-1 which identifies the initial team, or positive integer that identifies a team among its <i>sibling</i> <i>teams</i> (3.142.4)
<b>3.143</b>
<b>transformational</b> <b>function</b>
intrinsic function, or function in an intrinsic module, that is neither <i>elemental</i> (3.62) nor an <i>inquiry</i> <i>function</i>
(3.85)
<b>3.144</b>
<b>type</b>
<b>data</b> <b>type</b>
named category of data characterized by a set of values, a syntax for denoting these values, and a set of operations
that interpret and manipulate the values
Note 1 to entry: See 7.1.
<b>3.144.1</b>
<b>abstract</b> <b>type</b>
type with the ABSTRACT attribute
Note 1 to entry: The ABSTRACT attribute is described in 7.5.7.1.
<b>3.144.2</b>
<b>declared</b> <b>type</b>
type that a data entity is declared to have, either explicitly or implicitly
Note 1 to entry: See 7.3.2 and 10.1.9.
<b>3.144.3</b>
<b>derived</b> <b>type</b>
type defined by a derived-type definition (7.5) or by an intrinsic module
<b>3.144.4</b>
<b>dynamic</b> <b>type</b>
type of a data entity at a particular point during execution of a program
Note 1 to entry: See 7.3.2.3 and 10.1.9.
<b>3.144.5</b>
<b>extended</b> <b>type</b>
type with the EXTENDS attribute
Note 1 to entry: The EXTENDS attribute is described in 7.5.7.1.
<b>3.144.6</b>
<b>extensible</b> <b>type</b>
type that can be extended using the EXTENDS clause
Note 1 to entry: See 7.5.7.1.
<b>3.144.7</b>
<b>extension</b> <b>type</b>
is the same type or is an extended type whose parent type is an extension type of the other type
Note 1 to entry: This is a relation of one type with respect to another.
<b>3.144.8</b>
<b>intrinsic</b> <b>type</b>
type defined by this document that is always accessible
Note 1 to entry: Intrinsic types are described in 7.4.
<b>3.144.9</b>
<b>numeric</b> <b>type</b>
one of the types integer, real, and complex
<b>3.144.10</b>
<b>parent</b> <b>type</b>
type named in the EXTENDS clause
Note 1 to entry: Only an extended type has a parent type.
<b>3.144.11</b>
<b>type</b> <b>compatible</b>
compatibility of the type of one entity with respect to another for purposes such as <i>argument</i> <i>association</i> (3.7.1),
<i>pointer</i> <i>association</i> (3.7.7), and allocation
Note 1 to entry: Type compatibility is described in 7.3.3.
<b>3.144.12</b>
<b>type</b> <b>parameter</b>
value used to parameterize a type
Note 1 to entry: Type parameters are described in 7.2.
<b>3.144.12.1</b>
<b>assumed</b> <b>type</b> <b>parameter</b>
<i>length</i> <i>type</i> <i>parameter</i> (3.144.12.4) that assumes the type parameter value from another entity
Note 1 to entry: The other entity is
 the selector for an <i>associate</i> <i>name</i> (3.5),
 the <i>constant-expr</i> for a <i>named</i> <i>constant</i> (3.34.2) of type character, or
 the <i>effective</i> <i>argument</i> (3.60) for a <i>dummy</i> <i>argument</i> (3.59).
<b>3.144.12.2</b>
<b>deferred</b> <b>type</b> <b>parameter</b>
<i>length</i> <i>type</i> <i>parameter</i> (3.144.12.4) whose value can change during execution of a program and whose <i>type-param-</i>
<i>value</i> is a colon
<b>3.144.12.3</b>
<b>kind</b> <b>type</b> <b>parameter</b>
type parameter whose value is required to be defaulted or given by a constant expression
<b>3.144.12.4</b>
<b>length</b> <b>type</b> <b>parameter</b>
type parameter whose value is permitted to be assumed, deferred, or given by a <i>specification</i> <i>expression</i> (3.128)
<b>3.144.12.5</b>
<b>type</b> <b>parameter</b> <b>inquiry</b>
syntax (<i>type-param-inquiry</i>) that is used to inquire the value of a type parameter of a data object
Note 1 to entry: Type parameter enquiries are described in 9.4.5.
<b>3.144.12.6</b>
<b>type</b> <b>parameter</b> <b>order</b>
ordering of the type parameters of a type used for derived-type specifiers
Note 1 to entry: Type parameter order is defined in 7.5.3.2. The syntax of a derived-type specifier is <i>derived-</i>
<i>type-spec</i>, defined in 7.5.9.
<b>3.145</b>
<b>ultimate</b> <b>argument</b>
nondummy entity with which a <i>dummy</i> <i>argument</i> (3.59) is associated via a chain of argument associations
Note 1 to entry: Argument association is described in 15.5.2.4.
<b>3.146</b>
<b>undefined</b>
?data object? without a valid value
<b>3.147</b>
<b>undefined</b>
?pointer? does not have a pointer association status of associated or disassociated
Note 1 to entry: Pointer association status is described in 19.5.2.2.
<b>3.148</b>
<b>unit</b>
<b>input/output</b> <b>unit</b>
means, specified by an <i>io-unit</i>, for referring to a file
Note 1 to entry: See 12.5.1.
<b>3.149</b>
<b>unlimited</b> <b>polymorphic</b>
able to have any <i>dynamic</i> <i>type</i> (3.144.4) during program execution
Note 1 to entry: See 7.3.2.3.
<b>3.150</b>
<b>unsaved</b>
without the SAVE attribute
Note 1 to entry: The SAVE attribute is described in 8.5.16.
<b>3.151</b>
<b>variable</b>
<i>data</i> <i>entity</i> (3.41) that can be <i>defined</i> (3.48) and redefined during execution of a program
<b>3.151.1</b>
<b>event</b> <b>variable</b>
scalar variable of type EVENT_TYPE from the intrinsic module ISO_FORTRAN_ENV
Note 1 to entry: See 16.10.2.10.
<b>3.151.2</b>
<b>local</b> <b>variable</b>
variable in a <i>scoping</i> <i>unit</i> (3.120) that is not a <i>dummy</i> <i>argument</i> (3.59) or part thereof, is not a global entity or
part thereof, and is not an entity or part of an entity that is accessible outside that <i>scoping</i> <i>unit</i> (3.120)
<b>3.151.3</b>
<b>lock</b> <b>variable</b>
scalar variable of type LOCK_TYPE from the intrinsic module ISO_FORTRAN_ENV
Note 1 to entry: See 16.10.2.19.
<b>3.151.4</b>
<b>notify</b> <b>variable</b>
scalar variable of type NOTIFY_TYPE from the intrinsic module ISO_FORTRAN_ENV
Note 1 to entry: See 16.10.2.22.
<b>3.151.5</b>
<b>team</b> <b>variable</b>
scalar variable of type TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV
Note 1 to entry: See 16.10.2.34.
<b>3.152</b>
<b>vector</b> <b>subscript</b>
<i>section-subscript</i> that is an array
Note 1 to entry: See 9.5.3.4.3.
<b>3.153</b>
<b>whole</b> <b>array</b>
array component or array name without further qualification
Note 1 to entry: See 9.5.2.
<b>4</b> <b>Notation,</b> <b>conformance,</b> <b>and</b> <b>compatibility</b>
<b>4.1</b> <b>Notation,</b> <b>symbols</b> <b>and</b> <b>abbreviated</b> <b>terms</b>
<b>4.1.1</b> <b>Syntax</b> <b>rules</b>
Syntax rules describe the forms that Fortran lexical tokens, statements, and constructs may take. These syntax
rules are expressed in a variation of Backus-Naur form (BNF) with the following conventions.
 Characters from the Fortran character set (6.1) are interpreted literally as shown, except where otherwise
  noted.
 Lower-case italicized letters and words (often hyphenated and abbreviated) represent general syntactic
  classes for which particular syntactic entities shall be substituted in actual statements.
  Common abbreviations used in syntactic terms are:
             <i>arg</i> for argument <i>attr</i> for attribute
             <i>decl</i> for declaration <i>def</i> for definition
             <i>desc</i> for descriptor <i>expr</i> for expression
             <i>int</i> for integer <i>op</i> for operator
             <i>spec</i> for specifier <i>stmt</i> for statement
 The syntactic metasymbols used are:
            <b>is</b> introduces a syntactic class definition
            <b>or</b> introduces a syntactic class alternative
                          [ ] encloses an optional item
                          [ ] ... encloses an optionally repeated item
                  that may occur zero or more times
                 continues a syntax rule
 Each syntax rule is given a unique identifying number of the form Rsnn, where s is a one- or two-digit
  clause number and nn is a two-digit sequence number within that clause. The syntax rules are distributed
  as appropriate throughout the text, and are referenced by number as needed. Some rules in Clauses 5 and
  6 are more fully described in later clauses; in such cases, the clause number s is the number of the later
  clause where the rule is repeated.
 The syntax rules are not a complete and accurate syntax description of Fortran, and cannot be used to
  generate a Fortran parser automatically; where a syntax rule is incomplete, it is restricted by corresponding
  constraints and text.
<b>NOTE</b>
An example of the use of the syntax rules is:
   <i>digit-string</i> <b>is</b> <i>digit</i> [ <i>digit</i> ] ...
The following are examples of forms for a digit string allowed by the above rule:
  <i>digit</i>
  <i>digit</i> <i>digit</i>
  <i>digit</i> <i>digit</i> <i>digit</i> <i>digit</i>
  <i>digit</i> <i>digit</i> <i>digit</i> <i>digit</i> <i>digit</i> <i>digit</i> <i>digit</i> <i>digit</i>
Some examples of <i>digit-string</i> are:
                <b>J3/23-007r1</b> <b>29</b>
<b>NOTE</b> <b>(cont.)</b>
   4
   67
   1999
   10243852
<b>4.1.2</b> <b>Constraints</b>
Each constraint is given a unique identifying number of the form Csnn, where s is a one- or two-digit clause
number and nn is a two- or three-digit sequence number within that clause.
Often a constraint is associated with a particular syntax rule. Where that is the case, the constraint is annotated
with the syntax rule number in parentheses. A constraint that is associated with a syntax rule constitutes part of
the definition of the syntax term defined by the rule. It thus applies in all places where the syntax term appears.
Some constraints are not associated with particular syntax rules. The effect of such a constraint is similar to
that of a restriction stated in the text, except that a processor is required to have the capability to detect and
report violations of constraints (4.2). In some cases, a broad requirement is stated in text and a subset of the
same requirement is also stated as a constraint. This indicates that a standard-conforming program is required to
adhere to the broad requirement, but that a standard-conforming processor is required only to have the capability
of diagnosing violations of the constraint.
<b>4.1.3</b> <b>Assumed</b> <b>syntax</b> <b>rules</b>
In order to minimize the number of additional syntax rules and convey appropriate constraint information, the
following rules, where the letters <i>xyz</i> stand for any syntactic class phrase, are assumed.
R401 <i>xyz-list</i> <b>is</b> <i>xyz</i> [ , <i>xyz</i> ] ...
R402 <i>xyz-name</i> <b>is</b> <i>name</i>
R403 <i>scalar-xyz</i> <b>is</b> <i>xyz</i>
C401 (R403) <i>scalar-xyz</i> shall be scalar.
An explicit syntax rule for a term overrides an assumed rule.
<b>4.1.4</b> <b>Syntax</b> <b>conventions</b> <b>and</b> <b>characteristics</b>
Any syntactic class name ending in "-<i>stmt</i>" follows the source form statement rules: it shall be delimited by
end-of-line or semicolon, and may be labeled unless it forms part of another statement (such as an IF or WHERE
statement). Conversely, everything considered to be a source form statement is given a "-<i>stmt</i>" ending in the
syntax rules.
The rules on statement ordering are described rigorously in the definition of <i>program-unit</i> (R502). Expression
hierarchy is described rigorously in the definition of <i>expr</i> (R1023).
The suffix "-<i>spec</i>" is used consistently for specifiers, such as input/output statement specifiers. It also is used for
type declaration attribute specifications (for example, "<i>array-spec</i>" in R814), and in a few other cases.
Where reference is made to a type parameter, including the surrounding parentheses, the suffix "-<i>selector</i>" is
used. See, for example, "<i>kind-selector</i>" (R706) and "<i>length-selector</i>" (R722).
<b>4.1.5</b> <b>Text</b> <b>conventions</b>
In descriptive text, an equivalent English word is frequently used in place of a syntactic term. Particular state-
ments and attributes are identified in the text by an upper-case keyword, e.g., "END statement". The descriptions
of obsolescent features appear in a smaller type size.
<b>NOTE</b>
This sentence is an example of the type size used for obsolescent features.
<b>4.2</b> <b>Conformance</b>
A program (5.2.2) is a standard-conforming program if it uses only those forms and relationships described herein
and if the program has an interpretation according to this document. A program unit (5.2.1) conforms to this
document if it can be included in a program in a manner that allows the program to be standard conforming.
A Fortran processor shall:
  (1) execute any standard-conforming program in a manner that fulfills the interpretations herein, subject
     to any limits that the processor may impose on the size and complexity of the program;
  (2) contain the capability to detect and report the use within a submitted program unit of a form
     designated herein as obsolescent, insofar as such use can be detected by reference to the numbered
     syntax rules and constraints;
  (3) contain the capability to detect and report the use within a submitted program unit of a form or
     relationship that is not permitted by the numbered syntax rules or constraints, including the deleted
     features described in Annex B;
  (4) contain the capability to detect and report the use within a submitted program unit of an intrinsic
     type with a kind type parameter value not supported by the processor (7.4);
  (5) contain the capability to detect and report the use within a submitted program unit of source form
     or characters not permitted by Clause 6;
  (6) contain the capability to detect and report the use within a submitted program of name usage not
     consistent with the scope rules for names, labels, operators, and assignment symbols in Clause 19;
  (7) contain the capability to detect and report the use within a submitted program unit of a nonstandard
     intrinsic procedure (including one with the same name as a standard intrinsic procedure but with
     different requirements);
  (8) contain the capability to detect and report the use within a submitted program unit of a nonstandard
     intrinsic module;
  (9) contain the capability to detect and report the use within a submitted program unit of a procedure
     from a standard intrinsic module, if the procedure is not defined by this document or the procedure
     has different requirements from those specified by this document; and
  (10) contain the capability to detect and report the reason for rejecting a submitted program.
However, in a format specification that is not part of a FORMAT statement (13.2.1), a processor need not detect
or report the use of deleted or obsolescent features, or the use of additional forms or relationships.
A standard-conforming processor may allow additional forms and relationships provided that such additions
do not conflict with the standard forms and relationships. However, a standard-conforming processor may allow
additional intrinsic procedures even though this could cause a conflict with the name of a procedure in a standard-
conforming program. If such a conflict occurs and involves the name of an external procedure, the processor is
permitted to use the intrinsic procedure unless the name has the EXTERNAL attribute (8.5.9) where it is used.
A standard-conforming program shall not use nonstandard intrinsic procedures or modules that have been added
by the processor.
Because a standard-conforming program may place demands on a processor that are not within the scope of this
document or may include standard items that are not portable, such as external procedures defined by means
other than Fortran, conformance to this document does not ensure that a program will execute consistently on
all or any standard-conforming processors.
Thesemanticsoffacilitiesthatareidentifiedasprocessordependentarenotcompletelyspecifiedinthisdocument.
They shall be provided, with methods or semantics determined by the processor.
The processor should be accompanied by documentation that specifies the limits it imposes on the size and com-
plexity of a program and the means of reporting when these limits are exceeded, that defines the additional forms
and relationships it allows, and that defines the means of reporting the use of additional forms and relationships
and the use of deleted or obsolescent forms. In this context, the use of a deleted form is the use of an additional
form.
The processor should be accompanied by documentation that specifies the methods or semantics of processor-
dependent facilities.
<b>4.3</b> <b>Compatibility</b>
<b>4.3.1</b> <b>Previous</b> <b>Fortran</b> <b>standards</b>
Table 4.3 lists the previous editions of the Fortran International Standard, along with their informal names.
      <b>Table</b> <b>4.3</b> <b>-</b> <b>Previous</b> <b>editions</b> <b>of</b> <b>the</b> <b>Fortran</b> <b>International</b> <b>Standard</b>
                Official designation Informal name
                ISO R 1539-1972 Fortran 66
                ISO 1539-1980 Fortran 77
                ISO/IEC 1539:1991 Fortran 90
                ISO/IEC 1539-1:1997 Fortran 95
                ISO/IEC 1539-1:2004 Fortran 2003
                ISO/IEC 1539-1:2010 Fortran 2008
                ISO/IEC 1539-1:2018 Fortran 2018
<b>4.3.2</b> <b>New</b> <b>intrinsic</b> <b>procedures</b>
Each Fortran International Standard since ISO 1539:1980 (Fortran 77), defines more intrinsic procedures than
the previous one. Therefore, a Fortran program conforming to an older standard might have a different inter-
pretation under a newer standard if it invokes an external procedure having the same name as one of the new
standard intrinsic procedures, unless that procedure is specified to have the EXTERNAL attribute.
<b>4.3.3</b> <b>Fortran</b> <b>2018</b> <b>compatibility</b>
Except as identified in this subclause, this document is an upward compatible extension to the preceding Fortran
International Standard, ISO/IEC 1539-1:2018 (Fortran 2018). A standard-conforming Fortran 2018 program that
does not use any feature identified in this subclause as being no longer permitted remains standard-conforming
under this document.
Fortran 2018 allowed integer arguments to the intrinsic subroutine SYSTEM_CLOCK to be of any kind. This
document requires integer arguments to SYSTEM_CLOCK to have a decimal exponent range at least as large
as a default integer, and requires that all integer arguments in a reference to SYSTEM_CLOCK have the same
kind type parameter.
Fortran 2018 permitted a variable in a BLOCK construct that was declared only by a DATA statement to be
used before the DATA statement. This document does not permit such usage.
Fortran 2018 permitted the POINTER and TARGET arguments to the intrinsic function ASSOCIATED to have
different rank; this document does not permit such usage.
The following Fortran 2018 features might have a different interpretation under this document.
 After an allocatable deferred length character variable is assigned a value by an IOMSG= or ERRMSG=
  clause, is the unit in an internal WRITE statement, or is an INTENT (OUT) argument in a reference to
  an intrinsic subroutine, that variable might be of shorter or longer length under this document than under
  Fortran 2018, since this document specifies intrinsic assignment semantics for these assignments.
 This document permits the intrinsic subroutine SYSTEM_CLOCK to use two or more clocks, with different
  characteristics based on the type and kind type parameters of its arguments. A program that invokes
  SYSTEM_CLOCK with different argument types or kinds in different references, could have a different
  interpretation under this document.
 TheresultofareferencetoIEEE_MAX_NUM,IEEE_MAX_NUM_MAG,IEEE_MIN_NUM,orIEEE_-
  MIN_NUM_MAG where one argument is a number and the other is a signaling NaN is specified to be the
  number in this document. Fortran 2018 specified that the result is a NaN.
<b>4.3.4</b> <b>Fortran</b> <b>2008</b> <b>compatibility</b>
Except as identified in this subclause, and except for the deleted features noted in Clause B.2, this document
is an upward compatible extension to ISO/IEC 1539-1:2010 (Fortran 2008). Any standard-conforming Fortran
2008 program that does not use any deleted features, and does not use any feature identified in this subclause as
being no longer permitted, remains standard-conforming under this document.
Fortran 2008 specifies that the IOSTAT= variable shall be set to a processor-dependent negative value if the flush
operation is not supported for the unit specified. This document specifies that the processor-dependent negative
integer value shall be different from the named constants IOSTAT_EOR or IOSTAT_END from the intrinsic
module ISO_FORTRAN_ENV.
Fortran 2008 permitted a noncontiguous array that was supplied as an actual argument corresponding to a
contiguous INTENT (INOUT) dummy argument in one iteration of a DO CONCURRENT construct, without
being previously defined in that iteration, to be defined in another iteration; this document does not permit this.
Fortran 2008 permitted a pure statement function to reference a volatile variable, and permitted a local variable
of a pure subprogram or of a BLOCK construct within a pure subprogram to be volatile (provided it was not
used); this document does not permit that.
Fortran 2008 permitted a pure function to have a result that has a polymorphic allocatable ultimate component;
this document does not permit that.
Fortran 2008 permitted a PROTECTED TARGET variable accessed by use association to be used as an <i>initial-</i>
<i>data-target</i>; this document does not permit that.
Fortran 2008 permitted a named constant to have declared type LOCK_TYPE, or have a noncoarray potential
subobject component with declared type LOCK_TYPE; this document does not permit that.
Fortran 2008 permitted a polymorphic object to be finalized within a DO CONCURRENT construct; this docu-
ment does not permit that.
Fortran 2008 permitted an unallocated allocatable coarray or coindexed object to be allocated by an assignment
statement, provided it was scalar, nonpolymorphic, and had no deferred type parameters; this document does
not permit that.
Fortran 2008 permitted the processor to use a common pseudorandom number generator for all images. This
document requires separate seeds on each image for the pseudorandom number generator.
Fortran 2008 required ACOSH of a complex value to have the imaginary part nonnegative and had no requirement
on the real part. This document requires ACOSH of a complex value to have a nonnegative real part and has no
such requirement on the imaginary part.
Fortran 2008 allowed integer arguments to the intrinsic subroutine SYSTEM_CLOCK to be of any kind. This
document requires integer arguments to SYSTEM_CLOCK to have a decimal exponent range at least as large
as a default integer, and requires that all integer arguments in a reference to SYSTEM_CLOCK have the same
kind type parameter.
Fortran 2008 permitted a variable in a BLOCK construct that was declared only by a DATA statement to be
used before the DATA statement. This document does not permit such usage.
Fortran 2008 permitted the POINTER and TARGET arguments to the intrinsic function ASSOCIATED to have
different rank; this document does not permit such usage.
The following Fortran 2008 features might have a different interpretation under this document.
 After an allocatable deferred length character variable is assigned a value by an IOMSG= or ERRMSG=
  clause, is the unit in an internal WRITE statement, or is an INTENT (OUT) argument in a reference to
  an intrinsic subroutine, that variable might be of shorter or longer length under this document than under
  Fortran 2008, since this document specifies intrinsic assignment semantics for these assignments.
 This document permits the intrinsic subroutine SYSTEM_CLOCK to use two or more clocks, with different
  characteristics based on the type and kind type parameters of its arguments. A program that invokes
  SYSTEM_CLOCK with different argument types or kinds in different references, could have a different
  interpretation under this document.
<b>4.3.5</b> <b>Fortran</b> <b>2003</b> <b>compatibility</b>
Except as identified in this subclause, this document is an upward compatible extension to ISO/IEC 1539-1:2004
(Fortran 2003). Except as identified in this subclause, any standard-conforming Fortran 2003 program remains
standard-conforming under this document.
Fortran 2003 permitted a sequence type to have type parameters; that is not permitted by this document.
Fortran 2003 specified that array constructors and structure constructors of finalizable type are finalized. This
document specifies that these constructors are not finalized.
The form produced by the G edit descriptor for some values and some input/output rounding modes differs from
that specified by Fortran 2003.
Fortran 2003 required an explicit interface only for a procedure that was actually referenced in the scope, not
merely passed as an actual argument. This document requires an explicit interface for a procedure under the
conditions listed in 15.4.2.2, regardless of whether the procedure is referenced in the scope.
Fortran 2003 permitted the function result of a pure function to be a polymorphic allocatable variable, to have
a polymorphic allocatable ultimate component, or to be finalizable by an impure final subroutine. These are not
permitted by this document.
Fortran 2003 permitted an INTENT (OUT) argument of a pure subroutine to be polymorphic; that is not
permitted by this document.
Fortran 2003 interpreted assignment to an allocatable variable from a nonconformable array as intrinsic assign-
ment, even when an elemental defined assignment was in scope; this document does not permit assignment from
a nonconformable array in this context.
Fortran 2003 permitted a statement function to be of parameterized derived type; this document does not permit
that.
Fortran 2003 permitted a pure statement function to reference a volatile variable, and permitted a local variable
of a pure subprogram to be volatile (provided it was not used); this document does not permit that.
Fortran 2003 allowed integer arguments to the intrinsic subroutine SYSTEM_CLOCK to be of any kind. This
document requires integer arguments to SYSTEM_CLOCK to have a decimal exponent range at least as large
as a default integer, and requires that all integer arguments in a reference to SYSTEM_CLOCK have the same
kind type parameter.
Fortran 2003 permitted the POINTER and TARGET arguments to the intrinsic function ASSOCIATED to have
different rank; this document does not permit such usage.
The following Fortran 2003 features might have a different interpretation under this document.
 After an allocatable deferred length character variable is assigned a value by an IOMSG= or ERRMSG=
  clause, is the unit in an internal WRITE statement, or is an INTENT (OUT) argument in a reference to
  an intrinsic subroutine, that variable might be of shorter or longer length under this document than under
  Fortran 2003, since this document specifies intrinsic assignment semantics for these assignments.
 This document permits the intrinsic subroutine SYSTEM_CLOCK to use two or more clocks, with different
  characteristics based on the type and kind type parameters of its arguments. A program that invokes
  SYSTEM_CLOCK with different argument types or kinds in different references, could have a different
  interpretation under this document.
<b>4.3.6</b> <b>Fortran</b> <b>95</b> <b>compatibility</b>
Except as identified in this subclause, this document is an upward compatible extension to ISO/IEC 1539-1:1997
(Fortran 95). Except as identified in this subclause, any standard-conforming Fortran 95 program remains
standard-conforming under this document.
Fortran 95 permitted defined assignment between character strings of the same rank and different kinds. This
document does not permit that if both of the different kinds are ASCII, ISO 10646, or default kind.
The following Fortran 95 features might have different interpretations in this document.
 Earlier Fortran standards had the concept of printing, meaning that column one of formatted output had
  special meaning for a processor-dependent (possibly empty) set of external files. This could be neither
  detected nor specified by a standard-specified means. The interpretation of the first column is not specified
  by this document.
 This document specifies a different output format for real zero values in list-directed and namelist output.
 If the processor distinguishes between positive and negative real zero, this document requires different
  returned values for ATAN2(Y,X) when X <i><</i> 0 and Y is negative real zero and for LOG(X) and SQRT(X)
  when X is complex with X%RE <i><</i> 0 and X%IM is negative real zero.
 ThisdocumenthasfewerrestrictionsonconstantexpressionsthanFortran95; thisaffects whether avariable
  is considered to be an automatic data object.
 The form produced by the G edit descriptor with <i>d</i> equal to zero differs from that specified by Fortran 95
  for some values.
<b>4.3.7</b> <b>Fortran</b> <b>90</b> <b>compatibility</b>
Except for the deleted features noted in Clause B.1, and except as identified in this subclause, this document
is an upward compatible extension to ISO/IEC 1539:1991 (Fortran 90). Any standard-conforming Fortran 90
program that does not use one of the deleted features remains standard-conforming under this document.
The PAD= specifier in the INQUIRE statement in this document returns the value UNDEFINED if there is no
connection or the connection is for unformatted input/output. Fortran 90 specified YES.
Fortran 90 specified that if the second argument to MOD or MODULO was zero, the result was processor
dependent. This document specifies that the second argument shall not be zero.
Fortran 90 permitted defined assignment between character strings of the same rank and different kinds. This
document does not permit that if both of the different kinds are ASCII, ISO 10646, or default kind.
The following Fortran 90 features have different interpretations in this document:
 iftheprocessordistinguishesbetweenpositiveandnegativerealzero, theresultvalueoftheintrinsicfunction
  SIGN when the second argument is a negative real zero;
 formatted output of negative real values (when the output value is zero);
 whether an expression is a constant expression (thus whether a variable is considered to be an automatic
  data object);
 the G edit descriptor with <i>d</i> equal to zero for some values.
<b>4.3.8</b> <b>FORTRAN</b> <b>77</b> <b>compatibility</b>
Except for the deleted features noted in Clause B.1, and except as identified in this subclause, this document is an
upward compatible extension to ISO 1539:1980 (Fortran 77). Any standard-conforming Fortran 77 program
that does not use one of the deleted features noted in Clause B.1 and that does not depend on the differences
specified here remains standard-conforming under this document. This document restricts the behavior for some
features that were processor dependent inFortran 77. Therefore, a standard-conformingFortran 77 program
that uses one of these processor-dependent features might have a different interpretation under this document, yet
remain a standard-conforming program. The followingFortran 77 features might have different interpretations
in this document.
 Fortran 77 permitted a processor to supply more precision derived from a default real constant than can
  be represented in a default real datum when the constant is used to initialize a double precision real data
  object in a DATA statement. This document does not permit a processor this option.
 If a named variable that was not in a common block was initialized in a DATA statement and did not have
  the SAVE attribute specified, Fortran 77 left its SAVE attribute processor dependent. This document
  specifies (8.6.7) that this named variable has the SAVE attribute.
 Fortran 77 specified that the number of characters required by the input list was to be less than or equal
  to the number of characters in the record during formatted input. This document specifies (12.6.4.5.3) that
  the input record is logically padded with blanks if there are not enough characters in the record, unless the
  PAD= specifier with the value 'NO' is specified in an appropriate OPEN or READ statement.
 A value of zero for an effective item in a formatted output statement will be formatted in a different form
  for some G edit descriptors. In addition, this document specifies how rounding of values will affect the
  output field form, but Fortran 77 did not address this issue. Therefore, the form produced for certain
  combinations of values and G edit descriptors might differ from that produced by some Fortran 77
  processors.
 Fortran 77 did not permit a processor to distinguish between positive and negative real zero; if the
  processor does so distinguish, the result will differ for the intrinsic function SIGN when the second argument
  is negative real zero, and formatted output of negative real zero will be different.
<b>4.4</b> <b>Deleted</b> <b>and</b> <b>obsolescent</b> <b>features</b>
<b>4.4.1</b> <b>General</b>
This document protects the users' investment in existing software by including all but six of the language elements
of Fortran 90 that are not processor dependent. This document identifies two categories of outmoded features.
The first category, deleted features, consists of features considered to have been redundant in Fortran 77 and
largely unused in Fortran 90. Those in the second category, obsolescent features, are considered to have been
redundant in Fortran 90 and Fortran 95, but are still frequently used.
<b>4.4.2</b> <b>Nature</b> <b>of</b> <b>deleted</b> <b>features</b>
There are two groups of deleted features. The first group contains features for which better methods existed in
Fortran 77; these features were not included in Fortran 95, Fortran 2003, or Fortran 2008, and are not included
in this document. The second group contains features for which better methods existed in Fortran 90; these
features were included in Fortran 2008, but are not included in this document.
<b>4.4.3</b> <b>Nature</b> <b>of</b> <b>obsolescent</b> <b>features</b>
Better methods existed in Fortran 90 and Fortran 95 for each obsolescent feature. It is recommended that
programmers use these better methods in new programs and convert existing code to these methods.
The obsolescent features are identified in the text of this document by a distinguishing type font (4.1.5).
A future revision of this document might delete an obsolescent feature if its use has become insignificant.
<b>5</b> <b>Fortran</b> <b>concepts</b>
<b>5.1</b> <b>High</b> <b>level</b> <b>syntax</b>
This subclause introduces the syntax associated with program units and other Fortran concepts above the con-
struct, statement, and expression levels and illustrates their relationships.
<b>NOTE</b>
Constraints and other information related to the rules that do not begin with R5 appear in the appropriate
clause.
R501 <i>program</i> <b>is</b> <i>program-unit</i>
                                   [ <i>program-unit</i> ] ...
R502 <i>program-unit</i> <b>is</b> <i>main-program</i>
              <b>or</b> <i>external-subprogram</i>
              <b>or</b> <i>module</i>
              <b>or</b> <i>submodule</i>
              <b>or</b> <i>block-data</i>
R1401 <i>main-program</i> <b>is</b> [ <i>program-stmt</i> ]
                                   [ <i>specification-part</i> ]
                                   [ <i>execution-part</i> ]
                                   [ <i>internal-subprogram-part</i> ]
                   <i>end-program-stmt</i>
R503 <i>external-subprogram</i> <b>is</b> <i>function-subprogram</i>
              <b>or</b> <i>subroutine-subprogram</i>
R1532 <i>function-subprogram</i> <b>is</b> <i>function-stmt</i>
                                   [ <i>specification-part</i> ]
                                   [ <i>execution-part</i> ]
                                   [ <i>internal-subprogram-part</i> ]
                   <i>end-function-stmt</i>
R1537 <i>subroutine-subprogram</i> <b>is</b> <i>subroutine-stmt</i>
                                   [ <i>specification-part</i> ]
                                   [ <i>execution-part</i> ]
                                   [ <i>internal-subprogram-part</i> ]
                   <i>end-subroutine-stmt</i>
R1404 <i>module</i> <b>is</b> <i>module-stmt</i>
                                   [ <i>specification-part</i> ]
                                   [ <i>module-subprogram-part</i> ]
                   <i>end-module-stmt</i>
R1416 <i>submodule</i> <b>is</b> <i>submodule-stmt</i>
                                   [ <i>specification-part</i> ]
                                   [ <i>module-subprogram-part</i> ]
                   <i>end-submodule-stmt</i>
R1420 <i>block-data</i> <b>is</b> <i>block-data-stmt</i>
                   [ <i>specification-part</i> ]
                      <i>end-block-data-stmt</i>
R504 <i>specification-part</i> <b>is</b> [ <i>use-stmt</i> ] ...
                                   [ <i>import-stmt</i> ] ...
                                   [ <i>implicit-part</i> ]
                                   [ <i>declaration-construct</i> ] ...
R505 <i>implicit-part</i> <b>is</b> [ <i>implicit-part-stmt</i> ] ...
                   <i>implicit-stmt</i>
R506 <i>implicit-part-stmt</i> <b>is</b> <i>implicit-stmt</i>
              <b>or</b> <i>parameter-stmt</i>
              <b>or</b> <i>format-stmt</i>
              <b>or</b> <i>entry-stmt</i>
R507 <i>declaration-construct</i> <b>is</b> <i>specification-construct</i>
              <b>or</b> <i>data-stmt</i>
              <b>or</b> <i>format-stmt</i>
              <b>or</b> <i>entry-stmt</i>
              <b>or</b> <i>stmt-function-stmt</i>
R508 <i>specification-construct</i> <b>is</b> <i>derived-type-def</i>
              <b>or</b> <i>enum-def</i>
              <b>or</b> <i>enumeration-type-def</i>
              <b>or</b> <i>generic-stmt</i>
              <b>or</b> <i>interface-block</i>
              <b>or</b> <i>parameter-stmt</i>
              <b>or</b> <i>procedure-declaration-stmt</i>
              <b>or</b> <i>other-specification-stmt</i>
              <b>or</b> <i>type-declaration-stmt</i>
R509 <i>execution-part</i> <b>is</b> <i>executable-construct</i>
                                   [ <i>execution-part-construct</i> ] ...
R510 <i>execution-part-construct</i> <b>is</b> <i>executable-construct</i>
              <b>or</b> <i>format-stmt</i>
              <b>or</b> <i>entry-stmt</i>
              <b>or</b> <i>data-stmt</i>
R511 <i>internal-subprogram-part</i> <b>is</b> <i>contains-stmt</i>
                                   [ <i>internal-subprogram</i> ] ...
R512 <i>internal-subprogram</i> <b>is</b> <i>function-subprogram</i>
              <b>or</b> <i>subroutine-subprogram</i>
R1407 <i>module-subprogram-part</i> <b>is</b> <i>contains-stmt</i>
                                   [ <i>module-subprogram</i> ] ...
R1408 <i>module-subprogram</i> <b>is</b> <i>function-subprogram</i>
              <b>or</b> <i>subroutine-subprogram</i>
              <b>or</b> <i>separate-module-subprogram</i>
R1541 <i>separate-module-subprogram</i> <b>is</b> <i>mp-subprogram-stmt</i>
                   [ <i>specification-part</i> ]
                   [ <i>execution-part</i> ]
                   [ <i>internal-subprogram-part</i> ]
                   <i>end-mp-subprogram-stmt</i>
R513 <i>other-specification-stmt</i> <b>is</b> <i>access-stmt</i>
              <b>or</b> <i>allocatable-stmt</i>
              <b>or</b> <i>asynchronous-stmt</i>
              <b>or</b> <i>bind-stmt</i>
              <b>or</b> <i>codimension-stmt</i>
              <b>or</b> <i>contiguous-stmt</i>
              <b>or</b> <i>dimension-stmt</i>
              <b>or</b> <i>external-stmt</i>
              <b>or</b> <i>intent-stmt</i>
              <b>or</b> <i>intrinsic-stmt</i>
              <b>or</b> <i>namelist-stmt</i>
              <b>or</b> <i>optional-stmt</i>
              <b>or</b> <i>pointer-stmt</i>
              <b>or</b> <i>protected-stmt</i>
              <b>or</b> <i>save-stmt</i>
              <b>or</b> <i>target-stmt</i>
              <b>or</b> <i>volatile-stmt</i>
              <b>or</b> <i>value-stmt</i>
              <b>or</b> <i>common-stmt</i>
              <b>or</b> <i>equivalence-stmt</i>
R514 <i>executable-construct</i> <b>is</b> <i>action-stmt</i>
              <b>or</b> <i>associate-construct</i>
              <b>or</b> <i>block-construct</i>
              <b>or</b> <i>case-construct</i>
              <b>or</b> <i>change-team-construct</i>
              <b>or</b> <i>critical-construct</i>
              <b>or</b> <i>do-construct</i>
              <b>or</b> <i>if-construct</i>
              <b>or</b> <i>select-rank-construct</i>
              <b>or</b> <i>select-type-construct</i>
              <b>or</b> <i>where-construct</i>
              <b>or</b> <i>forall-construct</i>
R515 <i>action-stmt</i> <b>is</b> <i>allocate-stmt</i>
              <b>or</b> <i>assignment-stmt</i>
              <b>or</b> <i>backspace-stmt</i>
              <b>or</b> <i>call-stmt</i>
              <b>or</b> <i>close-stmt</i>
              <b>or</b> <i>continue-stmt</i>
              <b>or</b> <i>cycle-stmt</i>
              <b>or</b> <i>deallocate-stmt</i>
              <b>or</b> <i>endfile-stmt</i>
              <b>or</b> <i>error-stop-stmt</i>
              <b>or</b> <i>event-post-stmt</i>
              <b>or</b> <i>event-wait-stmt</i>
              <b>or</b> <i>exit-stmt</i>
              <b>or</b> <i>fail-image-stmt</i>
              <b>or</b> <i>flush-stmt</i>
              <b>or</b> <i>form-team-stmt</i>
              <b>or</b> <i>goto-stmt</i>
              <b>or</b> <i>if-stmt</i>
              <b>or</b> <i>inquire-stmt</i>
              <b>or</b> <i>lock-stmt</i>
              <b>or</b> <i>notify-wait-stmt</i>
              <b>or</b> <i>nullify-stmt</i>
              <b>or</b> <i>open-stmt</i>
              <b>or</b> <i>pointer-assignment-stmt</i>
              <b>or</b> <i>print-stmt</i>
              <b>or</b> <i>read-stmt</i>
              <b>or</b> <i>return-stmt</i>
              <b>or</b> <i>rewind-stmt</i>
              <b>or</b> <i>stop-stmt</i>
              <b>or</b> <i>sync-all-stmt</i>
              <b>or</b> <i>sync-images-stmt</i>
              <b>or</b> <i>sync-memory-stmt</i>
              <b>or</b> <i>sync-team-stmt</i>
              <b>or</b> <i>unlock-stmt</i>
              <b>or</b> <i>wait-stmt</i>
              <b>or</b> <i>where-stmt</i>
              <b>or</b> <i>write-stmt</i>
              <b>or</b> <i>computed-goto-stmt</i>
              <b>or</b> <i>forall-stmt</i>
<b>5.2</b> <b>Program</b> <b>unit</b> <b>concepts</b>
<b>5.2.1</b> <b>Program</b> <b>units</b> <b>and</b> <b>scoping</b> <b>units</b>
Program units are the fundamental components of a Fortran program. A program unit is a main program, an
external subprogram, a module, a submodule, or a block data program unit.
A subprogram is a function subprogram or a subroutine subprogram. A module contains definitions that can be
made accessible to other program units. A submodule is an extension of a module; it may contain the definitions
of procedures declared in a module or another submodule. A block data program unit is used to specify initial values for
data objects in named common blocks.
Each type of program unit is described in Clause 14 or 15.
A program unit consists of a set of nonoverlapping scoping units.
<b>NOTE</b>
The module or submodule containing a module subprogram is the host scoping unit of the module subprogram.
The containing main program or subprogram is the host scoping unit of an internal subprogram.
An internal procedure is local to its host in the sense that its name is accessible within the host scoping unit
and all its other internal procedures but is not accessible elsewhere.
<b>5.2.2</b> <b>Program</b>
Aprogramshallconsistofexactlyonemainprogram, anynumber(includingzero)ofotherkindsofprogramunits,
any number (including zero) of external procedures, and any number (including zero) of other entities defined by
means other than Fortran. The main program shall be defined by a Fortran <i>main-program</i> <i>program-unit</i> or by
means other than Fortran, but not both.
<b>5.2.3</b> <b>Procedure</b>
A procedure is either a function or a subroutine. Invocation of a function in an expression causes a value to be
computed which is then used in evaluating the expression.
A procedure that is not pure may change the program state by changing the value of accessible data objects or
procedure pointers.
Procedures are described further in Clause 15.
<b>5.2.4</b> <b>Module</b>
Amodulecontains(oraccessesfromothermodules)definitionsthatcanbemadeaccessibletootherprogramunits.
These definitions include data object declarations, type definitions, procedure definitions, and interface blocks.
Modules are further described in Clause 14.
<b>5.2.5</b> <b>Submodule</b>
A submodule extends a module or another submodule.
It may provide definitions (15.6) for procedures whose interfaces are declared (15.4.3.2) in an ancestor module
or submodule. It may also contain declarations and definitions of other entities, which are accessible in its
descendants. Anentitydeclaredinasubmoduleisnotaccessiblebyuseassociationunlessitisamoduleprocedure
whose interface is declared in the ancestor module. Submodules are further described in Clause 14.
<b>NOTE</b>
A submodule has access to entities in its parent module or submodule by host association.
<b>5.3</b> <b>Execution</b> <b>concepts</b>
<b>5.3.1</b> <b>Statement</b> <b>classification</b>
Each Fortran statement is classified as either an executable statement or a nonexecutable statement.
An executable statement is an instruction to perform or control an action. Thus, the executable statements of a
program unit determine the behavior of the program unit.
Nonexecutable statements are used to configure the program environment in which actions take place.
<b>5.3.2</b> <b>Statement</b> <b>order</b>
          <b>Table</b> <b>5.1</b> <b>-</b> <b>Requirements</b> <b>on</b> <b>statement</b> <b>ordering</b>
               PROGRAM, FUNCTION, SUBROUTINE,
            MODULE, SUBMODULE, or BLOCK DATA statement
                     USE statements
                   IMPORT statements
                       IMPLICIT NONE
                 PARAMETER IMPLICIT
                  statements statements
           FORMAT
               and PARAMETER Specification constructs
              ENTRY and DATA and statement function statements
           statements statements
                      DATA Executable
                     statements constructs
                   CONTAINS statement
                   Internal subprograms
                   or module subprograms
                     END statement
The syntax rules of 5.1 specify the statement order within program units and subprograms. These rules are
illustrated in Table 5.1 and Table 5.2. Table 5.1 shows the ordering rules for statements and applies to all
program units, subprograms, and interface bodies. Vertical lines delineate varieties of statements that can be
interspersed and horizontal lines delineate varieties of statements that shall not be interspersed. Internal or
module subprograms shall follow a CONTAINS statement. Between USE and CONTAINS statements in a
subprogram, nonexecutable statements generally precede executable statements, although the ENTRY statement,
FORMAT statement, and DATA statement may appear among the executable statements. Table 5.2 shows which
statements are allowed in some kinds of scoping units.
          <b>Table</b> <b>5.2</b> <b>-</b> <b>Statements</b> <b>allowed</b> <b>in</b> <b>scoping</b> <b>units</b>
                        Kind of scoping unit
          Main Module or Block External Module Internal Interface
 Statement type program submodule data subprogram subprogram subprogram body
 USE Yes Yes Yes Yes Yes Yes Yes
 IMPORT No Submodule No No Yes Yes Yes
  ENTRY No No No Yes Yes No No
 FORMAT Yes No No Yes Yes Yes No
 Misc. decl.s
        1
           Yes Yes Yes Yes Yes Yes Yes
 DATA Yes Yes Yes Yes Yes Yes No
 Derived-type Yes Yes Yes Yes Yes Yes Yes
 Interface Yes Yes No Yes Yes Yes Yes
 Executable Yes No No Yes Yes Yes No
 CONTAINS Yes Yes No Yes Yes No No
  Statement function Yes No No Yes Yes Yes No
 (1) Miscellaneous declarations are PARAMETER statements, IMPLICIT statements, type declaration
 statements, enumeration definitions, procedure declaration statements, and specification statements.
<b>5.3.3</b> <b>The</b> <b>END</b> <b>statement</b>
Each program unit, module subprogram, and internal subprogram shall have exactly one END statement. The
<i>end-program-stmt</i>, <i>end-function-stmt</i>, <i>end-subroutine-stmt</i>, and <i>end-mp-subprogram-stmt</i> statements are execut-
able, and may be branch target statements (11.2). Executing an <i>end-program-stmt</i> initiates normal termination.
Executing an <i>end-function-stmt</i>, <i>end-subroutine-stmt</i>, or <i>end-mp-subprogram-stmt</i> is equivalent to executing a
<i>return-stmt</i> with no <i>scalar-int-expr</i>.
The <i>end-module-stmt</i>, <i>end-submodule-stmt</i>, and <i>end-block-data-stmt</i> statements are nonexecutable.
<b>5.3.4</b> <b>Program</b> <b>execution</b>
Executionofaprogramconsistsoftheasynchronous execution ofa fixed number(which maybe one)ofitsimages.
Each image has its own execution state, floating-point status (17.7), and set of data objects, input/output units,
and procedure pointers. The image index that identifies an image is an integer value in the range one to the
number of images in a team.
A team is an ordered set of images that is either the initial team, consisting of all images, or a subset of a parent
team formed by execution of a FORM TEAM statement. The initial team has no parent; every other team has
a unique parent team. Among its sibling teams, each team is identified by its team number; this is the integer
value that was specified in the FORM TEAM statement.
During execution, each image has a current team, which is only changed by execution of CHANGE TEAM
and END TEAM statements. Image indices, and thus coindexing of variable names with an <i>image-selector</i>, are
relative to the current team unless a different team is specified. Initially, the current team is the initial team.
<b>NOTE</b> <b>1</b>
Fortran control constructs (11.1, 11.2) control the progress of execution in each image. Image control statements
(11.7.1) affect the relative progress of execution between images. Coarrays (5.4.7) provide a mechanism for
accessing data on one image from another image.
<b>NOTE</b> <b>2</b>
A processor might allow the number of images to be chosen at compile time, link time, or run time. It might
be the same as the number of CPUs but this is not required. Compiling for a single image might permit the
optimizer to eliminate overhead associated with parallel execution. A program that makes assumptions about
the number of images is unlikely to be portable.
<b>5.3.5</b> <b>Execution</b> <b>sequence</b>
Following the creation of a fixed number of images, execution begins on each image. Image execution is a
sequence, in time, of actions. Actions take place during execution of the statement that performs them (except
when explicitly stated otherwise). Segments (11.7.2) executed by a single image are totally ordered, and segments
executed by separate images are partially ordered by image control statements (11.7.1).
If the program contains a Fortran main program, each image begins execution with the first executable construct
of the main program. The execution of a main program or subprogram involves execution of the executable
constructs within its scoping unit. When a Fortran procedure is invoked, the specification expressions within
the <i>specification-part</i> of the invoked procedure, if any, are evaluated in a processor dependent order. Thereafter,
execution proceeds to the first executable construct appearing within the scoping unit of the procedure after the
invoked entry point. With the following exceptions, the effect of execution is as if the executable constructs are
executed in the order in which they appear in the main program or subprogram until a STOP, ERROR STOP,
RETURN, or END statement is executed.
 Execution of a branching statement (11.2) changes the execution sequence. These statements explicitly
  specify a new starting place for the execution sequence.
 DOconstructs, IFconstructs, SELECTCASEconstructs, SELECTRANKconstructs, andSELECTTYPE
  constructs contain an internal statement structure and execution of these constructs involves implicit in-
  ternal transfer of control. See Clause 11 for the detailed semantics of each of these constructs.
 ABLOCKconstructmaycontainspecificationexpressions; see11.1.4fordetailedsemanticsofthisconstruct.
 An END=, ERR=, or EOR= specifier (12.11) can result in a branch.
 An alternate return can result in a branch.
<b>5.3.6</b> <b>Image</b> <b>execution</b> <b>states</b>
There are three image execution states: active, stopped, and failed. An image that has initiated normal termin-
ation of execution is a stopped image. An image that has ceased participating in program execution but has not
initiated termination is a failed image. All other images are active images.
A failed image remains failed for the remainder of the execution of the program. The conditions that cause an
image to fail are processor dependent. It is processor dependent whether the processor has the ability to detect
that an image has failed.
Defining a coindexed object on a failed image has no effect other than defining the <i>stat-variable</i>, if one appears,
with the value STAT_FAILED_IMAGE (16.10.2.28). The value of a reference to a coindexed object on a failed
image is processor dependent. Execution continues after such a reference.
When an image fails during the execution of a segment, a data object on a nonfailed image becomes undefined
if it is not a lock variable, notify variable, or event variable, and it might be defined or become undefined by
execution of a statement of the segment other than an invocation of an atomic subroutine with the object as an
actual argument corresponding to the ATOM dummy argument.
<b>5.3.7</b> <b>Termination</b> <b>of</b> <b>execution</b>
Termination of execution of a program is either normal termination or error termination. Normal termination
occurs only when all images initiate normal termination and occurs in three steps: initiation, synchronization,
and completion. In this case, all images synchronize execution at the second step so that no image starts the
completion step until all images have finished the initiation step. Error termination occurs when any image
initiates error termination. Once error termination has been initiated on an image, error termination is initiated
on all images that have not already initiated error termination. Termination of execution of the program occurs
when all images have terminated execution or failed.
NormalterminationofexecutionofanimageisinitiatedwhenaSTOPstatementor <i>end-program-stmt</i> isexecuted.
Normal termination of execution of an image can also be initiated during execution of a procedure defined by a
companion processor (ISO/IEC 9899:2018, 5.1.2.2.3 and 7.22.4.4). If normal termination of execution is initiated
within a Fortran program unit and the program incorporates procedures defined by a companion processor, the
process of execution termination shall include the effect of executing the C exit() function (ISO/IEC 9899:2018,
7.22.4.4) during the completion step.
Error termination of execution of an image is initiated if an ERROR STOP statement is executed or as specified
elsewhere in this document. When error termination on an image has been initiated, the processor should initiate
error termination on other images as quickly as possible.
If the processor supports the concept of a process exit status, it is recommended that error termination initiated
other than by an ERROR STOP statement supplies a processor-dependent nonzero value as the process exit
status.
<b>NOTE</b> <b>1</b>
As well as in the circumstances specified in this document, error termination might be initiated by means other
than Fortran.
<b>NOTE</b> <b>2</b>
If an image has initiated normal termination, its data remain available for possible reference or definition by
other images that are still executing.
<b>5.4</b> <b>Data</b> <b>concepts</b>
<b>5.4.1</b> <b>Type</b>
<b>5.4.1.1</b> <b>General</b>
A type is a named categorization of data that, together with its type parameters, determines the set of values,
syntax for denoting these values, and the set of operations that interpret and manipulate the values. This central
concept is described in 7.1.
A type is either an intrinsic type or a nonintrinsic type. A nonintrinsic type is defined by the program or by an
intrinsic module.
<b>5.4.1.2</b> <b>Intrinsic</b> <b>type</b>
Theintrinsictypesareinteger, real, complex, character, andlogical. Thepropertiesofintrinsictypesaredescribed
in 7.4.
All intrinsic types have a kind type parameter called KIND, which determines the representation method for the
specified type. The intrinsic type character also has a length type parameter called LEN, which determines the
length of the character string.
<b>5.4.1.3</b> <b>Derived</b> <b>type</b>
Derived types can be parameterized. A scalar object of derived type is a structure; assignment of structures
is defined intrinsically (10.2.1.3), but there are no intrinsic operations for structures. For each derived type, a
structure constructor is available to create values (7.5.10). In addition, objects of derived type can be used as
procedure arguments and function results, and can appear in input/output lists. If additional operations are
needed for a derived type, they can be defined by procedures (10.1.6).
Derived types are described further in 7.5.
<b>5.4.2</b> <b>Data</b> <b>value</b>
Each intrinsic type has associated with it a set of values that a datum of that type can take, depending on the
values of the type parameters. The values for each intrinsic type are described in 7.4. The values that objects of
a derived type can assume are determined by the type definition, type parameter values, and the sets of values of
its components. The values that an object of a nonderived nonintrinsic type can assume are determined by the
type definition.
<b>5.4.3</b> <b>Data</b> <b>entity</b>
<b>5.4.3.1</b> <b>General</b>
A data entity has a type and type parameters; it might have a data value (an exception is an undefined variable).
Every data entity has a rank and is thus either a scalar or an array.
A data entity that is the result of the execution of a function reference is called the function result.
<b>5.4.3.2</b> <b>Data</b> <b>object</b>
<b>5.4.3.2.1</b> <b>Data</b> <b>object</b> <b>classification</b>
A data object is either a constant, variable, or a subobject of a constant. The type and type parameters of a
named data object can be specified explicitly (8.2) or implicitly (8.7).
Subobjects are portions of data objects that can be referenced and defined (variables only) independently of the
other portions.
These include portions of arrays (array elements and array sections), portions of character strings (substrings),
portions of complex objects (real and imaginary parts), and portions of structures (components). Subobjects
are themselves data objects, but subobjects are referenced only by object designators or intrinsic functions. A
subobject of a variable is a variable. Subobjects are described in Clause 9.
The following objects are referenced by a name:
  a named scalar (a scalar object);
  a named array (an array object).
The following subobjects are referenced by an object designator:
  an array element (a scalar subobject);
  an array section (an array subobject);
  a complex part designator (the real or imaginary part of a complex object);
  a structure component (a scalar or an array subobject);
  a substring (a scalar subobject).
<b>5.4.3.2.2</b> <b>Variable</b>
A variable can have a value or be undefined; during execution of a program it can be defined, redefined, or become
undefined.
A local variable of a module, submodule, main program, subprogram, or BLOCK construct is accessible only in
that scoping unit or construct and in any contained scoping units and constructs.
<b>NOTE</b>
A subobject of a local variable is also a local variable.
A local variable cannot be in COMMON or have the BIND attribute, because common blocks and variables with the
BIND attribute are global entities.
<b>5.4.3.2.3</b> <b>Constant</b>
A constant is either a named constant or a literal constant.
Named constants are defined using the PARAMETER attribute (8.5.13, 8.6.11). The syntax of literal constants
is described in 7.4.
<b>5.4.3.2.4</b> <b>Subobject</b> <b>of</b> <b>a</b> <b>constant</b>
A subobject of a constant is a portion of a constant.
In an object designator for a subobject of a constant, the portion referenced may depend on the value of a variable.
<b>NOTE</b>
For example, given:
CHARACTER (LEN = 10), PARAMETER :: DIGITS = '0123456789'
CHARACTER (LEN = 1) :: DIGIT
INTEGER :: I
 ...
DIGIT = DIGITS (I:I)
DIGITS is a named constant and DIGITS (I:I) designates a subobject of the constant DIGITS.
<b>5.4.3.3</b> <b>Expression</b>
An expression (10.1) produces a data entity when evaluated. An expression represents either a data object
reference or a computation; it is formed from operands, operators, and parentheses. The type, type parameters,
value, and rank of an expression result are determined by the rules in Clause 10.
<b>5.4.3.4</b> <b>Function</b> <b>reference</b>
A function reference produces a data entity when the function is executed during expression evaluation. The
type, type parameters, and rank of a function result are determined by the interface of the function (15.3.3). The
value of a function result is determined by execution of the function.
<b>5.4.4</b> <b>Definition</b> <b>of</b> <b>objects</b> <b>and</b> <b>pointers</b>
When an object is given a valid value during program execution, it becomes defined. This is often accomplished
by execution of an assignment or input statement. When a variable does not have a predictable value, it is
undefined.
Similarly, when a pointer is associated with a target or nullified, its pointer association status becomes defined.
When the association status of a pointer is not predictable, its pointer association status is undefined.
Clause 19 describes the ways in which variables become defined and undefined and the association status of
pointers becomes defined and undefined.
<b>5.4.5</b> <b>Reference</b>
A data object is referenced when its value is required during execution. A procedure is referenced when it is
executed.
The appearance of a data object designator or procedure designator as an actual argument does not constitute
a reference to that data object or procedure unless such a reference is necessary to complete the specification of
the actual argument.
<b>5.4.6</b> <b>Array</b>
An array may have up to fifteen dimensions minus its corank, and any extent in any dimension. The size of an
array is the total number of elements, which is equal to the product of the extents. An array may have zero
size. The shape of an array is determined by its rank and its extent in each dimension, and is represented as
a rank-one array whose elements are the extents. All named arrays shall be declared, and the rank of a named
array is specified in its declaration. Except for an assumed-rank array, the rank of a named array, once declared,
is constant.
Any intrinsic operation defined for scalar objects may be applied to conformable objects. Such operations are
performedelementallytoproducearesultantarrayconformablewiththearrayoperands. Ifanelementaloperation
isintrinsicallypureorisimplementedbyapureelementalfunction(15.9),theelementoperationscanbeperformed
simultaneously or in any order.
A rank-one array can be constructed from scalars and other arrays and can be reshaped into any allowable array
shape (7.8).
Arrays are described further in 9.5.
<b>5.4.7</b> <b>Coarray</b>
A coarray is a component (7.5.4.3), or variable (9.2), that has nonzero corank. A coarray variable can be directly
referenced or defined by other images. It may be a scalar or an array.
Requirements and semantics for coarrays that refer to properties that are possessed by variables, but not by type
components, only apply to coarray variables.
For each coarray on an image, there is a corresponding coarray with the same type, type parameters, and bounds
on every other image of a team in which it is established (5.4.8). If a coarray is an unsaved local variable of a
recursive procedure, its corresponding coarrays are the ones at the same depth of recursion of that procedure on
each image.
The set of corresponding coarrays on all images in a team is arranged in a rectangular pattern. The dimensions of
this pattern are the codimensions; the number of codimensions is the corank. The bounds for each codimension
are the cobounds.
<b>NOTE</b> <b>1</b>
If the total number of images is not a multiple of the product of the sizes of each but the rightmost of the
codimensions, the rectangular pattern will be incomplete.
A coarray on any image can be accessed directly by using cosubscripts. On its own image, a coarray can also be
accessed without use of cosubscripts.
A subobject of a coarray is a coarray if it does not have any cosubscripts, vector subscripts, allocatable component
selection, or pointer component selection.
For a coindexed object, its cosubscript list determines the image index (9.6) in the same way that a subscript list
determines the subscript order value for an array element (9.5.3.3).
Intrinsic procedures are provided for mapping between an image index and a list of cosubscripts.
<b>NOTE</b> <b>2</b>
The mechanism for an image to reference and define a coarray on another image might vary according to the
hardware. On a shared-memory machine, a coarray on an image and the corresponding coarrays on other images
could be implemented as a sequence of arrays with evenly spaced starting addresses. On a distributed-memory
machine with separate physical memory for each image, a processor might store a coarray at the same virtual
address in each physical memory.
<b>NOTE</b> <b>3</b>
Except in contexts where coindexed objects are disallowed, accessing a coarray on its own image by using a set
of cosubscripts that specify that image has the same effect as accessing it without cosubscripts. In particular,
the segment ordering rules (11.7.2) apply whether or not cosubscripts are used to access the coarray.
<b>5.4.8</b> <b>Established</b> <b>coarrays</b>
A nonallocatable coarray with the SAVE attribute is established in the initial team.
An allocated allocatable coarray is established in the team in which it was allocated. An unallocated allocatable
coarray is not established.
A coarray that is established in the team in which a CHANGE TEAM statement is executed is established in
the team of the CHANGE TEAM construct.
A coarray that is an associating entity in a <i>coarray-association</i> of a CHANGE TEAM statement is established
in the team of its CHANGE TEAM construct.
A nonallocatable coarray that is an associating entity in an ASSOCIATE, SELECT RANK, or SELECT TYPE
construct is established in the team in which the ASSOCIATE, SELECT RANK, or SELECT TYPE statement
is executed.
A nonallocatable coarray that is a dummy argument or host associated with a dummy argument is established
in the team in which the procedure was invoked. A nonallocatable coarray dummy argument is not established
in any ancestor team even if the corresponding actual argument is established in one or more of them.
<b>5.4.9</b> <b>Pointer</b>
A pointer has an association status which is either associated, disassociated, or undefined (19.5.2.2).
A pointer that is not associated shall not be referenced or defined.
If a data pointer is an array, the rank is declared, but the bounds are determined when it is associated with a
target.
<b>5.4.10</b> <b>Allocatable</b> <b>variables</b>
The allocation status of an allocatable variable is either allocated or unallocated. An allocatable variable becomes
allocated as described in 9.7.1.3. It becomes unallocated as described in 9.7.3.2.
An unallocated allocatable variable shall not be referenced or defined.
If an allocatable variable is an array, the rank is declared, but the bounds are determined when it is allocated. If
an allocatable variable is a coarray, the corank is declared, but the cobounds are determined when it is allocated.
<b>5.4.11</b> <b>Storage</b>
Many of the facilities of this document make no assumptions about the physical storage characteristics of data
objects. However, program units that include storage association dependent features shall observe the storage
restrictions described in 19.5.3.
<b>5.5</b> <b>Fundamental</b> <b>concepts</b>
<b>5.5.1</b> <b>Names</b> <b>and</b> <b>designators</b>
A name is used to identify a program constituent, such as a program unit, named variable, named constant,
dummy argument, or nonintrinsic type.
A designator is used to identify a program constituent or a part thereof.
<b>5.5.2</b> <b>Statement</b> <b>keyword</b>
A statement keyword is not a reserved word; that is, a name with the same spelling is allowed. In the syntax
rules, such keywords appear literally. In descriptive text, this meaning is denoted by the term "keyword" without
any modifier. Examples of statement keywords are IF, READ, UNIT, KIND, and INTEGER.
<b>5.5.3</b> <b>Other</b> <b>keywords</b>
Other keywords denote names that identify items in a list. In this case, items are identified by a preceding
<i>keyword</i>= rather than their position within the list.
An argument keyword is the name of a dummy argument in the interface for the procedure being referenced, and
can appear in an actual argument list. A type parameter keyword is the name of a type parameter in the type
being specified, and can appear in a <i>type-param-spec</i>. A component keyword is the name of a component in a
structure constructor.
R516 <i>keyword</i> <b>is</b> <i>name</i>
<b>NOTE</b>
Use of keywords rather than position to identify items in a list can make such lists more readable and allows
them to be reordered. This facilitates specification of a list in cases where optional items are omitted.
<b>5.5.4</b> <b>Association</b>
Name association (19.5.1) permits an entity to be identified by different names in the same scoping unit or by
the same name or different names in different scoping units.
Pointer association (19.5.2) between a pointer and a target allows the target to be denoted by the pointer.
Storage association (19.5.3) causes different entities to use the same storage.
Inheritance association (19.5.4) occurs between components of the parent component and components inherited
by type extension.
<b>5.5.5</b> <b>Intrinsic</b>
All intrinsic types, procedures, assignments, and operators may be used in any scoping unit without further
definition or specification. Intrinsic modules (16.10, 17, 18.2) may be accessed by use association.
<b>5.5.6</b> <b>Operator</b>
This document specifies a number of intrinsic operators (e.g., the arithmetic operators +, -, *, /, and ** with
numeric operands and the logical operators .AND., .OR., etc. with logical operands). Additional operators can
be defined within a program (7.5.5, 15.4.3.4).
<b>5.5.7</b> <b>Companion</b> <b>processors</b>
A processor has one or more companion processors. A companion processor can be a mechanism that references
and defines such entities by a means other than Fortran (15.6.3), it can be the Fortran processor itself, or it can
be another Fortran processor. If there is more than one companion processor, the means by which the Fortran
processor selects among them are processor dependent.
If a procedure is defined by means of a companion processor that is not the Fortran processor itself, this document
refers to the C function that defines the procedure, although the procedure need not be defined by means of the
C programming language.
<b>NOTE</b>
A companion processor might or might not be a mechanism that conforms to the requirements of ISO/IEC
9899:2018. If it does, 5.3.7 states that a program unit that is defined by means other than Fortran and that
initiates normal termination is required to include the effect of executing the C exit() function.
For example, a processor might allow a procedure defined by some language other than Fortran or C to be
invoked if it can be described by a C prototype as defined in ISO/IEC 9899:2018, 6.7.6.3.
<b>6</b> <b>Lexical</b> <b>tokens</b> <b>and</b> <b>source</b> <b>form</b>
<b>6.1</b> <b>Processor</b> <b>character</b> <b>set</b>
<b>6.1.1</b> <b>Characters</b>
The processor character set is processor dependent. Each character in a processor character set is either a control
character or a graphic character. The set of graphic characters is further divided into letters (6.1.2), digits (6.1.3),
underscore (6.1.4), special characters (6.1.5), and other characters (6.1.6).
The letters, digits, underscore, and special characters make up the Fortran character set. Together, the set of
letters, digits, and underscore define the syntax class <i>alphanumeric-character</i>.
R601 <i>alphanumeric-character</i> <b>is</b> <i>letter</i>
              <b>or</b> <i>digit</i>
              <b>or</b> <i>underscore</i>
Except for the currency symbol, the graphics used for the characters shall be as given in 6.1.2, 6.1.3, 6.1.4, and
6.1.5. However, the style of any graphic is not specified.
<b>6.1.2</b> <b>Letters</b>
The twenty-six letters are:
 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
The set of letters defines the syntactic class <i>letter</i>. The processor character set shall include lower-case and upper-
case letters. A lower-case letter is equivalent to the corresponding upper-case letter in program units except in a
character context (3.21).
<b>NOTE</b>
The following statements are equivalent:
CALL BIG_COMPLEX_OPERATION (NDATE)
call big_complex_operation (ndate)
Call Big_Complex_Operation (NDate)
<b>6.1.3</b> <b>Digits</b>
The ten digits are:
 0 1 2 3 4 5 6 7 8 9
The ten digits define the syntactic class <i>digit</i>.
<b>6.1.4</b> <b>Underscore</b>
R602 <i>underscore</i> <b>is</b> _
<b>6.1.5</b> <b>Special</b> <b>characters</b>
The special characters are shown in Table 6.1.
              <b>Table</b> <b>6.1</b> <b>-</b> <b>Special</b> <b>characters</b>
       Character Name of character Character Name of character
             Blank ; Semicolon
         = Equals ! Exclamation point
         + Plus " Quotation mark or quote
         - Minus % Percent
         * Asterisk & Ampersand
         / Slash ~ Tilde
         \ Backslash <i><</i> Less than
         ( Left parenthesis <i>></i> Greater than
         ) Right parenthesis ? Question mark
                 [ Left square bracket ' Apostrophe
                 ] Right square bracket ` Grave accent
         { Left curly bracket ^ Circumflex accent
         } Right curly bracket | Vertical line
         , Comma $ Currency symbol
         . Decimal point or period # Number sign
         : Colon @ Commercial at
Some of the special characters are used for operator symbols, bracketing, and various forms of separating and
delimiting other lexical tokens.
<b>6.1.6</b> <b>Other</b> <b>characters</b>
Additional characters may be representable in the processor, but shall appear only in comments (6.3.2.3, 6.3.3.2),
character constants (7.4.4), input/output records (12.2.2), and character string edit descriptors (13.3.2).
<b>6.2</b> <b>Low-level</b> <b>syntax</b>
<b>6.2.1</b> <b>Tokens</b>
The low-level syntax describes the fundamental lexical tokens of a program unit. A lexical token is a keyword,
name, literal constant other than a complex literal constant, .NIL., operator, statement label, delimiter, comma,
=, =<i>></i>, :, ::, ;, .., ?, or %.
<b>6.2.2</b> <b>Names</b>
Names are used for various entities such as variables, program units, dummy arguments, named constants, and
nonintrinsic types.
R603 <i>name</i> <b>is</b> <i>letter</i> [ <i>alphanumeric-character</i> ] ...
C601 (R603) The maximum length of a <i>name</i> is 63 characters.
<b>NOTE</b> <b>1</b>
Examples of names:
A1
NAME_LENGTH (single underscore)
S_P_R_E_A_D__O_U_T (two consecutive underscores)
TRAILER_ (trailing underscore)
<b>NOTE</b> <b>2</b>
The word "name" always denotes this particular syntactic form. The word "identifier" is used where entities
can be identified by other syntactic forms or by values; its particular meaning depends on the context in which
it is used.
<b>6.2.3</b> <b>Constants</b>
R604 <i>constant</i> <b>is</b> <i>literal-constant</i>
              <b>or</b> <i>named-constant</i>
R605 <i>literal-constant</i> <b>is</b> <i>int-literal-constant</i>
              <b>or</b> <i>real-literal-constant</i>
              <b>or</b> <i>complex-literal-constant</i>
              <b>or</b> <i>logical-literal-constant</i>
              <b>or</b> <i>char-literal-constant</i>
              <b>or</b> <i>boz-literal-constant</i>
R606 <i>named-constant</i> <b>is</b> <i>name</i>
R607 <i>int-constant</i> <b>is</b> <i>constant</i>
C602 (R607) <i>int-constant</i> shall be of type integer.
<b>6.2.4</b> <b>Operators</b>
R608 <i>intrinsic-operator</i> <b>is</b> <i>power-op</i>
              <b>or</b> <i>mult-op</i>
              <b>or</b> <i>add-op</i>
              <b>or</b> <i>concat-op</i>
              <b>or</b> <i>rel-op</i>
              <b>or</b> <i>not-op</i>
              <b>or</b> <i>and-op</i>
              <b>or</b> <i>or-op</i>
              <b>or</b> <i>equiv-op</i>
R1008 <i>power-op</i> <b>is</b> **
R1009 <i>mult-op</i> <b>is</b> *
              <b>or</b> /
R1010 <i>add-op</i> <b>is</b> +
              <b>or</b> -
R1012 <i>concat-op</i> <b>is</b> //
R1014 <i>rel-op</i> <b>is</b> .EQ.
              <b>or</b> .NE.
              <b>or</b> .LT.
              <b>or</b> .LE.
              <b>or</b> .GT.
              <b>or</b> .GE.
              <b>or</b> ==
              <b>or</b> /=
              <b>or</b> <i><</i>
              <b>or</b> <i><</i>=
              <b>or</b> <i>></i>
              <b>or</b> <i>></i>=
R1019 <i>not-op</i> <b>is</b> .NOT.
R1020 <i>and-op</i> <b>is</b> .AND.
R1021 <i>or-op</i> <b>is</b> .OR.
R1022 <i>equiv-op</i> <b>is</b> .EQV.
              <b>or</b> .NEQV.
R609 <i>defined-operator</i> <b>is</b> <i>defined-unary-op</i>
              <b>or</b> <i>defined-binary-op</i>
              <b>or</b> <i>extended-intrinsic-op</i>
R1004 <i>defined-unary-op</i> <b>is</b> . <i>letter</i> [ <i>letter</i> ] ... .
R1024 <i>defined-binary-op</i> <b>is</b> . <i>letter</i> [ <i>letter</i> ] ... .
R610 <i>extended-intrinsic-op</i> <b>is</b> <i>intrinsic-operator</i>
<b>6.2.5</b> <b>Statement</b> <b>labels</b>
A statement label provides a means of referring to an individual statement.
R611 <i>label</i> <b>is</b> <i>digit</i> [ <i>digit</i> [ <i>digit</i> [ <i>digit</i> [ <i>digit</i> ] ] ] ]
C603 (R611) At least one digit in a <i>label</i> shall be nonzero.
If a statement is labeled, the statement shall contain a nonblank character. The same statement label shall not
be given to more than one statement in its scope. Leading zeros are not significant in distinguishing between
statement labels. There are 99999 possible unique statement labels and a processor shall accept any of them as
a statement label. However, a processor may have a limit on the total number of unique statement labels in one
program unit.
<b>NOTE</b>
For example:
99999
10
010
are all statement labels. The last two are equivalent.
Any statement that is not part of another statement, and that is not preceded by a semicolon in fixed form, may begin
with a statement label, but the labels are used only in the following ways.
 The label on a branch target statement (11.2) is used to identify that statement as the possible destination
  of a branch.
 The label on a FORMAT statement (13.2.1) is used to identify that statement as the format specification
  for a data transfer statement (12.6).
 In some forms of the DO construct (11.1.7), the terminal statement of the construct is identified by a label.
<b>6.2.6</b> <b>Delimiters</b>
A lexical token that is a delimiter is a (, ), /, [, ], (/, or /).
<b>6.3</b> <b>Source</b> <b>form</b>
<b>6.3.1</b> <b>Program</b> <b>units,</b> <b>statements,</b> <b>and</b> <b>lines</b>
A Fortran program unit is a sequence of one or more lines, organized as Fortran statements, comments, and
INCLUDE lines. A line is a sequence of zero or more characters. Lines following a program unit END statement
are not part of that program unit. A Fortran statement is a sequence of one or more complete or partial lines.
A comment may contain any character that may occur in any character context.
There are two source forms. The rules in 6.3.2 apply only to free form source. The rules in 6.3.3 apply only to fixed source
form. Free form and fixed form shall not be mixed in the same program unit. The means for specifying the source form of a program
unit are processor dependent.
<b>6.3.2</b> <b>Free</b> <b>source</b> <b>form</b>
<b>6.3.2.1</b> <b>Free</b> <b>form</b> <b>line</b> <b>length</b>
In free source form there are no restrictions on where a statement (or portion of a statement) can appear within
a line. A line may contain zero characters. A line shall contain at most ten thousand characters.
<b>6.3.2.2</b> <b>Blank</b> <b>characters</b> <b>in</b> <b>free</b> <b>form</b>
In free source form blank characters shall not appear within lexical tokens other than in a character context or in
a format specification. Blanks may be inserted freely between tokens to improve readability; for example, blanks
may occur between the tokens that form a complex literal constant. A sequence of blank characters outside of a
character context is equivalent to a single blank character.
A blank shall be used to separate names, constants, or labels from adjacent keywords, names, constants, or labels.
<b>NOTE</b>
For example, the blanks after REAL, READ, 30, and DO are required in the following:
REAL X
READ 10
30 DO K=1,3
One or more blanks shall be used to separate adjacent keywords except in the following cases, where blanks are
optional:
      <b>Table</b> <b>6.2</b> <b>-</b> <b>Adjacent</b> <b>keywords</b> <b>where</b> <b>separating</b> <b>blanks</b> <b>are</b> <b>optional</b>
          BLOCK DATA END FILE END SUBROUTINE
         DOUBLE PRECISION END FORALL END TEAM
         ELSE IF END FUNCTION END TYPE
         ELSE WHERE END IF END WHERE
         END ASSOCIATE END INTERFACE GO TO
         END BLOCK END MODULE IN OUT
          END BLOCK DATA END PROCEDURE SELECT CASE
         END CRITICAL END PROGRAM SELECT TYPE
         END DO END SELECT
         END ENUM END SUBMODULE
<b>6.3.2.3</b> <b>Free</b> <b>form</b> <b>commentary</b>
The character "!" initiates a comment except where it appears within a character context. The comment extends
to the end of the line. If the first nonblank character on a line is an "!", the line is a comment line. Lines
containing only blanks or containing no characters are also comment lines. Comments may appear anywhere in
a program unit and may precede the first statement of a program unit or follow the last statement of a program
unit. Comments have no effect on the interpretation of the program unit.
<b>NOTE</b>
This document does not restrict the number of consecutive comment lines.
<b>6.3.2.4</b> <b>Free</b> <b>form</b> <b>statement</b> <b>continuation</b>
The character "&" is used to indicate that the statement is continued on the next line that is not a comment
line. Comment lines cannot be continued; an "&" in a comment has no effect. Comments may occur within a
continued statement. When used for continuation, the "&" is not part of the statement. No line shall contain
a single "&" as the only nonblank character or as the only nonblank character before an "!" that initiates a
comment.
If a noncharacter context is to be continued, an "&" shall be the last nonblank character on the line, or the last
nonblank character before an "!". There shall be a later line that is not a comment; the statement is continued
on the next such line. If the first nonblank character on that line is an "&", the statement continues at the next
character position following that "&"; otherwise, it continues with the first character position of that line.
If a lexical token is split across the end of a line, the first nonblank character on the first following noncomment
line shall be an "&" immediately followed by the successive characters of the split token.
If a character context is to be continued, an "&" shall be the last nonblank character on the line. There shall be
a later line that is not a comment; an "&" shall be the first nonblank character on the next such line and the
statement continues with the next character following that "&".
<b>6.3.2.5</b> <b>Free</b> <b>form</b> <b>statement</b> <b>termination</b>
If a statement is not continued, a comment or the end of the line terminates the statement.
A statement may alternatively be terminated by a ";" character that appears other than in a character context
or in a comment. The ";" is not part of the statement. After a ";" terminator, another statement may appear
on the same line, or begin on that line and be continued. A sequence consisting only of zero or more blanks and
one or more ";" terminators, in any order, is equivalent to a single ";" terminator.
<b>6.3.2.6</b> <b>Free</b> <b>form</b> <b>statements</b>
A label may precede any statement not forming part of another statement.
<b>NOTE</b>
No Fortran statement begins with a digit.
A statement shall not have more than one million characters.
<b>6.3.3</b> <b>Fixed</b> <b>source</b> <b>form</b>
<b>6.3.3.1</b> <b>General</b>
In fixed source form, there are restrictions on where a statement can appear within a line. If a source line contains only characters
of default kind, it shall contain exactly 72 characters; otherwise, its maximum number of characters is processor dependent.
Except in a character context, blanks are insignificant and may be used freely throughout the program.
<b>6.3.3.2</b> <b>Fixed</b> <b>form</b> <b>commentary</b>
The character "!" initiates a comment except where it appears within a character context or in character position 6. The comment
extends to the end of the line. If the first nonblank character on a line is an "!" in any character position other than character
position 6, the line is a comment line. Lines beginning with a "C" or "*" in character position 1 and lines containing only blanks are
also comment lines. Comments may appear anywhere in a program unit and may precede the first statement of the program unit or
follow the last statement of a program unit. Comments have no effect on the interpretation of the program unit.
<b>NOTE</b>
This document does not restrict the number of consecutive comment lines.
<b>6.3.3.3</b> <b>Fixed</b> <b>form</b> <b>statement</b> <b>continuation</b>
Except within commentary, character position 6 is used to indicate continuation. If character position 6 contains a blank or zero, the
line is the initial line of a new statement, which begins in character position 7. If character position 6 contains any character other
than blank or zero, character positions 7-72 of the line constitute a continuation of the preceding noncomment line.
<b>NOTE</b>
An "!" or ";" in character position 6 is interpreted as a continuation indicator unless it appears within commentary indicated by a
"C" or "*" in character position 1 or by an "!" in character positions 1-5.
Comment lines cannot be continued. Comment lines may occur within a continued statement.
<b>6.3.3.4</b> <b>Fixed</b> <b>form</b> <b>statement</b> <b>termination</b>
If a statement is not continued, a comment or the end of the line terminates the statement.
A statement may alternatively be terminated by a ";" character that appears other than in a character context, in a comment, or in
character position 6. The ";" is not part of the statement. After a ";" terminator, another statement may begin on the same line, or
begin on that line and be continued. A ";" shall not appear as the first nonblank character on an initial line. A sequence consisting
only of zero or more blanks and one or more ";" terminators, in any order, is equivalent to a single ";" terminator.
<b>6.3.3.5</b> <b>Fixed</b> <b>form</b> <b>statements</b>
A label, if it appears, shall occur in character positions 1 through 5 of the first line of a statement; otherwise, positions 1 through
5 shall be blank. Blanks may appear anywhere within a label. A statement following a ";" on the same line shall not be labeled.
Character positions 1 through 5 of any continuation lines shall be blank. A statement shall not have more than one million characters.
The program unit END statement shall not be continued. A statement whose initial line appears to be a program unit END statement
shall not be continued.
<b>6.4</b> <b>Including</b> <b>source</b> <b>text</b>
Additionaltextcanbeincorporatedintothesourcetextofaprogramunitduringprocessing. Thisisaccomplished
with the INCLUDE line, which has the form
  INCLUDE <i>char-literal-constant</i>
The <i>char-literal-constant</i> shall not have a kind type parameter value that is a <i>named-constant</i>.
An INCLUDE line is not a Fortran statement.
An INCLUDE line shall appear on a single source line where a statement can appear; it shall be the only nonblank
text on this line other than an optional trailing comment. Thus, a statement label is not allowed.
The effect of the INCLUDE line is as if the referenced source text physically replaced the INCLUDE line prior
to program processing. Included text may contain any source text, including additional INCLUDE lines; such
nested INCLUDE lines are similarly replaced with the specified source text. The maximum depth of nesting of
any nested INCLUDE lines is processor dependent. Inclusion of the source text referenced by an INCLUDE line
shall not, at any level of nesting, result in inclusion of the same source text.
When an INCLUDE line is resolved, the first included statement line shall not be a continuation line and the last
included statement line shall not be continued.
The interpretation of <i>char-literal-constant</i> is processor dependent. An example of a possible valid interpretation
is that <i>char-literal-constant</i> is the name of a file that contains the source text to be included.
<b>NOTE</b>
In some circumstances, for example where source code is maintained in an INCLUDE file for use in programs whose source form
might be either fixed or free, observing the following rules allows the code to be used with either source form.
  Confine statement labels to character positions 1 to 5 and statements to character positions 7 to 72.
  Treat blanks as being significant.
  Use only the exclamation mark (!) to indicate a comment, but do not start the comment in character position 6.
  For continued statements, place an ampersand (&) in both character position 73 of a continued line and character position
   6 of a continuation line.
<b>7</b> <b>Types</b>
<b>7.1</b> <b>Characteristics</b> <b>of</b> <b>types</b>
<b>7.1.1</b> <b>The</b> <b>concept</b> <b>of</b> <b>type</b>
Fortran provides an abstract means whereby data can be categorized without relying on a particular physical
representation. This abstract means is the concept of type.
A type has a name, a set of valid values, a means to denote such values (constants), and a set of operations to
manipulate the values.
<b>7.1.2</b> <b>Type</b> <b>classification</b>
A type is either an intrinsic type or a nonintrinsic type.
This document defines five intrinsic types: integer, real, complex, character, and logical.
A derived type is one that is defined by a derived-type definition (7.5.2) or by an intrinsic module. An enum
type is one that is defined by an enum type definition (7.6.1) or by an intrinsic module. An enumeration type
is one that is defined by an enumeration type definition (7.6.2) or by an intrinsic module. A nonintrinsic type
name shall be used only where it is accessible (7.5.2.2). An intrinsic type is always accessible.
<b>7.1.3</b> <b>Set</b> <b>of</b> <b>values</b>
For each type, there is a set of valid values. The set of valid values for logical is completely determined by this
document. The sets of valid values for integer, character, and real are processor dependent. The set of valid
values for complex consists of the set of all the combinations of the values of the real and imaginary parts. The
set of valid values for a derived type is as defined in 7.5.8. The set of valid values for an enum type is as defined
in 7.6.1. The set of valid values for an enumeration type is as defined in 7.6.2.
<b>7.1.4</b> <b>Constants</b>
The syntax for denoting a value indicates the type, type parameters, and the particular value.
The syntax for literal constants of each intrinsic type is specified in 7.4.
A structure constructor (7.5.10) that is a constant expression (10.1.12) denotes a scalar constant value of derived
type. An enum constructor (7.6.1) that is a constant expression denotes a scalar constant value of enum type.
An enumeration constructor (7.6.2) that is a constant expression denotes a scalar constant value of enumeration
type. An array constructor (7.8) that is a constant expression denotes a constant array value of intrinsic or
nonintrinsic type.
A constant value can be named (8.5.13, 8.6.11).
<b>7.1.5</b> <b>Operations</b>
For each of the intrinsic types, a set of operations and corresponding operators is defined intrinsically. These are
described in Clause 10. The intrinsic set can be augmented with operations and operators defined by functions
with the OPERATOR interface (15.4.3.2). Operator definitions are described in Clauses 10 and 15.
For derived types, there are no intrinsic operations. Operations on derived types can be defined by the program
(7.5.11).
For an enum or enumeration type, a set of intrinsic operations is defined intrinsically as described in Clause 10.
The intrinsic set can be augmented with operations and operators defined by the program.
<b>7.2</b> <b>Type</b> <b>parameters</b>
If a type has type parameters, the set of values, the syntax for denoting the values, and the set of operations on
the values of the type depend on the values of the parameters.
A type parameter is either a kind type parameter or a length type parameter. All type parameters are of type
integer. A kind type parameter participates in generic resolution (15.5.5.2), but a length type parameter does
not.
Each intrinsic type has a kind type parameter named KIND. The intrinsic character type has a length type
parameter named LEN. A derived type can have type parameters.
A type parameter value can be specified by a type specification (7.4, 7.5.9).
R701 <i>type-param-value</i> <b>is</b> <i>scalar-int-expr</i>
              <b>or</b> *
              <b>or</b> :
C701 (R701) The <i>type-param-value</i> for a kind type parameter shall be a constant expression.
C702 (R701) A colon shall not be used as a <i>type-param-value</i> except in the declaration of an entity that has
   the POINTER or ALLOCATABLE attribute.
A colon as a <i>type-param-value</i> specifies a deferred type parameter.
The values of the deferred type parameters of an object are determined by successful execution of an ALLOCATE
statement (9.7.1), execution of an intrinsic assignment statement (10.2.1.3), execution of a pointer assignment
statement (10.2.2), or by argument association (15.5.2).
<b>NOTE</b> <b>1</b>
Deferred type parameters of functions, including function procedure pointers, have no values. Instead, they
indicate that those type parameters of the function result will be determined by execution of the function, if it
returns an allocated allocatable result or an associated pointer result.
An asterisk as a <i>type-param-value</i> specifies that a length type parameter is an assumed type parameter. It is used
for a dummy argument to assume the type parameter value from the effective argument, for an associate name
in a SELECT TYPE construct to assume the type parameter value from the corresponding selector, and for a
named constant of type character to assume the character length from the <i>constant-expr</i>.
<b>NOTE</b> <b>2</b>
The value of a kind type parameter is always known at compile time. Some parameterizations that involve
multiple representation forms need to be distinguished at compile time for practical implementation and per-
formance. Examples include the multiple precisions of the intrinsic real type and the possible multiple character
sets of the intrinsic character type.
The adjective "length" is used for type parameters other than kind type parameters because they often specify a
length, as for intrinsic character type. However, they can be used for other purposes. The important difference
from kind type parameters is that their values need not be known at compile time and might change during
execution.
<b>7.3</b> <b>Types,</b> <b>type</b> <b>specifiers,</b> <b>and</b> <b>values</b>
<b>7.3.1</b> <b>Relationship</b> <b>of</b> <b>types</b> <b>and</b> <b>values</b> <b>to</b> <b>objects</b>
The name of a type serves as a type specifier and can be used to declare objects of that type. A declaration can
specify the type of a named object. A data object can be declared explicitly or implicitly. A data object has
attributes in addition to its type. Clause 8 describes the way in which a data object is declared and how its type
and other attributes are specified.
An array is formed of scalar data of an intrinsic or nonintrinsic type, and has the same type and type parameters
as its elements.
A variable is a data object. The type and type parameters of a variable determine which values that variable can
take. Assignment (10.2) provides one means of changing the value of a variable.
The type of a variable determines the operations that can be used to manipulate the variable.
<b>7.3.2</b> <b>Type</b> <b>specifiers</b>
<b>7.3.2.1</b> <b>Type</b> <b>specifier</b> <b>syntax</b>
A type specifier specifies a type and type parameter values. It is either a <i>type-spec</i> or a <i>declaration-type-spec</i>.
R702 <i>type-spec</i> <b>is</b> <i>intrinsic-type-spec</i>
              <b>or</b> <i>derived-type-spec</i>
              <b>or</b> <i>enum-type-spec</i>
              <b>or</b> <i>enumeration-type-spec</i>
C703 (R702) The <i>derived-type-spec</i> shall not specify an abstract type (7.5.7).
R703 <i>declaration-type-spec</i> <b>is</b> <i>intrinsic-type-spec</i>
              <b>or</b> TYPE ( <i>intrinsic-type-spec</i> )
              <b>or</b> TYPE ( <i>derived-type-spec</i> )
              <b>or</b> TYPE ( <i>enum-type-spec</i> )
              <b>or</b> TYPE ( <i>enumeration-type-spec</i> )
              <b>or</b> CLASS ( <i>derived-type-spec</i> )
              <b>or</b> CLASS ( * )
              <b>or</b> TYPE ( * )
              <b>or</b> TYPEOF ( <i>data-ref</i> )
              <b>or</b> CLASSOF ( <i>data-ref</i> )
C704 (R703) In a <i>declaration-type-spec</i>, every <i>type-param-value</i> that is not a colon or an asterisk shall be a
   specification expression.
C705 (R703) In a <i>declaration-type-spec</i> that uses the CLASS keyword, <i>derived-type-spec</i> shall specify an ex-
   tensible type (7.5.7).
C706 (R703) TYPE(<i>derived-type-spec</i>) shall not specify an abstract type (7.5.7).
C707 (R702) In TYPE(<i>intrinsic-type-spec</i>) the <i>intrinsic-type-spec</i> shall not end with a comma.
C708 An entity declared with the CLASS or CLASSOF keyword shall be a dummy argument or have the
   ALLOCATABLE or POINTER attribute.
C709 A TYPEOF or CLASSOF specifier shall appear only in a type declaration statement or component
   definition statement.
C710 The <i>data-ref</i> in a TYPEOF or CLASSOF specifier shall have its type and type parameters previously
   declared or established by the implicit typing rules.
C711 The <i>data-ref</i> in a TYPEOF specifier shall not be unlimited polymorphic or of abstract type.
C712 The <i>data-ref</i> in a CLASSOF specifier shall not be assumed-type or of intrinsic type.
C713 If the <i>data-ref</i> in a TYPEOF or CLASSOF specifier has the OPTIONAL attribute, it shall not have a
   deferred or assumed type parameter.
An <i>intrinsic-type-spec</i> specifies the named intrinsic type and its type parameter values. A <i>derived-type-spec</i>
specifies the named derived type and its type parameter values. An <i>enum-type-spec</i> specifies the named enum
type. An <i>enumeration-type-spec</i> specifies the named enumeration type.
TYPEOF and CLASSOF with a <i>data-ref</i> that is not unlimited polymorphic specify the same type and type
parameter values as the declared type and type parameter values of <i>data-ref</i>, except that they specify that a type
parameter is deferred if it is deferred in <i>data-ref</i>. An entity declared with CLASSOF is polymorphic, and one
declared with TYPEOF is not polymorphic. If a <i>data-ref</i> is CLASS (*), CLASSOF (<i>data-ref</i>) is equivalent to a
CLASS (*) specifier.
<b>NOTE</b> <b>1</b>
A <i>type-spec</i> is used in an array constructor, a SELECT TYPE construct, or an ALLOCATE statement. An
<i>integer-type-spec</i> is used in a DO CONCURRENT or FORALL statement. Elsewhere, a <i>declaration-type-spec</i> is
used.
<b>NOTE</b> <b>2</b>
Note that TYPEOF and CLASSOF declare entities whose type parameters depend on those of the <i>data-ref</i>,
they are not equivalent to simply repeating the declaration of the <i>data-ref</i>. For example, if the <i>data-ref</i> has an
assumed type parameter, the entities declared have the same values for that type parameter as <i>data-ref</i>, they
are not assumed (even if they are dummy arguments).
<b>7.3.2.2</b> <b>TYPE</b> <b>type</b> <b>specifier</b>
A TYPE type specifier is used to declare entities that are assumed-type, or of an intrinsic or nonintrinsic type.
A <i>derived-type-spec</i>, <i>enum-type-spec</i>, or <i>enumeration-type-spec</i> in a TYPE type specifier in a type declaration
statement shall specify a previously defined type. If the data entity is a function result, the type may be specified
in the FUNCTION statement provided the type is defined within the body of the function or is accessible there
by use or host association. If the type is specified in the FUNCTION statement and is defined within the body
of the function, it is as if the function result were declared with that type immediately following the definition of
the specified type.
An entity that is declared using the TYPE(*) type specifier is assumed-type and is an unlimited polymorphic
entity. It is not declared to have a type, and is not considered to have the same declared type as any other entity,
including another unlimited polymorphic entity. Its dynamic type and type parameters are assumed from its
effective argument.
C714 An assumed-type entity shall be a dummy data object that does not have the ALLOCATABLE, CODI-
   MENSION, INTENT (OUT), POINTER, or VALUE attribute and is not an explicit-shape array.
C715 An assumed-type variable name shall not appear in a designator or expression except as an actual
   argument corresponding to a dummy argument that is assumed-type, or as the first argument to the
   intrinsic function IS_CONTIGUOUS, LBOUND, PRESENT, RANK, SHAPE, SIZE, or UBOUND, or
   the function C_LOC from the intrinsic module ISO_C_BINDING.
C716 An assumed-type actual argument that corresponds to an assumed-rank dummy argument shall be
   assumed-shape or assumed-rank.
<b>7.3.2.3</b> <b>CLASS</b> <b>type</b> <b>specifier</b>
The CLASS type specifier is used to declare polymorphic entities. A polymorphic entity is a data entity that is
able to be of differing dynamic types during program execution.
A <i>derived-type-spec</i> in a CLASS type specifier in a type declaration statement shall specify a previously defined
derived type. If the data entity is a function result, the derived type may be specified in the FUNCTION
statement provided the derived type is defined within the body of the function or is accessible there by use or
host association. If the derived type is specified in the FUNCTION statement and is defined within the body
of the function, it is as if the function result were declared with that derived type immediately following its
<i>derived-type-def</i>.
The declared type of a polymorphic entity is the specified type if the CLASS type specifier contains a type name.
An entity declared with the CLASS(*) specifier is an unlimited polymorphic entity. It is not declared to have
a type, and is not considered to have the same declared type as any other entity, including another unlimited
polymorphic entity.
The dynamic type of an allocated allocatable polymorphic object is the type with which it was allocated. The
dynamic type of an associated polymorphic pointer is the dynamic type of its target. The dynamic type of a
nonallocatable nonpointer polymorphic dummy argument is the dynamic type of its effective argument. The
dynamic type of an unallocated allocatable object or a disassociated pointer is the same as its declared type. The
dynamic type of an entity identified by an associate name (11.1.3) is the dynamic type of the selector with which
it is associated. The dynamic type of an object that is not polymorphic is its declared type.
<b>7.3.3</b> <b>Type</b> <b>compatibility</b>
A nonpolymorphic entity is type compatible only with entities of the same declared type, except that an entity
of an enum type is also type compatible with an expression of type integer if the expression has a primary
that is an enumerator of that enum type. A polymorphic entity that is not an unlimited polymorphic entity
is type compatible with entities of the same declared type or any of its extensions. Even though an unlimited
polymorphic entity is not considered to have a declared type, it is type compatible with all entities. An entity is
type compatible with a type if it is type compatible with entities of that type.
<b>NOTE</b>
Given
 TYPE TROOT
 ...
 TYPE,EXTENDS(TROOT) :: TEXTENDED
 ...
 CLASS(TROOT) A
 CLASS(TEXTENDED) B
 ...
A is type compatible with B but B is not type compatible with A.
A polymorphic allocatable object may be allocated to be of any type with which it is type compatible. A
polymorphic pointer or dummy argument may, during program execution, be associated with objects with which
it is type compatible.
<b>7.4</b> <b>Intrinsic</b> <b>types</b>
<b>7.4.1</b> <b>Classification</b> <b>and</b> <b>specification</b>
Each intrinsic type is classified as a numeric type or a nonnumeric type. The numeric types are integer, real, and
complex. The nonnumeric intrinsic types are character and logical.
Each intrinsic type has a kind type parameter named KIND; this type parameter is of type integer with default
kind.
R704 <i>intrinsic-type-spec</i> <b>is</b> <i>integer-type-spec</i>
              <b>or</b> REAL [ <i>kind-selector</i> ]
              <b>or</b> DOUBLE PRECISION
              <b>or</b> COMPLEX [ <i>kind-selector</i> ]
              <b>or</b> CHARACTER [ <i>char-selector</i> ]
              <b>or</b> LOGICAL [ <i>kind-selector</i> ]
R705 <i>integer-type-spec</i> <b>is</b> INTEGER [ <i>kind-selector</i> ]
R706 <i>kind-selector</i> <b>is</b> ( [ KIND = ] <i>scalar-int-constant-expr</i> )
C717 (R706) The value of <i>scalar-int-constant-expr</i> shall be nonnegative and shall specify a representation
   method that exists on the processor.
<b>7.4.2</b> <b>Intrinsic</b> <b>operations</b> <b>on</b> <b>intrinsic</b> <b>types</b>
Intrinsic numeric operations are defined as specified in 10.1.5.2.1 for the numeric intrinsic types. Relational
intrinsic operations are defined as specified in 10.1.5.5 for numeric and character intrinsic types. The intrinsic
concatenation operation is defined as specified in 10.1.5.3 for the character type. Logical intrinsic operations are
defined as specified in 10.1.5.4 for the logical type.
<b>7.4.3</b> <b>Numeric</b> <b>intrinsic</b> <b>types</b>
<b>7.4.3.1</b> <b>Integer</b> <b>type</b>
The set of values for the integer type is a subset of the mathematical integers. The processor shall provide one or
more representation methods that define sets of values for data of type integer. Each such method is characterized
by a value for the kind type parameter KIND. The kind type parameter of a representation method is returned
by the intrinsic function KIND (16.9.118). The decimal exponent range of a representation method is returned
by the intrinsic function RANGE (16.9.170). The intrinsic function SELECTED_INT_KIND (16.9.181) returns
a kind value based on a specified decimal exponent range requirement. The integer type includes a zero value,
which is considered to be neither negative nor positive. The value of a signed integer zero is the same as the
value of an unsigned integer zero.
The processor shall provide at least one representation method with a decimal exponent range greater than or
equal to 18.
The type specifier for the integer type uses the keyword INTEGER.
The keyword INTEGER with no <i>kind-selector</i> specifies type integer with default kind; the kind type parameter
value is equal to KIND (0). The decimal exponent range of default integer shall be at least 5.
Any integer value can be represented as a <i>signed-int-literal-constant</i>.
R707 <i>signed-int-literal-constant</i> <b>is</b> [ <i>sign</i> ] <i>int-literal-constant</i>
R708 <i>int-literal-constant</i> <b>is</b> <i>digit-string</i> [ _ <i>kind-param</i> ]
R709 <i>kind-param</i> <b>is</b> <i>digit-string</i>
              <b>or</b> <i>scalar-int-constant-name</i>
R710 <i>signed-digit-string</i> <b>is</b> [ <i>sign</i> ] <i>digit-string</i>
R711 <i>digit-string</i> <b>is</b> <i>digit</i> [ <i>digit</i> ] ...
R712 <i>sign</i> <b>is</b> +
              <b>or</b> -
C718 (R709) A <i>scalar-int-constant-name</i> shall be a named constant of type integer.
C719 (R709) The value of <i>kind-param</i> shall be nonnegative.
C720 (R708) The value of <i>kind-param</i> shall specify a representation method that exists on the processor.
The optional kind type parameter following <i>digit-string</i> specifies the kind type parameter of the integer constant;
if it does not appear, the constant is default integer.
An integer constant is interpreted as a decimal value.
<b>NOTE</b>
Examples of signed integer literal constants are:
473
+56
-101
21_2
21_SHORT
1976354279568241_8
where SHORT is a scalar integer named constant. A program that uses a <i>digit-string</i> as a <i>kind-param</i> is unlikely
to be portable.
<b>7.4.3.2</b> <b>Real</b> <b>type</b>
The real type has values that approximate the mathematical real numbers. The processor shall provide two
or more approximation methods that define sets of values for data of type real. Each such method has a
representationmethodandischaracterizedbyavalueforthekindtypeparameterKIND.Thekindtypeparameter
of an approximation method is returned by the intrinsic function KIND (16.9.118).
The decimal precision, decimal exponent range, and radix of an approximation method are returned by the
intrinsic functions PRECISION (16.9.162), RANGE (16.9.170), and RADIX (16.9.166). The intrinsic function
SELECTED_REAL_KIND (16.9.183) returns a kind value based on specified precision, range, and radix re-
quirements.
<b>NOTE</b> <b>1</b>
See C.3.1 for remarks concerning selection of approximation methods.
The real type includes a zero value. Processors that distinguish between positive and negative zeros shall treat
them as mathematically equivalent
 in all intrinsic relational operations, and
 as actual arguments to intrinsic procedures other than those for which it is explicitly specified that negative
  zero is distinguished.
<b>NOTE</b> <b>2</b>
On a processor that distinguishes between 0.0 and-0<i>.</i>0,
   ( X >= 0.0 )
evaluates to true if X = 0.0 or if X =-0<i>.</i>0, and
   ( X < 0.0 )
evaluates to false for X =-0<i>.</i>0.
In order to distinguish between 0.0 and-0<i>.</i>0, a program can use the intrinsic function SIGN. SIGN (1.0, X)
will return-1<i>.</i>0 if X <i><</i> 0.0 or if the processor distinguishes between 0.0 and-0<i>.</i>0 and X has the value-0<i>.</i>0.
The typespecifier for thereal type usesthe keyword REAL. The keyword DOUBLE PRECISION is an alternative
specifier for one kind of real type.
If the type keyword REAL is used without a kind type parameter, the real type with default real kind is specified
and the kind value is KIND (0.0). The type specifier DOUBLE PRECISION specifies type real with double
precision kind; the kind value is KIND (0.0D0). The decimal precision of the double precision real approximation
method shall be greater than that of the default real method.
The decimal precision of double precision real shall be at least 10, and its decimal exponent range shall be at
least 37. It is recommended that the decimal precision of default real be at least 6, and that its decimal exponent
range be at least 37.
R713 <i>signed-real-literal-constant</i> <b>is</b> [ <i>sign</i> ] <i>real-literal-constant</i>
R714 <i>real-literal-constant</i> <b>is</b> <i>significand</i> [ <i>exponent-letter</i> <i>exponent</i> ] [ _ <i>kind-param</i> ]
              <b>or</b> <i>digit-string</i> <i>exponent-letter</i> <i>exponent</i> [ _ <i>kind-param</i> ]
R715 <i>significand</i> <b>is</b> <i>digit-string</i> . [ <i>digit-string</i> ]
              <b>or</b> . <i>digit-string</i>
R716 <i>exponent-letter</i> <b>is</b> E
              <b>or</b> D
R717 <i>exponent</i> <b>is</b> <i>signed-digit-string</i>
C721 (R714) If both <i>kind-param</i> and <i>exponent-letter</i> appear, <i>exponent-letter</i> shall be E.
C722 (R714) The value of <i>kind-param</i> shall specify an approximation method that exists on the processor.
A real literal constant without a kind type parameter is a default real constant if it is without an exponent part
or has exponent letter E, and is a double precision real constant if it has exponent letter D. A real literal constant
written with a kind type parameter is a real constant with the specified kind type parameter.
The exponent represents the power of ten scaling to be applied to the significand or digit string. The meaning of
these constants is as in decimal scientific notation.
Thesignificandmaybewrittenwithmoredigitsthanaprocessorwillusetoapproximatethevalueoftheconstant.
<b>NOTE</b> <b>3</b>
Examples of signed real literal constants are:
   -12.78
   +1.6E3
   2.1
   -16.E4_8
   0.45D-4
                <b>J3/23-007r1</b> <b>67</b>
<b>NOTE</b> <b>3</b> <b>(cont.)</b>
   10.93E7_QUAD
   .123
   3E4
where QUAD is a scalar integer named constant.
<b>7.4.3.3</b> <b>Complex</b> <b>type</b>
The complex type has values that approximate the mathematical complex numbers. The values of a complex
type are ordered pairs of real values. The first real value is called the real part, and the second real value is called
the imaginary part.
Each approximation method used to represent data entities of type real shall be available for both the real and
imaginary parts of a data entity of type complex. The (default integer) kind type parameter KIND for a complex
entity specifies for both parts the real approximation method characterized by this kind type parameter value.
The kind type parameter of an approximation method is returned by the intrinsic function KIND (16.9.118).
The type specifier for the complex type uses the keyword COMPLEX. There is no keyword for double precision
complex. If the type keyword COMPLEX is used without a kind type parameter, the complex type with default
complex kind is specified, the kind value is KIND (0.0), and both parts are default real.
R718 <i>complex-literal-constant</i> <b>is</b> ( <i>real-part</i> , <i>imag-part</i> )
R719 <i>real-part</i> <b>is</b> <i>signed-int-literal-constant</i>
              <b>or</b> <i>signed-real-literal-constant</i>
              <b>or</b> <i>named-constant</i>
R720 <i>imag-part</i> <b>is</b> <i>signed-int-literal-constant</i>
              <b>or</b> <i>signed-real-literal-constant</i>
              <b>or</b> <i>named-constant</i>
C723 (R718) Each named constant in a complex literal constant shall be scalar and of type integer or real.
If the real part and the imaginary part of a complex literal constant are both real, the kind type parameter value
of the complex literal constant is the kind type parameter value of the part with the greater decimal precision; if
the precisions are the same, it is the kind type parameter value of one of the parts as determined by the processor.
If a part has a kind type parameter value different from that of the complex literal constant, the part is converted
to the approximation method of the complex literal constant.
If both the real and imaginary parts are integer, they are converted to the default real approximation method
and the constant is default complex. If only one of the parts is an integer, it is converted to the approximation
method selected for the part that is real and the kind type parameter value of the complex literal constant is
that of the part that is real.
<b>NOTE</b>
Examples of complex literal constants are:
   (1.0, -1.0)
   (3, 3.1E6)
   (4.0_4, 3.6E7_8)
   ( 0., PI)
where PI is a previously declared named constant of type real.
<b>7.4.4</b> <b>Character</b> <b>type</b>
<b>7.4.4.1</b> <b>Character</b> <b>sets</b>
Thecharactertypehasasetofvaluescomposedofcharacterstrings. Acharacterstringisasequenceofcharacters,
numbered from left to right 1, 2, 3, ... up to the number of characters in the string. The number of characters in
the string is called the length of the string. The length is a type parameter; its kind is processor dependent and
its value is greater than or equal to zero.
The processor shall provide one or more representation methods that define sets of values for data of type
character. Each such method is characterized by a value for the (default integer) kind type parameter KIND.
The kind type parameter of a representation method is returned by the intrinsic function KIND (16.9.118). The
intrinsic function SELECTED_CHAR_KIND (16.9.180) returns a kind value based on the name of a character
type. Any character of a particular representation method representable in the processor may occur in a character
string of that representation method.
The character set specified in ISO/IEC 646:1991 (International Reference Version) is referred to as the ASCII
character set and its corresponding representation method is ASCII character kind. The character set UCS-4 as
specified in ISO/IEC 10646 is referred to as the ISO 10646 character set and its corresponding representation
method is the ISO 10646 character kind.
<b>7.4.4.2</b> <b>Character</b> <b>type</b> <b>specifier</b>
The type specifier for the character type uses the keyword CHARACTER.
If the type keyword CHARACTER is used without a kind type parameter, the character type with default
character kind is specified and the kind value is KIND ('A').
The default character kind shall support a character set that includes the characters in the Fortran character
set (6.1). The processor may support additional character sets by supplying nondefault character kinds. The
characters available in nondefault character kinds are not specified by this document, except that one character
in each nondefault character set shall be designated as a blank character to be used as a padding character.
R721 <i>char-selector</i> <b>is</b> <i>length-selector</i>
              <b>or</b> ( LEN = <i>type-param-value</i> ,
                   KIND = <i>scalar-int-constant-expr</i> )
              <b>or</b> ( <i>type-param-value</i> ,
                   [ KIND = ] <i>scalar-int-constant-expr</i> )
              <b>or</b> ( KIND = <i>scalar-int-constant-expr</i>
                   [ , LEN =<i>type-param-value</i> ] )
R722 <i>length-selector</i> <b>is</b> ( [ LEN = ] <i>type-param-value</i> )
              <b>or</b> * <i>char-length</i> [ , ]
R723 <i>char-length</i> <b>is</b> ( <i>type-param-value</i> )
              <b>or</b> <i>int-literal-constant</i>
C724 (R721) The value of <i>scalar-int-constant-expr</i> shall be nonnegative and shall specify a representation
   method that exists on the processor.
C725 (R723) The <i>int-literal-constant</i> shall not include a <i>kind-param</i>.
C726 (R721 R722 R723) A <i>type-param-value</i> of * shall be used only
   to declare a dummy argument,
   to declare a named constant,
   in the <i>type-spec</i> of an ALLOCATE statement wherein each <i>allocate-object</i> is a dummy argument of
     type CHARACTER with an assumed character length,
   in the <i>type-spec</i> or <i>derived-type-spec</i> of a type guard statement (11.1.11), or
   in an external function, to declare the character length parameter of the function result.
C727 Afunctionnameshallnotbedeclaredwithanasterisk <i>type-param-value</i> unlessitisoftypeCHARACTER
   and is the name of a dummy function or the name of the result of an external function.
C728 A function name declared with an asterisk <i>type-param-value</i> shall not be an array, a pointer, elemental, or pure. A function
    name declared with an asterisk <i>type-param-value</i> shall not have the RECURSIVE attribute.
C729 (R722) The optional comma in a <i>length-selector</i> is permitted only in a <i>declaration-type-spec</i> in a <i>type-declaration-stmt</i>.
C730 (R722) The optional comma in a <i>length-selector</i> is permitted only if no double-colon separator appears in the <i>type-</i>
    <i>declaration-stmt</i>.
C731 (R721) The length specified for a character statement function or for a statement function dummy argument of type
    character shall be a constant expression.
The<i>char-selector</i> inaCHARACTER<i>intrinsic-type-spec</i> andthe*<i>char-length</i> inan<i>entity-decl</i> orina<i>component-</i>
<i>decl</i> of a type definition specify character length. The * <i>char-length</i> in an <i>entity-decl</i> or a <i>component-decl</i> specifies
anindividuallengthandoverridesthelengthspecifiedinthe <i>char-selector</i>, ifany. Ifa*<i>char-length</i> isnotspecified
in an <i>entity-decl</i> or a <i>component-decl</i>, the <i>length-selector</i> or <i>type-param-value</i> specified in the <i>char-selector</i> is the
character length. If the length is not specified in a <i>char-selector</i> or a * <i>char-length</i>, the length is 1.
If the character length parameter value evaluates to a negative value, the length of character entities declared
is zero. A character length parameter value of : indicates a deferred type parameter (7.2). A <i>char-length</i> type
parameter value of * has the following meanings.
 If used to declare a dummy argument of a procedure, the dummy argument assumes its length from its
  effective argument.
 If used to declare a named constant, the length is that of the constant value.
 Ifusedinthe<i>type-spec</i> ofanALLOCATEstatement, each<i>allocate-object</i> assumesitslengthfromitseffective
  argument.
 If used in the <i>type-spec</i> of a type guard statement, the associating entity assumes its length from the selector.
 If used to specify the character length parameter of a function result, any scoping unit invoking the function or passing it as
  an actual argument shall declare the function name with a character length parameter value other than * or access such a
  definition by argument, host, or use association. When the function is invoked, the length of the function result is assumed
  from the value of this type parameter.
<b>7.4.4.3</b> <b>Character</b> <b>literal</b> <b>constant</b>
The syntax of a character literal constant is given by R724.
R724 <i>char-literal-constant</i> <b>is</b> [ <i>kind-param</i> _ ] ' [ <i>rep-char</i> ] ... '
              <b>or</b> [ <i>kind-param</i> _ ] " [ <i>rep-char</i> ] ... "
C732 (R724) The value of <i>kind-param</i> shall specify a representation method that exists on the processor.
The optional kind type parameter preceding the leading delimiter specifies the kind type parameter of the char-
acter constant; if it does not appear, the constant is default character.
For the type character with kind <i>kind-param</i>, if it appears, and for default character otherwise, a representable
character, <i>rep-char</i>, is defined as follows.
 In free source form, it is any graphic character in the processor-dependent character set.
 In fixed source form, it is any character in the processor-dependent character set. A processor may restrict the occurrence of
  some or all of the control characters.
The delimiting apostrophes or quotation marks are not part of the value of the character literal constant.
An apostrophe character within a character constant delimited by apostrophes is represented by two consecutive
apostrophes (without intervening blanks); in this case, the two apostrophes are counted as one character. Sim-
ilarly, a quotation mark character within a character constant delimited by quotation marks is represented by
two consecutive quotation marks (without intervening blanks) and the two quotation marks are counted as one
character.
Azero-lengthcharacterliteralconstantisrepresentedbytwoconsecutiveapostrophes(withoutinterveningblanks)
or two consecutive quotation marks (without intervening blanks) outside of a character context.
<b>NOTE</b> <b>1</b>
Examples of character literal constants are:
"DON'T"
'DON''T'
both of which have the value DON'T and
''
which has the zero-length character string as its value.
<b>NOTE</b> <b>2</b>
An example of a nondefault character literal constant, where the processor supports the corresponding character
set, is:
NIHONGO_'
? ? ? ? ? ? ? ? ? ?
                    '
whereNIHONGOisanamedconstantwhosevalueisthekindtypeparameterforNihongo(Japanese)characters.
This means "Without her, nothing is possible".
<b>7.4.4.4</b> <b>Collating</b> <b>sequence</b>
The processor defines a collating sequence for the character set of each kind of character. The collating sequence
is an isomorphism between the character set and the set of integers{<i>I</i> : 0 <i>I</i> <i><</i> <i>N</i>}, where <i>N</i> is the number of
characters in the set. The intrinsic functions CHAR (16.9.52) and ICHAR (16.9.105) provide conversions between
the characters and the integers according to this mapping.
<b>NOTE</b> <b>1</b>
For example:
 ICHAR ( 'X' )
returns the integer value of the character 'X' according to the collating sequence of the processor.
The collating sequence of the default character kind shall satisfy the following constraints.
 ICHAR ('A') <i><</i> ICHAR ('B') <i><</i> ... <i><</i> ICHAR ('Z') for the twenty-six upper-case letters.
 ICHAR ('0') <i><</i> ICHAR ('1') <i><</i> ... <i><</i> ICHAR ('9') for the ten digits.
 ICHAR (' ') <i><</i> ICHAR ('0') <i><</i> ICHAR ('9') <i><</i> ICHAR ('A') or
  ICHAR (' ') <i><</i> ICHAR ('A') <i><</i> ICHAR ('Z') <i><</i> ICHAR ('0').
 ICHAR ('a') <i><</i> ICHAR ('b') <i><</i> ... <i><</i> ICHAR ('z') for the twenty-six lower-case letters.
 ICHAR (' ') <i><</i> ICHAR ('0') <i><</i> ICHAR ('9') <i><</i> ICHAR ('a') or
  ICHAR (' ') <i><</i> ICHAR ('a') <i><</i> ICHAR ('z') <i><</i> ICHAR ('0').
There are no constraints on the location of any other character in the collating sequence, nor is there any specified
collating sequence relationship between the upper-case and lower-case letters.
The collating sequence for the ASCII character kind is as specified in ISO/IEC 646:1991 (International Reference
Version); this collating sequence is called the ASCII collating sequence in this document. The collating sequence
for the ISO 10646 character kind is as specified in ISO/IEC 10646.
<b>NOTE</b> <b>2</b>
The intrinsic functions ACHAR (16.9.3) and IACHAR (16.9.98) provide conversions between characters and
corresponding integer values according to the ASCII collating sequence.
The intrinsic functions LGT, LGE, LLE, and LLT (16.9.124-16.9.127) provide comparisons between strings based
on the ASCII collating sequence. International portability is guaranteed if the set of characters used is limited
to the Fortran character set (6.1).
<b>7.4.5</b> <b>Logical</b> <b>type</b>
The logical type has two values, which represent true and false.
The processor shall provide one or more representation methods for data of type logical. Each such method
is characterized by a value for the (default integer) kind type parameter KIND. The kind type parameter of a
representation method is returned by the intrinsic function KIND (16.9.118).
The type specifier for the logical type uses the keyword LOGICAL.
The keyword LOGICAL with no <i>kind-selector</i> specifies type logical with default kind; the kind type parameter
value is equal to KIND (.FALSE.).
R725 <i>logical-literal-constant</i> <b>is</b> .TRUE. [ _ <i>kind-param</i> ]
              <b>or</b> .FALSE. [ _ <i>kind-param</i> ]
C733 (R725) The value of <i>kind-param</i> shall specify a representation method that exists on the processor.
The optional kind type parameter specifies the kind type parameter of the logical constant; if it does not appear,
the constant has the default logical kind.
<b>7.5</b> <b>Derived</b> <b>types</b>
<b>7.5.1</b> <b>Derived</b> <b>type</b> <b>concepts</b>
Additional types can be derived from the intrinsic types and other derived types. A type definition defines the
name of the type and the names and attributes of its components and type-bound procedures.
A derived type can be parameterized by one or more type parameters, each of which is defined to be either a
kind or length type parameter and can have a default value.
The ultimate components of a derived type are the components that are of intrinsic type or have the ALLOC-
ATABLE or POINTER attribute, plus the ultimate components of the components that are of derived type and
have neither the ALLOCATABLE nor POINTER attribute.
The direct components of a derived type are the components of that type, plus the direct components of the
components that are of derived type and have neither the ALLOCATABLE nor POINTER attribute.
The potential subobject components of a derived type are the nonpointer components of that type together with
the potential subobject components of the nonpointer components that are of derived type. This includes all the
components that could be a subobject of an object of the type (9.4.2).
The components, direct components, potential subobject components, and ultimate components of an object of
derived type are the components, direct components, potential subobject components, and ultimate components
of its type, respectively.
By default, no storage sequence is implied by the order of the component definitions. However, a storage sequence
is implied for a sequence type (7.5.2.3). If the derived type has the BIND attribute, the storage sequence is that
required by the companion processor (5.5.7, 18.3.4).
A scalar entity of derived type is a structure. If a derived type has the SEQUENCE attribute, a scalar entity of
the type is a sequence structure.
<b>NOTE</b>
Theultimatecomponentsofanobjectofthederivedtypekidsdefinedbelowareoldest_child%name,oldest_-
child%age, and other_kids. The direct components of such an object are oldest_child%name, oldest_-
child%age, other_kids, and oldest_child.
type :: person
 character(len=20) :: name
 integer :: age
end type person
type :: kids
 type(person) :: oldest_child
 type(person), allocatable, dimension(:) :: other_kids
end type kids
<b>7.5.2</b> <b>Derived-type</b> <b>definition</b>
<b>7.5.2.1</b> <b>Syntax</b> <b>of</b> <b>a</b> <b>derived-type</b> <b>definition</b>
R726 <i>derived-type-def</i> <b>is</b> <i>derived-type-stmt</i>
                   [ <i>type-param-def-stmt</i> ] ...
                   [ <i>private-or-sequence</i> ] ...
                   [ <i>component-part</i> ]
                   [ <i>type-bound-procedure-part</i> ]
                   <i>end-type-stmt</i>
R727 <i>derived-type-stmt</i> <b>is</b> TYPE [ [ , <i>type-attr-spec-list</i> ] :: ] <i>type-name</i>
                   [ ( <i>type-param-name-list</i> ) ]
R728 <i>type-attr-spec</i> <b>is</b> ABSTRACT
              <b>or</b> <i>access-spec</i>
              <b>or</b> BIND (C)
              <b>or</b> EXTENDS ( <i>parent-type-name</i> )
C734 (R727) A derived type <i>type-name</i> shall not be DOUBLEPRECISION or the same as the name of any
   intrinsic type defined in this document.
C735 (R727) The same <i>type-attr-spec</i> shall not appear more than once in a given <i>derived-type-stmt</i>.
C736 The same <i>type-param-name</i> shall not appear more than once in a given <i>derived-type-stmt</i>.
C737 (R728) A <i>parent-type-name</i> shall be the name of a previously defined extensible type (7.5.7).
C738 (R726) If the type definition contains or inherits (7.5.7.2) a deferred type-bound procedure (7.5.5), AB-
   STRACT shall appear.
C739 (R726) If ABSTRACT appears, the type shall be extensible.
C740 (R726) If EXTENDS appears, SEQUENCE shall not appear.
C741 (R726) If EXTENDS appears and the type being defined has a coarray potential subobject component,
   its parent type shall have a coarray potential subobject component.
C742 (R726) If EXTENDS appears and the type being defined has a potential subobject component of type
   EVENT_TYPE,LOCK_TYPE,orNOTIFY_TYPEfromtheintrinsicmoduleISO_FORTRAN_ENV,
   its parent type shall be EVENT_TYPE, LOCK_TYPE, or NOTIFY_TYPE, or have a potential sub-
   object component of type EVENT_TYPE, LOCK_TYPE, or NOTIFY_TYPE.
R729 <i>private-or-sequence</i> <b>is</b> <i>private-components-stmt</i>
              <b>or</b> <i>sequence-stmt</i>
C743 (R726) The same <i>private-or-sequence</i> shall not appear more than once in a given <i>derived-type-def</i>.
R730 <i>end-type-stmt</i> <b>is</b> END TYPE [ <i>type-name</i> ]
C744 (R730) If END TYPE is followed by a <i>type-name</i>, the <i>type-name</i> shall be the same as that in the
   corresponding <i>derived-type-stmt</i>.
Derived types with the BIND attribute are subject to additional constraints as specified in 18.3.4.
<b>NOTE</b>
An example of a derived type definition is:
   TYPE PERSON
     INTEGER AGE
     CHARACTER (LEN = 50) NAME
   END TYPE PERSON
An example of declaring a variable CHAIRMAN of type PERSON is:
   TYPE (PERSON) :: CHAIRMAN
<b>7.5.2.2</b> <b>Accessibility</b>
The accessibility of a type name is determined as specified in 8.5.2. The accessibility of a type name does not
affect, and is not affected by, the accessibility of its components and type-bound procedures.
If a derived type is defined in the scoping unit of a module, and its name is private in that module, then the type
name, and thus the structure constructor (7.5.10) for the type, are accessible only within that module and its
descendants.
<b>NOTE</b>
An example of a type with a private name is:
   TYPE, PRIVATE :: AUXILIARY
     LOGICAL :: DIAGNOSTIC
     CHARACTER (LEN = 20) :: MESSAGE
   END TYPE AUXILIARY
Such a type would be accessible only within the module in which it is defined, and within its descendants.
<b>7.5.2.3</b> <b>Sequence</b> <b>type</b>
R731 <i>sequence-stmt</i> <b>is</b> SEQUENCE
C745 (R726) If SEQUENCE appears, the type shall have at least one component, each data component shall
   be declared to be of an intrinsic type or of a sequence type, the derived type shall not have any type
   parameter, and a <i>type-bound-procedure-part</i> shall not appear.
If the SEQUENCE statement appears, the type has the SEQUENCE attribute and is a sequence type. The order
of the component definitions in a sequence type specifies a storage sequence for objects of that type. The type
is a numeric sequence type if there are no pointer or allocatable components, and each component is default
integer, default real, double precision real, default complex, default logical, or of numeric sequence type. The
type is a character sequence type if there are no pointer or allocatable components, and each component is default
character or of character sequence type.
<b>NOTE</b> <b>1</b>
An example of a numeric sequence type is:
   TYPE NUMERIC_SEQ
     SEQUENCE
     INTEGER :: INT_VAL
     REAL :: REAL_VAL
     LOGICAL :: LOG_VAL
   END TYPE NUMERIC_SEQ
<b>NOTE</b> <b>2</b>
A structure resolves into a sequence of components. Unless the structure includes a SEQUENCE statement,
the use of this terminology in no way implies that these components are stored in this, or any other, order.
Nor is there any requirement that contiguous storage be used. The sequence merely refers to the fact that in
writing the definitions there will necessarily be an order in which the components appear, and this will define
a sequence of components.
This order is of limited significance because a component of an object of derived type will always be accessed
by a component name except in the following contexts:
  the sequence of expressions in a derived-type value constructor,
  intrinsic assignment,
  the sequence of data values in namelist input data, and
  and the inclusion of the structure in an input/output list of a formatted data transfer, where it is expanded
  to this sequence of components.
Provided the processor adheres to the defined order in these cases, it is otherwise free to organize the storage
of the components for any nonsequence structure in memory as best suited to the particular architecture.
<b>7.5.2.4</b> <b>Determination</b> <b>of</b> <b>derived</b> <b>types</b>
Derived-type definitions with the same type name may appear in different scoping units, in which case they might
be independent and describe different derived types or they might describe the same type.
Two data entities have the same type if they are declared with reference to the same derived-type definition. Data
entities also have the same type if they are declared with reference to different derived-type definitions that specify
the same type name, all have the SEQUENCE attribute or all have the BIND attribute, have no components
with PRIVATE accessibility, and have components that agree in order, name, and attributes. Otherwise, they
are of different derived types. A data entity declared using a type with the SEQUENCE attribute or with the
BIND attribute is not of the same type as an entity of a type that has any components that are PRIVATE.
<b>NOTE</b> <b>1</b>
An example of declaring two entities with reference to the same derived-type definition is:
   TYPE POINT
     REAL X, Y
   END TYPE POINT
   TYPE (POINT) :: X1
   CALL SUB (X1)
   ...
   CONTAINS
     SUBROUTINE SUB (A)
      TYPE (POINT) :: A
      ...
     END SUBROUTINE SUB
                <b>J3/23-007r1</b> <b>75</b>
<b>NOTE</b> <b>1</b> <b>(cont.)</b>
The definition of derived type POINT is known in subroutine SUB by host association. Because the declarations
of X1 and A both reference the same derived-type definition, X1 and A have the same type. X1 and A also
would have the same type if the derived-type definition were in a module and both SUB and its containing
program unit accessed that derived type from the module.
<b>NOTE</b> <b>2</b>
An example of data entities in different scoping units having the same type is:
   PROGRAM PGM
     TYPE EMPLOYEE
      SEQUENCE
      INTEGER ID_NUMBER
      CHARACTER (50) NAME
     END TYPE EMPLOYEE
     TYPE (EMPLOYEE) PROGRAMMER
     CALL SUB (PROGRAMMER)
     ...
   END PROGRAM PGM
   SUBROUTINE SUB (POSITION)
     TYPE EMPLOYEE
      SEQUENCE
      INTEGER ID_NUMBER
      CHARACTER (50) NAME
     END TYPE EMPLOYEE
     TYPE (EMPLOYEE) POSITION
     ...
   END SUBROUTINE SUB
The actual argument PROGRAMMER and the dummy argument POSITION have the same type because they
are declared with reference to a derived-type definition with the same name, the SEQUENCE attribute, and
components that agree in order, name, and attributes.
Suppose the component name ID_NUMBER was ID_NUM in the subroutine. Because all the component
names are not identical to the component names in derived type EMPLOYEE in the main program, the actual
argument PROGRAMMER would not be of the same type as the dummy argument POSITION. Thus, the
program would not be standard-conforming.
<b>NOTE</b> <b>3</b>
The requirement that the two types have the same name applies to the <i>type-name</i>s in the respective derived
type definitions, not to local names introduced via renaming in USE statements.
<b>7.5.3</b> <b>Derived-type</b> <b>parameters</b>
<b>7.5.3.1</b> <b>Type</b> <b>parameter</b> <b>definition</b> <b>statement</b>
R732 <i>type-param-def-stmt</i> <b>is</b> <i>integer-type-spec</i>, <i>type-param-attr-spec</i> ::
                  <i>type-param-decl-list</i>
R733 <i>type-param-decl</i> <b>is</b> <i>type-param-name</i> [ = <i>scalar-int-constant-expr</i> ]
C746 (R732) A <i>type-param-name</i> in a <i>type-param-def-stmt</i> in a <i>derived-type-def</i> shall be one of the <i>type-param-</i>
   <i>name</i>s in the <i>derived-type-stmt</i> of that <i>derived-type-def</i>.
C747 (R732) Each <i>type-param-name</i> in the <i>derived-type-stmt</i> in a <i>derived-type-def</i> shall appear exactly once as
   a <i>type-param-name</i> in a <i>type-param-def-stmt</i> in that <i>derived-type-def</i>.
R734 <i>type-param-attr-spec</i> <b>is</b> KIND
              <b>or</b> LEN
The derived type is parameterized if the <i>derived-type-stmt</i> has any <i>type-param-name</i>s.
Each type parameter is itself of type integer. If its kind selector is omitted, the kind type parameter is default
integer.
The <i>type-param-attr-spec</i> explicitly specifies whether a type parameter is a kind parameter or a length parameter.
If a <i>type-param-decl</i> has a <i>scalar-int-constant-expr</i>, the type parameter has a default value which is specified by
the expression. If necessary, the value is converted according to the rules of intrinsic assignment (10.2.1.3) to a
value of the same kind as the type parameter.
A type parameter may be used as a primary in a specification expression (10.1.11) in the <i>derived-type-def</i>. A
kind type parameter may also be used as a primary in a constant expression (10.1.12) in the <i>derived-type-def</i>.
<b>NOTE</b>
The following example uses derived-type parameters.
   TYPE humongous_matrix(k, d)
    INTEGER, KIND :: k = KIND (0.0)
    INTEGER (SELECTED_INT_KIND (12)), LEN :: d
     !-- Specify a potentially nondefault kind for d.
    REAL (k) :: element (d, d)
   END TYPE
In the following example, dim is declared to be a kind parameter, allowing generic overloading of procedures
distinguished only by dim.
   TYPE general_point(dim)
    INTEGER, KIND :: dim
    REAL :: coordinates(dim)
   END TYPE
<b>7.5.3.2</b> <b>Type</b> <b>parameter</b> <b>order</b>
Type parameter order is an ordering of the type parameters of a derived type; it is used for derived-type specifiers.
The type parameter order of a nonextended type is the order of the <i>type-param-name-list</i> in the derived-type
definition. The type parameter order of an extended type (7.5.7) consists of the type parameter order of its
parent type followed by any additional type parameters in the order of the <i>type-param-name-list</i> in the derived-
type definition.
<b>NOTE</b>
Given
   TYPE :: t1 (k1, k2)
    INTEGER, KIND :: k1, k2
    REAL (k1) a (k2)
   END TYPE
   TYPE, EXTENDS(t1) :: t2 (k3)
    INTEGER, KIND :: k3
    LOGICAL (k3) flag
   END TYPE
the type parameter order for type t1 is k1 then k2, and the type parameter order for type t2 is k1 then k2
then k3.
<b>7.5.4</b> <b>Components</b>
<b>7.5.4.1</b> <b>Component</b> <b>definition</b> <b>statement</b>
R735 <i>component-part</i> <b>is</b> [ <i>component-def-stmt</i> ] ...
R736 <i>component-def-stmt</i> <b>is</b> <i>data-component-def-stmt</i>
              <b>or</b> <i>proc-component-def-stmt</i>
R737 <i>data-component-def-stmt</i> <b>is</b> <i>declaration-type-spec</i> [ [ , <i>component-attr-spec-list</i> ] :: ]
                  <i>component-decl-list</i>
R738 <i>component-attr-spec</i> <b>is</b> <i>access-spec</i>
              <b>or</b> ALLOCATABLE
              <b>or</b> CODIMENSION <i>lbracket</i> <i>coarray-spec</i> <i>rbracket</i>
              <b>or</b> CONTIGUOUS
              <b>or</b> DIMENSION ( <i>component-array-spec</i> )
              <b>or</b> POINTER
R739 <i>component-decl</i> <b>is</b> <i>component-name</i> [ ( <i>component-array-spec</i> ) ]
                   [ <i>lbracket</i> <i>coarray-spec</i> <i>rbracket</i> ]
                   [ * <i>char-length</i> ] [ <i>component-initialization</i> ]
R740 <i>component-array-spec</i> <b>is</b> <i>explicit-shape-spec-list</i>
              <b>or</b> <i>deferred-shape-spec-list</i>
C748 (R737) No <i>component-attr-spec</i> shall appear more than once in a given <i>component-def-stmt</i>.
C749 (R737) If neither the POINTER nor the ALLOCATABLE attribute is specified, the <i>declaration-type-</i>
   <i>spec</i> in the <i>component-def-stmt</i> shall specify an intrinsic type, or a previously defined derived, enum, or
   enumeration type.
C750 (R737) If the POINTER or ALLOCATABLE attribute is specified, each <i>component-array-spec</i> shall be
   a <i>deferred-shape-spec-list</i>.
C751 (R737) If a <i>coarray-spec</i> appears, it shall be a <i>deferred-coshape-spec-list</i> and the component shall have
   the ALLOCATABLE attribute.
C752 (R737) If a <i>coarray-spec</i> appears, the component shall not be of type C_PTR or C_FUNPTR from
   the intrinsic module ISO_C_BINDING (18.2), or of type TEAM_TYPE from the intrinsic module
   ISO_FORTRAN_ENV (16.10.2).
C753 A data component whose type has a coarray potential subobject component shall be a nonpointer non-
   allocatable scalar and shall not be a coarray.
C754 (R737) If neither the POINTER nor the ALLOCATABLE attribute is specified, each <i>component-array-</i>
   <i>spec</i> shall be an <i>explicit-shape-spec-list</i>.
C755 (R740) Each bound in the <i>explicit-shape-spec</i> shall be a component specification expression.
C756 (R737) A component shall not have both the ALLOCATABLE and POINTER attributes.
C757 (R737) If the CONTIGUOUS attribute is specified, the component shall be an array with the POINTER
   attribute.
C758 (R739) The * <i>char-length</i> option is permitted only if the component is of type character.
C759 (R736) Each <i>type-param-value</i> within a <i>component-def-stmt</i> shall be a colon or a component specification
   expression.
<b>NOTE</b> <b>1</b>
Because a type parameter is not an object, a <i>type-param-value</i> or a bound in an <i>explicit-shape-spec</i> can contain
a <i>type-param-name</i>.
R741 <i>proc-component-def-stmt</i> <b>is</b> PROCEDURE ( [ <i>proc-interface</i> ] ) ,
                  <i>proc-component-attr-spec-list</i> :: <i>proc-decl-list</i>
<b>NOTE</b> <b>2</b>
See 15.4.3.6 for definitions of <i>proc-interface</i> and <i>proc-decl</i>.
R742 <i>proc-component-attr-spec</i> <b>is</b> <i>access-spec</i>
              <b>or</b> NOPASS
              <b>or</b> PASS [ (<i>arg-name</i>) ]
              <b>or</b> POINTER
C760 (R741) The same <i>proc-component-attr-spec</i> shall not appear more than once in a given <i>proc-component-</i>
   <i>def-stmt</i>.
C761 (R741) POINTER shall appear in each <i>proc-component-attr-spec-list</i>.
C762 (R741) If the procedure pointer component has an implicit interface or has no arguments, NOPASS shall
   be specified.
C763 (R741)IfPASS(<i>arg-name</i>)appears, theinterfaceoftheprocedurepointercomponentshallhaveadummy
   argument named <i>arg-name</i>.
C764 (R741) PASS and NOPASS shall not both appear in the same <i>proc-component-attr-spec-list</i>.
The <i>declaration-type-spec</i> in the <i>data-component-def-stmt</i> specifies the type and type parameters of the com-
ponents in the <i>component-decl-list</i>, except that the character length parameter can be specified or overridden
for a component by the appearance of * <i>char-length</i> in its <i>entity-decl</i>. The <i>component-attr-spec-list</i> in the <i>data-</i>
<i>component-def-stmt</i> specifies the attributes whose keywords appear for the components in the <i>component-decl-list</i>,
except that the DIMENSION attribute can be specified or overridden for a component by the appearance of a
<i>component-array-spec</i> in its <i>component-decl</i>, and the CODIMENSION attribute can be specified or overridden
for a component by the appearance of a <i>coarray-spec</i> in its <i>component-decl</i>.
<b>7.5.4.2</b> <b>Array</b> <b>components</b>
A data component is an array if its <i>component-decl</i> contains a <i>component-array-spec</i> or its <i>data-component-def-</i>
<i>stmt</i> contains a DIMENSION clause. If the <i>component-decl</i> contains a <i>component-array-spec</i>, it specifies the
array rank, and if the array is explicit shape (8.5.8.2), the array bounds; otherwise, the <i>component-array-spec</i> in
the DIMENSION clause specifies the array rank, and if the array is explicit shape, the array bounds.
<b>NOTE</b> <b>1</b>
An example of a derived type definition with an array component is:
   TYPE LINE
     REAL, DIMENSION (2, 2) :: COORD !
                      ! COORD(:,1) has the value of [X1, Y1]
                      ! COORD(:,2) has the value of [X2, Y2]
     REAL :: WIDTH ! Line width in centimeters
     INTEGER :: PATTERN ! 1 for solid, 2 for dash, 3 for dot
   END TYPE LINE
An example of declaring a variable LINE_SEGMENT to be of the type LINE is:
   TYPE (LINE) :: LINE_SEGMENT
                <b>J3/23-007r1</b> <b>79</b>
<b>NOTE</b> <b>1</b> <b>(cont.)</b>
The scalar variable LINE_SEGMENT has a component that is an array. In this case, the array is a subobject
of a scalar. The double colon in the definition for COORD is required; the double colon in the definition for
WIDTH and PATTERN is optional.
<b>NOTE</b> <b>2</b>
An example of a derived type definition with an allocatable component is:
   TYPE STACK
     INTEGER :: INDEX
     INTEGER, ALLOCATABLE :: CONTENTS (:)
   END TYPE STACK
For each scalar variable of type STACK, the shape of the component CONTENTS is determined by execution
of an ALLOCATE statement or assignment statement, or by argument association.
<b>NOTE</b> <b>3</b>
Default initialization of an explicit-shape array component can be specified by a constant expression consisting
of an array constructor (7.8), or of a single scalar that becomes the value of each array element.
<b>7.5.4.3</b> <b>Coarray</b> <b>components</b>
A data component is a coarray if its <i>component-decl</i> contains a <i>coarray-spec</i> or its <i>data-component-def-stmt</i>
containsaCODIMENSIONclause. Ifthe<i>component-decl</i> containsa<i>coarray-spec</i> itspecifiesthecorank; otherwise,
the <i>coarray-spec</i> in the CODIMENSION clause specifies the corank.
<b>NOTE</b>
An example of a derived type definition with a coarray component is:
   TYPE GRID_TYPE
     REAL, ALLOCATABLE, CODIMENSION [:, :, :] :: GRID (:, :, :)
   END TYPE GRID_TYPE
An object of type grid_type cannot be a coarray or a pointer.
<b>7.5.4.4</b> <b>Pointer</b> <b>components</b>
A data component is a data pointer (5.4.9) if its <i>component-attr-spec-list</i> contains the POINTER keyword. A
procedure pointer component has the POINTER keyword in its <i>proc-component-attr-spec-list</i>.
<b>NOTE</b>
An example of a derived type definition with a pointer component is:
   TYPE REFERENCE
     INTEGER :: VOLUME, YEAR, PAGE
     CHARACTER (LEN = 50) :: TITLE
     PROCEDURE (printer_interface), POINTER :: PRINT => NULL()
     CHARACTER, DIMENSION (:), POINTER :: SYNOPSIS
   END TYPE REFERENCE
Any object of type REFERENCE will have the four nonpointer components VOLUME, YEAR, PAGE, and
TITLE, the procedure pointer PRINT, which has an explicit interface the same as printer_interface, plus a
pointer to an array of characters holding SYNOPSIS. The size of this target array will be determined by the
length of the synopsis. The space for the target could be allocated (9.7.1) or the pointer component could be
associated with a target by a pointer assignment statement (10.2.2).
<b>7.5.4.5</b> <b>The</b> <b>passed-object</b> <b>dummy</b> <b>argument</b>
A passed-object dummy argument is a distinguished dummy argument of a procedure pointer component or
type-bound procedure (7.5.5). It affects procedure overriding (7.5.7.3) and argument association (15.5.2.2).
If NOPASS is specified, the procedure pointer component or type-bound procedure has no passed-object dummy
argument.
If neither PASS nor NOPASS is specified or PASS is specified without <i>arg-name</i>, the first dummy argument of a
procedure pointer component or type-bound procedure is its passed-object dummy argument.
If PASS (<i>arg-name</i>) is specified, the dummy argument named <i>arg-name</i> is the passed-object dummy argument of
the procedure pointer component or named type-bound procedure.
C765 The passed-object dummy argument shall be a scalar, nonpointer, nonallocatable dummy data object
   with the same declared type as the type being defined; all of its length type parameters shall be assumed;
   it shall be polymorphic (7.3.2.3) if and only if the type being defined is extensible (7.5.7). It shall not
   have the VALUE attribute.
<b>NOTE</b>
If a procedure is bound to several types as a type-bound procedure, different dummy arguments might be the
passed-object dummy argument in different contexts.
<b>7.5.4.6</b> <b>Default</b> <b>initialization</b> <b>for</b> <b>components</b>
Default initialization provides a means of automatically initializing pointer components to be disassociated or
associatedwithspecifictargets, andnonpointernonallocatablecomponentstohaveaparticularvalue. Allocatable
components are always initialized to unallocated.
A pointer variable or component is data-pointer-initialization compatible with a target if the pointer is type
compatible with the target, they have the same rank, all nondeferred type parameters of the pointer have the
same values as the corresponding type parameters of the target, and the target is contiguous if the pointer has
the CONTIGUOUS attribute.
R743 <i>component-initialization</i> <b>is</b> = <i>constant-expr</i>
              <b>or</b> =<i>></i> <i>null-init</i>
              <b>or</b> =<i>></i> <i>initial-data-target</i>
R744 <i>initial-data-target</i> <b>is</b> <i>designator</i>
C766 (R737) If <i>component-initialization</i> appears, a double-colon separator shall appear before the <i>component-</i>
   <i>decl-list</i>.
C767 (R737) If <i>component-initialization</i> appears, every type parameter and array bound of the component
   shall be a colon or constant expression.
C768 (R737) If =<i>></i> appears in <i>component-initialization</i>, POINTER shall appear in the <i>component-attr-spec-</i>
   <i>list</i>. If = appears in <i>component-initialization</i>, neither POINTER nor ALLOCATABLE shall appear in
   the <i>component-attr-spec-list</i>.
C769 If <i>initial-data-target</i> appears in a <i>component-initialization</i> in a <i>component-decl</i>, <i>component-name</i> shall be
   data-pointer-initialization compatible with it.
C770 A <i>designator</i> that is an <i>initial-data-target</i> shall designate a nonallocatable, noncoindexed variable that
   has the TARGET and SAVE attributes and does not have a vector subscript. Every subscript, sec-
   tion subscript, substring starting point, and substring ending point in <i>designator</i> shall be a constant
   expression.
If <i>null-init</i> appears for a pointer component, that component in any object of the type has an initial association
status of disassociated (3.57) or becomes disassociated as specified in 19.5.2.4.
If <i>initial-data-target</i> appears for a data pointer component, that component in any object of the type is initially
associated with the target or becomes associated with the target as specified in 19.5.2.3.
If <i>initial-proc-target</i> (15.4.3.6) appears in <i>proc-decl</i> for a procedure pointer component, that component in any
object of the type is initially associated with the target or becomes associated with the target as specified in
19.5.2.3.
If <i>constant-expr</i> appears for a nonpointer component, that component in any object of the type is initially defined
(19.6.3) or becomes defined as specified in 19.6.5 with the value determined from <i>constant-expr</i>. If necessary,
the value is converted according to the rules of intrinsic assignment (10.2.1.3) to a value that agrees in type,
type parameters, and shape with the component. If the component is of a type for which default initialization is
specified for a component, the default initialization specified by <i>constant-expr</i> overrides the default initialization
specified for that component. When one initialization overrides another it is as if only the overriding initialization
were specified (see NOTE 2). Explicit initialization in a type declaration statement (8.2) overrides default
initialization (see NOTE 1). Unlike explicit initialization, default initialization does not imply that the object
has the SAVE attribute.
A subcomponent (9.4.2) is default-initialized if the type of the object of which it is a component specifies default
initialization for that component, and the subcomponent is not a subobject of an object that is default-initialized
or explicitly initialized.
A type has default initialization if <i>component-initialization</i> is specified for any direct component of the type. An
object has default initialization if it is of a type that has default initialization.
<b>NOTE</b> <b>1</b>
It is not required that initialization be specified for each component of a derived type. For example:
   TYPE DATE
     INTEGER DAY
     CHARACTER (LEN = 5) MONTH
     INTEGER :: YEAR = 2008 ! Partial default initialization
   END TYPE DATE
In the following example, the default initial value for the YEAR component of TODAY is overridden by explicit
initialization in the type declaration statement:
   TYPE (DATE), PARAMETER :: TODAY = DATE (21, "Feb.", 2009)
<b>NOTE</b> <b>2</b>
The default initial value of a component of derived type can be overridden by default initialization specified in
the definition of the type. Continuing the example of NOTE 1:
   TYPE SINGLE_SCORE
     TYPE(DATE) :: PLAY_DAY = TODAY
     INTEGER SCORE
     TYPE(SINGLE_SCORE), POINTER :: NEXT => NULL ( )
   END TYPE SINGLE_SCORE
   TYPE(SINGLE_SCORE) SETUP
The PLAY_DAY component of SETUP receives its initial value from TODAY, overriding the initialization for
the YEAR component.
<b>NOTE</b> <b>3</b>
Arrays of structures can be declared with elements that are partially or totally initialized by default. Continuing
the example of NOTE 2:
   TYPE MEMBER (NAME_LEN)
     INTEGER, LEN :: NAME_LEN
     CHARACTER (LEN = NAME_LEN) :: NAME
     INTEGER :: TEAM_NO, HANDICAP = 0
     TYPE (SINGLE_SCORE), POINTER :: HISTORY => NULL ( )
   END TYPE MEMBER
   TYPE (MEMBER(9)) LEAGUE (36) ! Array of partially initialized elements
   TYPE (MEMBER(9)) :: ORGANIZER = MEMBER (9) ("I. Manage",1,5,NULL ( ))
ORGANIZER is explicitly initialized, overriding the default initialization for an object of type MEMBER.
Allocated objects can also be initialized partially or totally. For example:
   ALLOCATE (ORGANIZER % HISTORY) ! A partially initialized object of type
                    ! SINGLE_SCORE is created.
<b>NOTE</b> <b>4</b>
A pointer component of a derived type can have as its target an object of that derived type. The type definition
can specify that in objects declared to be of this type, such a pointer is default initialized to disassociated. For
example:
   TYPE NODE
     INTEGER :: VALUE = 0
     TYPE (NODE), POINTER :: NEXT_NODE => NULL ( )
   END TYPE
A type such as this can be used to construct linked lists of objects of type NODE. Linked lists can also be
constructed using allocatable components.
<b>NOTE</b> <b>5</b>
A pointer component of a derived type can be default initialized to have an initial target.
   TYPE NODE
    INTEGER :: VALUE = 0
    TYPE (NODE), POINTER :: NEXT_NODE => SENTINEL
   END TYPE
   TYPE(NODE), SAVE, TARGET :: SENTINEL
<b>7.5.4.7</b> <b>Component</b> <b>order</b>
Component order is an ordering of the nonparent components of a derived type; it is used for intrinsic format-
ted input/output and structure constructors where component keywords are not used. Parent components are
excluded from the component order of an extended type (7.5.7).
The component order of a nonextended type is the order of the declarations of the components in the derived-type
definition. The component order of an extended type consists of the component order of its parent type followed
by any additional components in the order of their declarations in the extended derived-type definition.
<b>NOTE</b>
Given the same type definitions as in 7.5.3.2, NOTE, the component order of type T1 is just A (there is only
one component), and the component order of type T2 is A then FLAG. The parent component (T1) does not
participate in the component order.
<b>7.5.4.8</b> <b>Component</b> <b>accessibility</b>
R745 <i>private-components-stmt</i> <b>is</b> PRIVATE
C771 (R745) A <i>private-components-stmt</i> is permitted only if the type definition is within the specification part
   of a module.
The default accessibility for the components that are declared in a type's <i>component-part</i> is private if the type
definition contains a <i>private-components-stmt</i>, and public otherwise. The accessibility of a component can be
explicitly declared by an <i>access-spec</i>; otherwise its accessibility is the default for the type definition in which it is
declared.
If a component is private, that component name is accessible only within the module containing the definition,
and within its descendants.
<b>NOTE</b> <b>1</b>
Type parameters are not components. They are effectively always public.
<b>NOTE</b> <b>2</b>
The accessibility of the components of a type is independent of the accessibility of the type name. It is possible
to have all four combinations of public and private type names with public and private components.
<b>NOTE</b> <b>3</b>
An example of a public type with private components is:
   TYPE, PUBLIC :: POINT
     PRIVATE
     REAL :: X, Y
   END TYPE POINT
Such a type definition can be accessed by use association; however, the components X and Y are accessible only
within the module and its descendants.
<b>NOTE</b> <b>4</b>
An example that uses an individual component <i>access-spec</i> to override the default accessibility is:
   TYPE MIXED
    PRIVATE
    INTEGER :: I
    INTEGER, PUBLIC :: J
   END TYPE MIXED
   TYPE (MIXED) :: M
The component M%J is accessible in any scoping unit where M is accessible; M%I is accessible only within the
module containing the TYPE MIXED definition, and within its descendants.
<b>7.5.5</b> <b>Type-bound</b> <b>procedures</b>
R746 <i>type-bound-procedure-part</i> <b>is</b> <i>contains-stmt</i>
                   [ <i>binding-private-stmt</i> ]
                   [ <i>type-bound-proc-binding</i> ] ...
R747 <i>binding-private-stmt</i> <b>is</b> PRIVATE
C772 (R746) A <i>binding-private-stmt</i> is permitted only if the type definition is within the specification part of
   a module.
R748 <i>type-bound-proc-binding</i> <b>is</b> <i>type-bound-procedure-stmt</i>
              <b>or</b> <i>type-bound-generic-stmt</i>
              <b>or</b> <i>final-procedure-stmt</i>
R749 <i>type-bound-procedure-stmt</i> <b>is</b> PROCEDURE [ [ , <i>binding-attr-list</i> ] :: ] <i>type-bound-proc-decl-list</i>
              <b>or</b> PROCEDURE (<i>interface-name</i>), <i>binding-attr-list</i> :: <i>binding-name-list</i>
R750 <i>type-bound-proc-decl</i> <b>is</b> <i>binding-name</i> [ =<i>></i> <i>procedure-name</i> ]
C773 (R749) If =<i>></i> <i>procedure-name</i> appears in a <i>type-bound-proc-decl</i>, the double-colon separator shall appear.
C774 (R750) The <i>procedure-name</i> shall be the name of an accessible module procedure or an external procedure
   that has an explicit interface.
C775 A <i>binding-name</i> in a <i>type-bound-proc-decl</i> in a derived type definition shall not be the same as any other
   <i>binding-name</i> within that derived type definition.
If =<i>>procedure-name</i> does not appear in a <i>type-bound-proc-decl</i>, it is as though =<i>>procedure-name</i> had appeared
with a procedure name the same as the binding name.
R751 <i>type-bound-generic-stmt</i> <b>is</b> GENERIC [ , <i>access-spec</i> ] :: <i>generic-spec</i> =<i>></i> <i>binding-name-list</i>
C776 (R751) Within the <i>specification-part</i> of a module, each <i>type-bound-generic-stmt</i> shall specify, either im-
   plicitly or explicitly, the same accessibility as every other <i>type-bound-generic-stmt</i> with that <i>generic-spec</i>
   in the same derived type.
C777 (R751) Each <i>binding-name</i> in <i>binding-name-list</i> shall be the name of a specific binding of the type.
C778 A <i>binding-name</i> in a type-bound GENERIC statement shall not specify a specific binding that was
   inherited or specified previously for the same generic identifier in that derived type definition.
C779 (R751) If <i>generic-spec</i> is not <i>generic-name</i>, each of its specific bindings shall have a passed-object dummy
   argument (7.5.4.5).
C780 (R751) If <i>generic-spec</i> is OPERATOR ( <i>defined-operator</i> ), the interface of each binding shall be as
   specified in 15.4.3.4.2.
C781 (R751) If <i>generic-spec</i> is ASSIGNMENT ( = ), the interface of each binding shall be as specified in
   15.4.3.4.3.
C782 (R751) If <i>generic-spec</i> is <i>defined-io-generic-spec</i>, the interface of each binding shall be as specified in
   12.6.4.8. The type of the dtv argument shall be <i>type-name</i>.
R752 <i>binding-attr</i> <b>is</b> <i>access-spec</i>
              <b>or</b> DEFERRED
              <b>or</b> NON_OVERRIDABLE
              <b>or</b> NOPASS
              <b>or</b> PASS [ (<i>arg-name</i>) ]
C783 (R752) The same <i>binding-attr</i> shall not appear more than once in a given <i>binding-attr-list</i>.
C784 (R749) If the interface of the binding has no dummy argument of the type being defined, NOPASS shall
   appear.
C785 (R749) If PASS (<i>arg-name</i>) appears, the interface of the binding shall have a dummy argument named
   <i>arg-name</i>.
C786 (R752) PASS and NOPASS shall not both appear in the same <i>binding-attr-list</i>.
C787 (R752) NON_OVERRIDABLE and DEFERRED shall not both appear in the same <i>binding-attr-list</i>.
C788 (R752) DEFERRED shall appear if and only if <i>interface-name</i> appears.
C789 (R749) An overriding binding (7.5.7.3) shall have the DEFERRED attribute only if the binding it over-
   rides is deferred.
C790 (R749) A binding shall not override an inherited binding (7.5.7.2) that has the NON_OVERRIDABLE
   attribute.
A type-bound procedure statement declares one or more specific type-bound procedures. A specific type-bound
procedure can have a passed-object dummy argument (7.5.4.5). A type-bound procedure with the DEFERRED
attribute is a deferred type-bound procedure. The DEFERRED keyword shall appear only in the definition of
an abstract type.
A GENERIC statement declares a generic type-bound procedure, which is a type-bound generic interface for its
specific type-bound procedures.
A binding of a type is a type-bound procedure (specific or generic), a generic type-bound interface, or a final
subroutine. These are referred to as specific bindings, generic bindings, and final bindings respectively.
A type-bound procedure can be identified by a binding name in the scope of the type definition. This name is the
<i>binding-name</i> for a specific type-bound procedure, and the <i>generic-name</i> for a generic binding whose <i>generic-spec</i>
is <i>generic-name</i>. A final binding, or a generic binding whose <i>generic-spec</i> is not <i>generic-name</i>, has no binding
name.
The interface of a specific type-bound procedure is that of the procedure specified by <i>procedure-name</i> or the
interface specified by <i>interface-name</i>.
The same <i>generic-spec</i> may be used in several GENERIC statements within a single derived-type definition. Each
additional GENERIC statement with the same <i>generic-spec</i> extends the generic interface.
<b>NOTE</b> <b>1</b>
Unlike the situation with generic procedure names, a generic type-bound procedure name is not permitted to
be the same as a specific type-bound procedure name in the same type (19.3).
Thedefaultaccessibilityforthetype-boundproceduresofatypeisprivateifthetypedefinitioncontainsa <i>binding-</i>
<i>private-stmt</i>, and public otherwise. The accessibility of a type-bound procedure can be explicitly declared by an
<i>access-spec</i>; otherwise its accessibility is the default for the type definition in which it is declared.
A public type-bound procedure is accessible via any accessible object of the type. A private type-bound procedure
is accessible only within the module containing the type definition, and within its descendants.
<b>NOTE</b> <b>2</b>
The accessibility of a type-bound procedure is not affected by a PRIVATE statement in the <i>component-part</i>;
the accessibility of a component is not affected by a PRIVATE statement in the <i>type-bound-procedure-part</i>.
<b>NOTE</b> <b>3</b>
An example of a type and a type-bound procedure is:
   TYPE POINT
    REAL :: X, Y
   CONTAINS
    PROCEDURE, PASS :: LENGTH => POINT_LENGTH
   END TYPE POINT
   ...
and in the <i>module-subprogram-part</i> of the same module:
<b>86</b> <b>J3/23-007r1</b>
<b>NOTE</b> <b>3</b> <b>(cont.)</b>
   REAL FUNCTION POINT_LENGTH (A, B)
    CLASS (POINT), INTENT (IN) :: A, B
    POINT_LENGTH = SQRT ( (A%X - B%X)**2 + (A%Y - B%Y)**2 )
   END FUNCTION POINT_LENGTH
<b>7.5.6</b> <b>Final</b> <b>subroutines</b>
<b>7.5.6.1</b> <b>FINAL</b> <b>statement</b>
R753 <i>final-procedure-stmt</i> <b>is</b> FINAL [ :: ] <i>final-subroutine-name-list</i>
C791 (R753) A <i>final-subroutine-name</i> shall be the name of a module procedure with exactly one dummy
   argument. That argument shall be nonoptional and shall be a noncoarray, nonpointer, nonallocatable,
   nonpolymorphic variable of the derived type being defined. All length type parameters of the dummy
   argument shall be assumed. The dummy argument shall not have the INTENT (OUT) or VALUE
   attribute.
C792 (R753) A <i>final-subroutine-name</i> shall not be one previously specified as a final subroutine for that type.
C793 (R753) A final subroutine shall not have a dummy argument with the same kind type parameters and
   rank as the dummy argument of another final subroutine of that type.
C794 (R753) If a final subroutine has an assumed-rank dummy argument, no other final subroutine of that
   type shall have a dummy argument with the same kind type parameters.
The FINAL statement specifies that each procedure it names is a final subroutine. A final subroutine might be
executed when a data entity of that type is finalized (7.5.6.2).
A derived type is finalizable if and only if it has a final subroutine or a nonpointer, nonallocatable component of
finalizable type. A nonpointer data entity is finalizable if and only if it is of finalizable type. No other entity is
finalizable.
<b>NOTE</b> <b>1</b>
Final subroutines are effectively always "accessible". They are called for entity finalization regardless of the
accessibility of the type, its other type-bound procedures, or the subroutine name itself.
<b>NOTE</b> <b>2</b>
Final subroutines are not inherited through type extension and cannot be overridden. The final subroutines of
the parent type are called after any additional final subroutines of an extended type are called.
<b>7.5.6.2</b> <b>The</b> <b>finalization</b> <b>process</b>
Only finalizable entities are finalized. When an entity is finalized, the following steps are carried out in sequence.
  (1) If the dynamic type of the entity has a final subroutine whose dummy argument has the same kind
     type parameters and rank as the entity being finalized, it is called with the entity as an actual
     argument. Otherwise, if there is an elemental final subroutine whose dummy argument has the same
     kind type parameters as the entity being finalized, or a final subroutine whose dummy argument is
     assumed-rank with the same kind type parameters as the entity being finalized, it is called with the
     entity as an actual argument. Otherwise, no subroutine is called at this point.
  (2) Allnonallocatablefinalizablecomponentsthatappearinthetypedefinitionarefinalizedinaprocessor-
     dependent order. If the entity being finalized is an array, each finalizable component of each element
     of that entity is finalized separately.
  (3) If the entity is of extended type and the parent type is finalizable, the parent component is finalized.
If several entities are to be finalized as a consequence of an event specified in 7.5.6.3, the order in which they
are finalized is processor dependent. During this process, execution of a final subroutine for one of these entities
shall not reference or define any of the other entities that have already been finalized.
<b>NOTE</b>
An implementation might need to ensure that when an event causes more than one coarray to be deallocated,
they are deallocated in the same order on all images in the current team.
<b>7.5.6.3</b> <b>When</b> <b>finalization</b> <b>occurs</b>
When an intrinsic assignment statement is executed (10.2.1.3), if the variable is not an unallocated allocatable
variable, it is finalized after evaluation of <i>expr</i> and before the definition of the variable. If the variable is an
allocated allocatable variable, or has an allocated allocatable subobject, that would be deallocated by intrinsic
assignment, the finalization occurs before the deallocation.
When a pointer is deallocated its target is finalized. When an allocatable entity is deallocated, it is finalized
unless it is the variable in an intrinsic assignment statement. If an error condition occurs during deallocation, it
is processor dependent whether finalization occurs.
A nonpointer, nonallocatable object that is not a dummy argument or function result is finalized immediately
before it would become undefined due to execution of a RETURN or END statement (19.6.6, item (3)).
A nonpointer nonallocatable local variable of a BLOCK construct is finalized immediately before it would become
undefined due to termination of the BLOCK construct (19.6.6, item (23)).
If an executable construct references a nonpointer function, the result is finalized after execution of the innermost
executable construct containing the reference.
If a specification expression in a scoping unit references a function, the result is finalized before execution of the
executable constructs in the scoping unit.
When a procedure is invoked, a nonpointer, nonallocatable, INTENT (OUT) dummy argument of that procedure
is finalized before it becomes undefined. The finalization caused by INTENT (OUT) is considered to occur within
the invoked procedure; so for elemental procedures, an INTENT (OUT) argument will be finalized only if a scalar
or elemental final subroutine is available, regardless of the rank of the actual argument.
If an object is allocated via pointer allocation and later becomes unreachable due to all pointers associated with
that object having their pointer association status changed, it is processor dependent whether it is finalized. If it
is finalized, it is processor dependent as to when the final subroutines are called.
<b>NOTE</b>
If finalization is used for storage management, it often needs to be combined with defined assignment.
<b>7.5.6.4</b> <b>Entities</b> <b>that</b> <b>are</b> <b>not</b> <b>finalized</b>
If image execution is terminated, either by an error (e.g. an allocation failure) or by execution of a <i>stop-stmt</i>,
<i>error-stop-stmt</i>, or <i>end-program-stmt</i>, entities existing immediately prior to termination are not finalized.
<b>NOTE</b>
A nonpointer, nonallocatable object that has the SAVE attribute is never finalized as a direct consequence of
the execution of a RETURN or END statement.
<b>7.5.7</b> <b>Type</b> <b>extension</b>
<b>7.5.7.1</b> <b>Extensible,</b> <b>extended,</b> <b>and</b> <b>abstract</b> <b>types</b>
A derived type, other than the type C_PTR or C_FUNPTR from the intrinsic module ISO_C_BINDING, that
does not have the BIND attribute or the SEQUENCE attribute is an extensible type.
A type with the EXTENDS attribute is an extended type; its parent type is the type named in the EXTENDS
<i>type-attr-spec</i>.
<b>NOTE</b> <b>1</b>
The name of the parent type might be a local name introduced via renaming in a USE statement.
An extensible type that does not have the EXTENDS attribute is an extension type of itself only. An extended
type is an extension of itself and of all types for which its parent type is an extension.
An abstract type is a type that has the ABSTRACT attribute.
<b>NOTE</b> <b>2</b>
The DEFERRED attribute (7.5.5) defers the implementation of a type-bound procedure to extensions of the
type; it can appear only in an abstract type. The dynamic type of an object cannot be abstract; therefore, a
deferred type-bound procedure cannot be invoked. An extension of an abstract type need not be abstract if it
has no deferred type-bound procedures. A short example of an abstract type is:
   TYPE, ABSTRACT :: FILE_HANDLE
   CONTAINS
     PROCEDURE(OPEN_FILE), DEFERRED, PASS(HANDLE) :: OPEN
     ...
   END TYPE
For a more elaborate example see C.3.4.
<b>7.5.7.2</b> <b>Inheritance</b>
An extended type includes all of the type parameters, all of the components, and the nonoverridden (7.5.7.3)
type-bound procedures of its parent type. These are inherited by the extended type from the parent type. They
retain all of the attributes that they had in the parent type. Additional type parameters, components, and
procedure bindings may be declared in the derived-type definition of the extended type.
<b>NOTE</b> <b>1</b>
Inaccessible components and bindings of the parent type are also inherited, but they remain inaccessible in the
extended type. Inaccessible entities occur if the type being extended is accessed via use association and has a
private entity.
<b>NOTE</b> <b>2</b>
An extensible derived type is not required to have any components, bindings, or parameters; an extended type
is not required to have more components, bindings, or parameters than its parent type.
An extended type has a scalar, nonpointer, nonallocatable, parent component with the type and type parameters
of the parent type. The name of this component is the parent type name. If the extended type is defined in a
module, the parent component has the accessibility of the parent type in the module in which the parent type
was defined. Components of the parent component are inheritance associated (19.5.4) with the corresponding
components inherited from the parent type. An ancestor component of a type is the parent component of the
type or an ancestor component of the parent component.
If a generic binding specified in a type definition has the same <i>generic-spec</i> as an inherited binding, it extends
the generic interface and shall satisfy the requirements specified in 15.4.3.4.5.
<b>NOTE</b> <b>3</b>
A component or type parameter declared in an extended type cannot have the same name as any accessible
component or type parameter of its parent type.
<b>NOTE</b> <b>4</b>
For example:
   TYPE POINT ! A base type
    REAL :: X, Y
   END TYPE POINT
   TYPE, EXTENDS(POINT) :: COLOR_POINT ! An extension of TYPE(POINT)
    ! Components X and Y, and component name POINT, inherited from parent
    INTEGER :: COLOR
   END TYPE COLOR_POINT
<b>7.5.7.3</b> <b>Type-bound</b> <b>procedure</b> <b>overriding</b>
If a specific type-bound procedure specified in a type definition has the same binding name as an accessible
type-bound procedure from the parent type then the binding specified in the type definition overrides the one
from the parent type.
The overriding and overridden type-bound procedures shall satisfy the following conditions.
 Either both shall have a passed-object dummy argument or neither shall.
 If the overridden type-bound procedure is pure then the overriding one shall also be pure.
 If the overridden type-bound procedure is simple then the overriding one shall also be simple.
 Either both shall be elemental or neither shall.
 They shall have the same number of dummy arguments.
 Passed-object dummy arguments, if any, shall correspond by name and position.
 Dummy arguments that correspond by position shall have the same names and characteristics, except for
  the type of the passed-object dummy arguments.
 Either both shall be subroutines or both shall be functions having the same result characteristics (15.3.3).
 If the overridden type-bound procedure is PUBLIC then the overriding one shall not be PRIVATE.
A binding of a type and a binding of an extension of that type correspond if the latter binding is the same binding
as the former, overrides a corresponding binding, or is an inherited corresponding binding.
<b>NOTE</b>
The following is an example of procedure overriding, expanding on the example in 7.5.5, NOTE 3.
   TYPE, EXTENDS (POINT) :: POINT_3D
    REAL :: Z
   CONTAINS
    PROCEDURE, PASS :: LENGTH => POINT_3D_LENGTH
   END TYPE POINT_3D
    ...
and in the <i>module-subprogram-part</i> of the same module:
   REAL FUNCTION POINT_3D_LENGTH ( A, B )
    CLASS (POINT_3D), INTENT (IN) :: A
    CLASS (POINT), INTENT (IN) :: B
    SELECT TYPE(B)
     CLASS IS(POINT_3D)
      POINT_3D_LENGTH = SQRT( (A%X-B%X)**2 + (A%Y-B%Y)**2 + (A%Z-B%Z)**2 )
<b>90</b> <b>J3/23-007r1</b>
<b>NOTE</b> <b>(cont.)</b>
      RETURN
    END SELECT
    PRINT *, 'In POINT_3D_LENGTH, dynamic type of argument is incorrect.'
    STOP
   END FUNCTION POINT_3D_LENGTH
<b>7.5.8</b> <b>Derived-type</b> <b>values</b>
The component value of
 a pointer component is its pointer association,
 anallocatablecomponentisitsallocationstatusand, ifitisallocated, itsdynamictypeandtypeparameters,
  bounds and value, and
 a nonpointer nonallocatable component is its value.
The set of values of a particular derived type consists of all possible sequences of the component values of its
components.
<b>7.5.9</b> <b>Derived-type</b> <b>specifier</b>
A derived-type specifier is used in several contexts to specify a particular derived type and type parameters.
R754 <i>derived-type-spec</i> <b>is</b> <i>type-name</i> [ ( <i>type-param-spec-list</i> ) ]
R755 <i>type-param-spec</i> <b>is</b> [ <i>keyword</i> = ] <i>type-param-value</i>
C795 (R754) <i>type-name</i> shall be the name of an accessible derived type.
C796 (R754) <i>type-param-spec-list</i> shall appear only if the type is parameterized.
C797 (R754) There shall be at most one <i>type-param-spec</i> corresponding to each parameter of the type. If a
   type parameter does not have a default value, there shall be a <i>type-param-spec</i> corresponding to that
   type parameter.
C798 (R755) The <i>keyword</i>= shall not be omitted from a <i>type-param-spec</i> unless the <i>keyword</i>= has been omitted
   from each preceding <i>type-param-spec</i> in the <i>type-param-spec-list</i>.
C799 (R755) Each <i>keyword</i> shall be the name of a parameter of the type.
C7100 (R755) An asterisk shall not be used as a <i>type-param-value</i> in a <i>type-param-spec</i> except in the declaration
   of a dummy argument or associate name or in the allocation of a dummy argument.
Type parameter values that do not have type parameter keywords specified correspond to type parameters in type
parameter order (7.5.3.2). If a type parameter keyword appears, the value corresponds to the type parameter
named by the keyword. If necessary, the value is converted according to the rules of intrinsic assignment (10.2.1.3)
to a value of the same kind as the type parameter.
The value of a type parameter for which no <i>type-param-value</i> has been specified is its default value.
<b>7.5.10</b> <b>Construction</b> <b>of</b> <b>derived-type</b> <b>values</b>
A derived-type definition implicitly defines a corresponding structure constructor that allows construction of
scalar values of that derived type. The type and type parameters of a constructed value are specified by a derived
type specifier.
R756 <i>structure-constructor</i> <b>is</b> <i>derived-type-spec</i> ( [ <i>component-spec-list</i> ] )
R757 <i>component-spec</i> <b>is</b> [ <i>keyword</i> = ] <i>component-data-source</i>
R758 <i>component-data-source</i> <b>is</b> <i>expr</i>
              <b>or</b> <i>data-target</i>
              <b>or</b> <i>proc-target</i>
C7101 (R756) The <i>derived-type-spec</i> shall not specify an abstract type (7.5.7).
C7102 (R756) At most one <i>component-spec</i> shall be provided for a component.
C7103 (R756)Ifa<i>component-spec</i> isprovidedforanancestorcomponent, a <i>component-spec</i> shallnotbeprovided
   for any component that is inheritance associated with a subcomponent of that ancestor component.
C7104 (R756) A <i>component-spec</i> shall be provided for a nonallocatable component unless it has default initializ-
   ation or is inheritance associated with a subcomponent of another component for which a <i>component-spec</i>
   is provided.
C7105 (R757) The <i>keyword</i>= shall not be omitted from a <i>component-spec</i> unless the <i>keyword</i>= has been omitted
   from each preceding <i>component-spec</i> in the constructor.
C7106 (R757) Each <i>keyword</i> shall be the name of a component of the type.
C7107 (R756) The type name and all components of the type for which a <i>component-spec</i> appears shall be
   accessible in the scoping unit containing the structure constructor.
C7108 (R756) If <i>derived-type-spec</i> is a type name that is the same as a generic name, the <i>component-spec-list</i>
   shall not be a valid <i>actual-arg-spec-list</i> for a function reference that is resolvable as a generic reference to
   that name (15.5.5.2).
C7109 (R758) A <i>data-target</i> shall correspond to a data pointer component; a <i>proc-target</i> shall correspond to a
   procedure pointer component.
C7110 (R758) A <i>data-target</i> shall have the same rank as its corresponding component.
<b>NOTE</b> <b>1</b>
The form 'name(...)' is interpreted as a generic <i>function-reference</i> if possible; it is interpreted as a <i>structure-</i>
<i>constructor</i> only if it cannot be interpreted as a generic <i>function-reference</i>.
In the absence of a component keyword, each <i>component-data-source</i> is assigned to the corresponding component
in component order (7.5.4.7). If a component keyword appears, the <i>expr</i> is assigned to the component named
by the keyword. For a nonpointer component, the declared type and type parameters of the component and
<i>expr</i> shall conform in the same way as for a <i>variable</i> and <i>expr</i> in an intrinsic assignment statement (10.2.1.2).
If necessary, each value of intrinsic type is converted according to the rules of intrinsic assignment (10.2.1.3) to
a value that agrees in type and type parameters with the corresponding component of the derived type. For a
nonpointer nonallocatable component, the shape of the expression shall conform with the shape of the component.
If a component with default initialization has no corresponding <i>component-data-source</i>, then the default initial-
ization is applied to that component. If an allocatable component has no corresponding <i>component-data-source</i>,
then that component has an allocation status of unallocated.
<b>NOTE</b> <b>2</b>
Because no parent components appear in the defined component ordering, a value for a parent component can
be specified only with a component keyword. Examples of equivalent values using types defined in 7.5.7.2,
NOTE 4:
   ! Create values with components x = 1.0, y = 2.0, color = 3.
   TYPE(POINT) :: PV = POINT(1.0, 2.0) ! Assume components of TYPE(POINT)
                         ! are accessible here.
    ...
<b>92</b> <b>J3/23-007r1</b>
<b>NOTE</b> <b>2</b> <b>(cont.)</b>
   COLOR_POINT( point=point(1,2), color=3) ! Value for parent component
   COLOR_POINT( point=PV, color=3) ! Available even if TYPE(point)
                         ! has private components
   COLOR_POINT( 1, 2, 3) ! All components of TYPE(point)
                         ! need to be accessible.
A structure constructor shall not appear before the referenced type is defined.
For a pointer component, the corresponding <i>component-data-source</i> shall be an allowable <i>data-target</i> or <i>proc-</i>
<i>target</i> for such a pointer in a pointer assignment statement (10.2.2). If the component data source is a pointer,
the association of the component is that of the pointer; otherwise, the component is pointer associated with the
component data source.
<b>NOTE</b> <b>3</b>
For example, if the variable TEXT were declared (8.2) to be
   CHARACTER, DIMENSION (1:400), TARGET :: TEXT
and BIBLIO were declared using the derived-type definition REFERENCE in 7.5.4.4, NOTE
   TYPE (REFERENCE) :: BIBLIO
the statement
   BIBLIO = REFERENCE (1, 1987, 1, "This is the title of the referenced &
                   &paper", SYNOPSIS=TEXT)
is valid and associates the pointer component SYNOPSIS of the object BIBLIO with the target object TEXT.
The keyword SYNOPSIS is required because the fifth component of the type REFERENCE is a procedure
pointer component, not a data pointer component of type character. It is not necessary to specify a <i>proc-target</i>
for the procedure pointer component because it has default initialization.
If a component of a derived type is allocatable, the corresponding constructor expression shall be a reference
to the intrinsic function NULL with no arguments, an allocatable entity of the same rank, or shall evaluate to
an entity of the same rank. If the expression is a reference to the intrinsic function NULL, the corresponding
component of the constructor has a status of unallocated.
If the component is allocatable and the expression is an allocatable entity, the corresponding component of the
constructor has the same allocation status as that allocatable entity. If it is allocated, it has the same bounds;
if a length parameter of the component is deferred, its value is the same as the corresponding parameter of the
expression. If the component is polymorphic, it has the same dynamic type and value; otherwise, it has the value
converted, if necessary, to the declared type of the component.
If the component is allocatable and the expression is not an allocatable entity, the component has an allocation
status of allocated and the same bounds as the expression; if a length parameter of the component is deferred,
its value is the same as the corresponding parameter of the expression. If the component is polymorphic, it has
the same dynamic type and value; otherwise, it has the value converted, if necessary, to the declared type of the
component.
<b>NOTE</b> <b>4</b>
This example shows a derived-type constant expression using the derived type defined in 7.5.2.1, NOTE:
   PERSON (21, 'JOHN SMITH')
This could also be written as
   PERSON (NAME = 'JOHN SMITH', AGE = 21)
<b>NOTE</b> <b>5</b>
An example constructor using the derived type GENERAL_POINT defined in 7.5.3.1, NOTE is
   general_point(dim=3) ( [ 1., 2., 3. ] )
<b>7.5.11</b> <b>Derived-type</b> <b>operations</b> <b>and</b> <b>assignment</b>
Intrinsic assignment of derived-type entities is described in 10.2.1. This document does not specify any intrinsic
operations on derived-type entities. Any operation on derived-type entities or defined assignment (10.2.1.4) for
derived-type entities shall be defined explicitly by a function or a subroutine, and a generic interface (7.5.5,
15.4.3.2).
<b>7.6</b> <b>Other</b> <b>nonintrinsic</b> <b>types</b>
<b>7.6.1</b> <b>Interoperable</b> <b>enumerations</b> <b>and</b> <b>enum</b> <b>types</b>
An interoperable enumeration is a set of interoperable enumerators, optionally together with an enum type. An
<i>enum-def</i> defines an interoperable enumeration. An interoperable enumerator is a named integer constant; all
the enumerators defined by a particular <i>enum-def</i> have the same kind. An enum type is a nonintrinsic type that
is not a derived type; it has no type parameter.
R759 <i>enum-def</i> <b>is</b> <i>enum-def-stmt</i>
                   <i>enumerator-def-stmt</i>
                   [ <i>enumerator-def-stmt</i> ] ...
                   <i>end-enum-stmt</i>
R760 <i>enum-def-stmt</i> <b>is</b> ENUM, BIND(C) [ :: <i>enum-type-name</i> ]
R761 <i>enumerator-def-stmt</i> <b>is</b> ENUMERATOR [ :: ] <i>enumerator-list</i>
R762 <i>enumerator</i> <b>is</b> <i>named-constant</i> [ = <i>scalar-int-constant-expr</i> ]
R763 <i>end-enum-stmt</i> <b>is</b> END ENUM
C7111 (R761) If = appears in an <i>enumerator</i>, a double-colon separator shall appear before the <i>enumerator-list</i>.
R764 <i>enum-type-spec</i> <b>is</b> <i>enum-type-name</i>
C7112 An <i>enum-type-name</i> in an <i>enum-type-spec</i> shall be the name of a previously defined enum type.
The kind type parameter of each enumerator defined by an <i>enum-def</i> is the kind that is interoperable (18.3.1)
with the corresponding C enumerated type. The corresponding C enumerated type is the type that would be
declared by a C enumeration specifier (ISO/IEC 9899:2018, 6.7.2.2) that specified C enumeration constants with
the same values as those specified by the <i>enum-def</i>, in the same order as specified by the <i>enum-def</i>.
If <i>enum-type-name</i> appears in an <i>enum-def</i>, the <i>enum-def</i> defines the enum type with that name. An enum type
is an interoperable type. The set of values of an enum type has a one-to-one correspondence with the set of
possible values for the integer kind of its enumerators. The internal representation of each enum type value is
the same as that of the corresponding integer.
An enum type specifier specifiers the type. Two data entities of enum type have the same type if they are declared
with reference to the same enum type definition.
The companion processor (5.5.7) shall be one that uses the same representation for the types declared by all C
enumeration specifiers that specify the same values in the same order.
<b>NOTE</b> <b>1</b>
If a companion processor uses an unsigned type to represent a C enumerated type, the Fortran processor will
use the signed integer type of the same width for the enumeration, even though some of the values of the C
enumerators might not be representable in this signed integer type. The types of any such enumerators will be
interoperable with the type declared in the C enumeration.
<b>NOTE</b> <b>2</b>
ISO/IEC9899:2018guaranteestheenumerationconstantsfitinaCint(ISO/IEC9899:2018, 6.7.2.2). Therefore,
the Fortran processor can evaluate all enumerator values using the integer type with kind parameter C_INT,
and then determine the kind parameter of the integer type that is interoperable with the corresponding C
enumerated type.
<b>NOTE</b> <b>3</b>
ISO/IEC 9899:2018 specifies that two C enumerated types are compatible only if they specify enumeration
constants with the same names and same values in the same order. This document further requires that a C
processor that is to be a companion processor of a Fortran processor use the same representation for two C
enumerated types if they both specify enumeration constants with the same values in the same order, even if
the names are different.
An enumerator is treated as if it were explicitly declared with the PARAMETER attribute. The enumerator is
a scalar named constant, with the value determined as follows.
  (1) If <i>scalar-int-constant-expr</i> appears, the enumerator has the value specified by <i>scalar-int-constant-</i>
     <i>expr</i>.
  (2) If <i>scalar-int-constant-expr</i> does not appear and the enumerator is the first enumerator in <i>enum-def</i>,
     the enumerator has the value zero.
  (3) If <i>scalar-int-constant-expr</i> does not appear and the enumerator is not the first enumerator in <i>enum-</i>
     <i>def</i>, it has the value obtained by adding one to the value of the enumerator that immediately precedes
     it in the <i>enum-def</i>.
R765 <i>enum-constructor</i> <b>is</b> <i>enum-type-spec</i> ( <i>scalar-expr</i> )
C7113 The <i>scalar-expr</i> in an <i>enum-constructor</i> shall be of type integer or be a <i>boz-literal-constant</i>.
An enum constructor produces a scalar value of the specified type, with the specified internal representation. The
value of <i>scalar-expr</i> shall be representable in objects of that type.
<b>NOTE</b> <b>4</b>
Example of an interoperable enumeration definition:
   ENUM, BIND(C)
    ENUMERATOR :: RED = 4, BLUE = 9
    ENUMERATOR YELLOW
   END ENUM
The kind type parameter for this enumeration is processor dependent, but the processor is required to select
a kind sufficient to represent the values 4, 9, and 10, which are the values of its enumerators. The following
declaration might be equivalent to the above enumeration definition.
   INTEGER (SELECTED_INT_KIND (2)), PARAMETER :: RED = 4, BLUE = 9, YELLOW = 10
An entity of the same kind type parameter value can be declared using the intrinsic function KIND with one of
the enumerators as its argument, for example
INTEGER (KIND (RED)) :: X
<b>NOTE</b> <b>5</b>
There is no difference in the effect of declaring the enumerators in multiple ENUMERATOR statements or
in a single ENUMERATOR statement. The order in which the enumerators in an enumeration definition are
declared is significant, but the number of ENUMERATOR statements is not.
<b>NOTE</b> <b>6</b>
Here is an example of a module that defines two enum types.
   Module enum_mod
    Enum,Bind(C) :: myenum
     Enumerator :: one=1, two, three
    End Enum
    Enum,Bind(C) :: flags
     Enumerator :: f1 = 1, f2 = 2, f3 = 4
    End Enum
   Contains
    Subroutine sub(a) Bind(C)
     Type(myenum),Value :: a
     Print *,a ! Prints the integer value, as if it were Print *,Int(a).
    End Subroutine
   End Module
Here is a simple program that uses that module and the enum constructor.
   Program example
    Use enum_mod
    Type(myenum) :: x = one ! Assign enumerator to enum-type var.
    Type(myenum) :: y = myenum(12345) ! Using the constructor.
    Type(myenum) :: x2 = myenum(two) ! Constructor not needed but valid.
    Call sub(x)
    Call sub(three)
    Call sub(myenum(-Huge(one)))
   End Program
Here is an example of invalid usage.
   Program invalid
    Use enum_mod
    Type(myenum) :: z = 12345 ! Integer expr with no enumerator.
    Call sub(999) ! Not type-compatible (constructor needed).
    Call sub(f1) ! Wrong enum type.
   End Program
<b>7.6.2</b> <b>Enumeration</b> <b>types</b>
An enumeration type is a nonintrinsic type with no type parameter. It is not a derived type and is not inter-
operable. An enumeration type definition defines the name of the type and lists all the possible values of the
type.
R766 <i>enumeration-type-def</i> <b>is</b> <i>enumeration-type-stmt</i>
                   <i>enumeration-enumerator-stmt</i>
                   [ <i>enumeration-enumerator-stmt</i> ]...
                   <i>end-enumeration-type-stmt</i>
R767 <i>enumeration-type-stmt</i> <b>is</b> ENUMERATION TYPE [ [ , <i>access-spec</i> ] :: ] <i>enumeration-type-name</i>
C7114 An <i>access-spec</i> on an <i>enumeration-type-stmt</i> shall only appear in the specification part of a module.
R768 <i>enumeration-enumerator-stmt</i> <b>is</b> ENUMERATOR [ :: ] <i>enumerator-name-list</i>
R769 <i>end-enumeration-type-stmt</i> <b>is</b> END ENUMERATION TYPE [ <i>enumeration-type-name</i> ]
C7115 If <i>enumeration-type-name</i> appears on an END ENUMERATION TYPE statement, it shall be the same
   as on the ENUMERATION TYPE statement.
The <i>access-spec</i> on an ENUMERATION TYPE statement specifies the accessibility of the <i>enumeration-type-</i>
<i>name</i> and the default accessibility of its enumerators. The accessibility of an enumerator may be confirmed or
overridden by an <i>access-stmt</i>.
Eachenumeratorinthedefinitionisascalarnamedconstantoftheenumerationtype. Theorderoftheenumerator
names in the definition defines the ordinal position of each enumerator.
R770 <i>enumeration-type-spec</i> <b>is</b> <i>enumeration-type-name</i>
C7116 The <i>enumeration-type-name</i> in an <i>enumeration-type-spec</i> shall be the name of a previously defined enu-
   meration type.
An enumeration type specifier specifiers the type. Two data entities of enumeration type have the same type if
they are declared with reference to the same enumeration type definition.
R771 <i>enumeration-constructor</i> <b>is</b> <i>enumeration-type-spec</i> ( <i>scalar-int-expr</i> )
An enumeration constructor produces the scalar value of the enumeration type whose ordinal position is the value
of the <i>scalar-int-expr</i>. The <i>scalar-int-expr</i> shall have a value that is positive and less than or equal to the number
of enumerators in the enumeration type's definition.
<b>NOTE</b>
Here is an example of a module defining two enumeration types.
   Module enumeration_mod
    Enumeration Type :: v_value
     Enumerator :: v_one, v_two, v_three
     Enumerator v_four
    End Enumeration Type
    Enumeration Type :: w_value
     Enumerator :: w1, w2, w3, w4, w5, wendsentinel
    End Enumeration Type
   Contains
    Subroutine sub(a)
     Type(v_value),Intent(In) :: a
     Print 1,a ! Acts similarly to Print *,Int(a).
  1 Format('A has ordinal value ',I0)
    End Subroutine
    Subroutine wcheck(w)
     Type(w_value),Intent(In) :: w
     Select Case(w)
     Case(w1)
      Print *,'w1 selected'
     Case (w2:w4)
      Print *,'One of w2...w4 selected'
     Case (wendsentinel)
      Stop 'Invalid w selected'
     Case Default
      Stop 'Unrecognized w selected'
                <b>J3/23-007r1</b> <b>97</b>
<b>NOTE</b> <b>(cont.)</b>
     End Select
    End Subroutine
   End Module
Here is an example of a program using that module.
   Program example
    Use enumeration_mod
    Type(v_value) :: x = v_one
    Type(v_value) :: y = v_value(2) ! Explicit constructor producing v_two.
    Type(v_value) :: z,nz ! Initially undefined.
    Call sub(x)
    Call sub(v_three)
    z = v_value(1) ! First value.
    Do
     If (z==Huge(x)) Write (*,'(A)',Advance='No') ' Huge:'
     Call sub(z)
     nz = Next(z)
     If (z==nz) Exit
     z = nz
    End Do
   End Program
Here is an example showing some invalid usages of enumerations.
   Program invalid
    Use enumeration_mod
    Type(v_value) :: a, b
    a = 1 ! INVALID - wrong type (INTEGER).
    b = w1 ! INVALID - wrong enumeration type.
    Print *,a ! INVALID - list-directed i/o not available.
   End Program
An enumeration type can be used to declare components, for example:
   Module example2
    Use enumeration_mod
    Type vw
     Type(v_value) v
     Type(w_value) w
    End Type
   Contains
    Subroutine showme(ka)
     Type(vw),Intent(In) :: ka
     Print 1,ka
  1 Format(1X,'v ordinal is ',I0,', w ordinal is ',I0)
    End Subroutine
   End Module
<b>7.7</b> <b>Binary,</b> <b>octal,</b> <b>and</b> <b>hexadecimal</b> <b>literal</b> <b>constants</b>
A binary, octal, or hexadecimal constant (<i>boz-literal-constant</i>) is a sequence of digits that represents an ordered
sequence of bits. Such a constant has no type.
R772 <i>boz-literal-constant</i> <b>is</b> <i>binary-constant</i>
              <b>or</b> <i>octal-constant</i>
              <b>or</b> <i>hex-constant</i>
R773 <i>binary-constant</i> <b>is</b> B ' <i>digit</i> [ <i>digit</i> ] ... '
              <b>or</b> B " <i>digit</i> [ <i>digit</i> ] ... "
C7117 (R773) <i>digit</i> shall have one of the values 0 or 1.
R774 <i>octal-constant</i> <b>is</b> O ' <i>digit</i> [ <i>digit</i> ] ... '
              <b>or</b> O " <i>digit</i> [ <i>digit</i> ] ... "
C7118 (R774) <i>digit</i> shall have one of the values 0 through 7.
R775 <i>hex-constant</i> <b>is</b> Z ' <i>hex-digit</i> [ <i>hex-digit</i> ] ... '
              <b>or</b> Z " <i>hex-digit</i> [ <i>hex-digit</i> ] ... "
R776 <i>hex-digit</i> <b>is</b> <i>digit</i>
              <b>or</b> A
              <b>or</b> B
              <b>or</b> C
              <b>or</b> D
              <b>or</b> E
              <b>or</b> F
The <i>hex-digit</i>s A through F represent the numbers ten through fifteen, respectively; they may be represented
by their lower-case equivalents. Each digit of a <i>boz-literal-constant</i> represents a sequence of bits, according to
its numerical interpretation, using the model of 16.3, with <i>z</i> equal to one for binary constants, three for octal
constants or four for hexadecimal constants. A <i>boz-literal-constant</i> represents a sequence of bits that consists of
the concatenation of the sequences of bits represented by its digits, in the order the digits are specified. The
positions of bits in the sequence are numbered from right to left, with the position of the rightmost bit being zero.
The length of a sequence of bits is the number of bits in the sequence. The processor shall allow the position
of the leftmost nonzero bit to be at least <i>z</i>- 1, where <i>z</i> is the maximum value that could result from invoking
the intrinsic function STORAGE_SIZE (16.9.200) with an argument that is a real or integer scalar of any kind
supported by the processor.
C7119 (R772) A <i>boz-literal-constant</i> shall appear only as a <i>data-stmt-constant</i> in a DATA statement, as the
   <i>initialization</i> foranamedconstantorvariableoftypeintegerorreal, asthe <i>expr</i> inanintrinsicassignment
   whose <i>variable</i> is of type integer or real, as an <i>ac-value</i> in an array constructor with a <i>type-spec</i> that
   specifies type integer or real, as the <i>scalar-expr</i> in an enum constructor, or where explicitly allowed in
   16.9 as an actual argument of an intrinsic procedure.
<b>7.8</b> <b>Construction</b> <b>of</b> <b>array</b> <b>values</b>
An array constructor constructs a rank-one array value from a sequence of scalar values, array values, and implied
DO loops.
R777 <i>array-constructor</i> <b>is</b> (/ <i>ac-spec</i> /)
              <b>or</b> <i>lbracket</i> <i>ac-spec</i> <i>rbracket</i>
R778 <i>ac-spec</i> <b>is</b> <i>type-spec</i> ::
              <b>or</b> [<i>type-spec</i> ::] <i>ac-value-list</i>
R779 <i>lbracket</i> <b>is</b> [
R780 <i>rbracket</i> <b>is</b> ]
R781 <i>ac-value</i> <b>is</b> <i>expr</i>
              <b>or</b> <i>ac-implied-do</i>
R782 <i>ac-implied-do</i> <b>is</b> ( <i>ac-value-list</i> , <i>ac-implied-do-control</i> )
R783 <i>ac-implied-do-control</i> <b>is</b> [ <i>integer-type-spec</i> :: ] <i>ac-do-variable</i> = <i>scalar-int-expr</i> ,
                  <i>scalar-int-expr</i> [ , <i>scalar-int-expr</i> ]
R784 <i>ac-do-variable</i> <b>is</b> <i>do-variable</i>
C7120 (R778) If <i>type-spec</i> is omitted, each <i>ac-value</i> expression in the <i>array-constructor</i> shall have the same
   declared type and kind type parameters.
C7121 (R778) If <i>type-spec</i> specifies an intrinsic type or enum type, each <i>ac-value</i> expression in the <i>array-</i>
   <i>constructor</i> shall be of a type that is in type conformance with a variable of type <i>type-spec</i> as specified
   in Table 10.8, or be a <i>boz-literal-constant</i>.
C7122 (R778) If <i>type-spec</i> specifies a derived type, the declared type of each <i>ac-value</i> expression in the <i>array-</i>
   <i>constructor</i> shall be that derived type and shall have the same kind type parameter values as specified
   by <i>type-spec</i>.
C7123 (R778) If <i>type-spec</i> specifies an enumeration type, each <i>ac-value</i> shall be of that type.
C7124 (R781) An <i>ac-value</i> shall not be unlimited polymorphic.
C7125 (R781) The declared type of an <i>ac-value</i> shall not be abstract.
C7126 If an <i>ac-value</i> is a <i>boz-literal-constant</i>, <i>type-spec</i> shall appear and shall specify type integer or real.
C7127 If an <i>ac-value</i> is a <i>boz-literal-constant</i> and <i>type-spec</i> specifies type real, the <i>boz-literal-constant</i> shall be a
   valid internal representation for the specified kind of real.
C7128 (R782) The <i>ac-do-variable</i> of an <i>ac-implied-do</i> that is in another <i>ac-implied-do</i> shall not appear as the
   <i>ac-do-variable</i> of the containing <i>ac-implied-do</i>.
If <i>type-spec</i> is omitted, corresponding length type parameters of the declared type of each <i>ac-value</i> expression
shall have the same value; in this case, the declared type and type parameters of the array constructor are those
of the <i>ac-value</i> expressions.
If <i>type-spec</i> appears, it specifies the declared type and type parameters of the array constructor. Each <i>ac-value</i>
expression in the <i>array-constructor</i> shall be compatible with intrinsic assignment to a variable of this type and
type parameters. Each value is converted to the type and type parameters of the <i>array-constructor</i> in accordance
with the rules of intrinsic assignment (10.2.1.3).
The dynamic type of an array constructor is the same as its declared type.
The character length of an <i>ac-value</i> in an <i>ac-implied-do</i> whose iteration count is zero shall not depend on the
value of the <i>ac-do-variable</i> and shall not depend on the value of an expression that is not a constant expression.
If an <i>ac-value</i> is a scalar expression, its value specifies an element of the array constructor. If an <i>ac-value</i> is
an array expression, the values of the elements of the expression, in array element order (9.5.3.3), specify the
corresponding sequence of elements of the array constructor. If an <i>ac-value</i> is an <i>ac-implied-do</i>, it is expanded to
form a sequence of elements under the control of the <i>ac-do-variable</i>, as in the DO construct (11.1.7.4).
For an <i>ac-implied-do</i>, the loop initialization and execution is the same as for a DO construct. The scope and
attributes of an <i>ac-do-variable</i> are described in 19.4.
An empty sequence forms a zero-sized array.
<b>NOTE</b> <b>1</b>
A one-dimensional array can be reshaped into any allowable array shape using the intrinsic function RESHAPE
(16.9.175). An example is:
   X = (/ 3.2, 4.01, 6.5 /)
   Y = RESHAPE (SOURCE = [ 2.0, [ 4.5, 4.5 ], X ], SHAPE = [ 3, 2 ])
This results in Y having the 3x 2 array of values:
   2.0 3.2
   4.5 4.01
   4.5 6.5
<b>NOTE</b> <b>2</b>
Examples of array constructors containing an implied DO are:
   (/ (I, I = 1, 1075) /)
and
   [ 3.6, (3.6 / I, I = 1, N) ]
<b>NOTE</b> <b>3</b>
Using the type definition for PERSON in 7.5.2.1, NOTE, an example of the construction of a derived-type array
value is:
   [ PERSON (40, 'SMITH'), PERSON (20, 'JONES') ]
<b>NOTE</b> <b>4</b>
Using the type definition for LINE in 7.5.4.2, NOTE 1, an example of the construction of a derived-type scalar
value with a rank-two array component is:
   LINE (RESHAPE ( [ 0.0, 0.0, 1.0, 2.0 ], [ 2, 2 ] ), 0.1, 1)
The intrinsic function RESHAPE is used to construct a value that represents a solid line from (0, 0) to (1, 2)
of width 0.1 centimeters.
<b>NOTE</b> <b>5</b>
Examples of zero-size array constructors are:
   [ INTEGER :: ]
   [ ( I, I = 1, 0) ]
<b>NOTE</b> <b>6</b>
An example of an array constructor that specifies a length type parameter:
   [ CHARACTER(LEN=7) :: 'Takata', 'Tanaka', 'Hayashi' ]
In this constructor, without the type specification, it would have been necessary to specify all of the constants
with the same character length.
<b>8</b> <b>Attribute</b> <b>declarations</b> <b>and</b> <b>specifications</b>
<b>8.1</b> <b>Attributes</b> <b>of</b> <b>procedures</b> <b>and</b> <b>data</b> <b>objects</b>
Every data object has a type and rank and can have type parameters and other properties that determine the
uses of the object. Collectively, these properties are the attributes of the object. The declared type of a named
data object is either specified explicitly in a type declaration statement or determined implicitly by the first letter
of its name (8.7). The attributes listed in 8.5 can be specified in a type declaration statement or individually in
separate specification statements.
A function has a type and rank and can have type parameters and other attributes that determine the uses of
the function. The type, rank, and type parameters are the same as those of the function result.
A subroutine does not have a type, rank, or type parameters, but can have other attributes that determine the
uses of the subroutine.
<b>8.2</b> <b>Type</b> <b>declaration</b> <b>statement</b>
R801 <i>type-declaration-stmt</i> <b>is</b> <i>declaration-type-spec</i> [ [ , <i>attr-spec</i> ] ... :: ] <i>entity-decl-list</i>
The type declaration statement specifies the declared type of the entities in the entity declaration list. The type
and type parameters are those specified by <i>declaration-type-spec</i>, except that the character length type parameter
can be overridden for an entity by the appearance of * <i>char-length</i> in its <i>entity-decl</i>.
R802 <i>attr-spec</i> <b>is</b> <i>access-spec</i>
              <b>or</b> ALLOCATABLE
              <b>or</b> ASYNCHRONOUS
              <b>or</b> CODIMENSION <i>lbracket</i> <i>coarray-spec</i> <i>rbracket</i>
              <b>or</b> CONTIGUOUS
              <b>or</b> DIMENSION ( <i>array-spec</i> )
              <b>or</b> EXTERNAL
              <b>or</b> INTENT ( <i>intent-spec</i> )
              <b>or</b> INTRINSIC
              <b>or</b> <i>language-binding-spec</i>
              <b>or</b> OPTIONAL
              <b>or</b> PARAMETER
              <b>or</b> POINTER
              <b>or</b> PROTECTED
              <b>or</b> <i>rank-clause</i>
              <b>or</b> SAVE
              <b>or</b> TARGET
              <b>or</b> VALUE
              <b>or</b> VOLATILE
C801 (R801) The same <i>attr-spec</i> shall not appear more than once in a given <i>type-declaration-stmt</i>.
C802 (R801) If a <i>language-binding-spec</i> with a NAME= specifier appears, the <i>entity-decl-list</i> shall consist of a
   single <i>entity-decl</i>.
C803 (R801) If a <i>language-binding-spec</i> is specified, the <i>entity-decl-list</i> shall not contain any procedure names.
The type declaration statement also specifies the attributes whose keywords appear in the <i>attr-spec</i>, except that
the DIMENSION attribute can be specified or overridden for an entity by the appearance of <i>array-spec</i> in its
<i>entity-decl</i>, and the CODIMENSION attribute can be specified or overridden for an entity by the appearance of
<i>coarray-spec</i> in its <i>entity-decl</i>.
R803 <i>entity-decl</i> <b>is</b> <i>object-name</i> [ ( <i>array-spec</i> ) ]
                   [ <i>lbracket</i> <i>coarray-spec</i> <i>rbracket</i> ]
                   [ * <i>char-length</i> ] [ <i>initialization</i> ]
              <b>or</b> <i>function-name</i> [ * <i>char-length</i> ]
C804 (R803) If the entity is not of type character, * <i>char-length</i> shall not appear.
C805 A <i>type-param-value</i> in a <i>char-length</i> in an <i>entity-decl</i> shall be a colon, asterisk, or specification expression.
C806 (R801) If <i>initialization</i> appears, a double-colon separator shall appear before the <i>entity-decl-list</i>.
C807 (R801) If the PARAMETER keyword appears, <i>initialization</i> shall appear in each <i>entity-decl</i>.
C808 (R803) An <i>initialization</i> shall not appear if <i>object-name</i> is a dummy argument, a function result, an object
    in a named common block unless the type declaration is in a block data program unit, an object in blank common, an
   allocatable variable, or an automatic data object.
C809 (R803) The <i>function-name</i> shall be the name of an external function, an intrinsic function, a dummy
   function, a procedure pointer, or a statement function.
R804 <i>object-name</i> <b>is</b> <i>name</i>
C810 (R804) The <i>object-name</i> shall be the name of a data object.
R805 <i>initialization</i> <b>is</b> = <i>constant-expr</i>
              <b>or</b> =<i>></i> <i>null-init</i>
              <b>or</b> =<i>></i> <i>initial-data-target</i>
R806 <i>null-init</i> <b>is</b> <i>function-reference</i>
C811 (R803) If =<i>></i> appears in <i>initialization</i>, the entity shall have the POINTER attribute. If = appears in
   <i>initialization</i>, the entity shall not have the POINTER attribute.
C812 (R803) If <i>initial-data-target</i> appears, <i>object-name</i> shall be data-pointer-initialization compatible with it
   (7.5.4.6).
C813 (R806) The <i>function-reference</i> shall be a reference to the intrinsic function NULL with no arguments.
A name that identifies a specific intrinsic function has a type as specified in 16.8. An explicit type declaration statement is not
required; however, it is permitted. Specifying a type for a generic intrinsic function name in a type declaration
statement has no effect.
If <i>initialization</i> appears for a nonpointer entity,
 its type and type parameters shall conform as specified for intrinsic assignment (10.2.1.2);
 if the entity has implied shape, the rank of <i>initialization</i> shall be the same as the rank of the entity;
 if the entity does not have implied shape, <i>initialization</i> shall either be scalar or have the same shape as the
  entity.
<b>NOTE</b>
Examples of type declaration statements:
   REAL A (10)
   LOGICAL, DIMENSION (5, 5) :: MASK1, MASK2
   COMPLEX :: CUBE_ROOT = (-0.5, 0.866)
                <b>J3/23-007r1</b> <b>103</b>
<b>NOTE</b> <b>(cont.)</b>
   INTEGER, PARAMETER :: SHORT = SELECTED_INT_KIND (4)
   INTEGER (SHORT) K ! Range at least -9999 to 9999.
   TYPEOF (K) K_TMP ! Also has range at least -9999 to 9999.
   REAL (KIND (0.0D0)) B1
   REAL (KIND = 2) B2
   COMPLEX (KIND = KIND (0.0D0)) :: C
   CHARACTER (LEN = 10, KIND = 2) TEXT2
   CHARACTER CHAR, STRING *20
   TYPE (PERSON) :: CHAIRMAN
   TYPE(NODE), POINTER :: HEAD => NULL ( )
   TYPE (humongous_matrix (k=8, d=1000)) :: MAT
   CLASSOF (MAT), POINTER :: MAT_REF ! Same declared type and type parameters as MAT.
(The type HUMONGOUS_MATRIX is defined in 7.5.3.1, NOTE.)
<b>8.3</b> <b>Automatic</b> <b>data</b> <b>objects</b>
An automatic data object is a nondummy data object with a type parameter or array bound that depends on
the value of a <i>specification-expr</i> that is not a constant expression.
C814 An automatic data object shall not have the SAVE attribute.
If a type parameter in a <i>declaration-type-spec</i> or in a <i>char-length</i> in an <i>entity-decl</i> for a local variable of a
subprogram or BLOCK construct is defined by an expression that is not a constant expression, the type parameter
value is established on entry to a procedure defined by the subprogram, or on execution of the BLOCK statement,
and is not affected by any redefinition or undefinition of the variables in the expression during execution of the
procedure or BLOCK construct.
<b>8.4</b> <b>Initialization</b>
The appearance of <i>initialization</i> in an <i>entity-decl</i> for an entity without the PARAMETER attribute specifies that
the entity is a variable with explicit initialization. Explicit initialization alternatively may be specified in a DATA
statement unless the variable is of a derived type for which default initialization is specified. If <i>initialization</i> is
= <i>constant-expr</i>, the variable is initially defined with the value specified by the <i>constant-expr</i>; if necessary, the
value is converted according to the rules of intrinsic assignment (10.2.1.3) to a value that agrees in type, type
parameters, and shape with the variable. A variable, or part of a variable, shall not be explicitly initialized more
than once in a program. If the variable is an array, it shall have its shape specified in either the type declaration
statement or a previous attribute specification statement in the same scoping unit.
If <i>null-init</i> appears, the initial association status of the object is disassociated. If <i>initial-data-target</i> appears, the
object is initially associated with the target.
Explicit initialization of a variable that is not in a common block implies the SAVE attribute, which may be confirmed
by explicit specification.
<b>8.5</b> <b>Attributes</b>
<b>8.5.1</b> <b>Attribute</b> <b>specification</b>
An attribute may be explicitly specified by an <i>attr-spec</i> in a type declaration statement or by an attribute
specification statement (8.6). The following constraints apply to attributes.
C815 An entity shall not be explicitly given any attribute more than once in a scoping unit.
C816 An <i>array-spec</i> for a nonallocatable nonpointer function result shall be an <i>explicit-shape-spec-list</i>.
<b>8.5.2</b> <b>Accessibility</b> <b>attribute</b>
The accessibility attribute specifies the accessibility of an entity via a particular identifier.
R807 <i>access-spec</i> <b>is</b> PUBLIC
              <b>or</b> PRIVATE
C817 An <i>access-spec</i> shall appear only in the <i>specification-part</i> of a module.
An <i>access-spec</i> in a type declaration statement specifies the accessibility of the names of all the entities declared
by that statement. An <i>access-spec</i> in a <i>derived-type-stmt</i> specifies the accessibility of the derived type name. An
<i>access-spec</i> in an <i>enumeration-type-stmt</i> specifies the accessibility of the enumeration type name, and the default
accessibility of its enumerators. Accessibility can also be specified by an <i>access-stmt</i>.
An identifier that is specified in a module or is accessible in a module by use association has either the PUB-
LIC attribute or PRIVATE attribute. An identifier whose accessibility is not explicitly specified has default
accessibility (8.6.1).
The default accessibility attribute for a module is PUBLIC unless it has been changed by a PRIVATE statement.
Only an identifier that has the PUBLIC attribute in that module is available to be accessed from that module
by use association.
<b>NOTE</b> <b>1</b>
An identifier can only be accessed by use association if it has the PUBLIC attribute in the module from which
it is accessed. It can nonetheless have the PRIVATE attribute in a module in which it is accessed by use
association, and therefore not be available by use association from that module.
<b>NOTE</b> <b>2</b>
An example of an accessibility specification is:
REAL, PRIVATE :: X, Y, Z
<b>8.5.3</b> <b>ALLOCATABLE</b> <b>attribute</b>
A variable with the ALLOCATABLE attribute is a variable for which space is allocated during execution.
<b>NOTE</b>
Only variables and components can have the ALLOCATABLE attribute. The result of referencing a function
whoseresultvariablehastheALLOCATABLEattributeisavaluethatdoesnotitselfhavetheALLOCATABLE
attribute.
<b>8.5.4</b> <b>ASYNCHRONOUS</b> <b>attribute</b>
An entity with the ASYNCHRONOUS attribute is a variable, and may be subject to asynchronous input/output
or asynchronous communication.
The base object of a variable shall have the ASYNCHRONOUS attribute in a scoping unit if
 the variable is a dummy argument or appears in an executable statement or specification expression in that
  scoping unit, and
 any statement of the scoping unit is executed while the variable is a pending input/output storage sequence
  affector (12.6.2.5) or a pending communication affector (18.10.4).
Use of a variable in an asynchronous data transfer statement can imply the ASYNCHRONOUS attribute; see
12.6.2.5.
An object with the ASYNCHRONOUS attribute may be associated with an object that does not have the
ASYNCHRONOUS attribute, including by use (14.2.2) or host association (19.5.1.4). If an object that is not a
local variable of a BLOCK construct is specified to have the ASYNCHRONOUS attribute in the <i>specification-</i>
<i>part</i> of the construct, the object has the attribute within the construct even if it does not have the attribute
outside the construct. If an object has the ASYNCHRONOUS attribute, then all of its subobjects also have the
ASYNCHRONOUS attribute.
<b>NOTE</b>
The ASYNCHRONOUS attribute specifies the variables that might be associated with a pending input/output
storage sequence (the actual memory locations on which asynchronous input/output is being performed) while
the scoping unit is in execution. This information could be used by the compiler to disable certain code motion
optimizations.
<b>8.5.5</b> <b>BIND</b> <b>attribute</b> <b>for</b> <b>data</b> <b>entities</b>
The BIND attribute for a variable or common block specifies that it is capable of interoperating with a C variable
whose name has external linkage (18.9).
R808 <i>language-binding-spec</i> <b>is</b> BIND (C [ , NAME = <i>scalar-default-char-constant-expr</i> ])
C818 An entity with the BIND attribute shall be a common block, variable, type, or procedure.
C819 A variable with the BIND attribute shall be declared in the specification part of a module.
C820 A variable with the BIND attribute shall be interoperable (18.3).
C821 Each variable of a common block with the BIND attribute shall be interoperable.
If the value of the <i>scalar-default-char-constant-expr</i> after discarding leading and trailing blanks has nonzero
length, it shall be valid as an identifier on the companion processor.
<b>NOTE</b>
ISO/IEC 9899:2018 provides a facility for creating C identifiers whose characters are not restricted to the C
basic character set. Such a C identifier is referred to as a universal character name (ISO/IEC 9899:2018, 6.4.3).
The name of such a C identifier might include characters that are not part of the representation method used
by the processor for default character. If so, the C entity cannot be referenced from Fortran.
The BIND attribute for a common block implies the SAVE attribute, which may be confirmed by explicit specification.
<b>8.5.6</b> <b>CODIMENSION</b> <b>attribute</b>
<b>8.5.6.1</b> <b>General</b>
The CODIMENSION attribute specifies that an entity is a coarray. The <i>coarray-spec</i> specifies its corank or
corank and cobounds.
R809 <i>coarray-spec</i> <b>is</b> <i>deferred-coshape-spec-list</i>
              <b>or</b> <i>explicit-coshape-spec</i>
C822 The sum of the rank and corank of an entity shall not exceed fifteen.
C823 A coarray shall be a component or a variable that is not a function result.
C824 A coarray shall not be of type C_PTR or C_FUNPTR from the intrinsic module ISO_C_BINDING
   (18.3.2), or of type TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV (16.10.2.34).
C825 An entity whose type has a coarray potential subobject component shall not be a pointer, shall not be a
   coarray, and shall not be a function result.
C826 A coarray or an object with a coarray potential subobject component shall be an associate name or a
   dummy argument, or have the ALLOCATABLE or SAVE attribute.
<b>NOTE</b> <b>1</b>
A coarray is permitted to be of a derived type with pointer or allocatable components. The target of such a
pointer component is always on the same image as the pointer.
<b>NOTE</b> <b>2</b>
This requirement for the SAVE attribute has the effect that automatic coarrays are not permitted; for example,
the coarray WORK in the following code fragment is not valid.
   SUBROUTINE SOLVE3(N,A,B)
   INTEGER :: N
   REAL :: A(N)[*], B(N)
   REAL :: WORK(N)[*] ! Not permitted
If this were permitted, it would require an implicit synchronization on entry to the procedure.
Explicit-shape coarrays that are declared in a subprogram and are not dummy arguments are required to have
the SAVE attribute because otherwise they might be implemented as if they were automatic coarrays.
<b>NOTE</b> <b>3</b>
Examples of CODIMENSION attribute specifications are:
   REAL W(100,100)[0:2,*] ! Explicit-shape coarray
   REAL, CODIMENSION[*] :: X ! Scalar coarray
   REAL, CODIMENSION[3,*] :: Y(:) ! Assumed-shape coarray
   REAL, CODIMENSION[:],ALLOCATABLE :: Z(:,:) ! Allocatable coarray
<b>8.5.6.2</b> <b>Allocatable</b> <b>coarray</b>
A coarray with the ALLOCATABLE attribute has a specified corank, but its cobounds are determined by
allocation or argument association.
R810 <i>deferred-coshape-spec</i> <b>is</b> :
C827 A coarray with the ALLOCATABLE attribute shall have a <i>coarray-spec</i> that is a <i>deferred-coshape-spec-</i>
   <i>list</i>.
The corank of an allocatable coarray is equal to the number of colons in its <i>deferred-coshape-spec-list</i>.
The cobounds of an unallocated allocatable coarray are undefined. No part of such a coarray shall be referenced
or defined; however, the coarray may appear as an argument to an intrinsic inquiry function as specified in 16.1.
The cobounds of an allocated allocatable coarray are those specified when the coarray is allocated.
The cobounds of an allocatable coarray are unaffected by any subsequent redefinition or undefinition of the
variables on which the cobounds' expressions depend.
<b>8.5.6.3</b> <b>Explicit-coshape</b> <b>coarray</b>
An explicit-coshape coarray is a named coarray that has its corank and cobounds declared by an <i>explicit-coshape-</i>
<i>spec</i>.
R811 <i>explicit-coshape-spec</i> <b>is</b> [ [ <i>lower-cobound</i> : ] <i>upper-cobound</i>, ]...
                   [ <i>lower-cobound</i> : ] *
C828 A nonallocatable coarray shall have a <i>coarray-spec</i> that is an <i>explicit-coshape-spec</i>.
The corank is equal to one plus the number of <i>upper-cobound</i>s.
R812 <i>lower-cobound</i> <b>is</b> <i>specification-expr</i>
R813 <i>upper-cobound</i> <b>is</b> <i>specification-expr</i>
C829 (R811) A <i>lower-cobound</i> or <i>upper-cobound</i> that is not a constant expression shall appear only in a sub-
   program, BLOCK construct, or interface body.
If an explicit-coshape coarray is a local variable of a subprogram or BLOCK construct and has cobounds that are
not constant expressions, the cobounds are determined on entry to a procedure defined by the subprogram, or
on execution of the BLOCK statement, by evaluating the cobounds expressions. The cobounds of such a coarray
are unaffected by the redefinition or undefinition of any variable during execution of the procedure or BLOCK
construct.
The values of each <i>lower-cobound</i> and <i>upper-cobound</i> determine the cobounds of the coarray along a particular
codimension. The cosubscript range of the coarray in that codimension is the set of integer values between and
including the lower and upper cobounds. If the lower cobound is omitted, the default value is 1. The upper
cobound shall not be less than the lower cobound.
<b>8.5.7</b> <b>CONTIGUOUS</b> <b>attribute</b>
C830 An entity with the CONTIGUOUS attribute shall be an array pointer, an assumed-shape array, or an
   assumed-rank dummy data object.
The CONTIGUOUS attribute specifies that an assumed-shape array is contiguous, that an array pointer can
only be pointer associated with a contiguous target, or that an assumed-rank dummy data object is contiguous.
An object is contiguous if it is
  (1) an object with the CONTIGUOUS attribute,
  (2) a nonpointer whole array that is not assumed-shape,
  (3) an assumed-shape array that is argument associated with an array that is contiguous,
  (4) an assumed-rank dummy data object whose effective argument is contiguous,
  (5) an array allocated by an ALLOCATE statement,
  (6) a pointer associated with a contiguous target, or
  (7) a nonzero-sized array section (9.5.3) provided that
     (a) its base object is contiguous,
     (b) it does not have a vector subscript,
     (c) the array element ordering of the elements of the section is the same as the array element
        ordering of those elements of the base object,
     (d) in the array element ordering of the base object, every element of the base object that is not
        an element of the section either precedes every element of the section or follows every element
        of the section,
     (e) if the array is of type character and a <i>substring-range</i> appears, the <i>substring-range</i> specifies all
        of the characters of the <i>parent-string</i> (9.4.1),
     (f) only its final <i>part-ref</i> has nonzero rank, and
     (g) it is not the real or imaginary part (9.4.4) of an array of type complex.
An object is not contiguous if it is an array subobject, and
 the object has two or more elements,
 the elements of the object in array element order are not consecutive in the elements of the base object,
 the object is not of type character with length zero, and
 the object is not of a derived type that has no ultimate components other than zero-sized arrays and
  characters with length zero.
It is processor dependent whether any other object is contiguous.
<b>NOTE</b> <b>1</b>
If a derived type has only one component that is not zero-sized, it is processor dependent whether a structure
component of a contiguous array of that type is contiguous. That is, the derived type might contain padding
on some processors.
<b>NOTE</b> <b>2</b>
The CONTIGUOUS attribute makes it easier for a processor to enable optimizations that depend on the
memory layout of the object occupying a contiguous block of memory. Examples of CONTIGUOUS attribute
specifications are:
   REAL, POINTER, CONTIGUOUS :: SPTR(:)
   REAL, CONTIGUOUS, DIMENSION(:,:) :: D
<b>NOTE</b> <b>3</b>
If an assumed-shape or assumed-rank dummy argument has the CONTIGUOUS attribute, there is no require-
ment for the actual argument to be contiguous. This is the same as for dummy arguments that have explicit
shape or assumed size. The dummy argument will be contiguous even when the actual argument is not.
<b>8.5.8</b> <b>DIMENSION</b> <b>attribute</b>
<b>8.5.8.1</b> <b>General</b>
The DIMENSION attribute specifies that an entity is scalar, assumed-rank, or an array. An assumed-rank
dummy data object has the rank, shape, and size of its effective argument; otherwise, the rank or rank and shape
is specified by its RANK clause or its <i>array-spec</i>.
R814 <i>array-spec</i> <b>is</b> <i>explicit-shape-spec-list</i>
              <b>or</b> <i>explicit-shape-bounds-spec</i>
              <b>or</b> <i>assumed-shape-spec-list</i>
              <b>or</b> <i>assumed-shape-bounds-spec</i>
              <b>or</b> <i>deferred-shape-spec-list</i>
              <b>or</b> <i>assumed-size-spec</i>
              <b>or</b> <i>implied-shape-spec</i>
              <b>or</b> <i>implied-shape-or-assumed-size-spec</i>
              <b>or</b> <i>assumed-rank-spec</i>
<b>NOTE</b> <b>1</b>
The maximum rank of an entity is fifteen minus the corank.
<b>NOTE</b> <b>2</b>
Examples of DIMENSION attribute specifications are:
   SUBROUTINE EX (N, A, B)
     REAL, DIMENSION (N, 10) :: W ! Automatic explicit-shape array
     REAL, DIMENSION (SHAPE (W)) :: X ! Array with the same shape as W
     REAL, DIMENSION ([1, 2, 3] : 10) :: Y ! Same as DIMENSION (1:10, 2:10, 3:10)
     REAL, DIMENSION (LBARRAY:UBARRAY) :: Z ! Upper/lower bounds provided by arrays
     REAL :: ZZ (LBARRAY+2:UBARRAY+2) ! Upper/lower bounds provided by arrays
     REAL A (:), B (0:) ! Assumed-shape arrays
     REAL C (LBARRAY:) ! Specified lower bounds, assumed shape
     REAL, POINTER :: D (:, :) ! Array pointer
     REAL, DIMENSION (:), POINTER :: P ! Array pointer
                <b>J3/23-007r1</b> <b>109</b>
<b>NOTE</b> <b>2</b> <b>(cont.)</b>
     REAL, ALLOCATABLE, DIMENSION (:) :: E ! Allocatable array
     REAL, PARAMETER :: V(0:*) = [0.1, 1.1] ! Implied-shape array
<b>8.5.8.2</b> <b>Explicit-shape</b> <b>array</b>
R815 <i>explicit-shape-spec</i> <b>is</b> [ <i>lower-bound</i> : ] <i>upper-bound</i>
R816 <i>lower-bound</i> <b>is</b> <i>specification-expr</i>
R817 <i>upper-bound</i> <b>is</b> <i>specification-expr</i>
R818 <i>explicit-shape-bounds-spec</i> <b>is</b> [ <i>explicit-bounds-expr</i> : ] <i>explicit-bounds-expr</i>
              <b>or</b> <i>lower-bound</i> : <i>explicit-bounds-expr</i>
              <b>or</b> <i>explicit-bounds-expr</i> : <i>upper-bound</i>
R819 <i>explicit-bounds-expr</i> <b>is</b> <i>int-expr</i>
C831 An <i>explicit-shape-spec</i> or <i>explicit-shape-bounds-spec</i> whose bounds are not constant expressions shall
   appear only in a subprogram, derived type definition, BLOCK construct, or interface body.
C832 If an <i>explicit-shape-bounds-spec</i> has two <i>explicit-bounds-expr</i>s, they shall have the same size.
C833 An <i>explicit-bounds-expr</i> shall be a restricted expression that is a rank one integer array with constant
   size.
The rank of an entity declared with an <i>explicit-shape-spec-list</i> is equal to the number of <i>explicit-shape-spec</i>s; the
rankofanentitydeclaredwithan <i>explicit-shape-bounds-spec</i> isequaltothesizeofoneofthe <i>explicit-bounds-expr</i>s.
If the rank of such an entity is nonzero, the entity is an explicit-shape array; otherwise, it is scalar.
The values of each <i>lower-bound</i> and <i>upper-bound</i> in an <i>explicit-shape-spec</i> determine the bounds along a particular
dimension and hence the extent in that dimension. If <i>lower-bound</i> is omitted, the lower bound is equal to one.
An <i>explicit-bounds-expr</i> that appears immediately before a colon specifies the lower bounds; otherwise, it specifies
the upper bounds. The first element specifies the bound for the first dimension, and so on. A <i>lower-bound</i> or
<i>upper-bound</i> in an <i>explicit-shape-bounds-spec</i> specifies the bound for every dimension of the entity. If no lower
bound is specified in an <i>explicit-shape-bounds-spec</i>, all the lower bounds are equal to one.
The value of a lower bound or an upper bound may be positive, negative, or zero. The subscript range of the
array in that dimension is the set of integer values between and including the lower and upper bounds, provided
the upper bound is not less than the lower bound. If the upper bound is less than the lower bound, the range is
empty, the extent in that dimension is zero, and the array is of zero size.
An explicit-shape array that is a named local variable of a subprogram or BLOCK construct may have bounds
that are not constant expressions. The bounds, and hence shape, are determined on entry to a procedure defined
by the subprogram, or on execution of the BLOCK statement, by evaluating the bounds' expressions. The
bounds of such an array are unaffected by the redefinition or undefinition of any variable during execution of the
procedure or BLOCK construct.
<b>8.5.8.3</b> <b>Assumed-shape</b> <b>array</b>
An assumed-shape array is a nonallocatable nonpointer dummy argument array that takes its shape from its
effective argument.
R820 <i>assumed-shape-spec</i> <b>is</b> [ <i>lower-bound</i> ] :
R821 <i>assumed-shape-bounds-spec</i> <b>is</b> <i>explicit-bounds-expr</i> :
If the rank is not specified by a <i>rank-clause</i>, it is equal to the number of colons in the <i>assumed-shape-spec-list</i>,
or the size of the <i>explicit-bounds-expr</i> in the <i>assumed-shape-bounds-spec</i>. If the rank is nonzero, the entity is an
assumed-shape array; otherwise, it is scalar.
If<i>explicit-bounds-expr</i> appearsitspecifiesthelowerboundsforeverydimension; otherwise, if <i>lower-bound</i> appears
it specifies the lower bound for that dimension; otherwise the lower bound is equal to one.
The extent of a dimension of an assumed-shape array dummy argument is the extent of the corresponding
dimension of its effective argument. If the lower bound value is <i>d</i> and the extent of the corresponding dimension
of its effective argument is <i>s</i>, then the value of the upper bound is <i>s</i> +<i>d</i>- 1.
<b>8.5.8.4</b> <b>Deferred-shape</b> <b>array</b>
A deferred-shape array is an allocatable array or an array pointer. (An allocatable array has the ALLOCATABLE
attribute; an array pointer has the POINTER attribute.)
R822 <i>deferred-shape-spec</i> <b>is</b> :
C834 An array with the POINTER or ALLOCATABLE attribute shall be declared with a <i>rank-clause</i> or have
   an <i>array-spec</i> that is a <i>deferred-shape-spec-list</i>.
If the rank is not specified by a <i>rank-clause</i>, it is equal to the number of colons in the <i>deferred-shape-spec-list</i>.
The size, bounds, and shape of an unallocated allocatable array or a disassociated array pointer are undefined.
No part of such an array shall be referenced or defined; however, the array may appear as an argument to an
intrinsic inquiry function as specified in 16.1.
The bounds of each dimension of an allocated allocatable array are those specified when the array is allocated
or, if it is a dummy argument, when it is argument associated with an allocated effective argument.
The bounds of each dimension of an associated array pointer, and hence its shape, may be specified
 in an ALLOCATE statement (9.7.1) when the target is allocated,
 by pointer assignment (10.2.2), or
 if it is a dummy argument, by argument association with a nonpointer actual argument or an associated
  pointer effective argument.
The bounds of an array pointer or allocatable array are unaffected by any subsequent redefinition or undefinition
of variables on which the bounds' expressions depend.
<b>8.5.8.5</b> <b>Assumed-size</b> <b>array</b>
An assumed-size array is a dummy argument array whose size is assumed from that of its effective argument, or
the associate name of a RANK ( * ) block in a SELECT RANK construct. The rank and extents may differ for
the effective and dummy arguments; only the size of the effective argument is assumed by the dummy argument.
A dummy argument is declared to be an assumed-size array by an <i>assumed-size-spec</i> or an <i>implied-shape-or-</i>
<i>assumed-size-spec</i>.
R823 <i>assumed-implied-spec</i> <b>is</b> [ <i>lower-bound</i> : ] *
R824 <i>assumed-size-spec</i> <b>is</b> <i>explicit-shape-spec-list</i>, <i>assumed-implied-spec</i>
C835 An object whose array bounds are specified by an <i>assumed-size-spec</i> shall be a dummy data object.
C836 An assumed-size array with the INTENT (OUT) attribute shall not be polymorphic, finalizable, of a
   type with an allocatable ultimate component, or of a type for which default initialization is specified.
R825 <i>implied-shape-or-assumed-size-spec</i> <b>is</b> <i>assumed-implied-spec</i>
C837 An object whose array bounds are specified by an <i>implied-shape-or-assumed-size-spec</i> shall be a dummy
   data object or a named constant.
The size of an assumed-size array is determined as follows.
 If the effective argument associated with the assumed-size dummy array is an array of any type other than
  default character, the size is that of the effective argument.
 If the actual argument corresponding to the assumed-size dummy array is an array element of any type
  other than default character with a subscript order value of <i>r</i> (9.5.3.3) in an array of size <i>x</i>, the size of the
  dummy array is <i>x</i>-<i>r</i> + 1.
 If the actual argument is a default character array, default character array element, or a default character
  array element substring (9.4.1), and if it begins at character storage unit <i>t</i> of an array with <i>c</i> character
  storage units, the size of the dummy array is MAX (INT ((<i>c</i>-<i>t</i> + 1)<i>/e</i>), 0), where <i>e</i> is the length of an
  element in the dummy character array.
 If the actual argument is a default character scalar that is not an array element or array element substring
  designator, the size of the dummy array is MAX (INT (<i>l/e</i>), 0), where <i>e</i> is the length of an element in the
  dummy character array and <i>l</i> is the length of the actual argument.
The rank is equal to one plus the number of <i>explicit-shape-spec</i>s.
An assumed-size array has no upper bound in its last dimension and therefore has no extent in its last dimension
and no shape. An assumed-size array shall not appear in a context that requires its shape.
If a list of <i>explicit-shape-spec</i>s appears, it specifies the bounds of the first rank-1 dimensions. If <i>lower-bound</i>
appears it specifies the lower bound of the last dimension; otherwise that lower bound is 1. An assumed-size
array can be subscripted or sectioned (9.5.3).
If an assumed-size array has bounds that are not constant expressions, the bounds are determined on entry to
the procedure. The bounds of such an array are unaffected by the redefinition or undefinition of any variable
during execution of the procedure.
<b>8.5.8.6</b> <b>Implied-shape</b> <b>array</b>
An implied-shape array is a named constant that takes its shape from the <i>constant-expr</i> in its declaration. A
named constant is declared to be an implied-shape array with an <i>array-spec</i> that is an <i>implied-shape-or-assumed-</i>
<i>size-spec</i> or an <i>implied-shape-spec</i>.
R826 <i>implied-shape-spec</i> <b>is</b> <i>assumed-implied-spec</i>, <i>assumed-implied-spec-list</i>
C838 An implied-shape array shall be a named constant.
The rank of an implied-shape array is the number of <i>assumed-implied-spec</i>s in its <i>array-spec</i>.
The extent of each dimension of an implied-shape array is the same as the extent of the corresponding dimension
of the <i>constant-expr</i>. The lower bound of each dimension is <i>lower-bound</i>, if it appears, and 1 otherwise; the upper
bound is one less than the sum of the lower bound and the extent.
<b>8.5.8.7</b> <b>Assumed-rank</b> <b>entity</b>
An assumed-rank entity is a dummy data object whose rank is assumed from its effective argument, or the
associate name of a RANK DEFAULT block in a SELECT RANK construct; this rank can be zero. The bounds
andshapeofanassumed-rankentitywiththeALLOCATABLEorPOINTERattributearedeterminedasspecified
in 8.5.8.4. An assumed-rank entity is declared with an <i>array-spec</i> that is an <i>assumed-rank-spec</i>.
R827 <i>assumed-rank-spec</i> <b>is</b> ..
C839 An assumed-rank entity shall be an associate name or a dummy data object that does not have the
   CODIMENSION or VALUE attribute.
C840 An assumed-rank variable name shall not appear in a designator or expression except as an actual
   argument that corresponds to a dummy argument that is assumed-rank, the argument of the function
   C_LOC or C_SIZEOF from the intrinsic module ISO_C_BINDING (18.2), the first dummy argument
   of an intrinsic inquiry function, or the selector of a SELECT RANK statement.
C841 If an assumed-size or nonallocatable nonpointer assumed-rank array is an actual argument that corres-
   ponds to a dummy argument that is an INTENT (OUT) assumed-rank array, it shall not be polymorphic,
   finalizable, of a type with an allocatable ultimate component, or of a type for which default initialization
   is specified.
<b>8.5.9</b> <b>EXTERNAL</b> <b>attribute</b>
TheEXTERNALattributespecifiesthatanentityisanexternalprocedure, dummyprocedure, procedurepointer,
or block data program unit.
C842 An entity shall not have both the EXTERNAL attribute and the INTRINSIC attribute.
C843 In an external subprogram, the EXTERNAL attribute shall not be specified for a procedure defined by
   the subprogram.
C844 In an interface body, the EXTERNAL attribute shall not be specified for the procedure declared by the
   interface body.
If an external procedure or dummy procedure is used as an actual argument or is the target of a procedure pointer
assignment, it shall be declared to have the EXTERNAL attribute.
<b>NOTE</b>
The EXTERNAL attribute can be specified in a type declaration statement, by an interface body (15.4.3.2),
by an EXTERNAL statement (15.4.3.5), or by a procedure declaration statement (15.4.3.6).
<b>8.5.10</b> <b>INTENT</b> <b>attribute</b>
The INTENT attribute specifies the intended use of a dummy argument. An INTENT (IN) dummy argument
is suitable for receiving data from the invoking scoping unit, an INTENT (OUT) dummy argument is suitable
for returning data to the invoking scoping unit, and an INTENT (INOUT) dummy argument is suitable for use
both to receive data from and to return data to the invoking scoping unit.
R828 <i>intent-spec</i> <b>is</b> IN
              <b>or</b> OUT
              <b>or</b> INOUT
C845 An entity with the INTENT attribute shall be a dummy data object or a dummy procedure pointer.
C846 (R828) A nonpointer object with the INTENT (IN) attribute shall not appear in a variable definition
   context (19.6.7).
C847 A pointer with the INTENT (IN) attribute shall not appear in a pointer association context (19.6.8).
C848 An INTENT (OUT) dummy argument of a nonintrinsic procedure shall not be an allocatable coarray or
   have a subobject that is an allocatable coarray.
C849 An entity with the INTENT (OUT) attribute shall not be of, or have a subcomponent of, type EVENT_-
   TYPE (16.10.2.10), LOCK_TYPE (16.10.2.19), or NOTIFY_TYPE (16.10.2.22) from the intrinsic mod-
   ule ISO_FORTRAN_ENV.
The INTENT (IN) attribute for a nonpointer dummy argument specifies that it shall neither be defined nor
become undefined during the invocation and execution of the procedure. The INTENT (IN) attribute for a
pointer dummy argument specifies that during the invocation and execution of the procedure its association shall
not be changed except that it may become undefined if the target is deallocated other than through the pointer
(19.5.2.5).
The INTENT (OUT) attribute for a nonpointer dummy argument specifies that the dummy argument becomes
undefined on invocation of the procedure, except for any subcomponents that are default-initialized (7.5.4.6). Any
actual argument that corresponds to such a dummy argument shall be definable. The INTENT (OUT) attribute
for a pointer dummy argument specifies that on invocation of the procedure the pointer association status of
the dummy argument becomes undefined. Any actual argument that corresponds to such a dummy pointer shall
be a pointer variable or a procedure pointer that is not the result of a function reference. Any undefinition or
definition implied by association of an actual argument with an INTENT (OUT) dummy argument shall not
affect any other entity within the statement that invokes the procedure.
The INTENT (INOUT) attribute for a nonpointer dummy argument specifies that any actual argument that
corresponds to the dummy argument shall be definable. The INTENT (INOUT) attribute for a pointer dummy
argument specifies that any actual argument that corresponds to the dummy argument shall be a pointer variable
or a procedure pointer that is not the result of a function reference.
<b>NOTE</b> <b>1</b>
The INTENT attribute for an allocatable dummy argument applies to both the allocation status and the
definition status. An actual argument that corresponds to an INTENT (OUT) allocatable dummy argument is
deallocated on procedure invocation (9.7.3.2). To avoid this deallocation for coarrays, INTENT (OUT) is not
allowed for a dummy argument that is an allocatable coarray or has a subobject that is an allocatable coarray.
If no INTENT attribute is specified for a dummy argument, its use is subject to the limitations of its effective
argument (15.5.2).
If a nonpointer object has an INTENT attribute, then all of its subobjects have the same INTENT attribute.
<b>NOTE</b> <b>2</b>
An example of INTENT specification is:
   SUBROUTINE MOVE (FROM, TO)
     TYPE (PERSON), INTENT (IN) :: FROM
     TYPE (PERSON), INTENT (OUT) :: TO
<b>NOTE</b> <b>3</b>
If a dummy argument is a nonpointer derived-type object with a pointer component, then the pointer as a
pointer is a subobject of the dummy argument, but the target of the pointer is not. Therefore, the restrictions
on subobjects of the dummy argument apply to the pointer in contexts where it is used as a pointer, but not in
contexts where it is dereferenced to indicate its target. For example, if X is a nonpointer dummy argument of
derived type with an integer pointer component P, and X is INTENT (IN), then the statement
   X%P => NEW_TARGET
is prohibited, but
   X%P = 0
is allowed (provided that X%P is associated with a definable target).
Similarly, the INTENT restrictions on pointer dummy arguments apply only to the association of the dummy
argument; they do not restrict the operations allowed on its target.
<b>NOTE</b> <b>4</b>
Argument intent specifications serve several purposes in addition to documenting the intended use of dummy
arguments. A processor can check whether an INTENT (IN) dummy argument is used in a way that could
<b>114</b> <b>J3/23-007r1</b>
<b>NOTE</b> <b>4</b> <b>(cont.)</b>
redefine it. A slightly more sophisticated processor could check to see whether an INTENT (OUT) dummy
argument could possibly be referenced before it is defined. If the procedure's interface is explicit, the processor
can also verify that actual arguments corresponding to INTENT (OUT) or INTENT (INOUT) dummy argu-
ments are definable. A more sophisticated processor could use this information to optimize the translation of
the referencing scoping unit by taking advantage of the fact that actual arguments corresponding to INTENT
(IN) dummy arguments will not be changed and that any prior value of an actual argument corresponding to
an INTENT (OUT) dummy argument will not be referenced and could thus be discarded.
INTENT (OUT) means that the value of the argument after invoking the procedure is entirely the result of
executing that procedure. If an argument might not be redefined and it is desired to have the argument retain its
value in that case, INTENT (OUT) cannot be used because it would cause the argument to become undefined;
however, INTENT (INOUT) can be used, even if there is no explicit reference to the value of the dummy
argument.
INTENT (INOUT) is not equivalent to omitting the INTENT attribute. The actual argument corresponding
to an INTENT (INOUT) dummy argument is always required to be definable, while an actual argument
corresponding to a dummy argument without an INTENT attribute need be definable only if the dummy
argument is actually redefined.
<b>8.5.11</b> <b>INTRINSIC</b> <b>attribute</b>
The INTRINSIC attribute specifies that the entity is an intrinsic procedure. The procedure name may be a
generic name (16.7), a specific name (16.8), or both.
If the specific name of an intrinsic procedure (16.8) is used as an actual argument, the name shall be explicitly specified to have the
INTRINSIC attribute. Note that a specific intrinsic procedure listed in Table 16.3 is not permitted to be used as an actual argument
(C1534).
C850 If the generic name of an intrinsic procedure is explicitly declared to have the INTRINSIC attribute,
   and it is also the generic name of one or more generic interfaces (15.4.3.2) accessible in the same scoping
   unit, the procedures in the interfaces and the generic intrinsic procedure shall all be functions or all be
   subroutines.
<b>8.5.12</b> <b>OPTIONAL</b> <b>attribute</b>
The OPTIONAL attribute specifies that the dummy argument need not have an effective argument in a reference
to the procedure (15.5.2.13).
C851 An entity with the OPTIONAL attribute shall be a dummy argument.
<b>NOTE</b>
The intrinsic function PRESENT (16.9.163) can be used to determine whether an optional dummy argument
has an associated effective argument.
<b>8.5.13</b> <b>PARAMETER</b> <b>attribute</b>
The PARAMETER attribute specifies that an entity is a named constant. The entity has the value specified by
its <i>constant-expr</i>, converted, if necessary, to the type, type parameters and shape of the entity.
C852 An entity with the PARAMETER attribute shall not be a variable, a coarray, or a procedure.
C853 An expression that specifies a length type parameter or array bound of a named constant shall be a
   constant expression.
A named constant shall not be referenced unless it has been defined previously; it may be defined previously in
the same statement.
<b>NOTE</b>
Examples of declarations with a PARAMETER attribute are:
   REAL, PARAMETER :: ONE = 1.0, Y = 4.1 / 3.0
   INTEGER, DIMENSION (3), PARAMETER :: ORDER = (/ 1, 2, 3 /)
   TYPE(NODE), PARAMETER :: DEFAULT = NODE(0, NULL ( ))
<b>8.5.14</b> <b>POINTER</b> <b>attribute</b>
EntitieswiththePOINTERattributecanbeassociatedwithdifferentdataobjectsorproceduresduringexecution
of a program. A pointer is either a data pointer or a procedure pointer.
C854 An entity with the POINTER attribute shall not have the ALLOCATABLE, INTRINSIC, or TARGET
   attribute, and shall not be a coarray.
C855 A named procedure with the POINTER attribute shall have the EXTERNAL attribute.
A data pointer shall not be referenced unless it is pointer associated with a target object that is defined. A data
pointer shall not be defined unless it is pointer associated with a target object that is definable.
If a data pointer is associated, the values of its deferred type parameters are the same as the values of the
corresponding type parameters of its target.
A procedure pointer shall not be referenced unless it is pointer associated with a target procedure.
<b>NOTE</b>
Examples of POINTER attribute specifications are:
   TYPE (NODE), POINTER :: CURRENT, TAIL
   REAL, DIMENSION (:, :), POINTER :: IN, OUT, SWAP
<b>8.5.15</b> <b>PROTECTED</b> <b>attribute</b>
The PROTECTED attribute imposes limitations on the usage of module entities.
C856 The PROTECTED attribute shall be specified only in the specification part of a module.
C857 An entity with the PROTECTED attribute shall be a procedure pointer or variable.
C858 An entity with the PROTECTED attribute shall not be in a common block.
C859 A nonpointer object that has the PROTECTED attribute and is accessed by use association shall not
   appear in a variable definition context (19.6.7) or as a <i>data-target</i> or <i>initial-data-target</i>.
C860 A pointer that has the PROTECTED attribute and is accessed by use association shall not appear in a
   pointer association context (19.6.8).
Other than within the module in which an entity is given the PROTECTED attribute, or within any of its
descendants,
 if it is a nonpointer object, it is not definable, and
 if it is a pointer, its association status shall not be changed except that it may become undefined if its target
  is deallocated other than through the pointer (19.5.2.5), or if its target becomes undefined by completing
  execution of a BLOCK construct or by execution of a RETURN or END statement.
If an object has the PROTECTED attribute, all of its subobjects have the PROTECTED attribute.
<b>NOTE</b>
An example of the PROTECTED attribute:
   MODULE temperature
    REAL, PROTECTED :: temp_c, temp_f
   CONTAINS
    SUBROUTINE set_temperature_c(c)
     REAL, INTENT(IN) :: c
     temp_c = c
     temp_f = temp_c*(9.0/5.0) + 32
    END SUBROUTINE
   END MODULE
The PROTECTED attribute ensures that the variables temp_c and temp_f cannot be modified other than via
the set_temperature_c procedure, thus keeping them consistent with each other.
<b>8.5.16</b> <b>SAVE</b> <b>attribute</b>
The SAVE attribute specifies that a local variable of a program unit or subprogram retains its association status,
allocation status, definition status, and value after execution of a RETURN or END statement unless it is a
pointer and its target becomes undefined (19.5.2.5(6)). If it is a local variable of a subprogram it is shared by all
instances (15.6.2.4) of the subprogram.
The SAVE attribute specifies that a local variable of a BLOCK construct retains its association status, allocation
status, definition status, and value after termination of the construct unless it is a pointer and its target becomes
undefined (19.5.2.5(7)). If the BLOCK construct is within a subprogram the variable is shared by all instances
(15.6.2.4) of the subprogram.
Giving a common block the SAVE attribute confers the attribute on all entities in the common block.
C861 An entity with the SAVE attribute shall be a common block, variable, or procedure pointer.
C862 The SAVE attribute shall not be specified for a dummy argument, a function result, an automatic data
   object, or an object that is in a common block.
A variable, common block, or procedure pointer declared in the scoping unit of a main program, module, or
submodule implicitly has the SAVE attribute, which may be confirmed by explicit specification. If a common block
has the SAVE attribute in any other kind of scoping unit, it shall have the SAVE attribute in every scoping unit that is not of a
main program, module, or submodule.
<b>8.5.17</b> <b>RANK</b> <b>clause</b>
The RANK clause specifies the DIMENSION attribute.
R829 <i>rank-clause</i> <b>is</b> RANK ( <i>scalar-int-constant-expr</i> )
C863 The <i>scalar-int-constant-expr</i> in a <i>rank-clause</i> shall be nonnegative with a value less than or equal to the
   maximum array rank supported by the processor.
C864 An entity declared with a <i>rank-clause</i> shall be a dummy data object or have the ALLOCATABLE or
   POINTER attribute.
An entity declared with a RANK clause has the specified rank. If the rank is zero the entity is scalar; otherwise,
if it has the ALLOCATABLE or POINTER attribute, it specifies that it is a deferred-shape array; otherwise, it
specifies that it is an assumed-shape array with all the lower bounds equal to one.
<b>NOTE</b>
Examples of RANK specifications are:
   INTEGER :: X0(10,10,10)
   LOGICAL, RANK(RANK(X0)), ALLOCATABLE :: X1 ! Rank 3, deferred shape
   COMPLEX, RANK(2), POINTER :: X2 ! Rank 2, deferred-shape
   LOGICAL, RANK(RANK(X0)) :: X3 ! Rank 3, assumed-shape
   REAL, RANK(0) :: X4 ! Scalar
<b>8.5.18</b> <b>TARGET</b> <b>attribute</b>
The TARGET attribute specifies that a data object may have a pointer associated with it (10.2.2). An object
without the TARGET attribute shall not have a pointer associated with it.
C865 An entity with the TARGET attribute shall be a variable.
C866 An entity with the TARGET attribute shall not have the POINTER attribute.
If an object has the TARGET attribute, then all of its nonpointer subobjects also have the TARGET attribute.
<b>NOTE</b> <b>1</b>
In addition to variables explicitly declared to have the TARGET attribute, the objects created by allocation of
pointers (9.7.1.4) have the TARGET attribute.
<b>NOTE</b> <b>2</b>
Examples of TARGET attribute specifications are:
   TYPE (NODE), TARGET :: HEAD
   REAL, DIMENSION (1000, 1000), TARGET :: A, B
<b>NOTE</b> <b>3</b>
Every object designator that starts from an object with the TARGET attribute will have either the TARGET
or POINTER attribute. If pointers are involved, the designator might not necessarily be a subobject of the
original object, but because a pointer can point only to an entity with the TARGET attribute, there is no way
to end up at a nonpointer that does not have the TARGET attribute.
<b>8.5.19</b> <b>VALUE</b> <b>attribute</b>
The VALUE attribute specifies a type of argument association (15.5.2.5) for a dummy argument.
C867 An entity with the VALUE attribute shall be a dummy data object. It shall not be an assumed-size
   array, a coarray, or a variable with a coarray potential subobject component.
C868 An entity with the VALUE attribute shall not have the ALLOCATABLE, INTENT (INOUT), INTENT
   (OUT), POINTER, or VOLATILE attributes.
C869 A dummy argument of a procedure with the BIND attribute shall not have both the OPTIONAL and
   VALUE attributes.
<b>8.5.20</b> <b>VOLATILE</b> <b>attribute</b>
The VOLATILE attribute specifies that an object may be referenced, defined, or become undefined, by means
not specified by the program. A pointer with the VOLATILE attribute may additionally have its association
status, dynamic type and type parameters, and array bounds changed by means not specified by the program.
An allocatable object with the VOLATILE attribute may additionally have its allocation status, dynamic type
and type parameters, and array bounds changed by means not specified by the program.
C870 An entity with the VOLATILE attribute shall be a variable that is not an INTENT (IN) dummy argu-
   ment.
C871 The VOLATILE attribute shall not be specified for a coarray, or a variable with a coarray potential
   subobject component, that is accessed by use (14.2.2) or host (19.5.1.4) association.
C872 Within a BLOCK construct (11.1.4), the VOLATILE attribute shall not be specified for a coarray, or
   a variable with a coarray potential subobject component, that is not a construct entity (19.4) of that
   construct.
A noncoarray object that has the VOLATILE attribute may be associated with an object that does not have
the VOLATILE attribute, including by use (14.2.2) or host association (19.5.1.4). If an object that is not a
local variable of a BLOCK construct is specified to have the VOLATILE attribute in the <i>specification-part</i> of
the construct, the object has the attribute within the construct even if it does not have the attribute outside the
construct. The relationship between coarrays, the VOLATILE attribute, and argument association is described
in 15.5.2.9. The relationship between coarrays, the VOLATILE attribute, and pointer association is described in
10.2.2.3.
A pointer should have the VOLATILE attribute if its target has the VOLATILE attribute. If, by means not
specified by the program, the target is referenced, defined, or becomes undefined, the pointer shall have the
VOLATILE attribute. All members of an EQUIVALENCE group should have the VOLATILE attribute if any member has the
VOLATILE attribute.
If an object has the VOLATILE attribute, then all of its subobjects also have the VOLATILE attribute.
The Fortran processor should use the most recent definition of a volatile object each time its value is required.
When a volatile object is defined by means of Fortran, it should make that definition available to the non-Fortran
parts of the program as soon as possible.
<b>8.6</b> <b>Attribute</b> <b>specification</b> <b>statements</b>
<b>8.6.1</b> <b>Accessibility</b> <b>statement</b>
R830 <i>access-stmt</i> <b>is</b> <i>access-spec</i> [ [ :: ] <i>access-id-list</i> ]
R831 <i>access-id</i> <b>is</b> <i>access-name</i>
              <b>or</b> <i>generic-spec</i>
C873 (R830) An <i>access-stmt</i> shall appear only in the <i>specification-part</i> of a module. Only one accessibility
   statement with an omitted <i>access-id-list</i> is permitted in the <i>specification-part</i> of a module.
C874 (R831) Each <i>access-name</i> shall be the name of a module, variable, procedure, nonintrinsic type, named
   constant, or namelist group.
C875 A module whose name appears in an <i>access-stmt</i> shall be referenced by a USE statement in the scoping
   unit that contains the <i>access-stmt</i>.
C876 The name of a module shall appear at most once in all of the <i>access-stmt</i>s in a module.
An <i>access-stmt</i> with an <i>access-id-list</i> specifies the accessibility attribute, PUBLIC or PRIVATE, of each <i>access-id</i>
in the list that is not a module name. An <i>access-stmt</i> without an <i>access-id</i> list specifies the default accessibility
of the identifiers of entities declared in the module, and of entities accessed from a module whose name does
not appear in any <i>access-stmt</i> in the module. If an identifier is accessed from another module and also declared
locally, it has the default accessibility of a locally declared identifier. The statement
 PUBLIC
specifies a default of public accessibility. The statement
 PRIVATE
specifies a default of private accessibility. If no such statement appears in a module, the default is public
accessibility.
If an identifier is accessed by use association and not declared in the module, and the name of every module
from which it is accessed appears in an <i>access-stmt</i> in the scoping unit, its default accessibility is PRIVATE if
the <i>access-spec</i> in every such <i>access-stmt</i> is PRIVATE, or PUBLIC if the <i>access-spec</i> in any such <i>access-stmt</i> is
PUBLIC.
<b>NOTE</b> <b>1</b>
Examples of accessibility statements are:
   MODULE EX
     PRIVATE
     PUBLIC :: A, B, C, ASSIGNMENT (=), OPERATOR (+)
<b>NOTE</b> <b>2</b>
The following is an example of using an accessibility statement on a module name.
   MODULE m2
    USE m1
    ! We want to use the types and procedures in m1, but we only want to
    ! re-export m_type from m1, and export our own procedures.
    PRIVATE m1
    PUBLIC m_type
     <i>...</i> <i>definitions</i> <i>for</i> <i>our</i> <i>own</i> <i>entities</i> <i>and</i> <i>module</i> <i>procedures.</i>
   END MODULE
<b>8.6.2</b> <b>ALLOCATABLE</b> <b>statement</b>
R832 <i>allocatable-stmt</i> <b>is</b> ALLOCATABLE [ :: ] <i>allocatable-decl-list</i>
R833 <i>allocatable-decl</i> <b>is</b> <i>object-name</i> [ ( <i>array-spec</i> ) ]
                   [ <i>lbracket</i> <i>coarray-spec</i> <i>rbracket</i> ]
The ALLOCATABLE statement specifies the ALLOCATABLE attribute (8.5.3) for a list of objects.
<b>NOTE</b>
An example of an ALLOCATABLE statement is:
   REAL A, B (:), SCALAR
   ALLOCATABLE :: A (:, :), B, SCALAR
<b>8.6.3</b> <b>ASYNCHRONOUS</b> <b>statement</b>
R834 <i>asynchronous-stmt</i> <b>is</b> ASYNCHRONOUS [ :: ] <i>object-name-list</i>
The ASYNCHRONOUS statement specifies the ASYNCHRONOUS attribute (8.5.4) for a list of objects.
<b>8.6.4</b> <b>BIND</b> <b>statement</b>
R835 <i>bind-stmt</i> <b>is</b> <i>language-binding-spec</i> [ :: ] <i>bind-entity-list</i>
R836 <i>bind-entity</i> <b>is</b> <i>entity-name</i>
              <b>or</b> / <i>common-block-name</i> /
C877 (R835) If the <i>language-binding-spec</i> has a NAME= specifier, the <i>bind-entity-list</i> shall consist of a single
   <i>bind-entity</i>.
The BIND statement specifies the BIND attribute for a list of variables and common blocks.
<b>8.6.5</b> <b>CODIMENSION</b> <b>statement</b>
R837 <i>codimension-stmt</i> <b>is</b> CODIMENSION [ :: ] <i>codimension-decl-list</i>
R838 <i>codimension-decl</i> <b>is</b> <i>coarray-name</i> <i>lbracket</i> <i>coarray-spec</i> <i>rbracket</i>
The CODIMENSION statement specifies the CODIMENSION attribute (8.5.6) for a list of objects.
<b>NOTE</b>
An example of a CODIMENSION statement is:
   CODIMENSION a[*], b[3,*], c[:]
<b>8.6.6</b> <b>CONTIGUOUS</b> <b>statement</b>
R839 <i>contiguous-stmt</i> <b>is</b> CONTIGUOUS [ :: ] <i>object-name-list</i>
The CONTIGUOUS statement specifies the CONTIGUOUS attribute (8.5.7) for a list of objects.
<b>8.6.7</b> <b>DATA</b> <b>statement</b>
R840 <i>data-stmt</i> <b>is</b> DATA <i>data-stmt-set</i> [ [ , ] <i>data-stmt-set</i> ] ...
The DATA statement specifies explicit initialization (8.4).
If a nonpointer variable has default initialization, it shall not appear in a <i>data-stmt-object-list</i>.
A variable that appears in a DATA statement and has not been typed previously shall not appear in a sub-
sequent type declaration unless that declaration confirms the implicit typing. An array name, array section, or
array element that appears in a DATA statement shall have had its array properties established by a previous
specification statement.
Except for variables in named common blocks, a named variable has the SAVE attribute if any part of it is initialized
in a DATA statement, and this may be confirmed by explicit specification.
R841 <i>data-stmt-set</i> <b>is</b> <i>data-stmt-object-list</i> / <i>data-stmt-value-list</i> /
R842 <i>data-stmt-object</i> <b>is</b> <i>variable</i>
              <b>or</b> <i>data-implied-do</i>
R843 <i>data-implied-do</i> <b>is</b> ( <i>data-i-do-object-list</i> , [ <i>integer-type-spec</i> :: ] <i>data-i-do-variable</i> =
                  <i>scalar-int-constant-expr</i> ,
                  <i>scalar-int-constant-expr</i>
                   [ , <i>scalar-int-constant-expr</i> ] )
R844 <i>data-i-do-object</i> <b>is</b> <i>array-element</i>
              <b>or</b> <i>scalar-structure-component</i>
              <b>or</b> <i>data-implied-do</i>
R845 <i>data-i-do-variable</i> <b>is</b> <i>do-variable</i>
C878 A <i>data-stmt-object</i> or <i>data-i-do-object</i> shall not be a coindexed variable.
C879 (R842) A <i>data-stmt-object</i> that is a <i>variable</i> shall be a <i>designator</i>. Each subscript, section subscript,
   substring starting point, and substring ending point in the variable shall be a constant expression.
C880 (R842) A variable whose designator appears as a <i>data-stmt-object</i> or a <i>data-i-do-object</i> shall not be a
   dummy argument, accessed by use or host association, in a named common block unless the DATA statement is
    in a block data program unit, in blank common, a function name, a function result name, an automatic data
   object, or an allocatable variable.
C881 (R842)A<i>data-i-do-object</i> ora<i>variable</i> thatappearsasa<i>data-stmt-object</i> shallnotbeanobjectdesignator
   in which a pointer appears other than as the entire rightmost <i>part-ref</i>.
C882 (R844) The <i>array-element</i> shall be a variable.
C883 (R844) The <i>scalar-structure-component</i> shall be a variable.
C884 (R844) The <i>scalar-structure-component</i> shall contain at least one <i>part-ref</i> that contains a <i>subscript-list</i>.
C885 (R844) In an <i>array-element</i> or <i>scalar-structure-component</i> that is a <i>data-i-do-object</i>, any subscript shall
   be a constant expression, and any primary within that subscript that is a <i>data-i-do-variable</i> shall be a
   DO variable of this <i>data-implied-do</i> or of a containing <i>data-implied-do</i>.
R846 <i>data-stmt-value</i> <b>is</b> [ <i>data-stmt-repeat</i> * ] <i>data-stmt-constant</i>
R847 <i>data-stmt-repeat</i> <b>is</b> <i>scalar-int-constant</i>
              <b>or</b> <i>scalar-int-constant-subobject</i>
C886 (R847) The <i>data-stmt-repeat</i> shall be positive or zero. If the <i>data-stmt-repeat</i> is a named constant, it
   shall have been defined previously.
R848 <i>data-stmt-constant</i> <b>is</b> <i>scalar-constant</i>
              <b>or</b> <i>scalar-constant-subobject</i>
              <b>or</b> <i>signed-int-literal-constant</i>
              <b>or</b> <i>signed-real-literal-constant</i>
              <b>or</b> <i>null-init</i>
              <b>or</b> <i>initial-data-target</i>
              <b>or</b> <i>structure-constructor</i>
              <b>or</b> <i>enum-constructor</i>
              <b>or</b> <i>enumeration-constructor</i>
C887 (R848)IfaDATAstatementconstantvalueisanamedconstant, structureconstructor, enumconstructor,
   or enumeration constructor, the named constant or type shall have been defined previously.
C888 (R848) If a <i>data-stmt-constant</i> is a <i>structure-constructor</i>, <i>enum-constructor</i>, or <i>enumeration-constructor</i>,
   it shall be a constant expression.
R849 <i>int-constant-subobject</i> <b>is</b> <i>constant-subobject</i>
C889 (R849) <i>int-constant-subobject</i> shall be of type integer.
R850 <i>constant-subobject</i> <b>is</b> <i>designator</i>
C890 (R850) <i>constant-subobject</i> shall be a subobject of a constant.
C891 (R850) Any subscript, substring starting point, or substring ending point shall be a constant expression.
The <i>data-stmt-object-list</i> is expanded to form a sequence of pointers and scalar variables, referred to as "sequence
of variables" in subsequent text. A nonpointer array whose unqualified name appears as a <i>data-stmt-object</i> or
<i>data-i-do-object</i> is equivalent to a complete sequence of its array elements in array element order (9.5.3.3). An
array section is equivalent to the sequence of its array elements in array element order. A <i>data-implied-do</i> is
expanded to form a sequence of array elements and structure components, under the control of the <i>data-i-do-</i>
<i>variable</i>, as in the DO construct (11.1.7.4). The scope and attributes of a <i>data-i-do-variable</i> are described in
19.4.
The <i>data-stmt-value-list</i> is expanded to form a sequence of <i>data-stmt-constant</i>s. A <i>data-stmt-repeat</i> indicates the
number of times the following <i>data-stmt-constant</i> is to be included in the sequence; omission of a <i>data-stmt-repeat</i>
has the effect of a repeat factor of 1.
A zero-sized array or a <i>data-implied-do</i> with an iteration count of zero contributes no variables to the expanded
sequence of variables, but a zero-length scalar character variable does contribute a variable to the expanded
sequence. A <i>data-stmt-constant</i> with a repeat factor of zero contributes no <i>data-stmt-constant</i>s to the expanded
sequence of scalar <i>data-stmt-constant</i>s.
The expanded sequences of variables and <i>data-stmt-constant</i>s are in one-to-one correspondence. Each <i>data-stmt-</i>
<i>constant</i> specifies the initial value, initial data target, or <i>null-init</i> for the corresponding variable. The lengths of
the two expanded sequences shall be the same.
A <i>data-stmt-constant</i> shall be <i>null-init</i> or <i>initial-data-target</i> if and only if the corresponding <i>data-stmt-object</i> has
the POINTER attribute. If <i>data-stmt-constant</i> is <i>null-init</i>, the initial association status of the corresponding data
statement object is disassociated. If <i>data-stmt-constant</i> is <i>initial-data-target</i> the corresponding data statement
object shall be data-pointer-initialization compatible (7.5.4.6) with the initial data target; the data statement
object is initially associated with the target.
A <i>data-stmt-constant</i> other than <i>boz-literal-constant</i>, <i>null-init</i>, or <i>initial-data-target</i> shall be compatible with its
corresponding variable according to the rules of intrinsic assignment (10.2.1.2). The variable is initially defined
with the value specified by the <i>data-stmt-constant</i>; if necessary, the value is converted according to the rules of
intrinsic assignment (10.2.1.3) to a value that agrees in type, type parameters, and shape with the variable.
If a <i>data-stmt-constant</i> is a <i>boz-literal-constant</i>, the corresponding variable shall be of type integer. The <i>boz-</i>
<i>literal-constant</i> is treated as if it were converted by the intrinsic function INT (16.9.110) to type integer with the
kind type parameter of the variable.
<b>NOTE</b>
Examples of DATA statements are:
   CHARACTER (LEN = 10) NAME
   INTEGER, DIMENSION (0:9) :: MILES
   REAL, DIMENSION (100, 100) :: SKEW
   TYPE (NODE), POINTER :: HEAD_OF_LIST
   TYPE (PERSON) MYNAME, YOURNAME
   DATA NAME / 'JOHN DOE' /, MILES / 10 * 0 /
   DATA ((SKEW (K, J), J = 1, K), K = 1, 100) / 5050 * 0.0 /
   DATA ((SKEW (K, J), J = K + 1, 100), K = 1, 99) / 4950 * 1.0 /
   DATA HEAD_OF_LIST / NULL() /
   DATA MYNAME / PERSON (21, 'JOHN SMITH') /
   DATA YOURNAME % AGE, YOURNAME % NAME / 35, 'FRED BROWN' /
The character variable NAME is initialized with the value JOHN DOE with padding on the right because the
length of the constant is less than the length of the variable. All ten elements of the integer array MILES
are initialized to zero. The two-dimensional array SKEW is initialized so that the lower triangle of SKEW is
zero and the strict upper triangle is one. The structures MYNAME and YOURNAME are declared using the
derived type PERSON from 7.5.2.1, NOTE. The pointer HEAD_OF_LIST is declared using the derived type
NODE from 7.5.4.6, NOTE 4; it is initially disassociated. MYNAME is initialized by a structure constructor.
YOURNAME is initialized by supplying a separate value for each component.
<b>8.6.8</b> <b>DIMENSION</b> <b>statement</b>
R851 <i>dimension-stmt</i> <b>is</b> DIMENSION [ :: ] <i>array-name</i> ( <i>array-spec</i> )
                   [ , <i>array-name</i> ( <i>array-spec</i> ) ] ...
The DIMENSION statement specifies the DIMENSION attribute (8.5.8) for a list of objects.
<b>NOTE</b>
An example of a DIMENSION statement is:
   DIMENSION A (10), B (10, 70), C (:)
<b>8.6.9</b> <b>INTENT</b> <b>statement</b>
R852 <i>intent-stmt</i> <b>is</b> INTENT ( <i>intent-spec</i> ) [ :: ] <i>dummy-arg-name-list</i>
The INTENT statement specifies the INTENT attribute (8.5.10) for the dummy arguments in the list.
<b>NOTE</b>
An example of an INTENT statement is:
   SUBROUTINE EX (A, B)
     INTENT (INOUT) :: A, B
<b>8.6.10</b> <b>OPTIONAL</b> <b>statement</b>
R853 <i>optional-stmt</i> <b>is</b> OPTIONAL [ :: ] <i>dummy-arg-name-list</i>
The OPTIONAL statement specifies the OPTIONAL attribute (8.5.12) for the dummy arguments in the list.
<b>NOTE</b>
An example of an OPTIONAL statement is:
   SUBROUTINE EX (A, B)
     OPTIONAL :: B
<b>8.6.11</b> <b>PARAMETER</b> <b>statement</b>
The PARAMETER statement specifies the PARAMETER attribute (8.5.13) and the values for the named con-
stants in the list.
R854 <i>parameter-stmt</i> <b>is</b> PARAMETER ( <i>named-constant-def-list</i> )
R855 <i>named-constant-def</i> <b>is</b> <i>named-constant</i> = <i>constant-expr</i>
If a named constant is defined by a PARAMETER statement, it shall not be subsequently declared to have a
type or type parameter value that differs from the type and type parameters it would have if declared implicitly
(8.7). A named array constant defined by a PARAMETER statement shall have its rank specified in a prior
specification statement.
The constant expression that corresponds to a named constant shall have type and type parameters that conform
with the named constant as specified for intrinsic assignment (10.2.1.2). If the named constant has implied shape,
the expression shall have the same rank as the named constant; otherwise, the expression shall either be scalar
or have the same shape as the named constant.
The value of each named constant is that specified by the corresponding constant expression; if necessary, the
value is converted according to the rules of intrinsic assignment (10.2.1.3) to a value that agrees in type, type
parameters, and shape with the named constant.
<b>NOTE</b>
An example of a PARAMETER statement is:
   PARAMETER (MODULUS = MOD (28, 3), NUMBER_OF_SENATORS = 100)
<b>8.6.12</b> <b>POINTER</b> <b>statement</b>
R856 <i>pointer-stmt</i> <b>is</b> POINTER [ :: ] <i>pointer-decl-list</i>
R857 <i>pointer-decl</i> <b>is</b> <i>object-name</i> [ ( <i>deferred-shape-spec-list</i> ) ]
              <b>or</b> <i>procptr-entity-name</i>
C892 A <i>procptr-entity-name</i> shall have the EXTERNAL attribute.
The POINTER statement specifies the POINTER attribute (8.5.14) for a list of entities.
<b>NOTE</b>
An example of a POINTER statement is:
   TYPE (NODE) :: CURRENT
   POINTER :: CURRENT, A (:, :)
<b>8.6.13</b> <b>PROTECTED</b> <b>statement</b>
R858 <i>protected-stmt</i> <b>is</b> PROTECTED [ :: ] <i>entity-name-list</i>
The PROTECTED statement specifies the PROTECTED attribute (8.5.15) for a list of entities.
<b>8.6.14</b> <b>SAVE</b> <b>statement</b>
R859 <i>save-stmt</i> <b>is</b> SAVE [ [ :: ] <i>saved-entity-list</i> ]
R860 <i>saved-entity</i> <b>is</b> <i>object-name</i>
              <b>or</b> <i>proc-pointer-name</i>
              <b>or</b> / <i>common-block-name</i> /
R861 <i>proc-pointer-name</i> <b>is</b> <i>name</i>
C893 (R859) If a SAVE statement with an omitted saved entity list appears in a scoping unit, no other
   appearance of the SAVE <i>attr-spec</i> or SAVE statement is permitted in that scoping unit.
C894 A <i>proc-pointer-name</i> shall be the name of a procedure pointer.
A SAVE statement with a saved entity list specifies the SAVE attribute (8.5.16) for a list of entities. A SAVE
statement without a saved entity list is treated as though it contained the names of all allowed items in the same
scoping unit.
<b>NOTE</b>
An example of a SAVE statement is:
   SAVE A, B, C, / BLOCKA /, D
<b>8.6.15</b> <b>TARGET</b> <b>statement</b>
R862 <i>target-stmt</i> <b>is</b> TARGET [ :: ] <i>target-decl-list</i>
R863 <i>target-decl</i> <b>is</b> <i>object-name</i> [ ( <i>array-spec</i> ) ]
                   [ <i>lbracket</i> <i>coarray-spec</i> <i>rbracket</i> ]
The TARGET statement specifies the TARGET attribute (8.5.18) for a list of objects.
<b>NOTE</b>
An example of a TARGET statement is:
   TARGET :: A (1000, 1000), B
<b>8.6.16</b> <b>VALUE</b> <b>statement</b>
R864 <i>value-stmt</i> <b>is</b> VALUE [ :: ] <i>dummy-arg-name-list</i>
The VALUE statement specifies the VALUE attribute (8.5.19) for a list of dummy arguments.
<b>8.6.17</b> <b>VOLATILE</b> <b>statement</b>
R865 <i>volatile-stmt</i> <b>is</b> VOLATILE [ :: ] <i>object-name-list</i>
The VOLATILE statement specifies the VOLATILE attribute (8.5.20) for a list of objects.
<b>8.7</b> <b>IMPLICIT</b> <b>statement</b>
In a scoping unit, an IMPLICIT statement specifies a type, and possibly type parameters, for all implicitly
typed data entities whose names begin with one of the letters specified in the statement. An IMPLICIT NONE
statement can indicate that no implicit typing rules are to apply in a particular scoping unit, or that external
and dummy procedures need to be explicitly given the EXTERNAL attribute.
R866 <i>implicit-stmt</i> <b>is</b> IMPLICIT <i>implicit-spec-list</i>
              <b>or</b> IMPLICIT NONE [ ( [ <i>implicit-none-spec-list</i> ] ) ]
R867 <i>implicit-spec</i> <b>is</b> <i>declaration-type-spec</i> ( <i>letter-spec-list</i> )
R868 <i>letter-spec</i> <b>is</b> <i>letter</i> [ - <i>letter</i> ]
R869 <i>implicit-none-spec</i> <b>is</b> EXTERNAL
              <b>or</b> TYPE
C895 (R866) If an IMPLICIT NONE statement appears in a scoping unit, it shall precede any PARAMETER
   statements that appear in the scoping unit. No more than one IMPLICIT NONE statement shall appear
   in a scoping unit.
C896 The same <i>implicit-none-spec</i> shall not appear more than once in a given <i>implicit-stmt</i>.
C897 If an IMPLICIT NONE statement in a scoping unit has an <i>implicit-none-spec</i> of TYPE or has no <i>implicit-</i>
   <i>none-spec-list</i>, there shall be no other IMPLICIT statements in the scoping unit.
C898 (R868) If the minus and second <i>letter</i> appear, the second letter shall follow the first letter alphabetically.
C899 If IMPLICIT NONE with an <i>implicit-none-spec</i> of EXTERNAL appears within a scoping unit, the
   name of an external or dummy procedure in that scoping unit or in a contained subprogram or BLOCK
   construct shall have an explicit interface or be explicitly declared to have the EXTERNAL attribute.
A<i>letter-spec</i> consistingoftwo<i>letter</i>sseparatedbyaminusisequivalenttowritingalistcontainingalloftheletters
in alphabetical order in the alphabetic sequence from the first letter through the second letter. For example, A-C
is equivalent to A, B, C. The same letter shall not appear as a single letter, or be included in a range of letters,
more than once in all of the IMPLICIT statements in a scoping unit.
In each scoping unit, there is a mapping, which may be null, between each of the letters A, B, ..., Z and a
type (and type parameters). An IMPLICIT statement specifies the mapping for the letters in its <i>letter-spec-</i>
<i>list</i>. IMPLICIT NONE with an <i>implicit-none-spec</i> of TYPE or with no <i>implicit-none-spec-list</i> specifies the null
mapping for all the letters. If a mapping is not specified for a letter, the default for a program unit or an interface
body is default integer if the letter is I, J, ..., or N and default real otherwise, and the default for a BLOCK
construct, internal subprogram, or module subprogram is the mapping in the host scoping unit.
Any data entity that is not explicitly declared by a type declaration statement, is not an intrinsic function, is
not a component, and is not accessed by use or host association is declared implicitly to be of the type (and
type parameters) mapped from the first letter of its name, provided the mapping is not null. The mapping for
the first letter of the data entity shall either have been established by a prior IMPLICIT statement or be the
default mapping for the letter. An explicit type specification in a FUNCTION statement overrides an IMPLICIT
statement for the result of that function.
<b>NOTE</b> <b>1</b>
The following are examples of the use of IMPLICIT statements:
   MODULE EXAMPLE_MODULE
     IMPLICIT NONE
     ...
     INTERFACE
      FUNCTION FUN (I) ! Not all data entities need to
        INTEGER FUN ! be declared explicitly
      END FUNCTION FUN
     END INTERFACE
   CONTAINS
     FUNCTION JFUN (J) ! All data entities need to
      INTEGER JFUN, J ! be declared explicitly.
       ...
     END FUNCTION JFUN
   END MODULE EXAMPLE_MODULE
   SUBROUTINE SUB
     IMPLICIT COMPLEX (C)
     C = (3.0, 2.0) ! C is implicitly declared COMPLEX
     ...
   CONTAINS
     SUBROUTINE SUB1
      IMPLICIT INTEGER (A, C)
      C = (0.0, 0.0) ! C is host associated and of
                ! type complex
      Z = 1.0 ! Z is implicitly declared REAL
      A = 2 ! A is implicitly declared INTEGER
      CC = 1 ! CC is implicitly declared INTEGER
       ...
     END SUBROUTINE SUB1
     SUBROUTINE SUB2
      Z = 2.0 ! Z is implicitly declared REAL and
                ! is different from the variable of
                ! the same name in SUB1
       ...
     END SUBROUTINE SUB2
     SUBROUTINE SUB3
      USE EXAMPLE_MODULE ! Accesses integer function FUN
                ! by use association
      Q = FUN (K) ! Q is implicitly declared REAL and
       ... ! K is implicitly declared INTEGER
     END SUBROUTINE SUB3
   END SUBROUTINE SUB
<b>NOTE</b> <b>2</b>
The following is an example of a mapping to a derived type that is inaccessible in the local scope:
   PROGRAM MAIN
    IMPLICIT TYPE(BLOB) (A)
    TYPE BLOB
     INTEGER :: I
    END TYPE BLOB
    TYPE(BLOB) :: B
    CALL STEVE
   CONTAINS
                <b>J3/23-007r1</b> <b>127</b>
<b>NOTE</b> <b>2</b> <b>(cont.)</b>
    SUBROUTINE STEVE
     INTEGER :: BLOB
      ...
     AA = B
      ...
    END SUBROUTINE STEVE
   END PROGRAM MAIN
In the subroutine STEVE, it is not possible to explicitly declare a variable to be of type BLOB because BLOB
has been given a different meaning, but implicit mapping for the letter A still maps to type BLOB, so AA is of
type BLOB.
<b>NOTE</b> <b>3</b>
Implicit typing is not affected by BLOCK constructs. For example, in
  SUBROUTINE S(N)
    ...
   IF (N>0) THEN
    BLOCK
     NSQP = CEILING (SQRT (DBLE (N)))
    END BLOCK
   END IF
    ...
   IF (N>0) THEN
    BLOCK
     PRINT *,NSQP
    END BLOCK
   END IF
  END SUBROUTINE
even if the only two appearances of NSQP are within the BLOCK constructs, the scope of NSQP is the whole
subroutine S.
<b>NOTE</b> <b>4</b>
In the subprogram
   SUBROUTINE EXAMPLE (X, Y)
    IMPLICIT NONE (EXTERNAL)
    REAL, EXTERNAL :: G
    REAL :: X, Y
    X = F (Y) ! Invalid: F lacks the EXTERNAL attribute.
    X = G (Y) ! Valid: G has the EXTERNAL attribute.
   END SUBROUTINE
the referenced function F needs to have the EXTERNAL attribute (8.5.9).
<b>8.8</b> <b>IMPORT</b> <b>statement</b>
R870 <i>import-stmt</i> <b>is</b> IMPORT [[ :: ] <i>import-name-list</i> ]
              <b>or</b> IMPORT, ONLY : <i>import-name-list</i>
              <b>or</b> IMPORT, NONE
              <b>or</b> IMPORT, ALL
C8100 (R870) An IMPORT statement shall not appear in the scoping unit of a <i>main-program</i>, <i>external-</i>
   <i>subprogram</i>, <i>module</i>, or <i>block-data</i>.
C8101 (R870) Each <i>import-name</i> shall be the name of an entity in the host scoping unit.
C8102 If any IMPORT statement in a scoping unit has an ONLY specifier, all IMPORT statements in that
   scoping unit shall have an ONLY specifier.
C8103 IMPORT, NONE shall not appear in the scoping unit of a submodule.
C8104 If an IMPORT, NONE or IMPORT, ALL statement appears in a scoping unit, no other IMPORT
   statement shall appear in that scoping unit.
C8105 Within an interface body, an entity that is accessed by host association shall be accessible by host or use
   association within the host scoping unit, or explicitly declared prior to the interface body.
C8106 An entity whose name appears as an <i>import-name</i> or which is made accessible by an IMPORT, ALL
   statement shall not appear in any context described in 19.5.1.4 that would cause the host entity of that
   name to be inaccessible.
If the ONLY specifier appears on an IMPORT statement in a scoping unit other than a BLOCK construct,
an entity is only accessible by host association if its name appears as an <i>import-name</i> in that scoping unit. If
a BLOCK construct contains one or more IMPORT statements with ONLY specifiers, identifiers of local and
construct entities in the host scoping unit that are not in the <i>import-name-list</i> of at least one of the IMPORT
statements are inaccessible in the BLOCK construct.
An IMPORT, NONE statement in a scoping unit specifies that no entities in the host scoping unit are accessible
by host association in that scoping unit. This is the default for an interface body that is not a module procedure
interface body. An IMPORT, NONE statement in a BLOCK construct specifies that the identifiers of local and
construct entities in the host scoping unit are inaccessible in the BLOCK construct.
An IMPORT, ALL statement in a scoping unit specifies that all entities from the host scoping unit are accessible
in that scoping unit.
If an IMPORT statement with no specifier and no <i>import-name-list</i> appears in a scoping unit, every entity in
the host scoping unit is accessible unless its name appears in a context described in 19.5.1.4 that causes it to be
inaccessible. This is the default for a derived-type definition, internal subprogram, module procedure interface
body, module subprogram, or submodule.
If an IMPORT statement with an <i>import-name-list</i> appears in a scoping unit other than a BLOCK construct,
each entity named in the list is accessible.
<b>NOTE</b> <b>1</b>
The IMPORT, NONE statement can be used to prevent accidental host association:
   SUBROUTINE s(x,n)
    IMPLICIT NONE
    IMPORT, NONE
     ...
    DO i=1,n ! Forces I to be locally declared.
<b>NOTE</b> <b>2</b>
The IMPORT, ALL statement can be used to prevent accidental "shadowing" of host entities:
   SUBROUTINE outer
     REAL x
     ...
    CONTAINS
     SUBROUTINE inner
      IMPORT, ALL
      ...
      x = x + 1 ! There is a host X, so this must be the host X.
<b>NOTE</b> <b>3</b>
The IMPORT, ONLY statement can be used to document deliberate access via host association whilst blocking
accidental access:
   SUBROUTINE sub
    IMPORT,ONLY : x, y
     ...
    x = y + z ! Only X and Y are imported, so Z is local.
<b>NOTE</b> <b>4</b>
The program
   PROGRAM MAIN
    BLOCK
     IMPORT, NONE
     !IMPORT, ONLY: X
     X = 1.0
    END BLOCK
   END
is not conformant. The variable X is implicitly declared in the scoping unit of the main program. The statement
IMPORT, NONE makes X inaccessible in the BLOCK construct. If the IMPORT, NONE statement is replaced
with the IMPORT statement in the comment, the program is conformant.
<b>NOTE</b> <b>5</b>
The IMPORT statement can be used to allow module procedures to have dummy arguments that are procedures
with assumed-shape arguments of an opaque type. For example:
   MODULE M
    TYPE T
     PRIVATE ! T is an opaque type
      ...
    END TYPE
   CONTAINS
    SUBROUTINE PROCESS(X,Y,RESULT,MONITOR)
     TYPE(T),INTENT(IN) :: X(:,:),Y(:,:)
     TYPE(T),INTENT(OUT) :: RESULT(:,:)
     INTERFACE
      SUBROUTINE MONITOR(ITERATION_NUMBER,CURRENT_ESTIMATE)
       IMPORT T
       INTEGER,INTENT(IN) :: ITERATION_NUMBER
       TYPE(T),INTENT(IN) :: CURRENT_ESTIMATE(:,:)
      END SUBROUTINE
     END INTERFACE
      ...
    END SUBROUTINE
   END MODULE
The MONITOR dummy procedure requires an explicit interface because it has an assumed-shape array argu-
ment, but TYPE(T) would not be available inside the interface body without the IMPORT statement.
<b>8.9</b> <b>NAMELIST</b> <b>statement</b>
A NAMELIST statement specifies a group of named data objects, which can be referred to by a single name for
the purpose of data transfer (12.6, 13.11).
R871 <i>namelist-stmt</i> <b>is</b> NAMELIST
                   / <i>namelist-group-name</i> / <i>namelist-group-object-list</i>
                   [ [ , ] / <i>namelist-group-name</i> /
                  <i>namelist-group-object-list</i> ] ...
C8107 (R871) The <i>namelist-group-name</i> shall not be a name accessed by use association.
R872 <i>namelist-group-object</i> <b>is</b> <i>variable-name</i>
C8108 (R872) A <i>namelist-group-object</i> shall not be an assumed-size array.
C8109 A <i>namelist-group-object</i> shall not be of enumeration type, or have a direct component that is of enumer-
   ation type.
The order in which the values appear on output is the same as the order of the <i>namelist-group-object</i>s in the
namelist group object list; if a variable appears more than once as a <i>namelist-group-object</i> for the same namelist
group, its value appears once for each occurrence.
Any <i>namelist-group-name</i> may occur more than once in the NAMELIST statements in a scoping unit. The
<i>namelist-group-object-list</i> following each successive appearance of the same <i>namelist-group-name</i> in a scoping
unit is treated as a continuation of the list for that <i>namelist-group-name</i>.
A namelist group object may be a member of more than one namelist group.
A namelist group object shall either be accessed by use or host association or shall have its declared type, kind
type parameters of the declared type, and rank specified by previous statements in the same scoping unit or
by the implicit typing rules in effect for the scoping unit. If a namelist group object is typed by the implicit
typing rules, its appearance in any subsequent type declaration statement shall confirm the implied type and
type parameters.
<b>NOTE</b>
An example of a NAMELIST statement is:
   NAMELIST /NLIST/ A, B, C
<b>8.10</b> <b>Storage</b> <b>association</b> <b>of</b> <b>data</b> <b>objects</b>
<b>8.10.1</b> <b>EQUIVALENCE</b> <b>statement</b>
<b>8.10.1.1</b> <b>General</b>
An EQUIVALENCE statement is used to specify the sharing of storage units by two or more objects in a scoping unit. This causes
storage association (19.5.3) of the objects that share the storage units.
If the equivalenced objects have differing type or type parameters, the EQUIVALENCE statement does not cause type conversion or
imply mathematical equivalence. If a scalar and an array are equivalenced, the scalar does not have array properties and the array
does not have the properties of a scalar.
R873 <i>equivalence-stmt</i> <b>is</b> EQUIVALENCE <i>equivalence-set-list</i>
R874 <i>equivalence-set</i> <b>is</b> ( <i>equivalence-object</i> , <i>equivalence-object-list</i> )
R875 <i>equivalence-object</i> <b>is</b> <i>variable-name</i>
              <b>or</b> <i>array-element</i>
              <b>or</b> <i>substring</i>
C8110 (R875) An <i>equivalence-object</i> shall not be a designator with a base object that is a dummy argument, a function result, a
    pointer, an allocatable variable, a derived-type object that has an allocatable or pointer ultimate component, an object of
    a nonsequence derived type, an object of enumeration type, an automatic data object, a coarray, a variable with the BIND
    attribute, a variable in a common block that has the BIND attribute, or a named constant.
C8111 (R875) An <i>equivalence-object</i> shall not be a designator that has more than one <i>part-ref</i>.
C8112 (R875) An <i>equivalence-object</i> shall not have the TARGET attribute.
C8113 (R875) Each subscript or substring range expression in an <i>equivalence-object</i> shall be an integer constant expression
    (10.1.12).
C8114 (R874) If an <i>equivalence-object</i> is default integer, default real, double precision real, default complex, default logical, or of
    numeric sequence type, all of the objects in the equivalence set shall be of these types and kinds.
C8115 (R874) If an <i>equivalence-object</i> is default character or of character sequence type, all of the objects in the equivalence set
    shall be of these types and kinds.
C8116 (R874) If an <i>equivalence-object</i> is of a sequence type that is not a numeric sequence or character sequence type, all of the
    objects in the equivalence set shall be of that type.
C8117 (R874) If an <i>equivalence-object</i> is of an intrinsic type but is not default integer, default real, double precision real, default
    complex, default logical, or default character, all of the objects in the equivalence set shall be of the same type with the
    same kind type parameter value.
C8118 (R875) If an <i>equivalence-object</i> has the PROTECTED attribute, all of the objects in the equivalence set shall have the
    PROTECTED attribute.
C8119 (R875) The name of an <i>equivalence-object</i> shall not be a name made accessible by use association.
C8120 (R875) A <i>substring</i> shall not have length zero.
<b>NOTE</b>
The EQUIVALENCE statement allows the equivalencing of sequence structures and the equivalencing of objects of intrinsic type
with nondefault type parameters, but there are strict rules regarding the appearance of these objects in an EQUIVALENCE
statement.
In addition to the above constraints, further rules on the interaction of EQUIVALENCE statements and default initialization are
given in 19.5.3.4.
<b>8.10.1.2</b> <b>Equivalence</b> <b>association</b>
An EQUIVALENCE statement specifies that the storage sequences (19.5.3.2) of the data objects specified in an <i>equivalence-set</i> are
storage associated. All of the nonzero-sized sequences in the <i>equivalence-set</i>, if any, have the same first storage unit, and all of
the zero-sized sequences in the <i>equivalence-set</i>, if any, are storage associated with one another and with the first storage unit of
any nonzero-sized sequences. This causes the storage association of the data objects in the <i>equivalence-set</i> and can cause storage
association of other data objects.
If any data object in an <i>equivalence-set</i> has the SAVE attribute, all other objects in the <i>equivalence-set</i> have the SAVE attribute;
this may be confirmed by explicit specification.
<b>8.10.1.3</b> <b>Equivalence</b> <b>of</b> <b>default</b> <b>character</b> <b>objects</b>
A default character data object shall not be equivalenced to an object that is not default character and not of a character sequence
type. The lengths of equivalenced default character objects need not be the same.
AnEQUIVALENCEstatementspecifiesthatthestoragesequencesofallthedefaultcharacterdataobjectsspecifiedinan <i>equivalence-</i>
<i>set</i> are storage associated. All of the nonzero-sized sequences in the <i>equivalence-set</i>, if any, have the same first character storage unit,
and all of the zero-sized sequences in the <i>equivalence-set</i>, if any, are storage associated with one another and with the first character
storage unit of any nonzero-sized sequences. This causes the storage association of the data objects in the <i>equivalence-set</i> and can
cause storage association of other data objects.
<b>NOTE</b>
For example, using the declarations:
   CHARACTER (LEN = 4) :: A, B
   CHARACTER (LEN = 3) :: C (2)
   EQUIVALENCE (A, C (1)), (B, C (2))
the association of A, B, and C can be illustrated graphically as:
    1 2 3 4 5 6 7
   |--- --- A --- ---|
              |--- --- B --- ---|
   |--- C(1) ---| |--- C(2) ---|
<b>8.10.1.4</b> <b>Array</b> <b>names</b> <b>and</b> <b>array</b> <b>element</b> <b>designators</b>
For a nonzero-sized array, the use of the array name unqualified by a subscript list as an <i>equivalence-object</i> has the same effect as
using an array element designator that identifies the first element of the array.
<b>8.10.1.5</b> <b>Restrictions</b> <b>on</b> <b>EQUIVALENCE</b> <b>statements</b>
An EQUIVALENCE statement shall not specify that the same storage unit is to occur more than once in a storage sequence.
An EQUIVALENCE statement shall not specify that consecutive storage units are to be nonconsecutive.
<b>8.10.2</b> <b>COMMON</b> <b>statement</b>
<b>8.10.2.1</b> <b>General</b>
The COMMON statement specifies blocks of physical storage, called common blocks, that can be accessed by any of the scoping
units in a program. Thus, the COMMON statement provides a global data facility based on storage association (19.5.3).
A common block that does not have a name is called blank common.
R876 <i>common-stmt</i> <b>is</b> COMMON
                      [ / [ <i>common-block-name</i> ] / ] <i>common-block-object-list</i>
                      [ [ , ] / [ <i>common-block-name</i> ] /
                     <i>common-block-object-list</i> ] ...
R877 <i>common-block-object</i> <b>is</b> <i>variable-name</i> [ ( <i>array-spec</i> ) ]
C8121 (R877) An <i>array-spec</i> in a <i>common-block-object</i> shall be an <i>explicit-shape-spec-list</i>.
C8122 (R877) Only one appearance of a given <i>variable-name</i> is permitted in all <i>common-block-object-list</i>s within a scoping unit.
C8123 (R877) A <i>common-block-object</i> shall not be a dummy argument, a function result, an allocatable variable, a derived-type
    object with an ultimate component that is allocatable, an object of enumeration type, a procedure pointer, an automatic
    data object, a variable with the BIND attribute, an unlimited polymorphic pointer, or a coarray.
C8124 (R877) If a <i>common-block-object</i> is of a derived type, the type shall have the BIND attribute or the SEQUENCE attribute
    and it shall have no default initialization.
C8125 (R877) A <i>variable-name</i> shall not be a name made accessible by use association.
In each COMMON statement, the data objects whose names appear in a common block object list following a common block name
are declared to be in that common block. If the first common block name is omitted, all data objects whose names appear in the
first common block object list are specified to be in blank common. Alternatively, the appearance of two slashes with no common
block name between them declares the data objects whose names appear in the common block object list that follows to be in blank
common.
Any common block name or an omitted common block name for blank common may occur more than once in one or more COMMON
statements in a scoping unit. The common block list following each successive appearance of the same common block name in a
scoping unit is treated as a continuation of the list for that common block name. Similarly, each blank common block object list in
a scoping unit is treated as a continuation of blank common.
The form <i>variable-name</i> (<i>array-spec</i>) specifies the DIMENSION attribute for that variable.
If derived-type objects of numeric sequence type or character sequence type (7.5.2.3) appear in common, it is as if the individual
components were enumerated directly in the common list.
<b>8.10.2.2</b> <b>Common</b> <b>block</b> <b>storage</b> <b>sequence</b>
For each common block in a scoping unit, a common block storage sequence is formed as follows:
   (1) A storage sequence is formed consisting of the sequence of storage units in the storage sequences (19.5.3.2) of all data
      objects in the common block object lists for the common block. The order of the storage sequences is the same as the
      order of the appearance of the common block object lists in the scoping unit.
   (2) The storage sequence formed in (1) is extended to include all storage units of any storage sequence associated with it
      by equivalence association. The sequence shall be extended only by adding storage units beyond the last storage unit.
      Data objects associated with an entity in a common block are considered to be in that common block.
Only COMMON statements and EQUIVALENCE statements appearing in the scoping unit contribute to common block storage
sequences formed in that scoping unit.
<b>8.10.2.3</b> <b>Size</b> <b>of</b> <b>a</b> <b>common</b> <b>block</b>
The size of a common block is the size of its common block storage sequence, including any extensions of the sequence resulting from
equivalence association.
<b>8.10.2.4</b> <b>Common</b> <b>association</b>
Within a program, the common block storage sequences of all nonzero-sized common blocks with the same name have the same first
storage unit, and the common block storage sequences of all zero-sized common blocks with the same name are storage associated
with one another. Within a program, the common block storage sequences of all nonzero-sized blank common blocks have the same
first storage unit and the storage sequences of all zero-sized blank common blocks are associated with one another and with the first
storage unit of any nonzero-sized blank common blocks. This results in the association of objects in different scoping units. Use or
host association can cause these associated objects to be accessible in the same scoping unit.
A nonpointer object that is default integer, default real, double precision real, default complex, default logical, or of numeric sequence
type shall be associated only with nonpointer objects of these types and kinds.
A nonpointer object that is default character or of character sequence type shall be associated only with nonpointer objects of these
types and kinds.
A nonpointer object of a derived type that is not a numeric sequence or character sequence type shall be associated only with
nonpointer objects of the same type.
A nonpointer object of an enum type shall be associated only with nonpointer objects of the same type.
A nonpointer object of intrinsic type but which is not default integer, default real, double precision real, default complex, default
logical, or default character shall be associated only with nonpointer objects of the same type and type parameters.
A data pointer shall be storage associated only with data pointers of the same type and rank. Data pointers that are storage
associated shall have deferred the same type parameters; corresponding nondeferred type parameters shall have the same value.
An object with the TARGET attribute shall be storage associated only with another object that has the TARGET attribute and the
same type and type parameters.
<b>NOTE</b>
A common block is permitted to contain sequences of different storage units, provided each scoping unit that accesses the common
block specifies an identical sequence of storage units for the common block. For example, this allows a single common block to
contain both numeric and character storage units.
Association in different scoping units between objects of default type, objects of double precision real type, and sequence structures
is permitted according to the rules for equivalence objects (8.10.1).
<b>8.10.2.5</b> <b>Differences</b> <b>between</b> <b>named</b> <b>common</b> <b>and</b> <b>blank</b> <b>common</b>
A blank common block has the same properties as a named common block, except for the following.
  Execution of a RETURN or END statement might cause data objects in a named common block to become undefined unless
  the common block has the SAVE attribute, but never causes nonpointer data objects in blank common to become undefined
  (19.6.6).
  Named common blocks of the same name shall be of the same size in all scoping units of a program in which they appear, but
  blank common blocks may be of different sizes.
  A data object in a named common block may be initially defined by means of a DATA statement or type declaration statement
  in a block data program unit (14.3), but objects in blank common shall not be initially defined.
<b>8.10.3</b> <b>Restrictions</b> <b>on</b> <b>common</b> <b>and</b> <b>equivalence</b>
An EQUIVALENCE statement shall not cause the storage sequences of two different common blocks to be associated.
Equivalence association shall not cause a derived-type object with default initialization to be associated with an object in a common
block.
Equivalence association shall not cause a common block storage sequence to be extended by adding storage units preceding the first
storage unit of the first object specified in a COMMON statement for the common block.
<b>9</b> <b>Use</b> <b>of</b> <b>data</b> <b>objects</b>
<b>9.1</b> <b>Designator</b>
R901 <i>designator</i> <b>is</b> <i>object-name</i>
              <b>or</b> <i>array-element</i>
              <b>or</b> <i>array-section</i>
              <b>or</b> <i>coindexed-named-object</i>
              <b>or</b> <i>complex-part-designator</i>
              <b>or</b> <i>structure-component</i>
              <b>or</b> <i>substring</i>
The appearance of a data object designator in a context that requires its value is termed a reference.
<b>9.2</b> <b>Variable</b>
R902 <i>variable</i> <b>is</b> <i>designator</i>
              <b>or</b> <i>function-reference</i>
C901 (R902) <i>designator</i> shall not be a constant or a subobject of a constant.
C902 (R902) <i>function-reference</i> shall have a data pointer result.
A variable is either the data object denoted by <i>designator</i> or the target of the pointer resulting from the evaluation
of <i>function-reference</i>; this pointer shall be associated.
A reference is permitted only if the variable is defined. A reference to a data pointer is permitted only if the
pointer is associated with a target object that is defined. A variable becomes defined with a value when events
described in 19.6.5 occur.
R903 <i>variable-name</i> <b>is</b> <i>name</i>
C903 (R903) <i>variable-name</i> shall be the name of a variable.
R904 <i>logical-variable</i> <b>is</b> <i>variable</i>
C904 (R904) <i>logical-variable</i> shall be of type logical.
R905 <i>char-variable</i> <b>is</b> <i>variable</i>
C905 (R905) <i>char-variable</i> shall be of type character.
R906 <i>default-char-variable</i> <b>is</b> <i>variable</i>
C906 (R906) <i>default-char-variable</i> shall be default character.
R907 <i>int-variable</i> <b>is</b> <i>variable</i>
C907 (R907) <i>int-variable</i> shall be of type integer.
<b>NOTE</b>
For example, given the declarations:
   CHARACTER (10) A, B (10)
   TYPE (PERSON) P ! See 7.5.2.1, NOTE
then A, B, B (1), B (1:5), P % AGE, and A (1:1) are all variables.
<b>9.3</b> <b>Constants</b>
A constant (6.2.3) is a literal constant or a named constant. A literal constant is a scalar denoted by a syntactic
form, which indicates its type, type parameters, and value. A named constant is a constant that has a name; the
name has the PARAMETER attribute (8.5.13, 8.6.11). A reference to a constant is always permitted; redefinition
of a constant is never permitted.
<b>9.4</b> <b>Scalars</b>
<b>9.4.1</b> <b>Substrings</b>
A substring is a contiguous portion of a character string (7.4.4).
R908 <i>substring</i> <b>is</b> <i>parent-string</i> ( <i>substring-range</i> )
R909 <i>parent-string</i> <b>is</b> <i>scalar-variable-name</i>
              <b>or</b> <i>array-element</i>
              <b>or</b> <i>coindexed-named-object</i>
              <b>or</b> <i>scalar-structure-component</i>
              <b>or</b> <i>scalar-constant</i>
R910 <i>substring-range</i> <b>is</b> [ <i>scalar-int-expr</i> ] : [ <i>scalar-int-expr</i> ]
C908 (R909) <i>parent-string</i> shall be of type character.
The value of the first <i>scalar-int-expr</i> in <i>substring-range</i> is the starting point of the substring and the value of
the second one is the ending point of the substring. The length of a substring is the number of characters in the
substring and is MAX (<i>l</i>-<i>f</i> + 1, 0), where <i>f</i> and <i>l</i> are the starting and ending points, respectively.
Let the characters in the parent string be numbered 1, 2, 3, ..., <i>n</i>, where <i>n</i> is the length of the parent string.
Then the characters in the substring are those from the parent string from the starting point and proceeding in
sequence up to and including the ending point. If the starting point is greater than the ending point, the substring
has length zero; otherwise, both the starting point and the ending point shall be within the range 1, 2, ..., <i>n</i>. If
the starting point is not specified, the default value is 1. If the ending point is not specified, the default value is
<i>n</i>.
<b>NOTE</b>
Examples of character substrings are:
   B(1)(1:5) array element as parent string
   P%NAME(1:1) structure component as parent string
   ID(4:9) scalar variable name as parent string
   '0123456789'(N:N) character constant as parent string
<b>9.4.2</b> <b>Structure</b> <b>components</b>
A structure component is part of an object of derived type; it can be referenced by an object designator. A
structure component may be a scalar or an array.
R911 <i>data-ref</i> <b>is</b> <i>part-ref</i> [ % <i>part-ref</i> ] ...
R912 <i>part-ref</i> <b>is</b> <i>part-name</i> [ ( <i>section-subscript-list</i> ) ] [ <i>image-selector</i> ]
C909 (R911) Each <i>part-name</i> except the rightmost shall be of derived type.
C910 (R911) Each <i>part-name</i> except the leftmost shall be the name of a component of the declared type of the
   preceding <i>part-name</i>.
C911 (R911) If the rightmost <i>part-name</i> is of abstract type, <i>data-ref</i> shall be polymorphic.
C912 (R911) The leftmost <i>part-name</i> shall be the name of a data object.
C913 (R912) If a <i>section-subscript-list</i> appears, the sum of the rank of <i>part-ref</i>, the sizes of the arrays in each
   multiple subscript, and the number of <i>subscript</i>s, shall equal the rank of <i>part-name</i>.
C914 (R912) If <i>image-selector</i> appears, the number of <i>cosubscript</i>s shall be equal to the corank of <i>part-name</i>.
C915 A <i>data-ref</i> shall not be of type C_PTR or C_FUNPTR from the intrinsic module ISO_C_BIND-
   ING (18.2), or of type TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV (16.10.2), if one
   of its <i>part-ref</i>s has an <i>image-selector</i>.
C916 (R912) If <i>image-selector</i> appears and <i>part-name</i> is an array, <i>section-subscript-list</i> shall appear.
C917 (R911) Except as an actual argument to an intrinsic inquiry function or as the <i>designator</i> in a type
   parameter inquiry, a <i>data-ref</i> shall not be a coindexed object that has a polymorphic allocatable potential
   subobject component.
C918 Except as an actual argument to an intrinsic inquiry function or as the <i>designator</i> in a type parameter
   inquiry, if the rightmost <i>part-ref</i> is polymorphic, no other <i>part-ref</i> shall be coindexed.
The rank of a <i>part-ref</i> of the form <i>part-name</i> is the rank of <i>part-name</i>. The rank of a <i>part-ref</i> that has a section
subscript list is the sum of the number of subscript triplets, the number of vector subscripts, and the sizes of one
of the arrays in each multiple section subscript.
C919 (R911) There shall not be more than one <i>part-ref</i> with nonzero rank. A <i>part-name</i> to the right of a
   <i>part-ref</i> with nonzero rank shall not have the ALLOCATABLE or POINTER attribute.
The rank of a <i>data-ref</i> is the rank of the <i>part-ref</i> with nonzero rank, if any; otherwise, the rank is zero. The base
object of a <i>data-ref</i> is the data object whose name is the leftmost part name.
The type and type parameters, if any, of a <i>data-ref</i> are those of the rightmost part name.
A <i>data-ref</i> with more than one <i>part-ref</i> is a subobject of its base object if none of the <i>part-name</i>s, except for
possiblytherightmost, isapointer. Iftherightmost <i>part-name</i> istheonlypointer, thenthe <i>data-ref</i> isasubobject
of its base object in contexts that pertain to its pointer association status but not in any other contexts.
<b>NOTE</b> <b>1</b>
If X is an object of derived type with a pointer component P, then the pointer X%P is a subobject of X when
considered as a pointer - that is in contexts where it is not dereferenced.
However the target of X%P is not a subobject of X. Thus, in contexts where X%P is dereferenced to refer to
the target, it is not a subobject of X.
R913 <i>structure-component</i> <b>is</b> <i>data-ref</i>
C920 (R913)Thereshallbemorethanone<i>part-ref</i> andtherightmost<i>part-ref</i> shallnothavea<i>section-subscript-</i>
   <i>list</i>.
A structure component shall be neither referenced nor defined before the declaration of the base object. A
structure component is a pointer only if the rightmost part name has the POINTER attribute.
<b>NOTE</b> <b>2</b>
Examples of structure components are:
   SCALAR_PARENT%SCALAR_FIELD scalar component of scalar parent
   ARRAY_PARENT(J)%SCALAR_FIELD component of array element parent
   ARRAY_PARENT(1:N)%SCALAR_FIELD component of array section parent
For a more elaborate example see C.5.1.
<b>NOTE</b> <b>3</b>
The syntax rules are structured such that a <i>data-ref</i> that ends in a component name without a following
subscript list is a structure component, even when other component names in the <i>data-ref</i> are followed by a
subscript list. A <i>data-ref</i> that ends in a component name with a following subscript list is either an array
element or an array section. A <i>data-ref</i> of nonzero rank that ends with a <i>substring-range</i> is an array section. A
<i>data-ref</i> of zero rank that ends with a <i>substring-range</i> is a substring.
<b>9.4.3</b> <b>Coindexed</b> <b>named</b> <b>objects</b>
A <i>coindexed-named-object</i> is a named scalar coarray variable followed by an image selector.
R914 <i>coindexed-named-object</i> <b>is</b> <i>data-ref</i>
C921 (R914) The <i>data-ref</i> shall contain exactly one <i>part-ref</i>. The <i>part-ref</i> shall contain an <i>image-selector</i>.
   The <i>part-name</i> shall be the name of a scalar coarray.
<b>9.4.4</b> <b>Complex</b> <b>parts</b>
R915 <i>complex-part-designator</i> <b>is</b> <i>designator</i> % RE
              <b>or</b> <i>designator</i> % IM
C922 (R915) The <i>designator</i> shall be of complex type.
If <i>complex-part-designator</i> is <i>designator</i>%RE it designates the real part of <i>designator</i>. If it is <i>designator</i>%IM
it designates the imaginary part of <i>designator</i>. The type of a <i>complex-part-designator</i> is real, and its kind and
shape are those of the <i>designator</i>, which can be an array or scalar.
<b>NOTE</b>
The following are examples of complex part designators:
   impedance%re Same value as REAL (impedance).
   fft%im Same value as AIMAG (fft).
   x%im = 0.0 Sets the imaginary part of X to zero.
<b>9.4.5</b> <b>Type</b> <b>parameter</b> <b>inquiry</b>
A type parameter inquiry is used to inquire about a type parameter of a data object. It applies to both intrinsic
and derived types.
R916 <i>type-param-inquiry</i> <b>is</b> <i>designator</i> % <i>type-param-name</i>
C923 (R916) The <i>type-param-name</i> shall be the name of a type parameter of the declared type of the object
   designated by the <i>designator</i>.
A deferred type parameter of a pointer that is not associated or of an unallocated allocatable variable shall not
be inquired about.
<b>NOTE</b> <b>1</b>
A <i>type-param-inquiry</i> has a syntax like that of a structure component reference, but it does not have the same
semantics. It is not a variable and thus can never be assigned to. It can be used only as a primary in an
expression. It is scalar even if <i>designator</i> is an array.
The intrinsic type parameters can also be inquired about by using the intrinsic functions KIND and LEN.
<b>NOTE</b> <b>2</b>
The following are examples of type parameter inquiries:
   a%kind A is real. Same value as KIND (a).
   s%len S is character. Same value as LEN (s).
   b(10)%kind Inquiry about an array element.
   p%dim P is of the derived type general_point.
See 7.5.3.1, NOTE for the definition of the general_point type used in the last example above.
<b>9.5</b> <b>Arrays</b>
<b>9.5.1</b> <b>Order</b> <b>of</b> <b>reference</b>
No order of reference to the elements of an array is indicated by the appearance of the array designator, except
where array element ordering (9.5.3.3) is specified.
<b>9.5.2</b> <b>Whole</b> <b>arrays</b>
A whole array is a named array or a structure component whose final <i>part-ref</i> is an array component name; no
subscript list is appended.
The appearance of a whole array variable in an executable construct specifies all the elements of the array (5.4.6).
The appearance of a whole array designator in a nonexecutable statement specifies the entire array except for the
appearance of a whole array designator in an equivalence set (8.10.1.4). An assumed-size array (8.5.8.5) is permitted to
appear as a whole array in an executable construct or specification expression only as an actual argument in a
procedure reference that does not require the shape.
<b>9.5.3</b> <b>Array</b> <b>elements</b> <b>and</b> <b>array</b> <b>sections</b>
<b>9.5.3.1</b> <b>Syntax</b>
R917 <i>array-element</i> <b>is</b> <i>data-ref</i>
C924 (R917) Every <i>part-ref</i> shall have rank zero and the last <i>part-ref</i> shall contain a <i>subscript-list</i>.
R918 <i>array-section</i> <b>is</b> <i>data-ref</i> [ ( <i>substring-range</i> ) ]
              <b>or</b> <i>complex-part-designator</i>
C925 (R918) Exactly one <i>part-ref</i> shall have nonzero rank, and either the final <i>part-ref</i> shall have a <i>section-</i>
   <i>subscript-list</i> with nonzero rank, another <i>part-ref</i> shall have nonzero rank, or the <i>complex-part-designator</i>
   shall be an array.
C926 (R918) If a <i>substring-range</i> appears, <i>data-ref</i> shall be of type character.
R919 <i>subscript</i> <b>is</b> <i>scalar-int-expr</i>
R920 <i>multiple-subscript</i> <b>is</b> @ <i>int-expr</i>
C927 The <i>int-expr</i> in a <i>multiple-subscript</i> shall be an array of rank one.
R921 <i>section-subscript</i> <b>is</b> <i>subscript</i>
              <b>or</b> <i>multiple-subscript</i>
              <b>or</b> <i>subscript-triplet</i>
              <b>or</b> <i>multiple-subscript-triplet</i>
              <b>or</b> <i>vector-subscript</i>
R922 <i>subscript-triplet</i> <b>is</b> [ <i>subscript</i> ] : [ <i>subscript</i> ] [ : <i>stride</i> ]
R923 <i>multiple-subscript-triplet</i> <b>is</b> @ [ <i>int-expr</i> ] : [ <i>int-expr</i> ] [ : <i>int-expr</i> ]
C928 A <i>multiple-subscript-triplet</i> shall have at least one <i>int-expr</i> that is an array of rank one. The <i>int-expr</i>s
   in a <i>multiple-subscript-triplet</i> shall be conformable.
R924 <i>stride</i> <b>is</b> <i>scalar-int-expr</i>
R925 <i>vector-subscript</i> <b>is</b> <i>int-expr</i>
C929 (R925) A <i>vector-subscript</i> shall be an integer array expression of rank one.
C930 (R922) The second subscript shall not be omitted from a <i>subscript-triplet</i> in the last dimension of an
   assumed-size array.
C931 If a <i>multiple-subscript-triplet</i> is the last <i>section-subscript</i> in the <i>section-subscript-list</i> of an assumed-size
   array, the second <i>int-expr</i> shall appear.
An array element is a scalar. An array section is an array. If a <i>substring-range</i> appears in an <i>array-section</i>, each
element is the designated substring of the corresponding element of the array section.
The value of a subscript in an array element shall be within the bounds for its dimension.
<b>NOTE</b> <b>1</b>
For example, with the declarations:
   REAL A (10, 10)
   CHARACTER (LEN = 10) B (5, 5, 5)
A (1, 2) is an array element, A (1:N:2, M) is a rank-one array section, and B (:, :, :) (2:3) is an array of shape
(5, 5, 5) whose elements are substrings of length 2 of the corresponding elements of B.
<b>NOTE</b> <b>2</b>
Unless otherwise specified, an array element or array section does not have an attribute of the whole array. In
particular, an array element or an array section does not have the POINTER or ALLOCATABLE attribute.
<b>NOTE</b> <b>3</b>
Examples of array elements and array sections are:
   ARRAY_A(1:N:2)%ARRAY_B(I, J)%STRING(K)(:) array section
   SCALAR_PARENT%ARRAY_FIELD(J) array element
   SCALAR_PARENT%ARRAY_FIELD(1:N) array section
   SCALAR_PARENT%ARRAY_FIELD(1:N)%SCALAR_FIELD array section
<b>9.5.3.2</b> <b>Sequences</b> <b>of</b> <b>subscripts</b> <b>and</b> <b>subscript</b> <b>triplets</b>
A <i>multiple-subscript</i> specifies a sequence of subscripts, the number of which is equal to the size of <i>multiple-</i>
<i>subscript</i>. The effect is as if the array elements were specified individually as subscripts of consecutive dimensions
(not preceded by @).
In a <i>multiple-subscript-triplet</i>, if the first <i>int-expr</i> does not appear, the effect is as if it were a rank-one array whose
element values are the lower bounds of the corresponding dimensions. If the second <i>int-expr</i> does not appear, the
effect is as if it were a rank-one array whose element values are the upper bounds of the corresponding dimensions.
If the third <i>int-expr</i> does not appear, the effect is as if it appeared with the value one.
A <i>multiple-subscript-triplet</i> specifies a sequence of subscript triplets, the number of which is equal to the size of
one of its array <i>int-expr</i>s. If any <i>int-expr</i> is a scalar, the effect is as if it were broadcast to the shape of one that is
an array. An element of the first array acts as if it were the first <i>subscript</i> in a <i>subscript</i> triplet; the corresponding
element of the second array acts as if it were the second <i>subscript</i>; the corresponding element of the third array
acts as if it were the <i>stride</i>.
<b>NOTE</b>
Examples of references to parts of arrays using one-dimensional arrays to specify sequences of subscripts or
sequences of subscript triplets, assuming V1, V2, and V3 are rank-one arrays, are:
   A(@[3,5]) ! Array element, equivalent to A(3, 5)
   A(6, @[3,5], 1) ! Array element, equivalent to A(6, 3, 5, 1)
   A(@[1,2]:[3,4]) ! Array section, equivalent to A(1:3, 2:4)
   A(@:[4,6]:2, :, 1) ! Array section with stride, equivalent to A(:4:2, :6:2, :, 1)
   A(@V1, :, @V2) ! Rank-one array section, the rank of A being
             ! SIZE (V1) + 1 + SIZE (V2).
   B(@V1, :, @V2:) ! Rank 1 + SIZE (V2) array section, the rank of B being
             ! SIZE (V1) + 1 + SIZE (V2).
   C(@V1, :, @::V3) ! Rank 1 + SIZE (V3) array section, the rank of C being
             ! SIZE (V1) + 1 + SIZE (V3).
<b>9.5.3.3</b> <b>Array</b> <b>element</b> <b>order</b>
The elements of an array form a sequence known as the array element order. The position of an array element
in this sequence is determined by the subscript order value of the subscript list designating the element. The
subscript order value is computed from the formulas in Table 9.1.
             <b>Table</b> <b>9.1</b> <b>-</b> <b>Subscript</b> <b>order</b> <b>value</b>
       Rank Subscript bounds Subscript list Subscript order value
        1 <i>j</i>
              1
             :<i>k</i>
                1
                  <i>s</i>
                          1
                                                        1 + (<i>s</i>
                                       1
                 -<i>j</i>
                                         1
                                                                 )
        2 <i>j</i>
              1
             :<i>k</i>
                1
              ,<i>j</i>
                 2
               :<i>k</i>
                  2
                  <i>s</i>
                          1
                   <i>,s</i>
                            2
                                                        1 + (<i>s</i>
                                       1
                 -<i>j</i>
                                         1
                                                                 )
                                                        +(<i>s</i>
                                      2
                -<i>j</i>
                                        2
                                                                )x<i>d</i>
                                           1
        3 <i>j</i>
              1
             :<i>k</i>
                1
            <i>,j</i>
                 2
               :<i>k</i>
                   2
              <i>,j</i>
                    3
                  :<i>k</i>
                      3
                  <i>s</i>
                          1
                   <i>,s</i>
                            2
                    <i>,s</i>
                             3
                                                        1 + (<i>s</i>
                                       1
                 -<i>j</i>
                                         1
                                                                 )
                                                        +(<i>s</i>
                                      2
                -<i>j</i>
                                        2
                                                                )x<i>d</i>
                                           1
                                                        +(<i>s</i>
                                      3
                -<i>j</i>
                                        3
                                                                )x<i>d</i>
                                           2
                   x<i>d</i>
                                              1
        .
        .
        .
            .
            .
            .
                       .
                       .
                       .
                                .
                                .
                                .
        15 <i>j</i>
              1
             :<i>k</i>
                1
            <i>,...,j</i>
                   15
                 :<i>k</i>
                     15
                  <i>s</i>
                          1
                   <i>,...,s</i>
                              15
                                                        1 + (<i>s</i>
                                       1
                 -<i>j</i>
                                         1
                                                                 )
                                                        +(<i>s</i>
                                      2
                -<i>j</i>
                                        2
                                                                )x<i>d</i>
                                           1
                                                        +<i>...</i>
                                                        +(<i>s</i>
                                      15
                -<i>j</i>
                                        15
                                                                 )x<i>d</i>
                                           14
                   x<i>...</i>x<i>d</i>
                                                1
      NOTE 1 <i>d</i>
            <i>i</i>
            = max (<i>k</i>
                  <i>i</i>
        -<i>j</i>
                    <i>i</i>
                                   + 1, 0) is the size of the <i>i</i>
                                   th
                               dimension.
      NOTE 2 If the size of the array is nonzero, <i>j</i>
                            <i>i</i>
             <i>s</i>
                               <i>i</i>
              <i>k</i>
                                 <i>i</i>
                                for all <i>i</i> = 1, 2, ..., 15.
<b>9.5.3.4</b> <b>Array</b> <b>sections</b>
<b>9.5.3.4.1</b> <b>Section</b> <b>subscript</b> <b>lists</b>
In an <i>array-section</i> having a <i>section-subscript-list</i>, each subscript triplet and <i>vector-subscript</i> in the section
subscript list indicates a sequence of subscripts, which may be empty. Each subscript in such a sequence shall
be within the bounds for its dimension unless the sequence is empty. The array section is the set of elements
from the array determined by all possible subscript lists obtainable from the single subscripts or sequences of
subscripts specified by each section subscript.
In an <i>array-section</i> with no <i>section-subscript-list</i>, the rank and shape of the array is the rank and shape of the
<i>part-ref</i> with nonzero rank; otherwise, the rank of the array section is the number of subscript triplets and vector
subscripts in the section subscript list. The shape is the rank-one array whose <i>i</i>th element is the number of
integer values in the sequence indicated by the <i>i</i>th subscript triplet or vector subscript. If any of these sequences
is empty, the array section has size zero. The subscript order of the elements of an array section is that of the
array data object that the array section represents.
<b>9.5.3.4.2</b> <b>Subscript</b> <b>triplet</b>
A subscript triplet designates a regular sequence of subscripts consisting of zero or more subscript values. The
stride in the subscript triplet specifies the increment between the subscript values. The subscripts and stride of a
subscript triplet are optional. An omitted first subscript in a subscript triplet is equivalent to a subscript whose
value is the lower bound for the array and an omitted second subscript is equivalent to the upper bound. An
omitted stride is equivalent to a stride of 1.
The stride shall not be zero.
When the stride is positive, the subscripts specified by a triplet form a regularly spaced sequence of integers
beginning with the first subscript and proceeding in increments of the stride to the largest such integer not
greater than the second subscript; the sequence is empty if the first subscript is greater than the second.
<b>NOTE</b> <b>1</b>
For example, suppose an array is declared as A (5, 4, 3). The section A (3 : 5, 2, 1 : 2) is the array of shape
(3, 2):
   A (3, 2, 1) A (3, 2, 2)
   A (4, 2, 1) A (4, 2, 2)
   A (5, 2, 1) A (5, 2, 2)
When the stride is negative, the sequence begins with the first subscript and proceeds in increments of the stride
down to the smallest such integer equal to or greater than the second subscript; the sequence is empty if the
second subscript is greater than the first.
<b>NOTE</b> <b>2</b>
For example, if an array is declared B (10), the section B (9 : 1 :-2) is the array of shape (5) whose elements
are B (9), B (7), B (5), B (3), and B (1), in that order.
<b>NOTE</b> <b>3</b>
A subscript in a subscript triplet need not be within the declared bounds for that dimension if all values used
in selecting the array elements are within the declared bounds.
For example, if an array is declared as B (10), the array section B (3 : 11 : 7) is the array of shape (2) consisting
of the elements B (3) and B (10), in that order.
<b>9.5.3.4.3</b> <b>Vector</b> <b>subscript</b>
Avectorsubscriptdesignatesasequenceofsubscriptscorrespondingtothevaluesoftheelementsoftheexpression.
Each element of the expression shall be defined.
An array section with a vector subscript shall not be finalized by a nonelemental final subroutine.
If a vector subscript has two or more elements with the same value, an array section with that vector subscript
is not definable and shall not be defined or become undefined.
<b>NOTE</b>
For example, suppose Z is a two-dimensional array of shape [5, 7] and U and V are one-dimensional arrays of
shape (3) and (4), respectively. Assume the values of U and V are:
   U = [ 1, 3, 2 ]
   V = [ 2, 1, 1, 3 ]
<b>142</b> <b>J3/23-007r1</b>
<b>NOTE</b> <b>(cont.)</b>
Then Z (3, V) consists of elements from the third row of Z in the order:
   Z (3, 2) Z (3, 1) Z (3, 1) Z (3, 3)
Z (U, 2) consists of the column elements:
   Z (1, 2) Z (3, 2) Z (2, 2)
and Z (U, V) consists of the elements:
    Z (1, 2) Z (1, 1) Z (1, 1) Z (1, 3)
    Z (3, 2) Z (3, 1) Z (3, 1) Z (3, 3)
    Z (2, 2) Z (2, 1) Z (2, 1) Z (2, 3)
Because Z (3, V) and Z (U, V) contain duplicate elements from Z, the sections Z (3, V) and Z (U, V) cannot
be redefined as sections.
<b>9.5.4</b> <b>Simply</b> <b>contiguous</b> <b>array</b> <b>designators</b>
A <i>section-subscript-list</i> specifies a simply contiguous section if and only if it does not have a vector subscript and
 all but the last <i>subscript-triplet</i> is a colon,
 the last <i>subscript-triplet</i> does not have a <i>stride</i>, and
 no <i>subscript-triplet</i> is preceded by a <i>section-subscript</i> that is a <i>subscript</i>.
An array designator is simply contiguous if and only if it is
 an <i>object-name</i> that has the CONTIGUOUS attribute,
 an <i>object-name</i> that is not a pointer, not assumed-shape, and not assumed-rank,
 a <i>structure-component</i> whose final <i>part-name</i> is an array and that either has the CONTIGUOUS attribute
  or is not a pointer, or
 an array section
   <b>-</b> that is not a <i>complex-part-designator</i>,
   <b>-</b> that does not have a <i>substring-range</i>,
   <b>-</b> whose final <i>part-ref</i> has nonzero rank,
   <b>-</b> whoserightmost<i>part-name</i> hastheCONTIGUOUSattributeorisneitherassumed-shapenorapointer,
    and
   <b>-</b> which either does not have a <i>section-subscript-list</i>, or has a <i>section-subscript-list</i> which specifies a
    simply contiguous section.
An array <i>variable</i> is simply contiguous if and only if it is a simply contiguous array designator or a reference to
a function that returns a pointer with the CONTIGUOUS attribute.
<b>NOTE</b>
Array sections that are simply contiguous include column, plane, cube, and hypercube subobjects of a simply
contiguous base object, for example:
   ARRAY1 (10:20, 3) Passes part of the third column of ARRAY1.
   X3D (:, i:j, 2) Passes part of the second plane of X3D (or the whole
                   plane if i==LBOUND (X3D, 2) and j==UBOUND (X3D, 2).
   Y5D (:, :, :, :, 7) Passes the seventh hypercube of Y5D.
All simply contiguous designators designate contiguous objects.
<b>9.6</b> <b>Image</b> <b>selectors</b>
An image selector determines the image index for a coindexed object.
R926 <i>image-selector</i> <b>is</b> <i>lbracket</i> <i>cosubscript-list</i> [ , <i>image-selector-spec-list</i> ] <i>rbracket</i>
R927 <i>cosubscript</i> <b>is</b> <i>scalar-int-expr</i>
R928 <i>image-selector-spec</i> <b>is</b> NOTIFY = <i>notify-variable</i>
              <b>or</b> STAT = <i>stat-variable</i>
              <b>or</b> TEAM = <i>team-value</i>
              <b>or</b> TEAM_NUMBER = <i>scalar-int-expr</i>
C932 No specifier shall appear more than once in a given <i>image-selector-spec-list</i>.
C933 A NOTIFY= <i>image-selector-spec</i> shall appear only in the designator of the variable of an intrinsic as-
   signment statement.
C934 TEAM and TEAM_NUMBER shall not both appear in the same <i>image-selector-spec-list</i>.
C935 A <i>stat-variable</i> in an <i>image-selector</i> shall not be a coindexed object.
The number of cosubscripts shall be equal to the corank of the object. The value of a cosubscript in an image
selector shall be within the cobounds for its codimension. Taking account of the cobounds, the cosubscript list in
an image selector determines the image index in the same way that a subscript list in an array element determines
the subscript order value (9.5.3.3), taking account of the bounds.
If a TEAM= specifier appears in an <i>image-selector</i>, the team of the image selector is specified by <i>team-value</i>,
which shall identify the current or an ancestor team; the object shall be an established coarray in that team. If
a TEAM_NUMBER= specifier appears in an <i>image-selector</i> and the current team is not the initial team, the
value of the <i>scalar-int-expr</i> shall be equal to the value of a team number for a sibling team of the current team
and the team of the image selector is that team; the object shall be an established coarray in the parent of the
current team, or be an associating entity of the CHANGE TEAM construct. If a TEAM_NUMBER= specifier
appears in an <i>image-selector</i> and the current team is the initial team, the value of <i>scalar-int-expr</i> shall be the
team number for the initial team; the object shall be an established coarray in the initial team. Otherwise, the
team of the image selector is the current team.
Execution of an assignment statement whose variable has a NOTIFY= specifier atomically increments the count
of the corresponding notify variable on the image specified by the image selector, and does not wait for that
image to execute a corresponding NOTIFY WAIT statement.
An image selector shall specify an image index value that is not greater than the number of images in the team
of the image selector, and identifies the image with that index in that team.
Execution of a statement containing an <i>image-selector</i> with a STAT= specifier causes the <i>stat-variable</i> to become
defined. If the designator is part of an operand that is evaluated or is a variable that is being defined or partly
defined, and the object designated is on a failed image, the <i>stat-variable</i> is defined with the value STAT_-
FAILED_IMAGE (16.10.2.28) in the intrinsic module ISO_FORTRAN_ENV; otherwise, it is defined with the
value zero.
The denotation of a <i>stat-variable</i> in an <i>image-selector</i> shall not depend on the evaluation of any entity in the
same statement. The value of an expression shall not depend on the value of any <i>stat-variable</i> that appears in
the same statement. The value of a <i>stat-variable</i> in an <i>image-selector</i> shall not be affected by the execution of
any part of the statement, other than by whether the image specified by the <i>image-selector</i> has failed.
<b>NOTE</b>
For example, if there are 16 images and the coarray A is declared
   REAL :: A(10)[5,*]
A(:)[1,4] is valid because it specifies image 16, but A(:)[2,4] is invalid because it specifies image 17.
<b>9.7</b> <b>Dynamic</b> <b>association</b>
<b>9.7.1</b> <b>ALLOCATE</b> <b>statement</b>
<b>9.7.1.1</b> <b>Form</b> <b>of</b> <b>the</b> <b>ALLOCATE</b> <b>statement</b>
The ALLOCATE statement dynamically creates pointer targets and allocatable variables.
R929 <i>allocate-stmt</i> <b>is</b> ALLOCATE ( [ <i>type-spec</i> :: ] <i>allocation-list</i>
                   [ , <i>alloc-opt-list</i> ] )
R930 <i>alloc-opt</i> <b>is</b> ERRMSG = <i>errmsg-variable</i>
              <b>or</b> MOLD = <i>source-expr</i>
              <b>or</b> SOURCE = <i>source-expr</i>
              <b>or</b> STAT = <i>stat-variable</i>
R931 <i>errmsg-variable</i> <b>is</b> <i>scalar-default-char-variable</i>
R932 <i>source-expr</i> <b>is</b> <i>expr</i>
R933 <i>allocation</i> <b>is</b> <i>allocate-object</i> [ ( <i>allocate-shape-spec-list</i> ) ]
                   [ <i>lbracket</i> <i>allocate-coarray-spec</i> <i>rbracket</i> ]
              <b>or</b> ( [ <i>lower-bounds-expr</i> : ] <i>upper-bounds-expr</i> )
                   [ <i>lbracket</i> <i>allocate-coarray-spec</i> <i>rbracket</i> ]
R934 <i>allocate-object</i> <b>is</b> <i>variable-name</i>
              <b>or</b> <i>structure-component</i>
R935 <i>allocate-shape-spec</i> <b>is</b> [ <i>lower-bound-expr</i> : ] <i>upper-bound-expr</i>
R936 <i>lower-bound-expr</i> <b>is</b> <i>scalar-int-expr</i>
R937 <i>lower-bounds-expr</i> <b>is</b> <i>int-expr</i>
R938 <i>upper-bound-expr</i> <b>is</b> <i>scalar-int-expr</i>
R939 <i>upper-bounds-expr</i> <b>is</b> <i>int-expr</i>
R940 <i>allocate-coarray-spec</i> <b>is</b> [ <i>allocate-coshape-spec-list</i> , ] [ <i>lower-bound-expr</i> : ] *
R941 <i>allocate-coshape-spec</i> <b>is</b> [ <i>lower-bound-expr</i> : ] <i>upper-bound-expr</i>
C936 (R934) Each <i>allocate-object</i> shall be a data pointer or an allocatable variable.
C937 (R929) If any <i>allocate-object</i> has a deferred type parameter, is unlimited polymorphic, or is of abstract
   type, either <i>type-spec</i> or <i>source-expr</i> shall appear.
C938 (R929) If <i>type-spec</i> appears, it shall specify a type with which each <i>allocate-object</i> is type compatible.
C939 (R929) A<i>type-param-value</i> in a<i>type-spec</i> shall be an asterisk if and only if each <i>allocate-object</i> is a dummy
   argument for which the corresponding type parameter is assumed.
C940 (R929) If <i>type-spec</i> appears, the kind type parameter values of each <i>allocate-object</i> shall be the same as
   the corresponding type parameter values of the <i>type-spec</i>.
C941 (R929) If an <i>allocate-object</i> is a coarray, <i>type-spec</i> shall not specify type C_PTR or C_FUNPTR from
   the intrinsic module ISO_C_BINDING, or type TEAM_TYPE from the intrinsic module ISO_FOR-
   TRAN_ENV.
C942 (R929) If an <i>allocate-object</i> is unlimited polymorphic, <i>type-spec</i> shall not specify a type that has a coarray
   potential subobject component.
C943 (R929) If an <i>allocate-object</i> is an array, either <i>allocate-shape-spec-list</i> or <i>upper-bounds-expr</i> shall appear
   in its <i>allocation</i>, or <i>source-expr</i> shall appear in the ALLOCATE statement and have the same rank as
   the <i>allocate-object</i>.
C944 (R933) If <i>allocate-object</i> is scalar, <i>allocate-shape-spec-list</i> shall not appear.
C945 (R933) An <i>allocate-coarray-spec</i> shall appear if and only if the <i>allocate-object</i> is a coarray.
C946 (R933) The number of <i>allocate-shape-spec</i>s in an <i>allocate-shape-spec-list</i> shall be the same as the rank
   of the <i>allocate-object</i>. The number of <i>allocate-coshape-spec</i>s in an <i>allocate-coarray-spec</i> shall be one less
   than the corank of the <i>allocate-object</i>.
C947 If <i>upper-bounds-expr</i> and <i>lower-bounds-expr</i> both appear in an <i>allocation</i>, at least one of them shall be
   a rank-one array of constant size equal to the rank of <i>allocate-object</i>. Otherwise, if <i>upper-bounds-expr</i>
   appears in an <i>allocation</i>, it shall be a rank-one array of constant size equal to the rank of <i>allocate-object</i>.
C948 (R930) No <i>alloc-opt</i> shall appear more than once in a given <i>alloc-opt-list</i>.
C949 (R929) At most one of <i>source-expr</i> and <i>type-spec</i> shall appear.
C950 (R929) Each <i>allocate-object</i> shall be type compatible (7.3.3) with <i>source-expr</i>. If SOURCE= appears,
   <i>source-expr</i> shall be a scalar or have the same rank as each <i>allocate-object</i>.
C951 (R929) If <i>source-expr</i> appears, the kind type parameters of each <i>allocate-object</i> shall have the same values
   as the corresponding type parameters of <i>source-expr</i>.
C952 (R929) The declared type of <i>source-expr</i> shall not be C_PTR or C_FUNPTR from the intrinsic module
   ISO_C_BINDING, or TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV, if an <i>allocate-</i>
   <i>object</i> is a coarray.
C953 (R929) If an <i>allocate-object</i> is unlimited polymorphic, the declared type of <i>source-expr</i> shall not be a
   type that has a coarray potential subobject component.
C954 (R929) If SOURCE= appears, the declared type of <i>source-expr</i> shall not be EVENT_TYPE, LOCK_-
   TYPE, or NOTIFY_TYPE from the intrinsic module ISO_FORTRAN_ENV, or have a potential sub-
   object component that is a coarray or of type EVENT_TYPE, LOCK_TYPE, or NOTIFY_TYPE.
C955 (R934) An <i>allocate-object</i> shall not be a coindexed object.
<b>NOTE</b> <b>1</b>
A pointer or allocatable component of a coarray can only be allocated by its own image.
   TYPE (SOMETHING), ALLOCATABLE :: T[:]
    ...
   ALLOCATE (T[*]) Allowed - implies synchronization.
   ALLOCATE (T%AAC (N)) Allowed - allocated by its own image.
   ALLOCATE (T[Q]%AAC (N)) Not allowed, because it is coindexed.
An<i>allocate-object</i> oraboundortypeparameterofan <i>allocate-object</i> shallnotdependonthevalueof <i>stat-variable</i>,
the value of <i>errmsg-variable</i>, or on the value, bounds, length type parameters, allocation status, or association
status of any <i>allocate-object</i> in the same ALLOCATE statement.
<i>source-expr</i> shall not be allocated within the ALLOCATE statement in which it appears; nor shall it depend on
the value, bounds, deferred type parameters, allocation status, or association status of any <i>allocate-object</i> in that
statement.
If an ALLOCATE statement has a SOURCE= specifier and an <i>allocate-object</i> that is a coarray, <i>source-expr</i> shall
not have a dynamic type of C_PTR or C_FUNPTR from the intrinsic module ISO_C_BINDING, or EVENT_-
TYPE, LOCK_TYPE, NOTIFY_TYPE, or TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV,
or have a subcomponent whose dynamic type is EVENT_TYPE, LOCK_TYPE, NOTIFY_TYPE, or TEAM_-
TYPE.
If <i>type-spec</i> is specified, each <i>allocate-object</i> is allocated with the specified dynamic type and type parameter
values; if <i>source-expr</i> is specified, each <i>allocate-object</i> is allocated with the dynamic type and type parameter
values of <i>source-expr</i>; otherwise, each <i>allocate-object</i> is allocated with its dynamic type the same as its declared
type. If an <i>allocate-object</i> is unlimited polymorphic, the dynamic type of <i>source-expr</i> shall not have a coarray
potential subobject component.
If a <i>type-param-value</i> in a <i>type-spec</i> in an ALLOCATE statement is an asterisk, it denotes the current value of
that assumed type parameter. If it is an expression, subsequent redefinition or undefinition of any entity in the
expression does not affect the type parameter value.
<b>NOTE</b> <b>2</b>
An example of an ALLOCATE statement is:
   ALLOCATE (X (N), B (-3 : M, 0:9), STAT = IERR_ALLOC)
<b>9.7.1.2</b> <b>Execution</b> <b>of</b> <b>an</b> <b>ALLOCATE</b> <b>statement</b>
When an ALLOCATE statement is executed for an array for which <i>allocate-shape-spec-list</i> is specified, the values
of the lower bound and upper bound expressions determine the bounds of the array. Subsequent redefinition
or undefinition of any entities in the bound expressions do not affect the array bounds. If the lower bound is
omitted, the default value is one. If the upper bound is less than the lower bound, the extent in that dimension
is zero and the array has zero size.
When an ALLOCATE statement is executed for an array for which <i>upper-bounds-expr</i> is specified, it determines
the upper bounds of the array. Subsequent redefinition or undefinition of an entity in a bounds expression does
not affect the array bounds. If <i>lower-bounds-expr</i> appears, it determines the lower bounds; otherwise the default
value is one. If <i>lower-bounds-expr</i> or <i>upper-bounds-expr</i> is scalar, the effect is as if it were broadcast to the shape
of the other. If any element of <i>upper-bounds-expr</i> is less than the corresponding element of <i>lower-bounds-expr</i>,
the extent in the corresponding dimension is zero and the array has zero size.
When an ALLOCATE statement is executed for a coarray, the values of the lower cobound and upper cobound
expressions determine the cobounds of the coarray. Subsequent redefinition or undefinition of any entities in the
cobound expressions do not affect the cobounds. If the lower cobound is omitted, the default value is 1. The
upper cobound shall not be less than the lower cobound.
If an <i>allocation</i> specifies a coarray, its dynamic type and the values of corresponding type parameters shall be
the same on every active image in the current team. The values of corresponding bounds and corresponding
cobounds shall be the same on those images. If the coarray is a dummy argument, the ultimate arguments
(15.5.2.4) on those images shall be corresponding coarrays. If the coarray is an ultimate component of a dummy
argument, the ultimate arguments on those images shall be declared with the same name in the same scoping unit;
if the ultimate argument is an unsaved local variable of a recursive procedure, the execution of the ALLOCATE
statement shall be at the same depth of recursion of that procedure on every active image in the current team.
If the coarray is an ultimate component of an array element, the element shall have the same position in array
element order on those images. If the coarray is an unsaved local variable of a recursive procedure, the execution
of the ALLOCATE statement shall be at the same depth of recursion of that procedure on every active image in
the current team.
When an ALLOCATE statement is executed for which an <i>allocate-object</i> is a coarray, there is an implicit syn-
chronization of all active images in the current team. If the current team contains a stopped or failed image,
an error condition occurs. If no other error condition occurs, execution on the active images of the segment
(11.7.2) following the statement is delayed until all other active images in the current team have executed the
same statement the same number of times in this team. The segments that executed before the ALLOCATE
statement on an active image of this team precede the segments that execute after the ALLOCATE statement on
another active image of this team. The coarray shall not become allocated on an image unless it is successfully
allocated on all active images in this team.
<b>NOTE</b>
When an image executes an ALLOCATE statement, communication is not necessarily involved apart from any
required for synchronization. The image allocates its coarray and records how the corresponding coarrays on
other images are to be addressed. The processor is not required to detect violations of the rule that the bounds
are the same on all images of the current team, nor is it responsible for detecting or resolving deadlock problems
(such as two images waiting on different ALLOCATE statements.).
If <i>source-expr</i> is a pointer, it shall be associated with a target. If <i>source-expr</i> is allocatable, it shall be allocated.
When an ALLOCATE statement is executed for an array with no <i>allocate-shape-spec-list</i> or <i>upper-bounds-expr</i>,
the array is allocated with the shape of <i>source-expr</i>, and with each lower bound equal to the corresponding
element of LBOUND (<i>source-expr</i>). Subsequent changes to the bounds of <i>source-expr</i> do not affect the array
bounds.
If SOURCE= appears, <i>source-expr</i> shall be conformable with <i>allocation</i>. If an <i>allocate-object</i> is not polymorphic
and the <i>source-expr</i> is polymorphic with a dynamic type that differs from its declared type, the value provided for
that<i>allocate-object</i> is the ancestor component of the <i>source-expr</i> that has the type of the <i>allocate-object</i>; otherwise
the value provided is the value of the <i>source-expr</i>. On successful allocation, if <i>allocate-object</i> and <i>source-expr</i>
have the same rank the value of <i>allocate-object</i> becomes the value provided, otherwise the value of each element
of <i>allocate-object</i> becomes the value provided. The <i>source-expr</i> is evaluated exactly once for each execution of an
ALLOCATE statement.
If MOLD= appears and <i>source-expr</i> is a variable, its value need not be defined.
If<i>type-spec</i> appearsandthevalueofalengthtypeparameteritspecifiesdiffersfromthevalueofthecorresponding
nondeferred type parameter specified in the declaration of any <i>allocate-object</i>, an error condition occurs. If the
value of a nondeferred length type parameter of an <i>allocate-object</i> differs from the value of the corresponding type
parameter of <i>source-expr</i>, an error condition occurs.
The set of error conditions for an ALLOCATE statement is processor dependent. If an error condition occurs
during execution of an ALLOCATE statement that does not contain the STAT= specifier, error termination is
initiated. The STAT= specifier is described in 9.7.4. The ERRMSG= specifier is described in 9.7.5.
<b>9.7.1.3</b> <b>Allocation</b> <b>of</b> <b>allocatable</b> <b>variables</b>
The allocation status of an allocatable entity is one of the following at any time.
 The status of an allocatable variable becomes "allocated" if it is allocated by an ALLOCATE statement, if
  it is allocated during assignment, or if it is given that status by the intrinsic subroutine MOVE_ALLOC
  (16.9.147). An allocatable variable with this status may be referenced, defined, or deallocated; allocating it
  causes an error condition in the ALLOCATE statement. The result of the intrinsic function ALLOCATED
  (16.9.13) is true for such a variable.
 An allocatable variable has a status of "unallocated" if it is not allocated. The status of an allocatable
  variable becomes unallocated if it is deallocated (9.7.3) or if it is given that status by the intrinsic sub-
  routine MOVE_ALLOC. An allocatable variable with this status shall not be referenced or defined. It shall
  not be supplied as an actual argument corresponding to a nonallocatable nonoptional dummy argument,
  except to certain intrinsic inquiry functions. It may be allocated with the ALLOCATE statement. Deal-
  locating it causes an error condition in the DEALLOCATE statement. The result of the intrinsic function
  ALLOCATED (16.9.13) is false for such a variable.
At the beginning of execution of a program, allocatable variables are unallocated.
When the allocation status of an allocatable variable changes, the allocation status of any associated allocat-
able variable changes accordingly. Allocation of an allocatable variable establishes values for the deferred type
parameters of all associated allocatable variables.
Anunsavedallocatablelocalvariableofaprocedurehasastatusofunallocatedatthebeginningofeachinvocation
of the procedure. An unsaved allocatable local variable of a construct has a status of unallocated at the beginning
of each execution of the construct.
When an object of derived type is created by an ALLOCATE statement, any allocatable ultimate components
have an allocation status of unallocated unless the SOURCE= specifier appears and the corresponding component
of the <i>source-expr</i> is allocated.
If the evaluation of a function would change the allocation status of a variable and if a reference to the function
appears in an expression in which the value of the function is not needed to determine the value of the expression,
the allocation status of the variable after evaluation of the expression is processor dependent.
<b>9.7.1.4</b> <b>Allocation</b> <b>of</b> <b>pointer</b> <b>targets</b>
AllocationofapointercreatesanobjectthatimplicitlyhastheTARGETattribute. Followingsuccessfulexecution
of an ALLOCATE statement for a pointer, the pointer is associated with the target and can be used to reference
or define the target. Additional pointers can become associated with the pointer target or a part of the pointer
target by pointer assignment. It is not an error to allocate a pointer that is already associated with a target.
In this case, a new pointer target is created as required by the attributes of the pointer and any array bounds,
type, and type parameters specified by the ALLOCATE statement. The pointer is then associated with this
new target. Any previous association of the pointer with a target is broken. If the previous target had been
created by allocation, it becomes inaccessible unless other pointers are associated with it. The intrinsic function
ASSOCIATED (16.9.20) can be used to determine whether a pointer that does not have undefined association
status is associated.
At the beginning of execution of a function whose result is a pointer, the association status of the result pointer
is undefined. Before such a function returns, it shall either associate a target with this pointer or cause the
association status of this pointer to become disassociated.
<b>9.7.2</b> <b>NULLIFY</b> <b>statement</b>
R942 <i>nullify-stmt</i> <b>is</b> NULLIFY ( <i>pointer-object-list</i> )
R943 <i>pointer-object</i> <b>is</b> <i>variable-name</i>
              <b>or</b> <i>structure-component</i>
              <b>or</b> <i>proc-pointer-name</i>
C956 (R943) Each <i>pointer-object</i> shall have the POINTER attribute.
A <i>pointer-object</i> shall not depend on the value, bounds, or association status of another <i>pointer-object</i> in the
same NULLIFY statement.
Execution of a NULLIFY statement causes each <i>pointer-object</i> to become disassociated.
<b>NOTE</b>
When a NULLIFY statement is applied to a polymorphic pointer (7.3.2.3), its dynamic type becomes the same
as its declared type.
<b>9.7.3</b> <b>DEALLOCATE</b> <b>statement</b>
<b>9.7.3.1</b> <b>Form</b> <b>of</b> <b>the</b> <b>DEALLOCATE</b> <b>statement</b>
The DEALLOCATE statement causes allocatable variables to be deallocated; it causes pointer targets to be
deallocated and the pointers to be disassociated.
R944 <i>deallocate-stmt</i> <b>is</b> DEALLOCATE ( <i>allocate-object-list</i> [ , <i>dealloc-opt-list</i> ] )
R945 <i>dealloc-opt</i> <b>is</b> STAT = <i>stat-variable</i>
              <b>or</b> ERRMSG = <i>errmsg-variable</i>
C957 (R945) No <i>dealloc-opt</i> shall appear more than once in a given <i>dealloc-opt-list</i>.
An <i>allocate-object</i> shall not depend on the value, bounds, allocation status, or association status of another
<i>allocate-object</i> in the same DEALLOCATE statement; it also shall not depend on the value of the <i>stat-variable</i>
or <i>errmsg-variable</i> in the same DEALLOCATE statement.
The set of error conditions for a DEALLOCATE statement is processor dependent. If an error condition occurs
during execution of a DEALLOCATE statement that does not contain the STAT= specifier, error termination is
initiated. The STAT= specifier is described in 9.7.4. The ERRMSG= specifier is described in 9.7.5.
When more than one allocated object is deallocated by execution of a DEALLOCATE statement, the order of
deallocation is processor dependent.
<b>NOTE</b>
An example of a DEALLOCATE statement is:
   DEALLOCATE (X, B)
<b>9.7.3.2</b> <b>Deallocation</b> <b>of</b> <b>allocatable</b> <b>variables</b>
Deallocating an unallocated allocatable variable causes an error condition in the DEALLOCATE statement.
Deallocating an allocatable variable with the TARGET attribute causes the pointer association status of any
pointer associated with it to become undefined. An allocatable variable shall not be deallocated if it or any
subobject of it is argument associated with a dummy argument or construct associated with an associate name.
When the execution of a procedure is terminated by execution of a RETURN or END statement, an unsaved
allocatable local variable of the procedure retains its allocation and definition status if it is a function result or a
subobject thereof; otherwise, if it is allocated it will be deallocated.
When a BLOCK construct terminates, any unsaved allocated allocatable local variable of the construct is deal-
located.
If an executable construct references a function whose result is allocatable or has an allocatable subobject, and
the function reference is executed, an allocatable result and any allocated allocatable subobject of the result is
deallocated after execution of the innermost executable construct containing the reference.
If a function whose result is allocatable or has an allocatable subobject is referenced in the specification part of a
scoping unit, and the function reference is executed, an allocatable result and any allocated allocatable subobject
of the result is deallocated before execution of the executable constructs of the scoping unit.
When a procedure is invoked, any allocated allocatable object that is an actual argument corresponding to an
INTENT (OUT) allocatable dummy argument is deallocated; any allocated allocatable object that is a subobject
of an actual argument corresponding to an INTENT (OUT) dummy argument is deallocated. If a Fortran proced-
ure that has an INTENT (OUT) allocatable dummy argument is invoked by a C function and the corresponding
argument in the C function call is a C descriptor that describes an allocated allocatable variable, the variable
is deallocated on entry to the Fortran procedure. If a C function is invoked from a Fortran procedure via an
interface with an INTENT (OUT) allocatable dummy argument and the corresponding actual argument in the
reference to the C function is an allocated allocatable variable, the variable is deallocated on invocation (before
execution of the C function begins).
When an intrinsic assignment statement (10.2.1.3) is executed, any noncoarray allocated allocatable subobject of
the variable is deallocated before the assignment takes place.
When a variable of derived type is deallocated, any allocated allocatable subobject is deallocated. If an error
condition occurs during deallocation, it is processor dependent whether an allocated allocatable subobject is
deallocated.
If an allocatable component is a subobject of a finalizable object, any final subroutine for that object is executed
before the component is automatically deallocated.
When a statement that deallocates a coarray or an object with a coarray potential subobject component is
executed, there is an implicit synchronization of all active images in the current team. If the current team
contains a stopped or failed image, an error condition occurs. If no other error condition occurs, execution on the
active images of the segment (11.7.2) following the statement is delayed until all other active images in the current
team have executed the same statement the same number of times in this team. The segments that executed
before the statement on an active image of this team precede the segments that execute after the statement on
another active image of this team. A coarray shall not become deallocated on an image unless it is successfully
deallocated on all active images in this team.
If an <i>allocate-object</i> is a coarray dummy argument, the ultimate arguments (15.5.2.4) on those images shall be
corresponding coarrays.
The effect of automatic deallocation is the same as that of a DEALLOCATE statement without a <i>dealloc-opt-list</i>.
<b>NOTE</b> <b>1</b>
In the following example:
   SUBROUTINE PROCESS
    REAL, ALLOCATABLE :: TEMP (:)
    REAL, ALLOCATABLE, SAVE :: X (:)
     ...
   END SUBROUTINE PROCESS
on return from subroutine PROCESS, the allocation status of X is preserved because X has the SAVE attribute.
TEMP does not have the SAVE attribute, so it will be deallocated if it was allocated. On the next invocation
of PROCESS, TEMP will have an allocation status of unallocated.
<b>NOTE</b> <b>2</b>
For example, executing a RETURN, END, or END BLOCK statement, or deallocating an object that has an
allocatable subobject, can cause deallocation of a coarray, and thus an implicit synchronization of all active
images in the current team.
<b>9.7.3.3</b> <b>Deallocation</b> <b>of</b> <b>pointer</b> <b>targets</b>
If a pointer appears in a DEALLOCATE statement, its association status shall be defined. Deallocating a pointer
that is disassociated or whose target was not created by an ALLOCATE statement causes an error condition
in the DEALLOCATE statement. If a pointer is associated with an allocatable entity, the pointer shall not be
deallocated. A pointer shall not be deallocated if its target or any subobject thereof is argument associated with
a dummy argument or construct associated with an associate name.
If a pointer appears in a DEALLOCATE statement, it shall be associated with the whole of an object that was
created by allocation. The pointer shall have the same dynamic type and type parameters as the allocated object,
and if the allocated object is an array the pointer shall be an array whose elements are the same as those of the
allocated object in array element order. Deallocating a pointer target causes the pointer association status of any
other pointer that is associated with the target or a portion of the target to become undefined.
<b>9.7.4</b> <b>STAT=</b> <b>specifier</b>
R946 <i>stat-variable</i> <b>is</b> <i>scalar-int-variable</i>
A <i>stat-variable</i> should have a decimal exponent range of at least four; otherwise the processor-dependent error
code might not be representable in the variable.
This rest of this subclause applies where an <i>alloc-opt</i> or <i>dealloc-opt</i> that is a STAT= specifier appears in an
ALLOCATE or DEALLOCATE statement.
The <i>stat-variable</i> shall not be allocated or deallocated within the ALLOCATE or DEALLOCATE statement
in which it appears; nor shall it depend on the value, bounds, deferred type parameters, allocation status, or
association status of any <i>allocate-object</i> in that statement. The <i>stat-variable</i> shall not depend on the value of the
<i>errmsg-variable</i>.
Successful execution of the ALLOCATE or DEALLOCATE statement causes the <i>stat-variable</i> to become defined
with a value of zero.
If an ALLOCATE statement with a coarray <i>allocate-object</i>, or a DEALLOCATE statement with an <i>allocate-</i>
<i>object</i> that is a coarray or which has a coarray potential subobject component, is executed when the current
team contains a stopped image, the <i>stat-variable</i> becomes defined with the value STAT_STOPPED_IMAGE
from the intrinsic module ISO_FORTRAN_ENV (16.10.2). Otherwise, if such a statement is executed when the
current team contains a failed image, and no other error condition occurs, the <i>stat-variable</i> becomes defined with
value STAT_FAILED_IMAGE from the intrinsic module ISO_FORTRAN_ENV. If any other error condition
occurs during execution of the ALLOCATE or DEALLOCATE statement, the <i>stat-variable</i> becomes defined with
a processor-dependent positive integer value different from STAT_STOPPED_IMAGE and STAT_FAILED_-
IMAGE.
If <i>stat-variable</i> became defined with the value STAT_FAILED_IMAGE, each <i>allocate-object</i> is successfully al-
located or deallocated on all the active images of the current team. If any other error condition occurs, each
<i>allocate-object</i> has a processor-dependent status:
 each <i>allocate-object</i> that was successfully allocated shall have an allocation status of allocated or a pointer
  association status of associated;
 each <i>allocate-object</i> that was successfully deallocated shall have an allocation status of unallocated or a
  pointer association status of disassociated;
 each <i>allocate-object</i> that was not successfully allocated or deallocated shall retain its previous allocation
  status or pointer association status.
<b>NOTE</b>
The status of objects that were not successfully allocated or deallocated can be individually checked with the
intrinsic functions ALLOCATED or ASSOCIATED.
<b>9.7.5</b> <b>ERRMSG=</b> <b>specifier</b>
The <i>errmsg-variable</i> shall not be an <i>allocate-object</i> of the ALLOCATE or DEALLOCATE statement in which
it appears; nor shall it depend on the value, bounds, deferred type parameters, allocation status, or association
status of any <i>allocate-object</i> in that statement. The <i>errmsg-variable</i> shall not depend on the value of the <i>stat-</i>
<i>variable</i>.
IfanerrorconditionoccursduringexecutionofanALLOCATEorDEALLOCATEstatementwithanERRMSG=
specifier, the<i>errmsg-variable</i> isassignedanexplanatorymessage, asifbyintrinsicassignment. Ifnosuchcondition
occurs, the definition status and value of <i>errmsg-variable</i> are unchanged.
<b>10</b> <b>Expressions</b> <b>and</b> <b>assignment</b>
<b>10.1</b> <b>Expressions</b>
<b>10.1.1</b> <b>Expression</b> <b>semantics</b>
An expression represents either a data object reference or a computation, and its value is either a scalar or an
array. Evaluation of an expression produces a value, which has a type, type parameters (if appropriate), and a
shape (10.1.9). The corank of an expression that is not a variable is zero.
<b>10.1.2</b> <b>Form</b> <b>of</b> <b>an</b> <b>expression</b>
<b>10.1.2.1</b> <b>Overall</b> <b>expression</b> <b>syntax</b>
An expression is formed from operands, operators, and parentheses. An operand is either a scalar or an array.
An operation is either intrinsic (10.1.5) or defined (10.1.6). More complicated expressions can be formed using
operands which are themselves expressions.
An expression is defined in terms of several categories: primary, level-1 expression, level-2 expression, level-3
expression, level-4 expression, and level-5 expression.
These categories are related to the different operator precedence levels and, in general, are defined in terms of
other categories. The simplest form of each expression category is a <i>primary</i>.
<b>10.1.2.2</b> <b>Primary</b>
R1001 <i>primary</i> <b>is</b> <i>literal-constant</i>
              <b>or</b> <i>designator</i>
              <b>or</b> <i>array-constructor</i>
              <b>or</b> <i>structure-constructor</i>
              <b>or</b> <i>enum-constructor</i>
              <b>or</b> <i>enumeration-constructor</i>
              <b>or</b> <i>function-reference</i>
              <b>or</b> <i>type-param-inquiry</i>
              <b>or</b> <i>type-param-name</i>
              <b>or</b> ( <i>expr</i> )
              <b>or</b> <i>conditional-expr</i>
C1001 (R1001) The <i>type-param-name</i> shall be the name of a type parameter.
C1002 (R1001) The <i>designator</i> shall not be a whole assumed-size array.
C1003 (R1001) The <i>expr</i> shall not be a function reference that returns a procedure pointer.
<b>NOTE</b>
Examples of a <i>primary</i> are:
   Example Syntactic class
   1.0 <i>constant</i>
   'ABCDEFGHIJKLMNOPQRSTUVWXYZ' (I:I) <i>designator</i>
   [ 1.0, 2.0 ] <i>array-constructor</i>
   PERSON ('Jones', 12) <i>structure-constructor</i>
   F (X, Y) <i>function-reference</i>
                <b>J3/23-007r1</b> <b>153</b>
<b>NOTE</b> <b>(cont.)</b>
   X%KIND <i>type-param-inquiry</i>
   KIND <i>type-param-name</i>
   (S + T) (<i>expr</i>)
<b>10.1.2.3</b> <b>Conditional</b> <b>expressions</b>
A conditional expression is a primary that selectively evaluates a chosen subexpression.
R1002 <i>conditional-expr</i> <b>is</b> ( <i>scalar-logical-expr</i> ? <i>expr</i> [ : <i>scalar-logical-expr</i> ? <i>expr</i> ]... : <i>expr</i> )
C1004 Each <i>expr</i> of a <i>conditional-expr</i> shall have the same declared type, kind type parameters, and rank.
<b>NOTE</b>
Examples of a conditional expression are:
   ( ABS (RESIDUAL)<=TOLERANCE ? 'ok' : 'did not converge' )
   ( I>0 .AND. I<=SIZE (A) ? A (I) : PRESENT (VAL) ? VAL : 0.0 )
<b>10.1.2.4</b> <b>Level-1</b> <b>expressions</b>
Defined unary operators have the highest operator precedence (Table 10.1). Level-1 expressions are primaries
optionally operated on by defined unary operators:
R1003 <i>level-1-expr</i> <b>is</b> [ <i>defined-unary-op</i> ] <i>primary</i>
R1004 <i>defined-unary-op</i> <b>is</b> . <i>letter</i> [ <i>letter</i> ] ... .
C1005 (R1004) A <i>defined-unary-op</i> shall not contain more than 63 letters and shall not be the same as any
   <i>intrinsic-operator</i> or <i>logical-literal-constant</i>.
<b>NOTE</b>
Simple examples of a level-1 expression are:
  Example Syntactic class
  A <i>primary</i> (R1001)
  .INVERSE. B <i>level-1-expr</i> (R1003)
A more complicated example of a level-1 expression is:
  .INVERSE. (A + B)
<b>10.1.2.5</b> <b>Level-2</b> <b>expressions</b>
Level-2 expressions are level-1 expressions optionally involving the numeric operators <i>power-op</i>, <i>mult-op</i>, and
<i>add-op</i>.
R1005 <i>mult-operand</i> <b>is</b> <i>level-1-expr</i> [ <i>power-op</i> <i>mult-operand</i> ]
R1006 <i>add-operand</i> <b>is</b> [ <i>add-operand</i> <i>mult-op</i> ] <i>mult-operand</i>
R1007 <i>level-2-expr</i> <b>is</b> [ [ <i>level-2-expr</i> ] <i>add-op</i> ] <i>add-operand</i>
R1008 <i>power-op</i> <b>is</b> **
R1009 <i>mult-op</i> <b>is</b> *
              <b>or</b> /
R1010 <i>add-op</i> <b>is</b> +
              <b>or</b> -
<b>NOTE</b>
Simple examples of a level-2 expression are:
    Example Syntactic class Remarks
   A <i>level-1-expr</i> A is a <i>primary</i>. (R1003)
   B ** C <i>mult-operand</i> B is a <i>level-1-expr</i>, ** is a <i>power-op</i>,
                     and C is a <i>mult-operand</i>. (R1005)
   D * E <i>add-operand</i> D is an <i>add-operand</i>, * is a <i>mult-op</i>,
                     and E is a <i>mult-operand</i>. (R1006)
   +1 <i>level-2-expr</i> + is an <i>add-op</i> and 1 is an <i>add-operand</i>. (R1007)
   F - I <i>level-2-expr</i> F is a <i>level-2-expr</i>, - is an <i>add-op</i>,
                     and I is an <i>add-operand</i>. (R1007)
A more complicated example of a level-2 expression is:
   - A + D * E + B ** C
<b>10.1.2.6</b> <b>Level-3</b> <b>expressions</b>
Level-3 expressions are level-2 expressions optionally involving the character operator <i>concat-op</i>.
R1011 <i>level-3-expr</i> <b>is</b> [ <i>level-3-expr</i> <i>concat-op</i> ] <i>level-2-expr</i>
R1012 <i>concat-op</i> <b>is</b> //
<b>NOTE</b>
Simple examples of a level-3 expression are:
  Example Syntactic class
  A <i>level-2-expr</i> (R1007)
  B // C <i>level-3-expr</i> (R1011)
A more complicated example of a level-3 expression is:
  X // Y // 'ABCD'
<b>10.1.2.7</b> <b>Level-4</b> <b>expressions</b>
Level-4 expressions are level-3 expressions optionally involving the relational operators <i>rel-op</i>.
R1013 <i>level-4-expr</i> <b>is</b> [ <i>level-3-expr</i> <i>rel-op</i> ] <i>level-3-expr</i>
R1014 <i>rel-op</i> <b>is</b> .EQ.
              <b>or</b> .NE.
              <b>or</b> .LT.
              <b>or</b> .LE.
              <b>or</b> .GT.
              <b>or</b> .GE.
              <b>or</b> ==
              <b>or</b> /=
              <b>or</b> <i><</i>
              <b>or</b> <i><</i>=
              <b>or</b> <i>></i>
              <b>or</b> <i>></i>=
<b>NOTE</b>
Simple examples of a level-4 expression are:
  Example Syntactic class
  A <i>level-3-expr</i> (R1011)
  B == C <i>level-4-expr</i> (R1013)
  D <i><</i> E <i>level-4-expr</i> (R1013)
A more complicated example of a level-4 expression is:
  (A + B) /= C
<b>10.1.2.8</b> <b>Level-5</b> <b>expressions</b>
Level-5 expressions are level-4 expressions optionally involving the logical operators <i>not-op</i>, <i>and-op</i>, <i>or-op</i>, and
<i>equiv-op</i>.
R1015 <i>and-operand</i> <b>is</b> [ <i>not-op</i> ] <i>level-4-expr</i>
R1016 <i>or-operand</i> <b>is</b> [ <i>or-operand</i> <i>and-op</i> ] <i>and-operand</i>
R1017 <i>equiv-operand</i> <b>is</b> [ <i>equiv-operand</i> <i>or-op</i> ] <i>or-operand</i>
R1018 <i>level-5-expr</i> <b>is</b> [ <i>level-5-expr</i> <i>equiv-op</i> ] <i>equiv-operand</i>
R1019 <i>not-op</i> <b>is</b> .NOT.
R1020 <i>and-op</i> <b>is</b> .AND.
R1021 <i>or-op</i> <b>is</b> .OR.
R1022 <i>equiv-op</i> <b>is</b> .EQV.
              <b>or</b> .NEQV.
<b>NOTE</b>
Simple examples of a level-5 expression are:
  Example Syntactic class
  A <i>level-4-expr</i> (R1013)
  .NOT. B <i>and-operand</i> (R1015)
  C .AND. D <i>or-operand</i> (R1016)
  E .OR. F <i>equiv-operand</i> (R1017)
  G .EQV. H <i>level-5-expr</i> (R1018)
  S .NEQV. T <i>level-5-expr</i> (R1018)
A more complicated example of a level-5 expression is:
  A .AND. B .EQV. .NOT. C
<b>10.1.2.9</b> <b>General</b> <b>form</b> <b>of</b> <b>an</b> <b>expression</b>
Expressions are level-5 expressions optionally involving defined binary operators. Defined binary operators have
the lowest operator precedence (Table 10.1).
R1023 <i>expr</i> <b>is</b> [ <i>expr</i> <i>defined-binary-op</i> ] <i>level-5-expr</i>
R1024 <i>defined-binary-op</i> <b>is</b> . <i>letter</i> [ <i>letter</i> ] ... .
C1006 (R1024) A <i>defined-binary-op</i> shall not contain more than 63 letters and shall not be the same as any
   <i>intrinsic-operator</i> or <i>logical-literal-constant</i>.
<b>NOTE</b>
Simple examples of an expression are:
  Example Syntactic class
  A <i>level-5-expr</i> (R1018)
  B.UNION.C <i>expr</i> (R1023)
More complicated examples of an expression are:
  (B .INTERSECT. C) .UNION. (X - Y)
  A + B == C * D
  .INVERSE. (A + B)
  A + B .AND. C * D
  E // G == H (1:10)
<b>10.1.3</b> <b>Precedence</b> <b>of</b> <b>operators</b>
There is a precedence among the intrinsic and extension operations corresponding to the form of expressions
specified in 10.1.2, which determines the order in which the operands are combined unless the order is changed
by the use of parentheses. This precedence order is summarized in Table 10.1.
       <b>Table</b> <b>10.1</b> <b>-</b> <b>Categories</b> <b>of</b> <b>operations</b> <b>and</b> <b>relative</b> <b>precedence</b>
        Category of operation Operators Precedence
           Extension <i>defined-unary-op</i> Highest
           Numeric ** .
           Numeric *, / .
           Numeric unary +, - .
           Numeric binary +, - .
           Character // .
           Relational .EQ., .NE., .LT., .LE., .GT., .GE.,
                     ==, /=, <i><</i>, <i><</i>=, <i>></i>, <i>></i>= .
           Logical .NOT. .
           Logical .AND. .
           Logical .OR. .
           Logical .EQV., .NEQV. .
           Extension <i>defined-binary-op</i> Lowest
The precedence of a defined operation is that of its operator.
<b>NOTE</b> <b>1</b>
For example, in the expression
   -A ** 2
the exponentiation operator (**) has precedence over the negation operator (-); therefore, the operands of
the exponentiation operator are combined to form an expression that is used as the operand of the negation
operator. The interpretation of the above expression is the same as the interpretation of the expression
   - (A ** 2)
The general form of an expression (10.1.2) also establishes a precedence among operators in the same syntactic
class. This precedence determines the order in which the operands are to be combined in determining the
interpretation of the expression unless the order is changed by the use of parentheses.
<b>NOTE</b> <b>2</b>
In interpreting a <i>level-2-expr</i> containing two or more binary operators + or -, each operand (<i>add-operand</i>) is
combined from left to right. Similarly, the same left-to-right interpretation for a <i>mult-operand</i> in <i>add-operand</i>,
as well as for other kinds of expressions, is a consequence of the general form. However, for interpreting a
<i>mult-operand</i> expression when two or more exponentiation operators ** combine <i>level-1-expr</i> operands, each
<i>level-1-expr</i> is combined from right to left.
For example, the expressions
   2.1 + 3.4 + 4.9
   2.1 * 3.4 * 4.9
   2.1 / 3.4 / 4.9
   2 ** 3 ** 4
   'AB' // 'CD' // 'EF'
have the same interpretations as the expressions
   (2.1 + 3.4) + 4.9
   (2.1 * 3.4) * 4.9
   (2.1 / 3.4) / 4.9
   2 ** (3 ** 4)
   ('AB' // 'CD') // 'EF'
As a consequence of the general form (10.1.2), only the first <i>add-operand</i> of a <i>level-2-expr</i> can be preceded
by the identity (+) or negation (-) operator. These formation rules do not permit expressions containing two
consecutive numeric operators, such as A ** -B or A + -B. However, expressions such as A ** (-B) and
A + (-B) are permitted. The rules do allow a binary operator or an intrinsic unary operator to be followed by
a defined unary operator, such as:
   A * .INVERSE. B
   - .INVERSE. (B)
As another example, in the expression
   A .OR. B .AND. C
the general form implies a higher precedence for the .AND. operator than for the .OR. operator; therefore, the
interpretation of the above expression is the same as the interpretation of the expression
   A .OR. (B .AND. C)
<b>NOTE</b> <b>3</b>
An expression can contain more than one category of operator. The logical expression
   L .OR. A + B >= C
where A, B, and C are of type real, and L is of type logical, contains a numeric operator, a relational operator,
and a logical operator. This expression would be interpreted the same as the expression
   L .OR. ((A + B) >= C)
<b>NOTE</b> <b>4</b>
If
  the operator ** is extended to type logical,
  the operator .STARSTAR. is defined to duplicate the function of ** on type real,
  .MINUS. is defined to duplicate the unary operator -, and
  L1 and L2 are type logical and X and Y are type real,
then in precedence: L1 ** L2 is higher than X * Y; X * Y is higher than X .STARSTAR. Y; and .MINUS. X
is higher than -X.
<b>10.1.4</b> <b>Evaluation</b> <b>of</b> <b>operations</b>
An intrinsic operation requires the values of its operands.
Execution of a function reference in the logical expression in an IF statement (11.1.8.4), the mask expression in a
WHERE statement (10.2.3.1), or the <i>concurrent-limit</i>s and <i>concurrent-step</i>s in a FORALL statement (10.2.4) is permitted to
define variables in the subsidiary <i>action-stmt</i>, <i>where-assignment-stmt</i>, or <i>forall-assignment-stmt</i> respectively. Except
in those cases:
 the evaluation of a function reference shall neither affect nor be affected by the evaluation of any other
  entity within the statement;
 if a function reference causes definition or undefinition of an actual argument of the function, that argument
  or any associated entities shall not appear elsewhere in the same statement.
<b>NOTE</b> <b>1</b>
For example, the statements
   A (I) = F (I)
   Y = G (X) + X
are prohibited if the reference to F defines or undefines I or the reference to G defines or undefines X.
However, in the statements
   IF (F (X)) A = X
   WHERE (G (X)) B = X
the reference to F and/or the reference to G can define X.
The appearance of an array constructor requires the evaluation of each <i>scalar-int-expr</i> of the<i>ac-implied-do-control</i>
in any <i>ac-implied-do</i> it contains.
When an elemental binary operation is applied to a scalar and an array or to two arrays of the same shape, the
operation is performed element-by-element on corresponding array elements of the array operands.
<b>NOTE</b> <b>2</b>
For example, the array expression
   A + B
produces an array of the same shape as A and B. The individual array elements of the result have the values of
the first element of A added to the first element of B, the second element of A added to the second element of
B, etc.
When an elemental unary operator operates on an array operand, the operation is performed element-by-element,
and the result is the same shape as the operand. If an elemental operation is intrinsically pure or is implemented
by a pure elemental function (15.9), the element operations may be performed simultaneously or in any order.
Evaluation of a <i>conditional-expr</i> evaluates each <i>scalar-logical-expr</i> in order, until the value of a <i>scalar-logical-expr</i>
is true, or there are no more <i>scalar-logical-expr</i>s. If the value of a <i>scalar-logical-expr</i> is true, its subsequent <i>expr</i>
is chosen; otherwise, the last <i>expr</i> of the <i>conditional-expr</i> is chosen. The chosen <i>expr</i> is evaluated, and its value
is the value of the conditional expression.
The declared type, kind type parameters, and rank of a <i>conditional-expr</i> are the same as those of its <i>expr</i>s. The
dynamic type, length type parameters, and shape are those of the chosen <i>expr</i>. A <i>conditional-expr</i> is polymorphic
if and only if one or more of its <i>expr</i>s is polymorphic.
<b>NOTE</b> <b>3</b>
Only one <i>expr</i> of a conditional expression is evaluated, and any of its <i>scalar-logical-expr</i>s subsequent to one that
evaluates to true are not evaluated.
<b>10.1.5</b> <b>Intrinsic</b> <b>operations</b>
<b>10.1.5.1</b> <b>Intrinsic</b> <b>operation</b> <b>classification</b>
An intrinsic operation is either a unary or binary operation. An intrinsic unary operation is an operation of the
form <i>intrinsic-operator</i> <i>x</i>
            2
           where <i>x</i>
                 2
                is of a type (7.4, 7.6) listed in Table 10.2 for the unary intrinsic operator.
An intrinsic binary operation is an operation of the form<i>x</i>
                            1
                         <i>intrinsic-operator</i> <i>x</i>
                                       2
                                   where<i>x</i>
                                            1
                                       and<i>x</i>
                                               2
                                          are conformable
and of the types listed in Table 10.2 for the binary intrinsic operator.
A numeric intrinsic operation is an intrinsic operation for which the <i>intrinsic-operator</i> is a numeric operator (+,
-, *, /, or **). A numeric intrinsic operator is the operator in a numeric intrinsic operation.
The character intrinsic operation is the intrinsic operation for which the <i>intrinsic-operator</i> is (//) and both
operands are of type character with the same kind type parameter. The character intrinsic operator is the
operator in a character intrinsic operation.
A logical intrinsic operation is an intrinsic operation for which the <i>intrinsic-operator</i> is .AND., .OR., .NOT.,
.EQV., or .NEQV. and both operands are of type logical. A logical intrinsic operator is the operator in a logical
intrinsic operation.
A relational intrinsic operator is an <i>intrinsic-operator</i> that is .EQ., .NE., .GT., .GE., .LT., .LE., ==, /=, <i>></i>,
<i>></i>=, <i><</i>, or <i><</i>=. A relational intrinsic operation is an intrinsic operation for which the <i>intrinsic-operator</i> is a
relational intrinsic operator. A numeric relational intrinsic operation is a relational intrinsic operation for which
both operands are of numeric type. A character relational intrinsic operation is a relational intrinsic operation for
which both operands are of type character. An enumeration relational intrinsic operation is a relational intrinsic
operation for which both operands are of the same enumeration type. An enum relational intrinsic operation is
a relational intrinsic operation for which one operand is of an enum type, and the other operand has the same
type or is an integer expression involving an enumerator of that type. The kind type parameters of the operands
of a character relational intrinsic operation shall be the same.
The interpretations defined in 10.1.5 apply to both scalars and arrays; the interpretation for arrays is obtained
by applying the interpretation for scalars element by element.
      <b>Table</b> <b>10.2</b> <b>-</b> <b>Types</b> <b>of</b> <b>operands</b> <b>and</b> <b>results</b> <b>for</b> <b>intrinsic</b> <b>operators</b>
        Intrinsic operator <i>op</i> Type of <i>x</i>
                             1
                          Type of <i>x</i>
                                    2
                                 Type of [<i>x</i>
                                            1
                                                                     ] <i>op</i> <i>x</i>
                                               2
          Unary +, - I, R, Z I, R, Z
                       I I, R, Z I, R, Z
        Binary +, -, *, /, ** R I, R, Z R, R, Z
                       Z I, R, Z Z, Z, Z
            // C C C
                       I I, R, Z, N L, L, L, L
          .EQ., .NE., R I, R, Z L, L, L
           ==, /= Z I, R, Z L, L, L
                      C C L
                      E E L
                      N N, I L, L
                       I I, R, N L, L, L
        .GT., .GE., .LT., .LE. R I, R L, L
        <i>></i>, <i>></i>=, <i><</i>, <i><</i>= C C L
                      E E L
                      N N, I L, L
           .NOT. L L
      .AND., .OR., .EQV., .NEQV. L L L
        <b>Types</b> <b>of</b> <b>operands</b> <b>and</b> <b>results</b> <b>for</b> <b>intrinsic</b> <b>operators</b> (cont.)
      The symbols I, R, Z, C, and L stand for the types integer, real, complex, character,
      and logical, respectively. The symbol E stands for the same enumeration type for
      both operands. The symbol N stands for an enum type, where if the other operand
      is N, they have the same type, and if the other operand is I, the integer operand
      is an expression with a primary that is an enumerator of the enum type. Where
      more than one type for <i>x</i>
                    2
                  is given, the type of the result of the operation is given
      in the same relative position in the next column.
<b>NOTE</b>
For example, if X is of type real and J is of type integer, the expression X + J is of type real.
<b>10.1.5.2</b> <b>Numeric</b> <b>intrinsic</b> <b>operations</b>
<b>10.1.5.2.1</b> <b>Interpretation</b> <b>of</b> <b>numeric</b> <b>intrinsic</b> <b>operations</b>
The two operands of numeric intrinsic binary operations may be of different numeric types or different kind
type parameters. Except for a value of type real or complex raised to an integer power, if the operands have
different types or kind type parameters, the effect is as if each operand that differs in type or kind type parameter
from those of the result is converted to the type and kind type parameter of the result before the operation is
performed. When a value of type real or complex is raised to an integer power, the integer operand need not be
converted.
A numeric operation is used to express a numeric computation. Evaluation of a numeric operation produces a
numeric value. The permitted data types for operands of the numeric intrinsic operations are specified in 10.1.5.1.
The numeric operators and their interpretation in an expression are given in Table 10.3, where <i>x</i>
                                                 1
                                            denotes the
operand to the left of the operator and <i>x</i>
                    2
                  denotes the operand to the right of the operator.
       <b>Table</b> <b>10.3</b> <b>-</b> <b>Interpretation</b> <b>of</b> <b>the</b> <b>numeric</b> <b>intrinsic</b> <b>operators</b>
        Operator Representing Use of operator Interpretation
          ** Exponentiation <i>x</i>
                           1
                        ** <i>x</i>
                              2
                             Raise <i>x</i>
                                     1
                                 to the power <i>x</i>
                                              2
          / Division <i>x</i>
                           1
                        / <i>x</i>
                              2
                             Divide <i>x</i>
                                      1
                                  by <i>x</i>
                                         2
          * Multiplication <i>x</i>
                           1
                        * <i>x</i>
                              2
                             Multiply <i>x</i>
                                       1
                                   by <i>x</i>
                                          2
     - Subtraction <i>x</i>
                           1
                       - <i>x</i>
                              2
                             Subtract <i>x</i>
                                       2
                                   from <i>x</i>
                                           1
     - Negation - <i>x</i>
                             2
                             Negate <i>x</i>
                                      2
          + Addition <i>x</i>
                           1
                        + <i>x</i>
                              2
                             Add <i>x</i>
                                     1
                                 and <i>x</i>
                                         2
          + Identity + <i>x</i>
                             2
                             Same as <i>x</i>
                                       2
The interpretation of a division operation depends on the types of the operands (10.1.5.2.2).
If <i>x</i>
 1
  and <i>x</i>
     2
     are of type integer and <i>x</i>
                   2
                 has a negative value, the interpretation of <i>x</i>
                                           1
                                      ** <i>x</i>
                                              2
                                         is the same as the
interpretation of 1/(<i>x</i>
           1
          ** ABS (<i>x</i>
                 2
               )), which is subject to the rules of integer division (10.1.5.2.2).
<b>NOTE</b>
For example, 2 ** (-3) has the value of 1/(2 ** 3), which is zero.
<b>10.1.5.2.2</b> <b>Integer</b> <b>division</b>
One operand of type integer may be divided by another operand of type integer. Although the mathematical
quotient of two integers is not necessarily an integer, Table 10.2 specifies that an expression involving the division
operator with two operands of type integer is interpreted as an expression of type integer. The result of such an
operation is the integer closest to the mathematical quotient and between zero and the mathematical quotient
inclusively.
<b>NOTE</b>
For example, the expression (-8) / 3 has the value (-2).
<b>10.1.5.2.3</b> <b>Complex</b> <b>exponentiation</b>
In the case of a complex value raised to a complex power, the value of the operation <i>x</i>
                                            1
                                       ** <i>x</i>
                                               2
                                          is the principal
value of <i>x</i>
    <i>x</i>2
    1
     .
<b>10.1.5.2.4</b> <b>Evaluation</b> <b>of</b> <b>numeric</b> <b>intrinsic</b> <b>operations</b>
The execution of any numeric operation whose result is not defined by the arithmetic used by the processor is
prohibited. Raising a negative real value to a real power is prohibited.
Once the interpretation of a numeric intrinsic operation is established, the processor may evaluate any mathem-
atically equivalent expression, provided that the integrity of parentheses is not violated.
Two expressions of a numeric type are mathematically equivalent if, for all possible values of their primaries, their
mathematical values are equal. However, mathematically equivalent expressions of numeric type can produce
different computational results.
<b>NOTE</b> <b>1</b>
Any difference between the values of the expressions (1./3.)*3. and 1. is a computational difference, not a
mathematical difference. The difference between the values of the expressions 5/2 and 5./2. is a mathematical
difference, not a computational difference.
The mathematical definition of integer division is given in 10.1.5.2.2.
<b>NOTE</b> <b>2</b>
The following are examples of expressions with allowable alternative forms that can be used by the processor in
the evaluation of those expressions. A, B, and C represent arbitrary real or complex operands; I and J represent
arbitrary integer operands; and X, Y, and Z represent arbitrary operands of numeric type.
  Expression Allowable alternative form
  X + Y Y + X
  X * Y Y * X
  -X + Y Y - X
  X + Y + Z X + (Y + Z)
  X - Y + Z X - (Y - Z)
  X * A / Z X * (A / Z)
  X * Y - X * Z X * (Y - Z)
  A / B / C A / (B * C)
  A / 5.0 0.2 * A
The following are examples of expressions with forbidden alternative forms that cannot be used by a processor
in the evaluation of those expressions.
  Expression Forbidden alternative form
  I / 2 0.5 * I
  X * I / J X * (I / J)
  I / J / A I / (J * A)
  (X + Y) + Z X + (Y + Z)
  (X * Y) - (X * Z) X * (Y - Z)
  X * (Y - Z) X * Y - X * Z
<b>NOTE</b> <b>3</b>
In addition to the parentheses required to establish the desired interpretation, parentheses can be included to
restrict the alternative forms that can be used by the processor in the actual evaluation of the expression. This
is useful for controlling the magnitude and accuracy of intermediate values developed during the evaluation of
an expression.
For example, in the expression
 A + (B - C)
the parenthesized expression (B- C) is evaluated and then added to A.
The inclusion of parentheses could change the mathematical value of an expression. For example, the two
expressions
 A * I / J
 A * (I / J)
could have different mathematical values if I and J are of type integer.
<b>NOTE</b> <b>4</b>
Each operand in a numeric intrinsic operation has a type that can depend on the order of evaluation used by
the processor.
For example, in the evaluation of the expression
 Z + R + I
where Z, R, and I represent data objects of complex, real, and integer type, respectively, the type of the operand
that is added to I could be either complex or real, depending on which pair of operands (Z and R, R and I, or
Z and I) is added first.
<b>10.1.5.3</b> <b>Character</b> <b>intrinsic</b> <b>operation</b>
<b>10.1.5.3.1</b> <b>Interpretation</b> <b>of</b> <b>the</b> <b>character</b> <b>intrinsic</b> <b>operation</b>
The character intrinsic operator // is used to concatenate two operands of type character with the same kind
type parameter. Evaluation of the character intrinsic operation produces a result of type character.
The interpretation of the character intrinsic operator // when used to form an expression is given in Table 10.4,
where <i>x</i>
    1
    denotes the operand to the left of the operator and <i>x</i>
                               2
                            denotes the operand to the right of the operator.
      <b>Table</b> <b>10.4</b> <b>-</b> <b>Interpretation</b> <b>of</b> <b>the</b> <b>character</b> <b>intrinsic</b> <b>operator</b> <b>//</b>
         Operator Representing Use of operator Interpretation
          // Concatenation <i>x</i>
                           1
                        // <i>x</i>
                              2
                             Concatenate <i>x</i>
                                         1
                                    with <i>x</i>
                                             2
The result of the character intrinsic operation <i>x</i>
                         1
                      // <i>x</i>
                            2
                         is a character string whose value is the value of <i>x</i>
                                                        1
concatenatedontherightwiththevalueof<i>x</i>
                      2
                   andwhoselengthisthesumofthelengthsof<i>x</i>
                                             1
                                        and<i>x</i>
                                                 2
                                           . Parentheses
used to specify the order of evaluation have no effect on the value of a character expression.
<b>NOTE</b>
For example, the value of the expression ('AB' // 'CDE') // 'F' is the string 'ABCDEF'. The value of the
expression 'AB' // ('CDE' // 'F') is also the string 'ABCDEF'.
<b>10.1.5.3.2</b> <b>Evaluation</b> <b>of</b> <b>the</b> <b>character</b> <b>intrinsic</b> <b>operation</b>
A processor is only required to evaluate as much of the character intrinsic operation as is required by the context
in which the expression appears.
<b>NOTE</b>
For example, the statements
   CHARACTER (LEN = 2) C1, C2, C3, CF
   C1 = C2 // CF (C3)
do not require the function CF to be evaluated, because only the value of C2 is needed to determine the value
of C1 because C1 and C2 both have a length of 2.
<b>10.1.5.4</b> <b>Logical</b> <b>intrinsic</b> <b>operations</b>
<b>10.1.5.4.1</b> <b>Interpretation</b> <b>of</b> <b>logical</b> <b>intrinsic</b> <b>operations</b>
A logical operation is used to express a logical computation. Evaluation of a logical operation produces a result
of type logical. The permitted types for operands of the logical intrinsic operations are specified in 10.1.5.1.
The logical operators and their interpretation when used to form an expression are given in Table 10.5, where <i>x</i>
                                                        1
denotes the operand to the left of the operator and <i>x</i>
                          2
                        denotes the operand to the right of the operator.
        <b>Table</b> <b>10.5</b> <b>-</b> <b>Interpretation</b> <b>of</b> <b>the</b> <b>logical</b> <b>intrinsic</b> <b>operators</b>
   Operator Representing Use of operator Interpretation
   .NOT. Logical negation .NOT. <i>x</i>
                               2
                               True if <i>x</i>
                                        2
                                   is false
   .AND. Logical conjunction <i>x</i>
                           1
                        .AND. <i>x</i>
                                2
                               True if <i>x</i>
                                        1
                                   and <i>x</i>
                                            2
                                       are both true
   .OR. Logical inclusive disjunction <i>x</i>
                           1
                        .OR. <i>x</i>
                               2
                               True if <i>x</i>
                                        1
                                   and/or <i>x</i>
                                             2
                                        is true
   .EQV. Logical equivalence <i>x</i>
                           1
                        .EQV. <i>x</i>
                                2
                               True if both<i>x</i>
                                           1
                                      and<i>x</i>
                                              2
                                         are true or
                               both are false
   .NEQV. Logical nonequivalence <i>x</i>
                           1
                        .NEQV. <i>x</i>
                                 2
                               True if either<i>x</i>
                                           1
                                      or<i>x</i>
                                              2
                                        is true, but
                               not both
The values of the logical intrinsic operations are shown in Table 10.6.
     <b>Table</b> <b>10.6</b> <b>-</b> <b>The</b> <b>values</b> <b>of</b> <b>operations</b> <b>involving</b> <b>logical</b> <b>intrinsic</b> <b>operators</b>
     <i>x</i>
        1
        <i>x</i>
           2
            .NOT. <i>x</i>
                  2
              <i>x</i>
                    1
                  .AND. <i>x</i>
                          2
                    <i>x</i>
                            1
                         .OR. <i>x</i>
                                 2
                         <i>x</i>
                                   1
                               .EQV. <i>x</i>
                                        2
                               <i>x</i>
                                           1
                                      .NEQV. <i>x</i>
                                                 2
      true true false true true true false
      true false true false true false true
      false true false false true false true
      false false true false false true false
<b>10.1.5.4.2</b> <b>Evaluation</b> <b>of</b> <b>logical</b> <b>intrinsic</b> <b>operations</b>
Once the interpretation of a logical intrinsic operation is established, the processor may evaluate any other
expression that is logically equivalent, provided that the integrity of parentheses in any expression is not violated.
<b>NOTE</b>
For example, for the variables L1, L2, and L3 of type logical, the processor could choose to evaluate the
expression
   L1 .AND. L2 .AND. L3
as
   L1 .AND. (L2 .AND. L3)
Two expressions of type logical are logically equivalent if their values are equal for all possible values of their
primaries.
<b>10.1.5.5</b> <b>Relational</b> <b>intrinsic</b> <b>operations</b>
<b>10.1.5.5.1</b> <b>Interpretation</b> <b>of</b> <b>relational</b> <b>intrinsic</b> <b>operations</b>
A relational intrinsic operation is used to compare values of two operands using the relational intrinsic operators
.LT., .LE., .GT., .GE., .EQ., .NE., <i><</i>, <i><</i>=, <i>></i>, <i>></i>=, ==, and /=. The permitted types for operands of the
relational intrinsic operators are specified in 10.1.5.1.
The operators <i><</i>, <i><</i>=, <i>></i>, <i>></i>=, ==, and /= always have the same interpretations as the operators .LT., .LE.,
.GT., .GE., .EQ., and .NE., respectively.
<b>NOTE</b> <b>1</b>
As shown in Table 10.2, a relational intrinsic operator cannot be used to compare the value of an expression of
a numeric type with one of type character or logical. Also, two operands of type logical cannot be compared,
a complex operand can be compared with another numeric operand only when the operator is .EQ., .NE., ==,
or /=, and two character operands cannot be compared unless they have the same kind type parameter value.
Evaluation of a relational intrinsic operation produces a default logical result.
The interpretation of the relational intrinsic operators is given in Table 10.7, where <i>x</i>
                                           1
                                      denotes the operand to
the left of the operator and <i>x</i>
              2
             denotes the operand to the right of the operator.
       <b>Table</b> <b>10.7</b> <b>-</b> <b>Interpretation</b> <b>of</b> <b>the</b> <b>relational</b> <b>intrinsic</b> <b>operators</b>
     Operator Representing Use of operator Interpretation
      .LT. Less than <i>x</i>
                            1
                        .LT. <i>x</i>
                                2
                         <i>x</i>
                                   1
                               less than <i>x</i>
                                          2
     <i><</i> Less than <i>x</i>
                            1
                     <i><</i> <i>x</i>
                               2
                         <i>x</i>
                                   1
                               less than <i>x</i>
                                          2
      .LE. Less than or equal to <i>x</i>
                           1
                        .LE. <i>x</i>
                                2
                         <i>x</i>
                                   1
                               less than or equal to <i>x</i>
                                                2
     <i><</i>= Less than or equal to <i>x</i>
                            1
                     <i><</i>= <i>x</i>
                               2
                         <i>x</i>
                                   1
                               less than or equal to <i>x</i>
                                                2
      .GT. Greater than <i>x</i>
                           1
                        .GT. <i>x</i>
                                2
                         <i>x</i>
                                   1
                               greater than <i>x</i>
                                            2
     <i>></i> Greater than <i>x</i>
                            1
                     <i>></i> <i>x</i>
                               2
                         <i>x</i>
                                   1
                               greater than <i>x</i>
                                            2
      .GE. Greater than or equal to <i>x</i>
                           1
                        .GE. <i>x</i>
                                2
                         <i>x</i>
                                   1
                               greater than or equal to <i>x</i>
                                                 2
     <i>></i>= Greater than or equal to <i>x</i>
                            1
                     <i>></i>= <i>x</i>
                               2
                         <i>x</i>
                                   1
                               greater than or equal to <i>x</i>
                                                 2
      .EQ. Equal to <i>x</i>
                           1
                        .EQ. <i>x</i>
                                2
                         <i>x</i>
                                   1
                               equal to <i>x</i>
                                         2
      == Equal to <i>x</i>
                            1
                         == <i>x</i>
                               2
                         <i>x</i>
                                   1
                               equal to <i>x</i>
                                         2
      .NE. Not equal to <i>x</i>
                           1
                        .NE. <i>x</i>
                                2
                         <i>x</i>
                                   1
                               not equal to <i>x</i>
                                            2
      /= Not equal to <i>x</i>
                            1
                         /= <i>x</i>
                               2
                         <i>x</i>
                                   1
                               not equal to <i>x</i>
                                            2
A numeric relational intrinsic operation is interpreted as having the logical value true if and only if the values of
the operands satisfy the relation specified by the operator.
In the numeric relational operation
  <i>x</i>
   1
   <i>rel-op</i> <i>x</i>
        2
if the types or kind type parameters of <i>x</i>
                     1
                   and <i>x</i>
                         2
                      differ, their values are converted to the type and kind type
parameter of the expression <i>x</i>
               1
             + <i>x</i>
                  2
                before evaluation.
A character relational intrinsic operation is interpreted as having the logical value true if and only if the values
of the operands satisfy the relation specified by the operator.
For a character relational intrinsic operation, the operands are compared one character at a time in order,
beginning with the first character of each character operand. If the operands are of unequal length, the shorter
operand is treated as if it were extended on the right with blanks to the length of the longer operand. If both
<i>x</i>
1
 and <i>x</i>
    2
     are of zero length, <i>x</i>
                1
               is equal to <i>x</i>
                        2
                     ; if every character of <i>x</i>
                                     1
                                 is the same as the character in the
corresponding position in <i>x</i>
              2
            , <i>x</i>
                1
              is equal to <i>x</i>
                       2
                    . Otherwise, at the first position where the character operands
differ, the character operand <i>x</i>
               1
              is considered to be less than <i>x</i>
                                 2
                             if the character value of <i>x</i>
                                               1
                                          at this position
precedes the value of <i>x</i>
           2
          in the collating sequence (3.27); <i>x</i>
                             1
                          is greater than <i>x</i>
                                      2
                                  if the character value of <i>x</i>
                                                    1
                                              at this
position follows the value of <i>x</i>
               2
             in the collating sequence.
<b>NOTE</b> <b>2</b>
The collating sequence depends partially on the processor; however, the result of the use of the operators .EQ.,
.NE., ==, and /= does not depend on the collating sequence.
For nondefault character kinds, the blank padding character is processor dependent.
An enumeration relational intrinsic operation is interpreted as having the logical value true if and only if the
ordinal values of the operands satisfy the relation specified by the operator.
An enum relational intrinsic operation is interpreted as if all operands of enum type were converted to their
corresponding integer values.
<b>10.1.5.5.2</b> <b>Evaluation</b> <b>of</b> <b>relational</b> <b>intrinsic</b> <b>operations</b>
Once the interpretation of a relational intrinsic operation is established, the processor may evaluate any other
expression that is relationally equivalent, provided that the integrity of parentheses in any expression is not
violated.
Two relational intrinsic operations are relationally equivalent if their logical values are equal for all possible values
of their primaries.
<b>NOTE</b>
Whether an operand of a relational intrinsic operation could be an IEEE NaN affects whether expressions are
equivalent. For example, if x or y could be a NaN, the expressions
   .NOT. (x .LT. y) and x .GE. y
are not equivalent.
<b>10.1.6</b> <b>Defined</b> <b>operations</b>
<b>10.1.6.1</b> <b>Definitions</b>
A defined operation is either a unary operation or a binary operation. A unary defined operation is an operation
that has the form <i>defined-unary-op</i> <i>x</i>
                   2
                 or <i>intrinsic-operator</i> <i>x</i>
                               2
                            and that is defined by a function and a generic
interface (7.5.5, 15.4.3.4).
A function defines the unary operation <i>op</i> <i>x</i>
                      2
                    if
  (1) the function is specified with a FUNCTION (15.6.2.2) or ENTRY (15.6.2.6) statement that specifies one
     dummy argument <i>d</i>
                2
              ,
  (2) either
     (a) a generic interface (15.4.3.2) provides the function with a <i>generic-spec</i> of OPERATOR (<i>op</i>),
        or
     (b) there is a generic binding (7.5.5) in the declared type of <i>x</i>
                                        2
                                   with a <i>generic-spec</i> of OPER-
        ATOR (<i>op</i>) and there is a corresponding binding to the function in the dynamic type of <i>x</i>
                                                       2
                                                ,
  (3) the type of <i>d</i>
            2
           is compatible with the dynamic type of <i>x</i>
                                  2
                              ,
  (4) the type parameters, if any, of <i>d</i>
                      2
                    match the corresponding type parameters of <i>x</i>
                                              2
                                         , and
  (5) either
     (a) the rank of <i>x</i>
                2
              matches that of <i>d</i>
                         2
                       or
     (b) the function is elemental and there is no other function that defines the operation.
If <i>d</i>
 2
  is an array, the shape of <i>x</i>
               2
              shall match the shape of <i>d</i>
                              2
                          .
A binary defined operation is an operation that has the form <i>x</i>
                               1
                           <i>defined-binary-op</i> <i>x</i>
                                          2
                                     or <i>x</i>
                                             1
                                       <i>intrinsic-operator</i> <i>x</i>
                                                        2
and that is defined by a function and a generic interface.
A function defines the binary operation <i>x</i>
                     1
                  <i>op</i> <i>x</i>
                        2
                     if
  (1) the function is specified with a FUNCTION (15.6.2.2) or ENTRY (15.6.2.6) statement that specifies
     two dummy arguments, <i>d</i>
                   1
                 and <i>d</i>
                      2
                    ,
  (2) either
     (a) a generic interface (15.4.3.2) provides the function with a <i>generic-spec</i> of OPERATOR (<i>op</i>),
        or
     (b) there is a generic binding (7.5.5) in the declared type of <i>x</i>
                                        1
                                    or <i>x</i>
                                            2
                                       with a <i>generic-spec</i> of
        OPERATOR (<i>op</i>) and there is a corresponding binding to the function in the dynamic type
        of <i>x</i>
           1
          or <i>x</i>
              2
            , respectively,
  (3) the types of <i>d</i>
             1
            and <i>d</i>
                 2
               are compatible with the dynamic types of <i>x</i>
                                       1
                                   and <i>x</i>
                                           2
                                      , respectively,
  (4) the type parameters, if any, of <i>d</i>
                       1
                    and <i>d</i>
                          2
                        match the corresponding type parameters of <i>x</i>
                                                   1
                                             and <i>x</i>
                                                       2
                                                ,
     respectively, and
  (5) either
     (a) the ranks of <i>x</i>
                1
               and <i>x</i>
                    2
                  match those of <i>d</i>
                             1
                          and <i>d</i>
                                 2
                             , respectively, or
     (b) the function is elemental,<i>x</i>
                      1
                    and<i>x</i>
                          2
                       are conformable, and there is no other function that defines
        the operation.
If <i>d</i>
 1
  or <i>d</i>
    2
    is an array, the shapes of <i>x</i>
                   1
                 and <i>x</i>
                       2
                    shall match the shapes of <i>d</i>
                                     1
                                 and <i>d</i>
                                         2
                                    , respectively.
<b>NOTE</b>
An intrinsic operator can be used as the operator in a defined operation. In such a case, the generic properties
of the operator are extended.
<b>10.1.6.2</b> <b>Interpretation</b> <b>of</b> <b>a</b> <b>defined</b> <b>operation</b>
The interpretation of a defined operation is provided by the function that defines the operation.
The operators <i><</i>, <i><</i>=, <i>></i>, <i>></i>=, ==, and /= always have the same interpretations as the operators .LT., .LE.,
.GT., .GE., .EQ., and .NE., respectively.
<b>10.1.6.3</b> <b>Evaluation</b> <b>of</b> <b>a</b> <b>defined</b> <b>operation</b>
Once the interpretation of a defined operation is established, the processor may evaluate any other expression
that is equivalent, provided that the integrity of parentheses is not violated.
Two expressions of derived type are equivalent if their values are equal for all possible values of their primaries.
<b>10.1.7</b> <b>Evaluation</b> <b>of</b> <b>operands</b>
It is not necessary for a processor to evaluate all of the operands of an expression, or to evaluate entirely each
operand, if the value of the expression can be determined otherwise.
<b>NOTE</b> <b>1</b>
This principle is most often applicable to logical expressions, zero-sized arrays, and zero-length strings, but it
applies to all expressions.
For example, in evaluating the expression
   X > Y .OR. L (Z)
                <b>J3/23-007r1</b> <b>167</b>
<b>NOTE</b> <b>1</b> <b>(cont.)</b>
where X, Y, and Z are real and L is a function of type logical, the function reference L (Z) need not be evaluated
if X is greater than Y. Similarly, in the array expression
   W (Z) + A
where A is of size zero and W is a function, the function reference W (Z) need not be evaluated.
If a statement contains a function reference in a part of an expression that need not be evaluated, all entities that
would have become defined in the execution of that reference become undefined at the completion of evaluation
of the expression containing the function reference.
<b>NOTE</b> <b>2</b>
In the examples in NOTE 1, if L or W defines its argument, evaluation of the expressions under the specified
conditions causes Z to become undefined, no matter whether or not L(Z) or W(Z) is evaluated.
If a statement contains a function reference in a part of an expression that need not be evaluated, no invocation
of that function in that part of the expression shall execute an image control statement other than CRITICAL
or END CRITICAL.
<b>NOTE</b> <b>3</b>
This restriction is intended to avoid inadvertent deadlock caused by optimization.
<b>10.1.8</b> <b>Integrity</b> <b>of</b> <b>parentheses</b>
Therulesforevaluationspecifiedin10.1.5statecertainconditionsunderwhichaprocessorcanevaluateanexpres-
sion that is different from the one specified by applying the rules given in 10.1.2 and the rules for interpretation
specified in 10.1.5. However, any expression in parentheses shall be treated as a data entity.
<b>NOTE</b>
For example, in evaluating the expression A + (B - C) where A, B, and C are of numeric types, the difference
of B and C shall be evaluated before the addition operation is performed; the processor shall not evaluate the
mathematically equivalent expression (A + B) - C.
<b>10.1.9</b> <b>Type,</b> <b>type</b> <b>parameters,</b> <b>and</b> <b>shape</b> <b>of</b> <b>an</b> <b>expression</b>
<b>10.1.9.1</b> <b>General</b>
Thetype, typeparameters, andshapeofanexpressiondependontheoperatorsandonthetypes, typeparameters,
and shapes of the primaries used in the expression, and are determined recursively from the syntactic form of the
expression. The type of an expression is one of the intrinsic types (7.4) or a nonintrinsic type (7.5, 7.6).
If an expression is a polymorphic primary or defined operation, the type parameters and the declared and dynamic
types of the expression are the same as those of the primary or defined operation. Otherwise the type parameters
and dynamic type of the expression are the same as its declared type and type parameters; they are referred to
simply as the type and type parameters of the expression.
R1025 <i>logical-expr</i> <b>is</b> <i>expr</i>
C1007 (R1025) <i>logical-expr</i> shall be of type logical.
R1026 <i>default-char-expr</i> <b>is</b> <i>expr</i>
C1008 (R1026) <i>default-char-expr</i> shall be default character.
R1027 <i>int-expr</i> <b>is</b> <i>expr</i>
C1009 (R1027) <i>int-expr</i> shall be of type integer.
R1028 <i>numeric-expr</i> <b>is</b> <i>expr</i>
C1010 (R1028) <i>numeric-expr</i> shall be of type integer, real, or complex.
<b>10.1.9.2</b> <b>Type,</b> <b>type</b> <b>parameters,</b> <b>and</b> <b>shape</b> <b>of</b> <b>a</b> <b>primary</b>
The type, type parameters, and shape of a primary are determined according to whether the primary is a
literal constant, designator, array constructor, structure constructor, enum constructor, enumeration constructor,
function reference, type parameter inquiry, type parameter name, or parenthesized expression. If a primary is
a literal constant, its type, type parameters, and shape are those of the literal constant. If it is a structure
constructor, it is scalar and its type and type parameters are as described in 7.5.10. If it is an enum constructor,
it is scalar and its type is as described in 7.6.1. If it is an enumeration constructor, it is scalar and its type is as
described in 7.6.2. If it is an array constructor, its type, type parameters, and shape are as described in 7.8. If it
is a designator or function reference, its type, type parameters, and shape are those of the designator (8.2, 8.5) or
the function reference (15.5.3), respectively. If the function reference is generic (15.4.3.2, 16.7) then its type, type
parameters, and shape are those of the specific function referenced, which is determined by the declared types,
type parameters, and ranks of its actual arguments as specified in 15.5.5.2. If it is a type parameter inquiry or
type parameter name, it is a scalar integer with the kind of the type parameter.
If a primary is a parenthesized expression, its type, type parameters, and shape are those of the expression.
The associated target object is referenced if a pointer appears as a primary in an intrinsic or defined operation, the
<i>expr</i> of a parenthesized primary, or the only primary on the right-hand side of an intrinsic assignment statement.
The type, type parameters, and shape of the primary are those of the target. If the pointer is not associated
with a target, it shall appear as a primary only as an actual argument in a reference to a procedure whose
corresponding dummy argument is declared to be a pointer, as the target in a pointer assignment statement, or
as explicitly permitted elsewhere in this document.
A disassociated array pointer or an unallocated allocatable array has no shape but does have rank. The type,
type parameters, and rank of the result of the intrinsic function NULL (16.9.155) depend on context.
<b>10.1.9.3</b> <b>Type,</b> <b>type</b> <b>parameters,</b> <b>and</b> <b>shape</b> <b>of</b> <b>the</b> <b>result</b> <b>of</b> <b>an</b> <b>operation</b>
The type of the result of an intrinsic operation [<i>x</i>
                         1
                                        ] <i>op</i> <i>x</i>
                            2
                         is specified by Table 10.2. The shape of the result of
an intrinsic operation is the shape of <i>x</i>
                   2
                 if <i>op</i> is unary or if <i>x</i>
                              1
                           is scalar, and is the shape of <i>x</i>
                                               1
                                         otherwise.
The type, type parameters, and shape of the result of a defined operation [<i>x</i>
                                      1
                                                            ] <i>op</i> <i>x</i>
                                         2
                                    are specified by the function
defining the operation (10.1.6).
An expression of an intrinsic type has a kind type parameter. An expression of type character also has a character
length parameter.
The type parameters of the result of an intrinsic operation are as follows.
 For an expression <i>x</i>
            1
           // <i>x</i>
               2
              where // is the character intrinsic operator and <i>x</i>
                                         1
                                    and <i>x</i>
                                             2
                                       are of type character,
  the character length parameter is the sum of the lengths of the operands and the kind type parameter is
  the kind type parameter of <i>x</i>
                 1
               , which shall be the same as the kind type parameter of <i>x</i>
                                               2
                                         .
 For an expression <i>op</i> <i>x</i>
              2
             where <i>op</i> is an intrinsic unary operator and <i>x</i>
                                      2
                                 is of type integer, real, complex, or
  logical, the kind type parameter of the expression is that of the operand.
 For an expression <i>x</i>
            1
           <i>op</i> <i>x</i>
               2
              where <i>op</i> is a numeric intrinsic binary operator with one operand of type integer
  and the other of type real or complex, the kind type parameter of the expression is that of the real or
  complex operand.
 For an expression <i>x</i>
            1
           <i>op</i> <i>x</i>
               2
              where <i>op</i> is a numeric intrinsic binary operator with both operands of the same
  type and kind type parameters, or with one real and one complex with the same kind type parameters, the
  kind type parameter of the expression is identical to that of each operand. In the case where both operands
  are integer with different kind type parameters, the kind type parameter of the expression is that of the
  operand with the greater decimal exponent range if the decimal exponent ranges are different; if the decimal
  exponent ranges are the same, the kind type parameter of the expression is processor dependent, but it is
  the same as that of one of the operands. In the case where both operands are any of type real or complex
  with different kind type parameters, the kind type parameter of the expression is that of the operand with
  the greater decimal precision if the decimal precisions are different; if the decimal precisions are the same,
  the kind type parameter of the expression is processor dependent, but it is the same as that of one of the
  operands.
 For an expression <i>x</i>
            1
           <i>op</i> <i>x</i>
                2
              where <i>op</i> is a logical intrinsic binary operator with both operands of the same
  kind type parameter, the kind type parameter of the expression is identical to that of each operand. In the
  case where both operands are of type logical with different kind type parameters, the kind type parameter
  of the expression is processor dependent, but it is the same as that of one of the operands.
 For an expression <i>x</i>
             1
            <i>op</i> <i>x</i>
                2
               where <i>op</i> is a relational intrinsic operator, the kind type parameter of the
  expression is default logical.
<b>10.1.10</b> <b>Conformability</b> <b>rules</b> <b>for</b> <b>elemental</b> <b>operations</b>
An elemental operation is an intrinsic operation or a defined operation for which the function is elemental (15.9).
For all elemental binary operations, the two operands shall be conformable. In the case where one is a scalar and
the other an array, the scalar is treated as if it were an array of the same shape as the array operand with every
element, if any, of the array equal to the value of the scalar.
<b>10.1.11</b> <b>Specification</b> <b>expression</b>
A specification expression is an expression with limitations that make it suitable for use in specifications such as
lengthtypeparameters(C704)andarraybounds(R816, R817). A <i>specification-expr</i> shallbeaconstantexpression
unless it is in an interface body (15.4.3.2), the specification part of a subprogram or BLOCK construct, a derived
type definition, or the <i>declaration-type-spec</i> of a FUNCTION statement (15.6.2.2).
R1029 <i>specification-expr</i> <b>is</b> <i>scalar-int-expr</i>
C1011 (R1029) The <i>scalar-int-expr</i> shall be a restricted expression.
A restricted expression is an expression in which each operation is intrinsic or defined by a specification function
and each primary is
  (1) a constant or subobject of a constant,
  (2) an object designator with a base object that is a dummy argument that has neither the OPTIONAL
     nor the INTENT (OUT) attribute,
  (3) an object designator with a base object that is in a common block,
  (4) an object designator with a base object that is made accessible by use or host association,
  (5) an array constructor where each element and each <i>scalar-int-expr</i> of each <i>ac-implied-do-control</i> is a
     restricted expression,
  (6) a structure constructor where each component is a restricted expression,
  (7) an enum constructor whose <i>expr</i> is a restricted expression,
  (8) an enumeration constructor whose <i>expr</i> is a restricted expression,
  (9) a specification inquiry where each designator or argument is
     (a) a restricted expression or
     (b) a variable that is not an optional dummy argument, and whose properties inquired about are
        not
        (i) dependent on the upper bound of the last dimension of an assumed-size array,
        (ii) deferred, or
        (iii) defined by an expression that is not a restricted expression,
  (10) a specification inquiry that is a constant expression,
  (11) a reference to the intrinsic function PRESENT,
  (12) a reference to any other standard intrinsic function where each argument is a restricted expression,
  (13) a reference to a transformational function from the intrinsic module IEEE_ARITHMETIC, IEEE_-
     EXCEPTIONS, or ISO_C_BINDING, where each argument is a restricted expression,
  (14) a reference to a specification function where each argument is a restricted expression,
  (15) a type parameter of the derived type being defined,
  (16) an <i>ac-do-variable</i> within an array constructor where each <i>scalar-int-expr</i> of the corresponding <i>ac-</i>
     <i>implied-do-control</i> is a restricted expression, or
  (17) a restricted expression enclosed in parentheses,
where each subscript, section subscript, substring starting point, substring ending point, and type parameter
value is a restricted expression.
A specification inquiry is a reference to
  (1) an intrinsic inquiry function other than PRESENT,
  (2) a type parameter inquiry (9.4.5),
  (3) an inquiry function from the intrinsic modules IEEE_ARITHMETIC and IEEE_EXCEPTIONS
     (17.10),
  (4) the function C_SIZEOF from the intrinsic module ISO_C_BINDING (18.2.3.8), or
  (5) the COMPILER_VERSION or COMPILER_OPTIONS function from the intrinsic module ISO_-
     FORTRAN_ENV (16.10.2.6, 16.10.2.7).
A function is a specification function if it is a pure function, is not a standard intrinsic function, is not an internal
function, is not a statement function, and does not have a dummy procedure argument.
Evaluation of a specification expression shall not directly or indirectly cause a procedure defined by the subpro-
gram in which it appears to be invoked.
<b>NOTE</b> <b>1</b>
Specification functions are nonintrinsic functions that can be used in specification expressions to determine
the attributes of data objects. The requirement that they be pure ensures that they cannot have side effects
that could affect other objects being declared in the same <i>specification-part</i>. The requirement that they not be
internal ensures that they cannot inquire, via host association, about other objects being declared in the same
<i>specification-part</i>. The prohibition against recursion avoids the creation of a new instance of a procedure while
construction of one is in progress.
A variable in a specification expression shall have its type and type parameters, if any, specified by a previous
declaration in the same scoping unit, by the implicit typing rules in effect for the scoping unit, or by host or
use association. If a variable in a specification expression is typed by the implicit typing rules, its appearance in
any subsequent type declaration statement shall confirm the implied type and type parameters. If a specification
inquiry depends on the type of an object of derived type, that type shall be previously defined.
If a specification expression includes a specification inquiry that depends on the type, a type parameter, an
array bound, or a cobound of an entity specified in the same <i>specification-part</i>, the type, type parameter, array
bound, or cobound shall be specified in a prior specification of the <i>specification-part</i>. The prior specification may
be to the left of the specification inquiry in the same statement, but shall not be within the same <i>entity-decl</i>.
If a specification expression includes a reference to the value of an element of an array specified in the same
<i>specification-part</i>, the array shall be completely specified in prior declarations.
A generic entity referenced in a specification expression in the <i>specification-part</i> of a scoping unit shall have no
specific procedures defined in the scoping unit, or its host scoping unit, subsequent to the specification expression.
A component specification expression is a specification expression in which
 there are no references to specification functions,
 there are no references to the intrinsic functions ALLOCATED, ASSOCIATED, COMMAND_ARGU-
  MENT_COUNT, EXTENDS_TYPE_OF, GET_TEAM, NUM_IMAGES, PRESENT, SAME_TYPE_-
  AS, TEAM_NUMBER, or THIS_IMAGE,
 every specification inquiry reference is a constant expression, and
 the value does not depend on the value of a variable.
A reference to the intrinsic function TRANSFER in a component specification expression is permitted only if
each argument is a a constant expression and each ultimate pointer component of the SOURCE argument is
disassociated.
<b>NOTE</b> <b>2</b>
The following are examples of specification expressions:
   LBOUND (B, 1) + 5 ! B is an assumed-shape dummy array
   M + LEN (C) ! M and C are dummy arguments
   2 * PRECISION (A) ! A is a real variable made accessible by a USE statement
<b>10.1.12</b> <b>Constant</b> <b>expression</b>
A constant expression is an expression with limitations that make it suitable for use as a kind type parameter,
initializer, or named constant. It is an expression in which each operation is intrinsic, and each primary is
  (1) a constant or subobject of a constant,
  (2) an array constructor where each element and each <i>scalar-int-expr</i> of each <i>ac-implied-do-control</i> is a
     constant expression,
  (3) a structure constructor where each <i>component-spec</i> corresponding to
     (a) an allocatable component is a reference to the intrinsic function NULL,
     (b) a pointer component is an initialization target or a reference to the intrinsic function NULL,
        and
     (c) any other component is a constant expression,
  (4) an enum constructor whose <i>expr</i> is a constant expression,
  (5) an enumeration constructor whose <i>expr</i> is a constant expression,
  (6) a specification inquiry where each designator or argument is
     (a) a constant expression or
     (b) a variable whose properties inquired about are not
        (i) assumed,
        (ii) deferred, or
        (iii) defined by an expression that is not a constant expression,
  (7) a reference to an elemental standard intrinsic function, where each argument is a constant expression,
  (8) a reference to a standard intrinsic function that is transformational, other than COMMAND_AR-
     GUMENT_COUNT, GET_TEAM, NULL, NUM_IMAGES, TEAM_NUMBER, THIS_IMAGE,
     or TRANSFER, where each argument is a constant expression,
  (9) a reference to the intrinsic function NULL that does not have an argument with a type parameter
     that is assumed or is defined by an expression that is not a constant expression,
  (10) a reference to the intrinsic function TRANSFER where each argument is a constant expression and
     each ultimate pointer component of the SOURCE argument is disassociated,
  (11) areferencetoatransformationalfunctionfromtheintrinsicmoduleIEEE_ARITHMETICorIEEE_-
     EXCEPTIONS, where each argument is a constant expression,
  (12) a previously declared kind type parameter of the derived type being defined,
  (13) a <i>data-i-do-variable</i> within a <i>data-implied-do</i>,
  (14) an <i>ac-do-variable</i> within an array constructor where each <i>scalar-int-expr</i> of the corresponding <i>ac-</i>
     <i>implied-do-control</i> is a constant expression, or
  (15) a constant expression enclosed in parentheses,
and where each subscript, section subscript, substring starting point, substring ending point, and type parameter
value is a constant expression.
R1030 <i>constant-expr</i> <b>is</b> <i>expr</i>
C1012 (R1030) <i>constant-expr</i> shall be a constant expression.
R1031 <i>default-char-constant-expr</i> <b>is</b> <i>default-char-expr</i>
C1013 (R1031) <i>default-char-constant-expr</i> shall be a constant expression.
R1032 <i>int-constant-expr</i> <b>is</b> <i>int-expr</i>
C1014 (R1032) <i>int-constant-expr</i> shall be a constant expression.
If a constant expression includes a specification inquiry that depends on a type parameter or an array bound of
an entity specified in the same <i>specification-part</i>, the type parameter or array bound shall be specified in a prior
specification of the <i>specification-part</i>. The prior specification may be to the left of the specification inquiry in the
same statement, but shall not be within the same <i>entity-decl</i> unless the specification inquiry appears within an
<i>initialization</i>.
A generic entity referenced in a constant expression in the <i>specification-part</i> of a scoping unit shall have no specific
procedures defined in that scoping unit, or its host scoping unit, subsequent to the constant expression.
<b>NOTE</b>
The following are examples of constant expressions:
   3
   -3 + 4
   'AB'
   'AB' // 'CD'
   ('AB' // 'CD') // 'EF'
   SIZE (A)
   DIGITS (X) + 4
   4.0 * ATAN (1.0)
   CEILING (number_of_decimal_digits / LOG10 (REAL (RADIX (0.0))))
where A is an explicit-shape array with constant bounds, X is default real, and number_of_decimal_digits is
an integer named constant.
<b>10.2</b> <b>Assignment</b>
<b>10.2.1</b> <b>Assignment</b> <b>statement</b>
<b>10.2.1.1</b> <b>General</b> <b>form</b>
R1033 <i>assignment-stmt</i> <b>is</b> <i>variable</i> = <i>expr</i>
C1015 (R1033) The <i>variable</i> shall not be a whole assumed-size array.
<b>NOTE</b>
Examples of an assignment statement are:
   A = 3.5 + X * Y
   I = INT (A)
An <i>assignment-stmt</i> shall meet the requirements of either a defined assignment statement or an intrinsic assign-
ment statement.
<b>10.2.1.2</b> <b>Intrinsic</b> <b>assignment</b> <b>statement</b>
An intrinsic assignment statement is an assignment statement that is not a defined assignment statement
(10.2.1.4). In an intrinsic assignment statement,
  (1) if the variable is polymorphic it shall be allocatable, and not a coarray or a data object with a coarray
     potential subobject component,
  (2) if <i>expr</i> is an array then the variable shall also be an array,
  (3) the variable and <i>expr</i> shall be conformable unless the variable is an allocatable array that has the
     same rank as <i>expr</i> and is not a coarray or of a type that has a coarray potential subobject component,
  (4) if the variable is polymorphic it shall be type compatible with <i>expr</i>,
  (5) if <i>expr</i> is a <i>boz-literal-constant</i>, the variable shall be of type integer or real,
  (6) if the variable is not polymorphic and <i>expr</i> is not a <i>boz-literal-constant</i>, the declared types of the
     variable and <i>expr</i> shall conform as specified in Table 10.8,
  (7) if the variable is of type character and of ISO 10646, ASCII, or default character kind, <i>expr</i> shall be
     of ISO 10646, ASCII, or default character kind,
  (8) otherwise if the variable is of type character <i>expr</i> shall have the same kind type parameter,
  (9) if the variable is of derived type each kind type parameter of the variable shall have the same value
     as the corresponding kind type parameter of <i>expr</i>, and
  (10) if the variable is of derived type each length type parameter of the variable shall have the same value
     as the corresponding type parameter of <i>expr</i> unless the variable is allocatable, is not a coarray, and
     its corresponding type parameter is deferred.
         <b>Table</b> <b>10.8</b> <b>-</b> <b>Intrinsic</b> <b>assignment</b> <b>type</b> <b>conformance</b>
       Type of the variable Type of <i>expr</i>
          integer integer, real, complex
          real integer, real, complex
         complex integer, real, complex
         character character
          logical logical
        derived type same derived type as the variable
       enumeration type same enumeration type
         enum type same enum type, or integer; if of type integer, a primary
                  in <i>expr</i> shall be an enumerator of the enum type
If the variable in an intrinsic assignment statement is a coindexed object,
 the variable shall not be polymorphic,
 the variable shall not have an allocatable ultimate component,
 the variable shall be conformable with <i>expr</i>, and
 each deferred length type parameter of the variable shall have the same value as the corresponding type
  parameter of <i>expr</i>.
If the variable is a pointer, it shall be associated with a definable target such that the type, type parameters,
and shape of the target and <i>expr</i> conform. If the variable is a coarray or a coindexed object, it shall not be an
unallocated allocatable variable.
<b>10.2.1.3</b> <b>Interpretation</b> <b>of</b> <b>intrinsic</b> <b>assignments</b>
Execution of an intrinsic assignment causes, in effect, the evaluation of the expression <i>expr</i> and all expressions
within <i>variable</i> (10.1), the possible conversion of <i>expr</i> to the type and type parameters of the variable (Table
10.9), and the definition of the variable with the resulting value. The execution of the assignment shall have
the same effect as if the evaluation of <i>expr</i> and the evaluation of all expressions in <i>variable</i> occurred before any
portion of the variable is defined by the assignment. The evaluation of expressions within <i>variable</i> shall neither
affect nor be affected by the evaluation of <i>expr</i>.
If the variable is a pointer, the value of <i>expr</i> is assigned to the target of the variable.
If the variable is an unallocated allocatable array, <i>expr</i> shall have the same rank. If the variable is an allocated
allocatablevariable, itisdeallocatedif<i>expr</i> isanarrayofdifferentshape, anycorrespondinglengthtypeparameter
values of the variable and <i>expr</i> differ, or the variable is polymorphic and the dynamic type or any corresponding
kind type parameter values of the variable and <i>expr</i> differ. If the variable is or becomes an unallocated allocatable
variable, it is then allocated with
 the same dynamic type and kind type parameter values as <i>expr</i> if the variable is polymorphic,
 each deferred type parameter equal to the corresponding type parameter of <i>expr</i>,
 the same bounds as before if the variable is an array and <i>expr</i> is scalar, and
 the shape of <i>expr</i> with each lower bound equal to the corresponding element of LBOUND (<i>expr</i>) if <i>expr</i> is
  an array.
<b>NOTE</b> <b>1</b>
For example, given the declaration
   CHARACTER(:),ALLOCATABLE :: NAME
then after the assignment statement
   NAME = 'Dr. '//FIRST_NAME//' '//SURNAME
NAME will have the length LEN (FIRST_NAME) + LEN (SURNAME) + 5, even if it had previously been
unallocated, or allocated with a different length. However, the assignment statement
   NAME(:) = 'Dr. '//FIRST_NAME//' '//SURNAME
is only conforming if NAME is already allocated at the time of the assignment; the assigned value is truncated
or blank padded to the previously allocated length of NAME.
Both <i>variable</i> and <i>expr</i> may contain references to any portion of the variable.
<b>NOTE</b> <b>2</b>
For example, in the character intrinsic assignment statement:
   STRING (2:5) = STRING (1:4)
the assignment of the first character of STRING to the second character does not affect the evaluation of
STRING (1:4). If the value of STRING prior to the assignment was 'ABCDEF', the value following the
assignment is 'AABCDF'.
If <i>expr</i> is a scalar and the variable is an array, the <i>expr</i> is treated as if it were an array of the same shape as the
variable with every element of the array equal to the scalar value of <i>expr</i>.
If the variable is an array, the assignment is performed element-by-element on corresponding array elements of
the variable and <i>expr</i>.
<b>NOTE</b> <b>3</b>
For example, if A and B are arrays of the same shape, the array intrinsic assignment
   A = B
assigns the corresponding elements of B to those of A; that is, the first element of B is assigned to the first
element of A, the second element of B is assigned to the second element of A, etc.
If C is an allocatable array of rank 1, then
 C = PACK (ARRAY, ARRAY>0)
will cause C to contain all the positive elements of ARRAY in array element order; if C is not allocated or is
allocated with the wrong size, it will be re-allocated to be of the correct size to hold the result of PACK.
The processor may perform the element-by-element assignment in any order.
<b>NOTE</b> <b>4</b>
For example, the following program segment results in the values of the elements of array X being reversed:
   REAL X (10)
     ...
   X (1:10) = X (10:1:-1)
For an intrinsic assignment statement where the variable is of numeric type, the <i>expr</i> can have a different numeric
type or kind type parameter, in which case the value of <i>expr</i> is converted to the type and kind type parameter
of the variable according to the rules of Table 10.9.
For an intrinsic assignment statement where the variable is of type integer or real, and <i>expr</i> is a <i>boz-literal-</i>
<i>constant</i>, <i>expr</i> is converted to the type and kind type parameter of the variable according to the rules of Table
10.9.
       <b>Table</b> <b>10.9</b> <b>-</b> <b>Numeric</b> <b>conversion</b> <b>and</b> <b>the</b> <b>assignment</b> <b>statement</b>
          Type of the variable Value assigned
          integer INT (<i>expr</i>, KIND = KIND (<i>variable</i>))
          real REAL (<i>expr</i>, KIND = KIND (<i>variable</i>))
          complex CMPLX (<i>expr</i>, KIND = KIND (<i>variable</i>))
          NOTE INT, REAL, CMPLX, and KIND are the generic names
              of functions defined in 16.9.
For an intrinsic assignment statement where the variable is of type logical, the <i>expr</i> can have a different kind
type parameter, in which case the value of <i>expr</i> is converted to the kind type parameter of the variable.
For an intrinsic assignment statement where the variable is of type character, the <i>expr</i> can have a different
character length parameter in which case the conversion of <i>expr</i> to the length of the variable is as follows.
  (1) If the length of the variable is less than that of <i>expr</i>, the value of <i>expr</i> is truncated from the right
     until it is the same length as the variable.
  (2) If the length of the variable is greater than that of <i>expr</i>, the value of <i>expr</i> is extended on the right
     with blanks until it is the same length as the variable.
Foranintrinsicassignmentstatementwherethevariableisoftypecharacter, if <i>expr</i> hasadifferentkindtypepara-
meter, each character <i>c</i> in <i>expr</i> is converted to the kind type parameter of the variable by ACHAR (IACHAR(<i>c</i>),
KIND (<i>variable</i>)).
<b>NOTE</b> <b>5</b>
For nondefault character kinds, the blank padding character is processor dependent. When assigning a character
expression to a variable of a different kind, each character of the expression that is not representable in the kind
of the variable is replaced by a processor-dependent character.
For an intrinsic assignment where the variable is of enum type, if <i>expr</i> is of type integer, it is converted to the
type of the variable as if by the enum constructor <i>enum-type-name</i> ( <i>expr</i> ).
For an intrinsic assignment of the type C_PTR or C_FUNPTR from the intrinsic module ISO_C_BINDING,
or of the type TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV, the variable becomes undefined
if the variable and <i>expr</i> are not on the same image.
<b>NOTE</b> <b>6</b>
An intrinsic assignment statement for a variable of declared type C_PTR, C_FUNPTR, or TEAM_TYPE
cannot involve a coindexed object, see C915, which prevents inappropriate copying from one image to another.
However, such copying can occur for a component in a derived-type intrinsic assignment.
An intrinsic assignment where the variable is of derived type is performed as if each component of the variable
were assigned from the corresponding component of <i>expr</i> using pointer assignment (10.2.2) for each pointer
component, defined assignment for each nonpointer nonallocatable component of a type that has a type-bound
defined assignment consistent with the component, intrinsic assignment for each other nonpointer nonallocatable
component, and intrinsic assignment for each allocated coarray component. For unallocated coarray components,
the corresponding component of the variable shall be unallocated. For a noncoarray allocatable component the
following sequence of operations is applied.
  (1) If the component of the variable is allocated, it is deallocated.
  (2) If the component of the value of <i>expr</i> is allocated, the corresponding component of the variable is
     allocated with the same dynamic type and type parameters as the component of the value of <i>expr</i>.
     If it is an array, it is allocated with the same bounds. The value of the component of the value of
     <i>expr</i> is then assigned to the corresponding component of the variable using defined assignment if the
     declared type of the component has a type-bound defined assignment consistent with the component,
     and intrinsic assignment for the dynamic type of that component otherwise.
The processor may perform the component-by-component assignment in any order or by any means that has the
same effect.
<b>NOTE</b> <b>7</b>
For an example of a derived-type intrinsic assignment statement, if C and D are of the same derived type with a
pointer component P and nonpointer components S, T, U, and V of type integer, logical, character, and another
derived type, respectively, the intrinsic assignment
   C = D
pointer assigns D%P to C%P. It assigns D%S to C%S, D%T to C%T, and D%U to C%U using intrinsic
assignment. It assigns D%V to C%V using defined assignment if objects of that type have a compatible type-
bound defined assignment, and intrinsic assignment otherwise.
<b>NOTE</b> <b>8</b>
Ifanallocatablecomponentof<i>expr</i> isunallocated, thecorrespondingcomponentofthevariablehasanallocation
status of unallocated after execution of the assignment.
<b>10.2.1.4</b> <b>Defined</b> <b>assignment</b> <b>statement</b>
A defined assignment statement is an assignment statement that is defined by a subroutine and a generic interface
(7.5.5, 15.4.3.4.3) that specifies ASSIGNMENT (=).
A subroutine defines the defined assignment <i>x</i>
                       1
                    = <i>x</i>
                          2
                       if
  (1) thesubroutineisspecifiedwithaSUBROUTINE(15.6.2.3) orENTRY(15.6.2.6)statementthatspecifies
     two dummy arguments, <i>d</i>
                   1
                 and <i>d</i>
                      2
                    ,
  (2) either
     (a) agenericinterface(15.4.3.2)providesthesubroutinewitha <i>generic-spec</i> ofASSIGNMENT(=),
        or
     (b) there is a generic binding (7.5.5) in the declared type of <i>x</i>
                                        1
                                    or <i>x</i>
                                            2
                                       with a <i>generic-spec</i> of
        ASSIGNMENT (=) and there is a corresponding binding to the subroutine in the dynamic
        type of <i>x</i>
              1
            or <i>x</i>
                2
               , respectively,
  (3) the types of <i>d</i>
             1
            and <i>d</i>
                 2
               are compatible with the dynamic types of <i>x</i>
                                       1
                                   and <i>x</i>
                                           2
                                      , respectively,
  (4) the type parameters, if any, of <i>d</i>
                       1
                    and <i>d</i>
                          2
                        match the corresponding type parameters of <i>x</i>
                                                   1
                                             and <i>x</i>
                                                       2
                                                ,
     respectively, and
  (5) either
     (a) the ranks of <i>x</i>
                1
               and <i>x</i>
                    2
                  match those of <i>d</i>
                             1
                          and <i>d</i>
                                 2
                             or
     (b) the subroutine is elemental, <i>x</i>
                        2
                      is scalar or has the same rank as <i>x</i>
                                            1
                                      , and there is no other
        subroutine that defines the assignment.
If<i>d</i>
 1
  or<i>d</i>
    2
    is an array, the shapes of <i>x</i>
                  1
                and<i>x</i>
                      2
                    shall match the shapes of <i>d</i>
                                    1
                                and<i>d</i>
                                        2
                                   , respectively. If the subroutine
is elemental, <i>x</i>
       2
       shall be conformable with <i>x</i>
                      1
                   .
<b>10.2.1.5</b> <b>Interpretation</b> <b>of</b> <b>defined</b> <b>assignment</b> <b>statements</b>
The interpretation of a defined assignment is provided by the subroutine that defines it.
If the defined assignment is an elemental assignment and the variable in the assignment is an array, the defined
assignment is performed element-by-element, on corresponding elements of the variable and <i>expr</i>. If <i>expr</i> is a
scalar, it is treated as if it were an array of the same shape as the variable with every element of the array equal
to the scalar value of <i>expr</i>.
<b>NOTE</b>
The rules of defined assignment (15.4.3.4.3), procedure references (15.5), subroutine references (15.5.4), and
elemental subroutine arguments (15.9.3) ensure that the defined assignment has the same effect as if the eval-
uation of all operations in <i>x</i>
              2
             and <i>x</i>
                  1
                occurs before any portion of <i>x</i>
                                  1
                               is defined. If an elemental assignment is
defined by a pure elemental subroutine, the element assignments can be performed simultaneously or in any
order.
<b>10.2.2</b> <b>Pointer</b> <b>assignment</b>
<b>10.2.2.1</b> <b>General</b>
Pointer assignment causes a pointer to become associated with a target or causes its pointer association status
to become disassociated or undefined. Any previous association between the pointer and a target is broken.
Pointer assignment for a pointer component of a structure can also take place by execution of a derived-type
intrinsic assignment statement (10.2.1.3).
<b>10.2.2.2</b> <b>Syntax</b> <b>of</b> <b>the</b> <b>pointer</b> <b>assignment</b> <b>statement</b>
R1034 <i>pointer-assignment-stmt</i> <b>is</b> <i>data-pointer-object</i> [ ( <i>bounds-spec-list</i> ) ] =<i>></i> <i>data-target</i>
              <b>or</b> <i>data-pointer-object</i> ( <i>lower-bounds-expr</i> : ) =<i>></i> <i>data-target</i>
              <b>or</b> <i>data-pointer-object</i> ( <i>bounds-remapping-list</i> ) =<i>></i> <i>data-target</i>
              <b>or</b> <i>data-pointer-object</i> ( <i>lower-bounds-expr</i> : <i>upper-bounds-expr</i> )
                   =<i>></i> <i>data-target</i>
              <b>or</b> <i>proc-pointer-object</i> =<i>></i> <i>proc-target</i>
R1035 <i>data-pointer-object</i> <b>is</b> <i>variable-name</i>
              <b>or</b> <i>scalar-variable</i> % <i>data-pointer-component-name</i>
C1016 (R1034) If <i>data-target</i> is not unlimited polymorphic, <i>data-pointer-object</i> shall be type compatible (7.3.3)
   with it and the corresponding kind type parameters shall be equal.
C1017 (R1034) If <i>data-target</i> is unlimited polymorphic, <i>data-pointer-object</i> shall be unlimited polymorphic, or
   of a type with the BIND attribute or the SEQUENCE attribute.
C1018 (R1034) If <i>bounds-spec-list</i> is specified, the number of <i>bounds-spec</i>s shall equal the rank of <i>data-pointer-</i>
   <i>object</i>.
C1019 (R1034) If <i>bounds-remapping-list</i> is specified, the number of <i>bounds-remapping</i>s shall equal the rank of
   <i>data-pointer-object</i>.
C1020 If <i>lower-bounds-expr</i> and <i>upper-bounds-expr</i> appear in a <i>pointer-assignment-stmt</i>, at least one of them
   shall be a rank-one array of constant size equal to the rank of <i>data-pointer-object</i>.
C1021 If <i>lower-bounds-expr</i> appears in a <i>pointer-assignment-stmt</i> but not <i>upper-bounds-expr</i>, it shall be a rank-
   one array of constant size equal to the rank of <i>data-pointer-object</i>.
C1022 If neither <i>bounds-remapping-list</i> nor <i>upper-bounds-expr</i> appears in a <i>pointer-assignment-stmt</i>, the ranks
   of <i>data-pointer-object</i> and <i>data-target</i> shall be the same.
C1023 (R1034) A coarray <i>data-target</i> shall have the VOLATILE attribute if and only if the <i>data-pointer-object</i>
   has the VOLATILE attribute.
C1024 (R1035) A <i>variable-name</i> shall have the POINTER attribute.
C1025 (R1035) A <i>scalar-variable</i> shall be a <i>data-ref</i>.
C1026 (R1035) A <i>data-pointer-component-name</i> shall be the name of a component of <i>scalar-variable</i> that is a
   data pointer.
C1027 (R1035) A <i>data-pointer-object</i> shall not be a coindexed object.
R1036 <i>bounds-spec</i> <b>is</b> <i>lower-bound-expr</i> :
R1037 <i>bounds-remapping</i> <b>is</b> <i>lower-bound-expr</i> : <i>upper-bound-expr</i>
R1038 <i>data-target</i> <b>is</b> <i>expr</i>
C1028 (R1038) The <i>expr</i> shall be a <i>designator</i> that designates a variable with either the TARGET or POINTER
   attribute and is not an array section with a vector subscript, or it shall be a reference to a function that
   returns a data pointer.
C1029 (R1038) A <i>data-target</i> shall not be a coindexed object.
<b>NOTE</b>
A data pointer and its target are always on the same image. A coarray can be of a derived type with pointer
or allocatable subcomponents. For example, if PTR is a pointer component, and Z%PTR on image P has
been associated with a target by execution of an ALLOCATE statement or a pointer assignment on image P,
Z[P]%PTR will be a reference to that target.
R1039 <i>proc-pointer-object</i> <b>is</b> <i>proc-pointer-name</i>
              <b>or</b> <i>proc-component-ref</i>
R1040 <i>proc-component-ref</i> <b>is</b> <i>scalar-variable</i> % <i>procedure-component-name</i>
C1030 (R1040) The <i>scalar-variable</i> shall be a <i>data-ref</i> that is not a coindexed object.
C1031 (R1040) The <i>procedure-component-name</i> shall be the name of a procedure pointer component of the
   declared type of <i>scalar-variable</i>.
R1041 <i>proc-target</i> <b>is</b> <i>expr</i>
              <b>or</b> <i>procedure-name</i>
              <b>or</b> <i>proc-component-ref</i>
C1032 (R1041) An <i>expr</i> shall be a reference to a function whose result is a procedure pointer.
C1033 (R1041) A <i>procedure-name</i> shall be the name of an internal, module, or dummy procedure, a procedure
   pointer, a specific intrinsic function listed in Table 16.2, or an external procedure that is accessed by use or host
   association, referenced in the scoping unit as a procedure, or that has the EXTERNAL attribute.
C1034 (R1041) The <i>proc-target</i> shall not be a nonintrinsic elemental procedure.
In a pointer assignment statement, <i>data-pointer-object</i> or <i>proc-pointer-object</i> denotes the pointer object and
<i>data-target</i> or <i>proc-target</i> denotes the pointer target.
For pointer assignment performed by a derived-type intrinsic assignment statement, the pointer object is the
pointer component of the variable and the pointer target is the corresponding component of <i>expr</i>.
<b>10.2.2.3</b> <b>Data</b> <b>pointer</b> <b>assignment</b>
If the pointer object is not polymorphic (7.3.2.3) and the pointer target is polymorphic with dynamic type that
differs from its declared type, the assignment target is the ancestor component of the pointer target that has the
type of the pointer object. Otherwise, the assignment target is the pointer target.
If the pointer target is not a pointer, the pointer object becomes pointer associated with the assignment target;
if the pointer target is a pointer with a target that is not on the same image, the pointer association status of the
pointer object becomes undefined. Otherwise, the pointer association status of the pointer object becomes that
of the pointer target; if the pointer target is associated with an object, the pointer object becomes associated
with the assignment target. If the pointer target is allocatable, it shall be allocated.
<b>NOTE</b>
A pointer assignment statement is not permitted to involve a coindexed pointer or target, see C1027 and C1029.
This prevents a pointer assignment statement from associating a pointer with a target on another image. If
such an association would otherwise be implied, the association status of the pointer becomes undefined. For
example, aderived-typeintrinsicassignmentwherethevariableand <i>expr</i> areondifferentimagesandthevariable
has an ultimate pointer component.
If the pointer object is polymorphic, it assumes the dynamic type of the pointer target. If the pointer object is
of a type with the BIND attribute or the SEQUENCE attribute, the dynamic type of the pointer target shall be
that type.
If the pointer target is a disassociated pointer, all nondeferred type parameters of the declared type of the pointer
object that correspond to nondeferred type parameters of the pointer target shall have the same values as the
corresponding type parameters of the pointer target. Otherwise, all nondeferred type parameters of the declared
type of the pointer object shall have the same values as the corresponding type parameters of the pointer target.
If the pointer object has nondeferred type parameters that correspond to deferred type parameters of the pointer
target, the pointer target shall not be a pointer with undefined association status.
If the pointer object has the CONTIGUOUS attribute, the pointer target shall be contiguous.
If the target of a pointer is a coarray, the pointer shall have the VOLATILE attribute if and only if the coarray
has the VOLATILE attribute.
If <i>bounds-remapping-list</i> appears, it specifies the upper and lower bounds of each dimension of the pointer,
and thus the extents; the pointer target shall be simply contiguous (9.5.4) or of rank one, and shall not be a
disassociated or undefined pointer. The number of elements of the pointer target shall not be less than the
number implied by the <i>bounds-remapping-list</i>. The elements of the pointer object are associated with those of
the pointer target, in array element order; if the pointer target has more elements than specified for the pointer
object, the remaining elements are not associated with the pointer object.
If <i>lower-bounds-expr</i> and <i>upper-bounds-expr</i> appear, the effect is the same as a <i>bounds-remapping-list</i> with each
<i>bounds-remapping</i> comprising corresponding elements of the lower and upper bounds arrays, in array element
order. If one of them is a scalar, the effect is as if it were broadcast to the same shape as the other.
If neither <i>bounds-remapping-list</i> nor <i>upper-bounds-expr</i> appears, the extent of a dimension of the pointer object is
the extent of the corresponding dimension of the pointer target. If <i>bounds-spec-list</i> or <i>lower-bounds-expr</i> appears,
it specifies the lower bounds; otherwise, the lower bound of each dimension is the result of the intrinsic function
LBOUND (16.9.119) applied to the corresponding dimension of the pointer target. The upper bound of each
dimension is one less than the sum of the lower bound and the extent.
<b>10.2.2.4</b> <b>Procedure</b> <b>pointer</b> <b>assignment</b>
If the pointer target is not a pointer or dummy argument, the pointer object becomes pointer associated with
the pointer target. If the pointer target is a nonpointer dummy argument, the pointer object becomes associated
with the ultimate argument of the dummy argument. Otherwise, the pointer association status of the pointer
object becomes that of the pointer target; if the pointer target is associated with a procedure, the pointer object
becomes associated with the same procedure.
The host instance (15.6.2.4) of an associated procedure pointer is the host instance of its target.
If the pointer object has an explicit interface, its characteristics shall be the same as the pointer target except
that the pointer target may be pure even if the pointer object is not pure, the pointer target may be simple even
if the pointer object is not simple, and the pointer target may be an elemental intrinsic procedure, even though
the pointer object cannot be elemental.
If the characteristics of the pointer object or the pointer target are such that an explicit interface is required,
both the pointer object and the pointer target shall have an explicit interface.
If the pointer object has an implicit interface and is explicitly typed or referenced as a function, the pointer target
shall be a function. If the pointer object has an implicit interface and is referenced as a subroutine, the pointer
target shall be a subroutine.
If the pointer object is a function with an implicit interface, the pointer target shall be a function with the same
type; corresponding type parameters shall have the same value.
If<i>procedure-name</i> isaspecificprocedurename that is also a generic name, only the specific procedure is associated
with the pointer object.
<b>10.2.2.5</b> <b>Examples</b> <b>of</b> <b>pointer</b> <b>assignment</b> <b>statements</b>
<b>NOTE</b> <b>1</b>
The following are examples of pointer assignment statements. (See 15.4.3.6, NOTE for declarations of P and
BESSEL.)
   NEW_NODE % LEFT => CURRENT_NODE
   SIMPLE_NAME => TARGET_STRUCTURE % SUBSTRUCT % COMPONENT
   PTR => NULL ( )
   ROW => MAT2D (N, :)
   WINDOW => MAT2D (I-1:I+1, J-1:J+1)
   POINTER_OBJECT => POINTER_FUNCTION (ARG_1, ARG_2)
   EVERY_OTHER => VECTOR (1:N:2)
   WINDOW2 (0:, 0:) => MAT2D (ML:MU, NL:NU)
   ! P is a procedure pointer, BESSEL is a procedure with a compatible interface.
   P => BESSEL
   ! Likewise for a structure component.
   STRUCT % COMPONENT => BESSEL
<b>NOTE</b> <b>2</b>
Itispossibletoobtaindifferent-rankviewsofpartsofanobjectbyspecifyingupperboundsinpointerassignment
statements. This requires that the object be either rank one or contiguous. Consider the following example,
in which a matrix is under consideration. The matrix is stored as a rank-one object in MYDATA because
its diagonal is needed for some reason - the diagonal cannot be gotten as a single object from a rank-two
representation. The matrix is represented as a rank-two view of MYDATA.
   real, target :: MYDATA ( NR*NC ) ! An automatic array
   real, pointer :: MATRIX ( :, : ) ! A rank-two view of MYDATA
   real, pointer :: VIEW_DIAG ( : )
   MATRIX (1:NR, 1:NC) => MYDATA ! The MATRIX view of the data
   VIEW_DIAG => MYDATA (1::NR+1) ! The diagonal of MATRIX
Rows, columns, or blocks of the matrix can be accessed as sections of MATRIX.
Rank remapping can be applied to CONTIGUOUS arrays, for example:
   REAL, CONTIGUOUS, POINTER :: A (:)
   REAL, CONTIGUOUS, TARGET :: B (:,:) ! Dummy argument
   A (1:SIZE(B)) => B ! Linear view of a rank-2 array
<b>10.2.3</b> <b>Masked</b> <b>array</b> <b>assignment</b> <b>-</b> <b>WHERE</b>
<b>10.2.3.1</b> <b>General</b> <b>form</b> <b>of</b> <b>the</b> <b>masked</b> <b>array</b> <b>assignment</b>
A masked array assignment is either a WHERE statement or a WHERE construct. It is used to mask the
evaluation of expressions and assignment of values in array assignment statements, according to the value of a
logical array expression.
R1042 <i>where-stmt</i> <b>is</b> WHERE ( <i>mask-expr</i> ) <i>where-assignment-stmt</i>
R1043 <i>where-construct</i> <b>is</b> <i>where-construct-stmt</i>
                     [ <i>where-body-construct</i> ] ...
                   [ <i>masked-elsewhere-stmt</i>
                     [ <i>where-body-construct</i> ] ... ] ...
                   [ <i>elsewhere-stmt</i>
                     [ <i>where-body-construct</i> ] ... ]
                   <i>end-where-stmt</i>
R1044 <i>where-construct-stmt</i> <b>is</b> [<i>where-construct-name</i>:] WHERE ( <i>mask-expr</i> )
R1045 <i>where-body-construct</i> <b>is</b> <i>where-assignment-stmt</i>
              <b>or</b> <i>where-stmt</i>
              <b>or</b> <i>where-construct</i>
R1046 <i>where-assignment-stmt</i> <b>is</b> <i>assignment-stmt</i>
R1047 <i>mask-expr</i> <b>is</b> <i>logical-expr</i>
R1048 <i>masked-elsewhere-stmt</i> <b>is</b> ELSEWHERE (<i>mask-expr</i>) [<i>where-construct-name</i>]
R1049 <i>elsewhere-stmt</i> <b>is</b> ELSEWHERE [<i>where-construct-name</i>]
R1050 <i>end-where-stmt</i> <b>is</b> END WHERE [<i>where-construct-name</i>]
C1035 (R1046) A <i>where-assignment-stmt</i> that is a defined assignment shall be elemental.
C1036 (R1043) If the <i>where-construct-stmt</i> is identified by a <i>where-construct-name</i>, the corresponding <i>end-</i>
   <i>where-stmt</i> shall specify the same <i>where-construct-name</i>. If the <i>where-construct-stmt</i> is not identified by
   a <i>where-construct-name</i>, the corresponding <i>end-where-stmt</i> shall not specify a <i>where-construct-name</i>. If
   an <i>elsewhere-stmt</i> or a <i>masked-elsewhere-stmt</i> is identified by a <i>where-construct-name</i>, the corresponding
   <i>where-construct-stmt</i> shall specify the same <i>where-construct-name</i>.
C1037 (R1045) A statement that is part of a <i>where-body-construct</i> shall not be a branch target statement.
If a <i>where-construct</i> contains a <i>where-stmt</i>, a <i>masked-elsewhere-stmt</i>, or another <i>where-construct</i> then each <i>mask-</i>
<i>expr</i> within the <i>where-construct</i> shall have the same shape. In each <i>where-assignment-stmt</i>, the <i>mask-expr</i> and
the variable being defined shall be arrays of the same shape.
<b>NOTE</b>
Examples of masked array assignment are:
   WHERE (TEMP > 100.0) TEMP = TEMP - REDUCE_TEMP
   WHERE (PRESSURE <= 1.0)
     PRESSURE = PRESSURE + INC_PRESSURE
     TEMP = TEMP - 5.0
   ELSEWHERE
     RAINING = .TRUE.
   END WHERE
<b>10.2.3.2</b> <b>Interpretation</b> <b>of</b> <b>masked</b> <b>array</b> <b>assignments</b>
When a WHERE statement or a <i>where-construct-stmt</i> is executed, a control mask is established. In addition,
when a WHERE construct statement is executed, a pending control mask is established. If the statement does
not appear as part of a <i>where-body-construct</i>, the <i>mask-expr</i> of the statement is evaluated, and the control mask is
established to be the value of <i>mask-expr</i>. The pending control mask is established to have the value .NOT. <i>mask-</i>
<i>expr</i> upon execution of a WHERE construct statement that does not appear as part of a <i>where-body-construct</i>.
The <i>mask-expr</i> in a WHERE statement, WHERE construct statement, or masked ELSEWHERE statement, is
evaluated at most once per execution of the statement.
Each statement in a WHERE construct is executed in sequence.
Upon execution of a <i>masked-elsewhere-stmt</i>, the following actions take place in sequence.
  (1) The control mask <i>m</i>
               <i>c</i>
               is established to have the value of the pending control mask.
  (2) The pending control mask is established to have the value <i>m</i>
                                 <i>c</i>
                                .AND. (.NOT. <i>mask-expr</i>).
  (3) The control mask <i>m</i>
               <i>c</i>
               is established to have the value <i>m</i>
                               <i>c</i>
                              .AND. <i>mask-expr</i>.
Upon execution of an ELSEWHERE statement, the control mask is established to have the value of the pending
control mask. No new pending control mask value is established.
Upon execution of an ENDWHERE statement, the control mask and pending control mask are established to
have the values they had prior to the execution of the corresponding WHERE construct statement. Following
the execution of a WHERE statement that appears as a <i>where-body-construct</i>, the control mask is established to
have the value it had prior to the execution of the WHERE statement.
<b>NOTE</b> <b>1</b>
The establishment of control masks and the pending control mask is illustrated with the following example:
   WHERE(cond1) ! Statement 1
    ...
   ELSEWHERE(cond2) ! Statement 2
    ...
   ELSEWHERE ! Statement 3
    ...
   END WHERE
Following execution of statement 1, the control mask has the value cond1 and the pending control
mask has the value .NOT. cond1. Following execution of statement 2, the control mask has the value
(.NOT. cond1) .AND. cond2 and the pending control mask has the value (.NOT. cond1) .AND. (.NOT. cond2).
Following execution of statement 3, the control mask has the value (.NOT. cond1) .AND. (.NOT. cond2). The
false condition values are propagated through the execution of the masked ELSEWHERE statement.
Upon execution of a WHERE construct statement that is part of a <i>where-body-construct</i>, the pending control
mask is established to have the value <i>m</i>
                   <i>c</i>
                  .AND. (.NOT. <i>mask-expr</i>). The control mask is then established to
have the value <i>m</i>
       <i>c</i>
        .AND. <i>mask-expr</i>. The <i>mask-expr</i> is evaluated at most once.
Upon execution of a WHERE statement that is part of a <i>where-body-construct</i>, the control mask is established
to have the value <i>m</i>
         <i>c</i>
         .AND. <i>mask-expr</i>. The pending control mask is not altered.
If a nonelemental function reference occurs in the <i>expr</i> or <i>variable</i> of a <i>where-assignment-stmt</i> or in a <i>mask-expr</i>,
the function is evaluated without any masked control; that is, all of its argument expressions are fully evaluated
and the function is fully evaluated. If the result is an array and the reference is not within the argument list
of a nonelemental function, elements corresponding to true values in the control mask are selected for use in
evaluating the <i>expr</i>, variable or <i>mask-expr</i>.
If an elemental operation or function reference occurs in the <i>expr</i> or <i>variable</i> of a <i>where-assignment-stmt</i> or in a
<i>mask-expr</i>, and is not within the argument list of a nonelemental function reference, the operation is performed
or the function is evaluated only for the elements corresponding to true values of the control mask.
If an array constructor appears in a <i>where-assignment-stmt</i> or in a <i>mask-expr</i>, the array constructor is evaluated
without any masked control and then the <i>where-assignment-stmt</i> is executed or the <i>mask-expr</i> is evaluated.
When a <i>where-assignment-stmt</i> is executed, the values of <i>expr</i> that correspond to true values of the control mask
are assigned to the corresponding elements of the variable.
The value of the control mask is established by the execution of a WHERE statement, a WHERE construct
statement, an ELSEWHERE statement, a masked ELSEWHERE statement, or an ENDWHERE statement.
Subsequent changes to the value of entities in a <i>mask-expr</i> have no effect on the value of the control mask. The
execution of a function reference in the mask expression of a WHERE statement is permitted to affect entities in
the assignment statement.
<b>NOTE</b> <b>2</b>
Examples of function references in masked array assignments are:
 WHERE (A > 0.0)
   A = LOG (A) ! LOG is invoked only for positive elements.
   A = A / SUM (LOG (A)) ! LOG is invoked for all elements
              ! because SUM is transformational
 END WHERE
<b>10.2.4</b> <b>FORALL</b>
<b>10.2.4.1</b> <b>Form</b> <b>of</b> <b>the</b> <b>FORALL</b> <b>Construct</b>
The FORALL construct allows multiple assignments, masked array (WHERE) assignments, and nested FORALL constructs and
statements to be controlled by a single <i>concurrent-control-list</i> and <i>scalar-mask-expr</i>.
R1051 <i>forall-construct</i> <b>is</b> <i>forall-construct-stmt</i>
                       [<i>forall-body-construct</i> ] ...
                       <i>end-forall-stmt</i>
R1052 <i>forall-construct-stmt</i> <b>is</b> [<i>forall-construct-name</i> :] FORALL <i>concurrent-header</i>
R1053 <i>forall-body-construct</i> <b>is</b> <i>forall-assignment-stmt</i>
              <b>or</b> <i>where-stmt</i>
              <b>or</b> <i>where-construct</i>
              <b>or</b> <i>forall-construct</i>
              <b>or</b> <i>forall-stmt</i>
R1054 <i>forall-assignment-stmt</i> <b>is</b> <i>assignment-stmt</i>
              <b>or</b> <i>pointer-assignment-stmt</i>
R1055 <i>end-forall-stmt</i> <b>is</b> END FORALL [<i>forall-construct-name</i> ]
C1038 (R1055) If the <i>forall-construct-stmt</i> has a <i>forall-construct-name</i>, the <i>end-forall-stmt</i> shall have the same <i>forall-construct-</i>
    <i>name</i>. If the <i>end-forall-stmt</i> has a <i>forall-construct-name</i>, the <i>forall-construct-stmt</i> shall have the same <i>forall-construct-</i>
    <i>name</i>.
C1039 (R1053) A statement in a <i>forall-body-construct</i> shall not define an <i>index-name</i> of the <i>forall-construct</i>.
C1040 (R1053) Any procedure referenced in a <i>forall-body-construct</i>, including one referenced by a defined operation, assignment,
    or finalization, shall be a pure procedure.
C1041 (R1053) A <i>forall-body-construct</i> shall not be a branch target.
The scope and attributes of an <i>index-name</i> in a <i>concurrent-header</i> in a FORALL construct or statement are described in 19.4.
<b>10.2.4.2</b> <b>Execution</b> <b>of</b> <b>the</b> <b>FORALL</b> <b>construct</b>
<b>10.2.4.2.1</b> <b>Execution</b> <b>stages</b>
There are three stages in the execution of a FORALL construct:
   (1) determination of the values for <i>index-name</i> variables,
   (2) evaluation of the <i>scalar-mask-expr</i>, and
   (3) execution of the FORALL body constructs.
<b>10.2.4.2.2</b> <b>Determination</b> <b>of</b> <b>the</b> <b>values</b> <b>for</b> <b>index</b> <b>variables</b>
The values of the index variables are determined as they are for the DO CONCURRENT statement (11.1.7.4.2).
<b>10.2.4.2.3</b> <b>Evaluation</b> <b>of</b> <b>the</b> <b>mask</b> <b>expression</b>
The mask expression is evaluated as it is for the DO CONCURRENT statement (11.1.7.4.2).
<b>10.2.4.2.4</b> <b>Execution</b> <b>of</b> <b>the</b> <b>FORALL</b> <b>body</b> <b>constructs</b>
The <i>forall-body-construct</i>s are executed in the order in which they appear. Each construct is executed for all active combinations of
the <i>index-name</i> values with the following interpretation:
Execution of a <i>forall-assignment-stmt</i> that is an <i>assignment-stmt</i> causes the evaluation of <i>expr</i> and all expressions within <i>variable</i>
for all active combinations of <i>index-name</i> values. These evaluations may be done in any order. After all these evaluations have been
performed, each <i>expr</i> value is assigned to the corresponding <i>variable</i>. The assignments may occur in any order.
Execution of a <i>forall-assignment-stmt</i> that is a <i>pointer-assignment-stmt</i> causes the evaluation of all expressions within <i>data-target</i>
and <i>data-pointer-object</i> or <i>proc-target</i> and <i>proc-pointer-object</i>, the determination of any pointers within <i>data-pointer-object</i> or <i>proc-</i>
<i>pointer-object</i>, and the determination of the target for all active combinations of <i>index-name</i> values. These evaluations may be done
in any order. After all these evaluations have been performed, each <i>data-pointer-object</i> or <i>proc-pointer-object</i> is associated with the
corresponding target. These associations may occur in any order.
In a <i>forall-assignment-stmt</i>, a defined assignment subroutine shall not reference any <i>variable</i> that becomes defined by the statement.
<b>NOTE</b>
If a variable defined in an assignment statement within a FORALL construct is referenced in a later statement in that construct,
the later statement uses the value(s) computed in the preceding assignment statement, not the value(s) the variable had prior to
execution of the FORALL.
Each statement in a <i>where-construct</i> (10.2.3) within a <i>forall-construct</i> is executed in sequence. When a <i>where-stmt</i>, <i>where-construct-</i>
<i>stmt</i> or <i>masked-elsewhere-stmt</i> is executed, the statement's <i>mask-expr</i> is evaluated for all active combinations of <i>index-name</i> values
as determined by the outer <i>forall-construct</i>s, masked by any control mask corresponding to outer <i>where-construct</i>s. Any <i>where-</i>
<i>assignment-stmt</i> is executed for all active combinations of <i>index-name</i> values, masked by the control mask in effect for the <i>where-</i>
<i>assignment-stmt</i>.
Execution of a <i>forall-stmt</i> or <i>forall-construct</i> causes the evaluation of the <i>concurrent-limit</i> and <i>concurrent-step</i> expressions in the
<i>concurrent-control-list</i> for all active combinations of the <i>index-name</i> values of the outer FORALL construct. The set of combinations
of<i>index-name</i> values for the inner FORALL is the union of the sets defined by these limits and steps for each active combination of the
outer <i>index-name</i> values; it also includes the outer <i>index-name</i> values. The <i>scalar-mask-expr</i> is then evaluated for all combinations
of the <i>index-name</i> values of the inner construct to produce a set of active combinations for the inner construct. If there is no
<i>scalar-mask-expr</i>, it is as if it appeared with the value true. Each statement in the inner FORALL is then executed for each active
combination of the <i>index-name</i> values.
<b>10.2.4.3</b> <b>The</b> <b>FORALL</b> <b>statement</b>
The FORALL statement allows a single assignment statement or pointer assignment statement to be controlled by a set of index
values and an optional mask expression.
R1056 <i>forall-stmt</i> <b>is</b> FORALL <i>concurrent-header</i> <i>forall-assignment-stmt</i>
A FORALL statement is equivalent to a FORALL construct containing a single <i>forall-body-construct</i> that is a <i>forall-assignment-stmt</i>.
The scope of an <i>index-name</i> in a <i>forall-stmt</i> is the statement itself (19.4).
<b>10.2.4.4</b> <b>Restrictions</b> <b>on</b> <b>FORALL</b> <b>constructs</b> <b>and</b> <b>statements</b>
A many-to-one assignment is more than one assignment to the same object, or association of more than one target with the same
pointer, whether the object is referenced directly or indirectly through a pointer. A many-to-one assignment shall not occur within
a single statement in a FORALL construct or statement. It is possible to assign or pointer-assign to the same object in different
assignment or pointer assignment statements in a FORALL construct.
<b>NOTE</b>
The appearance of each <i>index-name</i> in the identification of the left-hand side of an assignment statement is helpful in eliminating
many-to-one assignments, but it is not sufficient to guarantee there will be none. For example, the following is allowed
  FORALL (I = 1:10)
    A (INDEX (I)) = B(I)
  END FORALL
if and only if INDEX(1:10) contains no repeated values.
Within the scope of a FORALL construct, a nested FORALL statement or FORALL construct shall not have the same <i>index-name</i>.
The <i>concurrent-header</i> expressions within a nested FORALL may depend on the values of outer <i>index-name</i> variables.
<b>11</b> <b>Execution</b> <b>control</b>
<b>11.1</b> <b>Executable</b> <b>constructs</b> <b>containing</b> <b>blocks</b>
<b>11.1.1</b> <b>Blocks</b>
The following are executable constructs that contain blocks:
 ASSOCIATE construct;
 BLOCK construct;
 CHANGE TEAM construct;
 CRITICAL construct;
 DO construct;
 IF construct;
 SELECT CASE construct;
 SELECT RANK construct;
 SELECT TYPE construct.
R1101 <i>block</i> <b>is</b> [ <i>execution-part-construct</i> ] ...
Executable constructs can be used to control which blocks of a program are executed or how many times a block
is executed. Blocks are always bounded by statements that are particular to the construct in which they are
embedded.
<b>NOTE</b>
An example of a construct containing a block is:
   IF (A > 0.0) THEN
     B = SQRT (A) ! These two statements
     C = LOG (A) ! form a block.
   END IF
<b>11.1.2</b> <b>Rules</b> <b>governing</b> <b>blocks</b>
<b>11.1.2.1</b> <b>Control</b> <b>flow</b> <b>in</b> <b>blocks</b>
Transfer of control to the interior of a block from outside the block is prohibited, except for the return from a
procedure invoked within the block. Transfers within a block and transfers from the interior of a block to outside
the block may occur.
Subroutine and function references (15.5.3, 15.5.4) may appear in a block.
<b>11.1.2.2</b> <b>Execution</b> <b>of</b> <b>a</b> <b>block</b>
Execution of a block begins with the execution of the first executable construct in the block.
Execution of the block is completed when
 execution of the last executable construct in the block completes without branching to a statement within
  the block,
 a branch (11.2) within the block that has a branch target outside the block occurs,
 a RETURN statement within the block is executed, or
 an EXIT or CYCLE statement that belongs to a construct that contains the block is executed.
<b>NOTE</b>
The action that takes place at the terminal boundary depends on the particular construct and on the block
within that construct.
<b>11.1.3</b> <b>ASSOCIATE</b> <b>construct</b>
<b>11.1.3.1</b> <b>Purpose</b> <b>and</b> <b>form</b> <b>of</b> <b>the</b> <b>ASSOCIATE</b> <b>construct</b>
The ASSOCIATE construct associates named entities with expressions or variables during the execution of its
block. These named construct entities (19.4) are associating entities (19.5.1.6). The names are associate names.
R1102 <i>associate-construct</i> <b>is</b> <i>associate-stmt</i>
                   <i>block</i>
                   <i>end-associate-stmt</i>
R1103 <i>associate-stmt</i> <b>is</b> [ <i>associate-construct-name</i> : ] ASSOCIATE
                   (<i>association-list</i> )
R1104 <i>association</i> <b>is</b> <i>associate-name</i> =<i>></i> <i>selector</i>
R1105 <i>selector</i> <b>is</b> <i>expr</i>
              <b>or</b> <i>variable</i>
C1101 (R1104) If <i>selector</i> is not a <i>variable</i> or is a <i>variable</i> that has a vector subscript, neither <i>associate-name</i>
   nor any subobject thereof shall appear in a variable definition context (19.6.7) or pointer association
   context (19.6.8).
C1102 (R1104) An <i>associate-name</i> shall not be the same as another <i>associate-name</i> in the same <i>associate-stmt</i>.
C1103 (R1105) <i>variable</i> shall not be a coindexed object.
C1104 (R1105) <i>expr</i> shall not be a variable.
C1105 (R1105) <i>expr</i> shall not be a <i>designator</i> of a procedure pointer or a function reference that returns a
   procedure pointer.
R1106 <i>end-associate-stmt</i> <b>is</b> END ASSOCIATE [ <i>associate-construct-name</i> ]
C1106 (R1106) If the <i>associate-stmt</i> of an <i>associate-construct</i> specifies an <i>associate-construct-name</i>, the corres-
   ponding <i>end-associate-stmt</i> shall specify the same <i>associate-construct-name</i>. If the <i>associate-stmt</i> of an
   <i>associate-construct</i> does not specify an <i>associate-construct-name</i>, the corresponding <i>end-associate-stmt</i>
   shall not specify an <i>associate-construct-name</i>.
<b>11.1.3.2</b> <b>Execution</b> <b>of</b> <b>the</b> <b>ASSOCIATE</b> <b>construct</b>
Execution of an ASSOCIATE construct causes evaluation of every expression within every <i>selector</i> that is a
variable designator and evaluation of every other <i>selector</i>, followed by execution of its block. During execution of
that block each associate name identifies an entity which is associated (19.5.1.6) with the corresponding selector.
The associating entity assumes the declared type and type parameters of the selector. If and only if the selector
is polymorphic, the associating entity is polymorphic.
The other attributes of the associating entity are described in 11.1.3.3.
It is permissible to branch to an <i>end-associate-stmt</i> only from within its ASSOCIATE construct.
<b>11.1.3.3</b> <b>Other</b> <b>attributes</b> <b>of</b> <b>associate</b> <b>names</b>
Within an ASSOCIATE, CHANGE TEAM, or SELECT TYPE construct, each associating entity has the same
rank as its associated selector. The lower bound of each dimension is the result of the intrinsic function LBOUND
(16.9.119) applied to the corresponding dimension of <i>selector</i>. The upper bound of each dimension is one less
than the sum of the lower bound and the extent. The associating entity does not have the ALLOCATABLE or
POINTER attributes; it has the TARGET attribute if and only if the selector is a variable and has either the
TARGET or POINTER attribute.
Within an ASSOCIATE, SELECT RANK, or SELECT TYPE construct, each associating entity has the same
corank as its associated selector. If the selector is a coarray, the cobounds of each codimension of the associating
entity are the same as those of the selector.
Within a CHANGE TEAM construct, the associating entity is a coarray. Its corank and cobounds are as specified
in its <i>codimension-decl</i>.
WithinanASSOCIATE,CHANGETEAM,SELECTRANK,orSELECTTYPEconstruct, theassociatingentity
has the ASYNCHRONOUS or VOLATILE attribute if and only if the selector is a variable and has the attribute.
If the associating entity is polymorphic, it assumes the dynamic type and type parameter values of the selector.
The associating entity does not have the OPTIONAL attribute. If the selector has the OPTIONAL attribute, it
cannot be absent (15.5.2.13). The associating entity is contiguous if and only if the selector is contiguous.
The associating entity itself is a variable, but if the selector is not a definable variable, the associating entity
is not definable and shall not be defined or become undefined. If a selector is not permitted to appear in
a variable definition context (19.6.7), neither the associate name nor any subobject thereof shall appear in a
variable definition context or pointer association context (19.6.8).
<b>11.1.3.4</b> <b>Examples</b> <b>of</b> <b>the</b> <b>ASSOCIATE</b> <b>construct</b>
<b>NOTE</b>
The following example illustrates an association with an expression.
   ASSOCIATE ( Z => EXP (-(X**2+Y**2)) * COS (THETA) )
    PRINT *, A+Z, A-Z
   END ASSOCIATE
The following example illustrates an association with a derived-type variable.
   ASSOCIATE ( XC => AX%B(I,J)%C )
    XC%DV = XC%DV + PRODUCT (XC%EV(1:N))
   END ASSOCIATE
The following example illustrates association with an array section.
   ASSOCIATE ( ARRAY => AX%B(I,:)%C )
    ARRAY(N)%EV = ARRAY(N-1)%EV
   END ASSOCIATE
The following example illustrates multiple associations.
   ASSOCIATE ( W => RESULT(I,J)%W, ZX => AX%B(I,J)%D, ZY => AY%B(I,J)%D )
    W = ZX*X + ZY*Y
   END ASSOCIATE
<b>11.1.4</b> <b>BLOCK</b> <b>construct</b>
The BLOCK construct is an executable construct that can contain declarations.
R1107 <i>block-construct</i> <b>is</b> <i>block-stmt</i>
                    [ <i>block-specification-part</i> ]
                   <i>block</i>
                   <i>end-block-stmt</i>
R1108 <i>block-stmt</i> <b>is</b> [ <i>block-construct-name</i> : ] BLOCK
R1109 <i>block-specification-part</i> <b>is</b> [ <i>use-stmt</i> ] ...
                  [ <i>import-stmt</i> ] ...
                  [ <i>declaration-construct</i> ] ...
R1110 <i>end-block-stmt</i> <b>is</b> END BLOCK [ <i>block-construct-name</i> ]
C1107 (R1107) A <i>block-specification-part</i> shall not contain a COMMON, EQUIVALENCE, INTENT, NAMELIST,
   OPTIONAL, statement function, or VALUE statement.
C1108 (R1107) A SAVE statement in a BLOCK construct shall contain a <i>saved-entity-list</i> that does not specify a
    <i>common-block-name</i>.
C1109 The <i>block</i> of a <i>block-construct</i> shall not begin with a FORMAT statement or a DATA statement.
C1110 (R1107) If the <i>block-stmt</i> of a <i>block-construct</i> specifies a <i>block-construct-name</i>, the corresponding <i>end-</i>
   <i>block-stmt</i> shall specify the same <i>block-construct-name</i>. If the <i>block-stmt</i> does not specify a <i>block-</i>
   <i>construct-name</i>, the corresponding <i>end-block-stmt</i> shall not specify a <i>block-construct-name</i>.
Except for the ASYNCHRONOUS, IMPORT, and VOLATILE statements, specifications in a BLOCK construct
declare construct entities whose scope is that of the BLOCK construct (19.4). The appearance of the name of an
object that is not a construct entity in an ASYNCHRONOUS or VOLATILE statement in a BLOCK construct
specifies that the object has the attribute within the construct even if it does not have the attribute outside the
construct.
Execution of a BLOCK construct causes evaluation of the specification expressions within its specification part
in a processor-dependent order, followed by execution of its block.
It is permissible to branch to an <i>end-block-stmt</i> only from within its BLOCK construct.
<b>NOTE</b>
The following is an example of a BLOCK construct.
   IF (swapxy) THEN
    BLOCK
     REAL (KIND (x)) tmp
     tmp = x
     x = y
     y = tmp
    END BLOCK
   END IF
Actions on a variable local to a BLOCK construct do not affect any variable of the same name outside the
construct. For example,
   F = 254E-2
   BLOCK
    REAL F
    F = 39.37
   END BLOCK
   ! F is still equal to 254E-2.
A SAVE statement outside a BLOCK construct does not affect variables local to the BLOCK construct, because
a SAVE statement affects variables in its scoping unit rather than in its inclusive scope. For example,
   SUBROUTINE S
    ...
    SAVE
    ...
    BLOCK
     REAL X ! Not saved.
                <b>J3/23-007r1</b> <b>191</b>
<b>NOTE</b> <b>(cont.)</b>
     REAL,SAVE :: Y(100) ! SAVE attribute is allowed.
     Z = 3 ! Implicitly declared in S, thus saved.
     ...
    END BLOCK
    ...
   END SUBROUTINE
<b>11.1.5</b> <b>CHANGE</b> <b>TEAM</b> <b>construct</b>
<b>11.1.5.1</b> <b>Purpose</b> <b>and</b> <b>form</b> <b>of</b> <b>the</b> <b>CHANGE</b> <b>TEAM</b> <b>construct</b>
The CHANGE TEAM construct changes the current team. Named construct entities (19.4) can be associated
(19.5.1.6) with coarrays in the containing scoping unit, in the same way as for the ASSOCIATE construct.
R1111 <i>change-team-construct</i> <b>is</b> <i>change-team-stmt</i>
                   <i>block</i>
                   <i>end-change-team-stmt</i>
R1112 <i>change-team-stmt</i> <b>is</b> [ <i>team-construct-name</i> : ] CHANGE TEAM ( <i>team-value</i>
                   [ , <i>coarray-association-list</i> ] [ , <i>sync-stat-list</i> ] )
R1113 <i>coarray-association</i> <b>is</b> <i>codimension-decl</i> =<i>></i> <i>selector</i>
R1114 <i>end-change-team-stmt</i> <b>is</b> END TEAM [ ( [ <i>sync-stat-list</i> ] ) ] [ <i>team-construct-name</i> ]
R1115 <i>team-value</i> <b>is</b> <i>scalar-expr</i>
C1111 A branch (11.2) within a CHANGE TEAM construct shall not have a branch target that is outside the
   construct.
C1112 A RETURN statement shall not appear within a CHANGE TEAM construct.
C1113 If the <i>change-team-stmt</i> of a <i>change-team-construct</i> specifies a <i>team-construct-name</i>, the corresponding
   <i>end-change-team-stmt</i> shall specify the same <i>team-construct-name</i>. If the <i>change-team-stmt</i> of a <i>change-</i>
   <i>team-construct</i> does not specify a <i>team-construct-name</i>, the corresponding <i>end-change-team-stmt</i> shall
   not specify a <i>team-construct-name</i>.
C1114 In a <i>change-team-stmt</i>, a <i>coarray-name</i> in a <i>codimension-decl</i> shall not be the same as a <i>selector</i>, or
   another <i>coarray-name</i>, in that statement.
C1115 A <i>team-value</i> shall be of type TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV.
C1116 No <i>selector</i> shall appear more than once in a given <i>change-team-stmt</i>.
C1117 A <i>selector</i> in a <i>coarray-association</i> shall be a named coarray.
Each <i>coarray-name</i> in a <i>codimension-decl</i> in the CHANGE TEAM statement is an associate name which is
associated with the corresponding selector. Each associating entity assumes the type and type parameters of
its selector; it is polymorphic if and only if the selector is polymorphic. The other attributes of the associating
entities are described in 11.1.3.3.
<b>11.1.5.2</b> <b>Execution</b> <b>of</b> <b>a</b> <b>CHANGE</b> <b>TEAM</b> <b>construct</b>
The<i>team-value</i>sontheactiveimagesthatexecutetheCHANGETEAMstatementshallbethoseofteamvariables
defined by corresponding executions of the same FORM TEAM statement (11.7.9). When the CHANGE TEAM
statementisexecuted, thecurrentteamshallbetheteamthatwascurrentwhenthoseteamvariablesweredefined.
The current team for the statements of the CHANGE TEAM <i>block</i> is the team identified by the <i>team-value</i>. If
<i>team-value</i> is a variable, the variable shall not be defined or become undefined during execution of the CHANGE
TEAM construct. A CHANGE TEAM construct completes execution by executing its END TEAM statement,
which restores the current team to the original team that was current for the CHANGE TEAM statement.
Execution of a CHANGE TEAM construct causes evaluation of the expressions within each <i>codimension-decl</i> in
the CHANGE TEAM statement, followed by execution of its block. Each <i>selector</i> shall be an established coarray
when the CHANGE TEAM statement begins execution.
It is permissible to branch to an <i>end-change-team-stmt</i> only from within its CHANGE TEAM construct.
An allocatable coarray that was allocated immediately before executing a CHANGE TEAM statement shall not
be deallocated during execution of the construct. An allocatable coarray that was unallocated immediately before
executing a CHANGE TEAM statement, and which is allocated immediately before executing the corresponding
END TEAM statement, is deallocated by the execution of the END TEAM statement.
Successful execution of a CHANGE TEAM statement performs an implicit synchronization of all images of the
new team that is identified by <i>team-value</i>. All active images of the new team shall execute the same CHANGE
TEAM statement. On each image of the new team, execution of the segment following the CHANGE TEAM
statement is delayed until all other images of that team have executed the same statement the same number of
times in the original team.
If the new team contains a failed image and no other error condition occurs, there is an implicit synchronization
of all active images of the new team. On each active image of the new team, execution of the segment following
the CHANGE TEAM statement is delayed until all other active images of that team have executed the same
statement the same number of times in the original team.
If no error condition other than the new team containing a failed image occurs, the segments that executed before
the CHANGE TEAM statement on an active image of the new team precede the segments that execute after the
CHANGE TEAM statement on another active image of that team.
When a CHANGE TEAM construct completes execution, there is an implicit synchronization of all active images
in the new team. On each active image of the new team, execution of the segment following the END TEAM
statement is delayed until all other active images of this team have executed the same construct the same number
of times in this team. The segments that executed before the END TEAM statement on an active image of the
new team precede the segments that execute after the END TEAM statement on another active image of that
team.
<b>NOTE</b> <b>1</b>
Deallocation of an allocatable coarray that was not allocated at the beginning of a CHANGE TEAM construct,
but is allocated at the end of execution of the construct, occurs even for allocatable coarrays with the SAVE
attribute.
<b>NOTE</b> <b>2</b>
Execution of a CHANGE TEAM statement includes a synchronization of the executing image with the other
images that will be in the same team after execution of the CHANGE TEAM statement. Synchronization of
these images occurs again when the corresponding END TEAM statement is executed.
If it is desired to synchronize all of the images in the team that was current when the CHANGE TEAM
statement was executed, a SYNC TEAM statement that specifies the parent team can be executed immediately
after the CHANGE TEAM statement. If similar semantics are desired following the END TEAM statement, a
SYNC ALL statement could immediately follow the END TEAM statement.
<b>NOTE</b> <b>3</b>
A coarray that is established when a CHANGE TEAM statement is executed retains its corank and cobounds
inside the block. If it is desired to perform remote accesses based on corank or cobounds different from those
of the original coarray, an associating coarray can be used. An example of this is in C.7.7.
<b>11.1.6</b> <b>CRITICAL</b> <b>construct</b>
A CRITICAL construct limits execution of a block to one image at a time.
R1116 <i>critical-construct</i> <b>is</b> <i>critical-stmt</i>
                   <i>block</i>
                   <i>end-critical-stmt</i>
R1117 <i>critical-stmt</i> <b>is</b> [ <i>critical-construct-name</i> : ] CRITICAL [ ( [ <i>sync-stat-list</i> ] ) ]
R1118 <i>end-critical-stmt</i> <b>is</b> END CRITICAL [ <i>critical-construct-name</i> ]
C1118 (R1116) If the <i>critical-stmt</i> of a <i>critical-construct</i> specifies a <i>critical-construct-name</i>, the corresponding
   <i>end-critical-stmt</i> shall specify the same <i>critical-construct-name</i>. If the <i>critical-stmt</i> of a <i>critical-construct</i>
   does not specify a <i>critical-construct-name</i>, the corresponding <i>end-critical-stmt</i> shall not specify a <i>critical-</i>
   <i>construct-name</i>.
C1119 (R1116) The <i>block</i> of a <i>critical-construct</i> shall not contain a RETURN statement or an image control
   statement.
C1120 Abranch(11.2)withinaCRITICALconstructshallnothaveabranchtargetthatisoutsidetheconstruct.
Execution of the CRITICAL construct is completed when execution of its block is completed, or the executing
image fails (5.3.6). A procedure invoked, directly or indirectly, from a CRITICAL construct shall not execute an
image control statement.
The processor shall ensure that once an image has commenced executing <i>block</i>, no other image shall commence
executing <i>block</i> until this image has completed execution of the construct. The image shall not execute an image
control statement during the execution of <i>block</i>. The sequence of executed statements is therefore a segment
(11.7.2). If image M completes execution of the construct without failing and image T is the next to execute the
construct, the segment on image M precedes the segment on image T. Otherwise, if image M completes execution
of the construct by failing, and image T is the next to execute the construct, the previous segment on image M
precedes the segment on image T.
The effect of a STAT= or ERRMSG= specifier in a CRITICAL statement is specified in 11.7.11.
It is permissible to branch to an <i>end-critical-stmt</i> only from within its CRITICAL construct.
<b>NOTE</b> <b>1</b>
If more than one image executes the block of a CRITICAL construct without failing, its execution by one image
always either precedes or succeeds its execution by another nonfailed image. Typically no other statement
ordering is needed. Consider the following example:
   CRITICAL
     GLOBAL_COUNTER[1] = GLOBAL_COUNTER[1] + 1
   END CRITICAL
The definition of GLOBAL_COUNTER [1] by a particular image will always precede the reference to the same
variable by the next image to execute the block.
<b>NOTE</b> <b>2</b>
The following example permits a large number of jobs to be shared among the images:
   INTEGER :: NUM_JOBS[*], JOB
    ...
   IF (THIS_IMAGE() == 1) READ(*,*) NUM_JOBS
   SYNC ALL
   DO
     CRITICAL
<b>194</b> <b>J3/23-007r1</b>
<b>NOTE</b> <b>2</b> <b>(cont.)</b>
      JOB = NUM_JOBS[1]
      NUM_JOBS[1] = JOB - 1
     END CRITICAL
     IF (JOB > 0) THEN
       ... ! Work on JOB
     ELSE
      EXIT
     END IF
   END DO
   SYNC ALL
<b>11.1.7</b> <b>DO</b> <b>construct</b>
<b>11.1.7.1</b> <b>Purpose</b> <b>and</b> <b>form</b> <b>of</b> <b>the</b> <b>DO</b> <b>construct</b>
The DO construct specifies the repeated execution of a sequence of executable constructs. Such a repeated
sequence is called a loop.
The number of iterations of a loop can be determined at the beginning of execution of the DO construct, or can
be left indefinite ("DO forever" or DO WHILE). The execution order of the iterations can be left indeterminate
(DO CONCURRENT); except in this case, the loop can be terminated immediately (11.1.7.4.5). An iteration of
the loop can be curtailed by executing a CYCLE statement (11.1.7.4.4).
There are three phases in the execution of a DO construct: initiation of the loop, execution of each iteration of
the loop, and termination of the loop.
The scope and attributes of an <i>index-name</i> in a <i>concurrent-header</i> (DO CONCURRENT) are described in 19.4.
<b>11.1.7.2</b> <b>Form</b> <b>of</b> <b>the</b> <b>DO</b> <b>construct</b>
R1119 <i>do-construct</i> <b>is</b> <i>do-stmt</i>
                   <i>block</i>
                   <i>end-do</i>
R1120 <i>do-stmt</i> <b>is</b> <i>nonlabel-do-stmt</i>
              <b>or</b> <i>label-do-stmt</i>
R1121 <i>label-do-stmt</i> <b>is</b> [ <i>do-construct-name</i> : ] DO <i>label</i> [ <i>loop-control</i> ]
R1122 <i>nonlabel-do-stmt</i> <b>is</b> [ <i>do-construct-name</i> : ] DO [ <i>loop-control</i> ]
R1123 <i>loop-control</i> <b>is</b> [ , ] <i>do-variable</i> = <i>scalar-int-expr</i>, <i>scalar-int-expr</i>
                   [ , <i>scalar-int-expr</i> ]
              <b>or</b> [ , ] WHILE ( <i>scalar-logical-expr</i> )
              <b>or</b> [ , ] CONCURRENT <i>concurrent-header</i> <i>concurrent-locality</i>
R1124 <i>do-variable</i> <b>is</b> <i>scalar-int-variable-name</i>
C1121 (R1124) The <i>do-variable</i> shall be a variable of type integer.
R1125 <i>concurrent-header</i> <b>is</b> ( [ <i>integer-type-spec</i> :: ] <i>concurrent-control-list</i> [ , <i>scalar-mask-expr</i> ] )
R1126 <i>concurrent-control</i> <b>is</b> <i>index-name</i> = <i>concurrent-limit</i> : <i>concurrent-limit</i> [ : <i>concurrent-step</i> ]
R1127 <i>concurrent-limit</i> <b>is</b> <i>scalar-int-expr</i>
R1128 <i>concurrent-step</i> <b>is</b> <i>scalar-int-expr</i>
R1129 <i>concurrent-locality</i> <b>is</b> [ <i>locality-spec</i> ]...
R1130 <i>locality-spec</i> <b>is</b> LOCAL ( <i>variable-name-list</i> )
              <b>or</b> LOCAL_INIT ( <i>variable-name-list</i> )
              <b>or</b> REDUCE ( <i>reduce-operation</i> : <i>variable-name-list</i> )
              <b>or</b> SHARED ( <i>variable-name-list</i> )
              <b>or</b> DEFAULT ( NONE )
R1131 <i>reduce-operation</i> <b>is</b> <i>binary-reduce-op</i>
              <b>or</b> <i>function-reduction-name</i>
R1132 <i>binary-reduce-op</i> <b>is</b> +
              <b>or</b> *
              <b>or</b> .AND.
              <b>or</b> .OR.
              <b>or</b> .EQV.
              <b>or</b> .NEQV.
C1122 The <i>function-reduction-name</i> shall be the name of the standard intrinsic function IAND, IEOR, IOR,
   MAX, or MIN.
C1123 (R1125) Any procedure referenced in the <i>scalar-mask-expr</i>, including one referenced by a defined opera-
   tion, shall be a pure procedure (15.7).
C1124 (R1126) The <i>index-name</i> shall be a named scalar variable of type integer.
C1125 (R1126) A <i>concurrent-limit</i> or <i>concurrent-step</i> in a <i>concurrent-control</i> shall not contain a reference to
   any <i>index-name</i> in the <i>concurrent-control-list</i> in which it appears.
C1126 A <i>variable-name</i> in a <i>locality-spec</i> shall be the name of a variable in the innermost executable construct
   or scoping unit that includes the DO CONCURRENT statement.
C1127 A <i>variable-name</i> in a <i>locality-spec</i> shall not be the same as an <i>index-name</i> in the <i>concurrent-header</i> of
   the same DO CONCURRENT statement.
C1128 The name of a variable shall not appear in more than one <i>variable-name-list</i>, or more than once in a
   <i>variable-name-list</i>, in a given <i>concurrent-locality</i>.
C1129 The DEFAULT ( NONE ) <i>locality-spec</i> shall not appear more than once in a given <i>concurrent-locality</i>.
C1130 A <i>variable-name</i> that appears in a LOCAL or LOCAL_INIT <i>locality-spec</i> shall not have the ALLOC-
   ATABLE, INTENT (IN), or OPTIONAL attribute, shall not be of finalizable type, shall not have an
   allocatable ultimate component, shall not be a nonpointer polymorphic dummy argument, and shall not
   be a coarray or an assumed-size array. A <i>variable-name</i> that is not permitted to appear in a variable
   definition context shall not appear in a LOCAL or LOCAL_INIT <i>locality-spec</i>.
C1131 A<i>variable-name</i> thatappearsinaREDUCE<i>locality-spec</i> shallnothavetheASYNCHRONOUS,INTENT
   (IN), OPTIONAL, or VOLATILE attribute, shall not be coindexed, and shall not be an assumed-size
   array. A <i>variable-name</i> that is not permitted to appear in a variable definition context shall not appear
   in a REDUCE <i>locality-spec</i>.
C1132 A<i>variable-name</i> thatappearsinaREDUCE<i>locality-spec</i> shallbeofintrinsictypesuitablefortheintrinsic
   operation or function specified by its <i>reduce-operation</i>.
C1133 A variable that is referenced by the <i>scalar-mask-expr</i> of a <i>concurrent-header</i> or by any <i>concurrent-limit</i>
   or <i>concurrent-step</i> in that <i>concurrent-header</i> shall not appear in a LOCAL <i>locality-spec</i> in the same DO
   CONCURRENT statement.
C1134 If the <i>locality-spec</i> DEFAULT ( NONE ) appears in a DO CONCURRENT statement, a variable that is
   a local or construct entity of a scope containing the DO CONCURRENT construct, and that appears in
   the block of the construct, shall have its locality explicitly specified by that statement.
R1133 <i>end-do</i> <b>is</b> <i>end-do-stmt</i>
              <b>or</b> <i>continue-stmt</i>
R1134 <i>end-do-stmt</i> <b>is</b> END DO [ <i>do-construct-name</i> ]
C1135 (R1119) If the <i>do-stmt</i> of a <i>do-construct</i> specifies a <i>do-construct-name</i>, the corresponding <i>end-do</i> shall be
   an <i>end-do-stmt</i> specifying the same <i>do-construct-name</i>. If the <i>do-stmt</i> of a <i>do-construct</i> does not specify
   a <i>do-construct-name</i>, the corresponding <i>end-do</i> shall not specify a <i>do-construct-name</i>.
C1136 (R1119) If the <i>do-stmt</i> is a <i>nonlabel-do-stmt</i>, the corresponding <i>end-do</i> shall be an <i>end-do-stmt</i>.
C1137 (R1119) If the <i>do-stmt</i> is a <i>label-do-stmt</i>, the corresponding <i>end-do</i> shall be identified with the same <i>label</i>.
It is permissible to branch to an <i>end-do</i> only from within its DO construct.
<b>11.1.7.3</b> <b>Active</b> <b>and</b> <b>inactive</b> <b>DO</b> <b>constructs</b>
A DO construct is either active or inactive. Initially inactive, a DO construct becomes active only when its DO
statement is executed.
Once active, the DO construct becomes inactive only when it terminates (11.1.7.4.5).
<b>11.1.7.4</b> <b>Execution</b> <b>of</b> <b>a</b> <b>DO</b> <b>construct</b>
<b>11.1.7.4.1</b> <b>Loop</b> <b>initiation</b>
When the DO statement is executed, the DO construct becomes active. If <i>loop-control</i> is
 [ , ] <i>do-variable</i> = <i>scalar-int-expr</i>
                  1
                 , <i>scalar-int-expr</i>
                           2
                        [ , <i>scalar-int-expr</i>
                                     3
                                 ]
the following steps are performed in sequence.
  (1) The initial parameter <i>m</i>
                  1
                , the terminal parameter <i>m</i>
                                 2
                             , and the incrementation parameter <i>m</i>
                                                      3
                                               are
     of type integer with the same kind type parameter as the <i>do-variable</i>. Their values are established
     by evaluating <i>scalar-int-expr</i>
                    1
                  , <i>scalar-int-expr</i>
                             2
                          , and <i>scalar-int-expr</i>
                                        3
                                   , respectively, including, if ne-
     cessary, conversion to the kind type parameter of the <i>do-variable</i> according to the rules for numeric
     conversion (Table 10.9). If <i>scalar-int-expr</i>
                           3
                        does not appear, <i>m</i>
                                      3
                                  has the value 1. The value of <i>m</i>
                                                        3
     shall not be zero.
  (2) The DO variable becomes defined with the value of the initial parameter <i>m</i>
                                            1
                                       .
  (3) The iteration count is established and is the value of the expression (<i>m</i>
                                         2
                  -<i>m</i>
                                            1
                                                                      +<i>m</i>
                                               3
                                                                           )<i>/m</i>
                                                  3
                                           , unless that
     value is negative, in which case the iteration count is 0.
<b>NOTE</b>
The iteration count is zero whenever:
 <i>m</i>
   1
   <i>>m</i>
      2
      and <i>m</i>
          3
        <i>></i> 0, or
 <i>m</i>
   1
   <i><m</i>
      2
      and <i>m</i>
          3
        <i><</i> 0.
If <i>loop-control</i> is omitted, no iteration count is calculated. The effect is as if a large positive iteration count,
impossible to decrement to zero, were established. If <i>loop-control</i> is [ , ] WHILE (<i>scalar-logical-expr</i>), the effect
is as if <i>loop-control</i> were omitted and the following statement inserted as the first statement of the <i>block</i>:
 IF (.NOT. (<i>scalar-logical-expr</i>)) EXIT
For a DO CONCURRENT construct, the values of the index variables for the iterations of the construct are
determined by the rules in 11.1.7.4.2.
At the completion of the execution of the DO statement, the execution cycle begins.
<b>11.1.7.4.2</b> <b>DO</b> <b>CONCURRENT</b> <b>loop</b> <b>control</b>
The <i>concurrent-limit</i> and <i>concurrent-step</i> expressions in the <i>concurrent-control-list</i> are evaluated. These ex-
pressions may be evaluated in any order. The set of values that a particular <i>index-name</i> variable assumes is
determined as follows.
  (1) The lower bound <i>m</i>
                1
              , the upper bound <i>m</i>
                           2
                        , and the step <i>m</i>
                                    3
                                are of type integer with the same kind
     type parameter as the <i>index-name</i>. Their values are established by evaluating the first <i>concurrent-</i>
     <i>limit</i>, the second <i>concurrent-limit</i>, and the <i>concurrent-step</i> expressions, respectively, including, if
     necessary, conversion to the kind type parameter of the <i>index-name</i> according to the rules for numeric
     conversion (Table 10.9). If <i>concurrent-step</i> does not appear, <i>m</i>
                                     3
                                 has the value 1. The value <i>m</i>
                                                     3
                                               shall
     not be zero.
  (2) Let the value of <i>max</i> be (<i>m</i>
                    2
         -<i>m</i>
                       1
                                     +<i>m</i>
                          3
                                         )<i>/m</i>
                            3
                         . If <i>max</i> 0 for some <i>index-name</i>, the execution of the
     construct is complete. Otherwise, the set of values for the <i>index-name</i> is
      <i>m</i>
         1
                + (<i>k</i>- 1)x<i>m</i>
                 3
                  where <i>k</i> = 1, 2, ..., <i>max</i>.
The set of combinations of <i>index-name</i> values is the Cartesian product of the sets defined by each triplet specific-
ation. An <i>index-name</i> becomes defined when this set is evaluated.
The <i>scalar-mask-expr</i>, if any, is evaluated for each combination of <i>index-name</i> values. If there is no <i>scalar-</i>
<i>mask-expr</i>, it is as if it appeared with the value true. The <i>index-name</i> variables may be primaries in the
<i>scalar-mask-expr</i>.
The set of active combinations of <i>index-name</i> values is the subset of all possible combinations for which the
<i>scalar-mask-expr</i> has the value true.
<b>NOTE</b>
The <i>index-name</i> variables can appear in the mask, for example
   DO CONCURRENT (I=1:10, J=1:10, A(I) > 0.0 .AND. B(J) < 1.0)
     ...
<b>11.1.7.4.3</b> <b>The</b> <b>execution</b> <b>cycle</b>
The execution cycle of a DO construct that is not a DO CONCURRENT construct consists of the following steps
performed in sequence repeatedly until termination.
  (1) The iteration count, if any, is tested. If it is zero, the loop terminates and the DO construct becomes
     inactive. If <i>loop-control</i> is [ , ] WHILE (<i>scalar-logical-expr</i>), the <i>scalar-logical-expr</i> is evaluated; if
     the value of this expression is false, the loop terminates and the DO construct becomes inactive.
  (2) The <i>block</i> of the loop is executed.
  (3) The iteration count, if any, is decremented by one. The DO variable, if any, is incremented by the
     value of the incrementation parameter <i>m</i>
                          3
                       .
ExceptfortheincrementationoftheDOvariablethatoccursinstep(3), theDOvariableshallneitherberedefined
nor become undefined while the DO construct is active.
The <i>block</i> of a DO CONCURRENT construct is executed for every active combination of the <i>index-name</i> values.
Each execution of the <i>block</i> is an iteration. The executions may occur in any order.
<b>11.1.7.4.4</b> <b>CYCLE</b> <b>statement</b>
Execution of a loop iteration can be curtailed by executing a CYCLE statement that belongs to the construct.
R1135 <i>cycle-stmt</i> <b>is</b> CYCLE [ <i>do-construct-name</i> ]
C1138 If a <i>do-construct-name</i> appears on a CYCLE statement, the CYCLE statement shall be within that
   <i>do-construct</i>; otherwise, it shall be within at least one <i>do-construct</i>.
C1139 A <i>cycle-stmt</i> shall not appear within a CHANGE TEAM, CRITICAL, or DO CONCURRENT construct
   if it belongs to an outer construct.
A CYCLE statement belongs to a particular DO construct. If the CYCLE statement contains a DO construct
name, it belongs to that DO construct; otherwise, it belongs to the innermost DO construct in which it appears.
Execution of a CYCLE statement that belongs to a DO construct that is not a DO CONCURRENT construct
causes immediate progression to step (3) of the execution cycle of the DO construct to which it belongs.
Execution of a CYCLE statement that belongs to a DO CONCURRENT construct completes execution of that
iteration of the construct.
In a DO construct, a transfer of control to the <i>end-do</i> has the same effect as execution of a CYCLE statement
belonging to that construct.
<b>11.1.7.4.5</b> <b>Loop</b> <b>termination</b>
For a DO construct that is not a DO CONCURRENT construct, the loop terminates, and the DO construct
becomes inactive, when any of the following occurs.
 The iteration count is determined to be zero or the <i>scalar-logical-expr</i> is false, when tested during step (1)
  of the above execution cycle.
 An EXIT statement that belongs to the DO construct is executed.
 An EXIT or CYCLE statement that belongs to an outer construct and is within the DO construct is
  executed.
 A branch occurs within the DO construct and the branch target statement is outside the construct.
 A RETURN statement within the DO construct is executed.
For a DO CONCURRENT construct, the loop terminates, and the DO construct becomes inactive when all of
the iterations have completed execution.
When a DO construct becomes inactive, the DO variable, if any, of the DO construct retains its last defined
value.
<b>11.1.7.5</b> <b>Additional</b> <b>semantics</b> <b>for</b> <b>DO</b> <b>CONCURRENT</b> <b>constructs</b>
C1140 A RETURN statement shall not appear within a DO CONCURRENT construct.
C1141 An image control statement shall not appear within a DO CONCURRENT construct.
C1142 A branch (11.2) within a DO CONCURRENT construct shall not have a branch target that is outside
   the construct.
C1143 A reference to an impure procedure shall not appear within a DO CONCURRENT construct.
C1144 A statement that might result in the deallocation of a polymorphic entity shall not appear within a DO
   CONCURRENT construct.
C1145 A reference to the procedure IEEE_GET_FLAG, IEEE_GET_HALTING_MODE, IEEE_GET_-
   STATUS, IEEE_SET_HALTING_MODE, IEEE_SET_MODES, or IEEE_SET_STATUS from the
   intrinsic module IEEE_EXCEPTIONS, shall not appear within a DO CONCURRENT construct.
C1146 AreferencetotheprocedureIEEE_SET_ROUNDING_MODEorIEEE_SET_UNDERFLOW_MODE
   from the intrinsic module IEEE_ARITHMETIC shall not appear within a DO CONCURRENT con-
   struct.
The locality of a variable that appears in a DO CONCURRENT construct is LOCAL, LOCAL_INIT, REDUCE,
SHARED, or unspecified. A construct or statement entity of a construct or statement within the DO CONCUR-
RENT construct has SHARED locality if it has the SAVE attribute. If it does not have the SAVE attribute, it
is a different entity in each iteration, similar to LOCAL locality.
A variable that has LOCAL or LOCAL_INIT locality is a construct entity with the same type, type parameters,
and rank as the variable with the same name in the innermost executable construct or scoping unit that includes
theDOCONCURRENTconstruct,andtheoutsidevariableisinaccessiblebythatnamewithintheconstruct. The
construct entity has the ASYNCHRONOUS, CONTIGUOUS, POINTER, TARGET, or VOLATILE attribute if
and only if the outside variable has that attribute; it does not have the BIND, INTENT, PROTECTED, SAVE,
or VALUE attribute, even if the outside variable has that attribute. If it is not a pointer, it has the same bounds
as the outside variable. At the beginning of execution of each iteration,
 if a variable with LOCAL locality is a pointer it has undefined pointer association status, and otherwise it
  is undefined except for any subobjects that are default-initialized;
 a variable with LOCAL_INIT locality has the pointer association status and definition status of the out-
  side variable with that name; the outside variable shall not be an undefined pointer or a nonallocatable
  nonpointer variable that is undefined.
If a variable with LOCAL or LOCAL_INIT locality becomes an affector of a pending input/output operation,
the operation shall have completed before the end of the iteration. If a variable with LOCAL or LOCAL_INIT
locality has the TARGET attribute, a pointer associated with it during an iteration becomes undefined when
execution of that iteration completes.
A variable that has REDUCE locality is a construct entity with the same type, type parameters, rank, and bounds
as the variable with the same name in the innermost executable construct or scoping unit that includes the DO
CONCURRENT construct (the outside variable); the outside variable is inaccessible by that name within the
construct. The outside variable shall not be an unallocated allocatable variable or a pointer that is not associated.
The construct entity has the CONTIGUOUS attribute if and only if the outside variable has that attribute; it
does not have the ALLOCATABLE, BIND, INTENT, POINTER, PROTECTED, SAVE, TARGET, or VALUE
attribute, even if the outside variable has that attribute. Before execution of the iterations begins, the construct
entity is assigned an initial value corresponding to its <i>reduce-operation</i> as specified in Table 11.1.
          <b>Table</b> <b>11.1</b> <b>-</b> <b>Initial</b> <b>values</b> <b>for</b> <b>reduction</b> <b>operations</b>
           Operation Initial value
            + 0
             * 1
           .AND. .TRUE.
            .OR. .FALSE.
           .EQV. .TRUE.
           .NEQV. .FALSE.
            IAND All bits set
            IEOR 0
            IOR 0
            MAX Least representable value of the type and kind
            MIN Largest representable value of the type and kind
<b>NOTE</b> <b>1</b>
A processor can implement a DO CONCURRENT construct in a manner such that a variable with REDUCE
locality might not have the initial value from Table 11.1 at the start of every iteration.
A variable that has REDUCE locality shall only appear within the <i>block</i> of a DO CONCURRENT construct in
the<i>designator</i> of a<i>variable</i>, as the <i>object-name</i>, or as the leftmost <i>part-name</i> of an<i>array-element</i> or<i>array-section</i>,
in an intrinsic assignment statement with the following forms:
 <i>variable</i> = <i>variable</i> <i>binary-reduce-op</i> <i>expr</i>
 <i>variable</i> = <i>expr</i> <i>binary-reduce-op</i> <i>variable</i>
 <i>variable</i> = <i>function-reduction-name</i> ( [ <i>expr</i>, ]... <i>variable</i> [, <i>expr</i> ]... )
where each occurrence of <i>variable</i> has the same form.
If a variable has REDUCE locality, on termination of the DO CONCURRENT construct the outside variable
is updated by combining it with the values the construct entity had at completion of each iteration, using the
<i>reduce-operation</i>. The processor may combine the values in any order.
If a variable has SHARED locality, appearances of the variable within the DO CONCURRENT construct refer
to the variable in the innermost executable construct or scoping unit that includes the DO CONCURRENT
construct. If it is defined or becomes undefined during any iteration, it shall not be referenced, defined, or
become undefined during any other iteration. If it is allocated, deallocated, nullified, or pointer-assigned during
an iteration it shall not have its allocation or association status, dynamic type, array bounds, shape, or a deferred
type parameter value inquired about in any other iteration. A noncontiguous array with SHARED locality shall
not be supplied as an actual argument corresponding to a contiguous INTENT (INOUT) dummy argument.
If a variable has unspecified locality,
 if it is referenced in an iteration it shall either be previously defined during that iteration, or shall not be
  defined or become undefined during any other iteration; if it is defined or becomes undefined by more than
  one iteration it becomes undefined when the loop terminates;
 if it is noncontiguous and is supplied as an actual argument corresponding to a contiguous INTENT (IN-
  OUT) dummy argument in an iteration, it shall either be previously defined in that iteration or shall not
  be defined in any other iteration;
 if it is a pointer and is used in an iteration other than as the pointer in pointer assignment, allocation,
  or nullification, it shall either be previously pointer associated during that iteration or shall not have its
  pointer association changed during any iteration;
 if it is a pointer whose pointer association is changed in more than one iteration, it has an association status
  of undefined when the construct terminates;
 if it is allocatable and is allocated in more than one iteration, it shall have an allocation status of unallocated
  at the end of every iteration;
 if it is allocatable and is referenced, defined, deallocated, or has its allocation status, dynamic type, or a
  deferred type parameter value inquired about, in any iteration, it shall either be previously allocated in
  that iteration or shall not be allocated or deallocated in any other iteration.
A DO CONCURRENT construct shall not contain an input/output statement that has an ADVANCE= specifier.
If data are written to a file record or position in one iteration, that record or position in that file shall not be
read from or written to in a different iteration. If records are written to a file connected for sequential access by
more than one iteration, the ordering of records written by different iterations is processor dependent.
<b>NOTE</b> <b>2</b>
The restrictions on referencing variables defined in an iteration of a DO CONCURRENT construct apply to
any procedure invoked within the loop.
<b>NOTE</b> <b>3</b>
The restrictions on the statements in a DO CONCURRENT construct are designed to ensure there are no data
dependencies between iterations of the loop. This permits code optimizations that might otherwise be difficult
or impossible because they would depend on properties of the program not visible to the compiler.
<b>11.1.7.6</b> <b>Examples</b> <b>of</b> <b>DO</b> <b>constructs</b>
<b>NOTE</b> <b>1</b>
The following program fragment computes a tensor product of two arrays:
   DO I = 1, M
     DO J = 1, N
      C (I, J) = DOT_PRODUCT (A (I, J, :), B(:, I, J))
     END DO
   END DO
<b>NOTE</b> <b>2</b>
The following program fragment contains a DO construct that uses the WHILE form of <i>loop-control</i>. The
loop will continue to execute until an end-of-file or input/output error is encountered, at which point the DO
statement terminates the loop. When a negative value of X is read, the program skips immediately to the next
READ statement, bypassing most of the <i>block</i> of the loop.
   READ (IUN, '(1X, G14.7)', IOSTAT = IOS) X
   DO WHILE (IOS == 0)
     IF (X >= 0.) THEN
      CALL SUBA (X)
      CALL SUBB (X)
       ...
      CALL SUBZ (X)
     ENDIF
     READ (IUN, '(1X, G14.7)', IOSTAT = IOS) X
   END DO
<b>NOTE</b> <b>3</b>
The following example behaves exactly the same as the one in NOTE 2. However, the READ statement has
been moved to the interior of the loop, so that only one READ statement is needed. Also, a CYCLE statement
has been used to avoid an extra level of IF nesting.
   DO ! A "DO WHILE + 1/2" loop
     READ (IUN, '(1X, G14.7)', IOSTAT = IOS) X
     IF (IOS /= 0) EXIT
     IF (X < 0.) CYCLE
     CALL SUBA (X)
     CALL SUBB (X)
     ...
     CALL SUBZ (X)
   END DO
<b>NOTE</b> <b>4</b>
The following example illustrates a case in which the user knows that there are no repeated values in the index
arrayIND.TheDOCONCURRENTconstructmakesiteasierfortheprocessortogeneratevectorgather/scatter
code, unroll the loop, or parallelize the code for this loop, potentially improving performance.
   INTEGER :: A(N),IND(N)
    ...
   DO CONCURRENT (I=1:M)
     A(IND(I)) = I
   END DO
<b>NOTE</b> <b>5</b>
The following code demonstrates the use of the LOCAL clause so that the X inside the DO CONCURRENT
construct is a temporary variable, and will not affect the X outside the construct.
   X = 1.0
   DO CONCURRENT (I=1:10) LOCAL (X)
    IF (A (I) > 0) THEN
     X = SQRT (A (I))
     A (I) = A (I) - X**2
    END IF
    B (I) = B (I) - A (I)
   END DO
   PRINT *, X ! Always prints 1.0.
<b>NOTE</b> <b>6</b>
Additional examples of DO constructs are in C.7.3.
<b>11.1.8</b> <b>IF</b> <b>construct</b> <b>and</b> <b>statement</b>
<b>11.1.8.1</b> <b>Purpose</b> <b>and</b> <b>form</b> <b>of</b> <b>the</b> <b>IF</b> <b>construct</b>
The IF construct selects for execution at most one of its constituent blocks. The selection is based on a sequence
of logical expressions.
R1136 <i>if-construct</i> <b>is</b> <i>if-then-stmt</i>
                     <i>block</i>
                   [ <i>else-if-stmt</i>
                     <i>block</i> ] ...
                   [ <i>else-stmt</i>
                     <i>block</i> ]
                   <i>end-if-stmt</i>
R1137 <i>if-then-stmt</i> <b>is</b> [ <i>if-construct-name</i> : ] IF ( <i>scalar-logical-expr</i> ) THEN
R1138 <i>else-if-stmt</i> <b>is</b> ELSE IF ( <i>scalar-logical-expr</i> ) THEN [ <i>if-construct-name</i> ]
R1139 <i>else-stmt</i> <b>is</b> ELSE [ <i>if-construct-name</i> ]
R1140 <i>end-if-stmt</i> <b>is</b> END IF [ <i>if-construct-name</i> ]
C1147 (R1136) If the <i>if-then-stmt</i> of an <i>if-construct</i> specifies an <i>if-construct-name</i>, the corresponding <i>end-if-</i>
   <i>stmt</i> shall specify the same <i>if-construct-name</i>. If the <i>if-then-stmt</i> of an <i>if-construct</i> does not specify an
   <i>if-construct-name</i>, the corresponding <i>end-if-stmt</i> shall not specify an <i>if-construct-name</i>. If an <i>else-if-</i>
   <i>stmt</i> or <i>else-stmt</i> specifies an <i>if-construct-name</i>, the corresponding <i>if-then-stmt</i> shall specify the same
   <i>if-construct-name</i>.
<b>11.1.8.2</b> <b>Execution</b> <b>of</b> <b>an</b> <b>IF</b> <b>construct</b>
At most one of the blocks in the IF construct is executed. If there is an ELSE statement in the construct,
exactly one of the blocks in the construct is executed. The scalar logical expressions are evaluated in the order
of their appearance in the construct until a true value is found or an ELSE statement or END IF statement is
encountered. If a true value or an ELSE statement is found, the block immediately following is executed and this
completes the execution of the construct. The scalar logical expressions in any remaining ELSE IF statements of
the IF construct are not evaluated. If none of the evaluated expressions is true and there is no ELSE statement,
the execution of the construct is completed without the execution of any block within the construct.
It is permissible to branch to an END IF statement only from within its IF construct. Execution of an END IF
statement has no effect.
<b>11.1.8.3</b> <b>Examples</b> <b>of</b> <b>IF</b> <b>constructs</b>
<b>NOTE</b>
   IF (CVAR == 'RESET') THEN
     I = 0; J = 0; K = 0
   END IF
   PROOF_DONE: IF (PROP) THEN
     WRITE (3, '(''QED'')')
     STOP
   ELSE
     PROP = NEXTPROP
   END IF PROOF_DONE
   IF (A > 0) THEN
     B = C/A
     IF (B > 0) THEN
      D = 1.0
     END IF
   ELSE IF (C > 0) THEN
     B = A/C
     D = -1.0
   ELSE
     B = ABS (MAX (A, C))
     D = 0
   END IF
<b>11.1.8.4</b> <b>IF</b> <b>statement</b>
The IF statement controls the execution of a single action statement based on a single logical expression.
R1141 <i>if-stmt</i> <b>is</b> IF ( <i>scalar-logical-expr</i> ) <i>action-stmt</i>
C1148 (R1141) The <i>action-stmt</i> in the <i>if-stmt</i> shall not be an <i>if-stmt</i>.
Execution of an IF statement causes evaluation of the scalar logical expression. If the value of the expression is
true, the action statement is executed. If the value is false, the action statement is not executed.
The execution of a function reference in the scalar logical expression may affect entities in the action statement.
<b>NOTE</b>
An example of an IF statement is:
   IF (A > 0.0) A = LOG (A)
<b>11.1.9</b> <b>SELECT</b> <b>CASE</b> <b>construct</b>
<b>11.1.9.1</b> <b>Purpose</b> <b>and</b> <b>form</b> <b>of</b> <b>the</b> <b>SELECT</b> <b>CASE</b> <b>construct</b>
The SELECT CASE construct selects for execution at most one of its constituent blocks. The selection is based
on the value of an expression.
R1142 <i>case-construct</i> <b>is</b> <i>select-case-stmt</i>
                   [ <i>case-stmt</i>
                     <i>block</i> ] ...
                   <i>end-select-stmt</i>
R1143 <i>select-case-stmt</i> <b>is</b> [ <i>case-construct-name</i> : ] SELECT CASE ( <i>case-expr</i> )
R1144 <i>case-stmt</i> <b>is</b> CASE <i>case-selector</i> [<i>case-construct-name</i>]
R1145 <i>end-select-stmt</i> <b>is</b> END SELECT [ <i>case-construct-name</i> ]
C1149 (R1142) If the <i>select-case-stmt</i> of a<i>case-construct</i> specifies a <i>case-construct-name</i>, the corresponding <i>end-</i>
   <i>select-stmt</i> shall specify the same <i>case-construct-name</i>. If the <i>select-case-stmt</i> of a <i>case-construct</i> does
   not specify a <i>case-construct-name</i>, the corresponding <i>end-select-stmt</i> shall not specify a <i>case-construct-</i>
   <i>name</i>. If a <i>case-stmt</i> specifies a <i>case-construct-name</i>, the corresponding <i>select-case-stmt</i> shall specify the
   same <i>case-construct-name</i>.
R1146 <i>case-expr</i> <b>is</b> <i>scalar-expr</i>
C1150 <i>case-expr</i> shall be of type character, integer, or logical, or of enum or enumeration type.
R1147 <i>case-selector</i> <b>is</b> ( <i>case-value-range-list</i> )
              <b>or</b> DEFAULT
C1151 (R1142) No more than one of the selectors of one of the CASE statements shall be DEFAULT.
R1148 <i>case-value-range</i> <b>is</b> <i>case-value</i>
              <b>or</b> <i>case-value</i> :
              <b>or</b> : <i>case-value</i>
              <b>or</b> <i>case-value</i> : <i>case-value</i>
R1149 <i>case-value</i> <b>is</b> <i>scalar-constant-expr</i>
C1152 (R1142) For a given <i>case-construct</i>, each <i>case-value</i> shall be of the same type as <i>case-expr</i>, or in type
   conformance as specified in Table 10.8 if <i>case-expr</i> is of an enum type. For character type, the kind type
   parameters shall be the same; character length differences are allowed.
C1153 (R1142) A <i>case-value-range</i> using a colon shall not be used if <i>case-expr</i> is of type logical.
C1154 (R1142) For a given <i>case-construct</i>, there shall be no possible value of the <i>case-expr</i> that matches more
   than one <i>case-value-range</i>.
<b>11.1.9.2</b> <b>Execution</b> <b>of</b> <b>a</b> <b>SELECT</b> <b>CASE</b> <b>construct</b>
The execution of the SELECT CASE statement causes the case expression to be evaluated. For a case value
range list, a match occurs if the case expression value matches any of the case value ranges in the list. For a case
expression with a value of <i>c</i>, a match is determined as follows.
  (1) If the case value range contains a single value <i>v</i> without a colon, a match occurs for type logical if
     the expression <i>c</i> .EQV. <i>v</i> is true, and a match occurs for other types if the expression <i>c</i> == <i>v</i> is true.
  (2) If the case value range is of the form <i>low</i> : <i>high</i>, a match occurs if the expression <i>low</i> <= <i>c</i> .AND.
    <i>c</i> <= <i>high</i> is true.
  (3) If the case value range is of the form <i>low</i> :, a match occurs if the expression <i>low</i> <= <i>c</i> is true.
  (4) If the case value range is of the form : <i>high</i>, a match occurs if the expression <i>c</i> <= <i>high</i> is true.
  (5) If no other selector matches and a DEFAULT selector appears, it matches the case index.
  (6) If no other selector matches and the DEFAULT selector does not appear, there is no match.
The block following the CASE statement containing the matching selector, if any, is executed. This completes
execution of the construct.
It is permissible to branch to an <i>end-select-stmt</i> only from within its SELECT CASE construct.
<b>11.1.9.3</b> <b>Examples</b> <b>of</b> <b>SELECT</b> <b>CASE</b> <b>constructs</b>
<b>NOTE</b> <b>1</b>
An integer signum function:
   INTEGER FUNCTION SIGNUM (N)
   SELECT CASE (N)
   CASE (:-1)
     SIGNUM = -1
   CASE (0)
     SIGNUM = 0
   CASE (1:)
     SIGNUM = 1
   END SELECT
   END
<b>NOTE</b> <b>2</b>
A code fragment to check for balanced parentheses:
   CHARACTER (80) :: LINE
    ...
   LEVEL = 0
   SCAN_LINE: DO I = 1, 80
     CHECK_PARENS: SELECT CASE (LINE (I:I))
     CASE ('(')
      LEVEL = LEVEL + 1
     CASE (')')
      LEVEL = LEVEL - 1
      IF (LEVEL < 0) THEN
        PRINT *, 'UNEXPECTED RIGHT PARENTHESIS'
        EXIT SCAN_LINE
      END IF
     CASE DEFAULT
      ! Ignore all other characters
     END SELECT CHECK_PARENS
   END DO SCAN_LINE
   IF (LEVEL > 0) THEN
     PRINT *, 'MISSING RIGHT PARENTHESIS'
   END IF
<b>NOTE</b> <b>3</b>
The following three fragments are equivalent:
   IF (SILLY == 1) THEN ! Fragment one
     CALL THIS
   ELSE
     CALL THAT
   END IF
   SELECT CASE (SILLY == 1) ! Fragment two
   CASE (.TRUE.)
     CALL THIS
   CASE (.FALSE.)
     CALL THAT
   END SELECT
<b>206</b> <b>J3/23-007r1</b>
<b>NOTE</b> <b>3</b> <b>(cont.)</b>
   SELECT CASE (SILLY) ! Fragment three
   CASE DEFAULT
     CALL THAT
   CASE (1)
     CALL THIS
   END SELECT
<b>NOTE</b> <b>4</b>
A code fragment showing several selections of one block:
   SELECT CASE (N)
   CASE (1, 3:5, 8) ! Selects 1, 3, 4, 5, 8
     CALL SUB
   CASE DEFAULT
     CALL OTHER
   END SELECT
<b>11.1.10</b> <b>SELECT</b> <b>RANK</b> <b>construct</b>
<b>11.1.10.1</b> <b>Purpose</b> <b>and</b> <b>form</b> <b>of</b> <b>the</b> <b>SELECT</b> <b>RANK</b> <b>construct</b>
The SELECT RANK construct selects for execution at most one of its constituent blocks. The selection is based
on the rank of an assumed-rank variable. A name is associated with the variable (19.4, 19.5.1.6), in the same
way as for the ASSOCIATE construct.
R1150 <i>select-rank-construct</i> <b>is</b> <i>select-rank-stmt</i>
                   [ <i>select-rank-case-stmt</i>
                   <i>block</i> ]...
                   <i>end-select-rank-stmt</i>
R1151 <i>select-rank-stmt</i> <b>is</b> [ <i>select-construct-name</i> : ] SELECT RANK
                   ( [ <i>associate-name</i> =<i>></i> ] <i>selector</i> )
C1155 The <i>selector</i> in a <i>select-rank-stmt</i> shall be the name of an assumed-rank array.
R1152 <i>select-rank-case-stmt</i> <b>is</b> RANK ( <i>scalar-int-constant-expr</i> ) [ <i>select-construct-name</i> ]
              <b>or</b> RANK ( * ) [ <i>select-construct-name</i> ]
              <b>or</b> RANK DEFAULT [ <i>select-construct-name</i> ]
C1156 A <i>scalar-int-constant-expr</i> in a <i>select-rank-case-stmt</i> shall be nonnegative.
C1157 For a given <i>select-rank-construct</i>, the same rank value shall not be specified in more than one <i>select-rank-</i>
   <i>case-stmt</i>.
C1158 For a given <i>select-rank-construct</i>, there shall be at most one RANK ( * ) <i>select-rank-case-stmt</i> and at
   most one RANK DEFAULT <i>select-rank-case-stmt</i>.
C1159 If <i>select-construct-name</i> appears on a <i>select-rank-case-stmt</i> the corresponding <i>select-rank-stmt</i> shall spe-
   cify the same <i>select-construct-name</i>.
C1160 A SELECT RANK construct shall not have a <i>select-rank-case-stmt</i> that is RANK ( * ) if the selector
   has the ALLOCATABLE or POINTER attribute.
R1153 <i>end-select-rank-stmt</i> <b>is</b> END SELECT [ <i>select-construct-name</i> ]
C1161 If the <i>select-rank-stmt</i> of a <i>select-rank-construct</i> specifies a <i>select-construct-name</i>, the corresponding
   <i>end-select-rank-stmt</i> shall specify the same <i>select-construct-name</i>. If the <i>select-rank-stmt</i> of a <i>select-</i>
   <i>rank-construct</i> does not specify a <i>select-construct-name</i>, the corresponding <i>end-select-rank-stmt</i> shall not
   specify a <i>select-construct-name</i>.
The associate name of a SELECT RANK construct is the <i>associate-name</i> if specified; otherwise it is the name
that constitutes the selector.
The <i>scalar-int-constant-expr</i> in a <i>select-rank-case-stmt</i> may have a value greater than the maximum possible rank
of the selector; in this case, its block will never be executed.
<b>11.1.10.2</b> <b>Execution</b> <b>of</b> <b>the</b> <b>SELECT</b> <b>RANK</b> <b>construct</b>
A SELECT RANK construct selects at most one block to be executed. During execution of that block, the
associate name identifies an entity which is associated (19.5.1.6) with the selector. A RANK ( * ) statement
matches the selector if the selector is argument associated with an assumed-size array. A RANK ( <i>scalar-int-</i>
<i>constant-expr</i> ) statement matches the selector if the selector has that rank and is not argument associated with
an assumed-size array. A RANK DEFAULT statement matches the selector if no other <i>select-rank-case-stmt</i>
of the construct matches the selector. If a <i>select-rank-case-stmt</i> matches the selector, the block following that
statement is executed; otherwise, control is transferred to the <i>end-select-rank-stmt</i>.
It is permissible to branch to an <i>end-select-rank-stmt</i> only from within its SELECT RANK construct.
<b>11.1.10.3</b> <b>Attributes</b> <b>of</b> <b>a</b> <b>SELECT</b> <b>RANK</b> <b>associate</b> <b>name</b>
The associating entity (19.5.5) assumes the declared type and type parameters of the selector. It is polymorphic
if and only if the selector is polymorphic.
Within the block following a RANK DEFAULT statement, the associating entity is assumed-rank and has exactly
the same attributes as the selector. Within the block following a RANK ( * ) statement, the associating entity
has rank 1 and is assumed-size, as if it were declared with DIMENSION(1:*). Within the block following a
RANK ( <i>scalar-int-constant-expr</i> ) statement, the associating entity has the specified rank; the lower bound of
each dimension is the result of the intrinsic function LBOUND (16.9.119) applied to the corresponding dimension
of the selector, and the upper bound of each dimension is the result of the intrinsic function UBOUND (16.9.215)
applied to the corresponding dimension of the selector.
The associating entity has the ALLOCATABLE, POINTER, or TARGET attribute if the selector has that
attribute. The other attributes of the associating entity are described in 11.1.3.3.
<b>11.1.10.4</b> <b>Examples</b> <b>of</b> <b>the</b> <b>SELECT</b> <b>RANK</b> <b>construct</b>
<b>NOTE</b> <b>1</b>
This example shows how to use a SELECT RANK construct to process scalars and rank-2 arrays; anything else
will be rejected as an error.
   SUBROUTINE process(x)
    REAL x(..)
    !
    SELECT RANK(x)
    RANK (0)
     x = 0
    RANK (2)
     IF (SIZE(x,2)>=2) x(:,2) = 2
    RANK DEFAULT
     Print *, 'I did not expect rank', RANK(x), 'shape', SHAPE(x)
     ERROR STOP 'process bad arg'
    END SELECT
<b>NOTE</b> <b>2</b>
The following example shows how to process assumed-size arrays, including how to use sequence association for
multi-dimensional processing of an assumed-size array.
   SELECT RANK (y => x)
   RANK (*)
    IF (RANK(x)==2) THEN
     ! Special code for the rank two case.
     CALL sequence_assoc_2(y, LBOUND(x,1), UBOUND(x,1), LBOUND(x,2))
    ELSE
     ! We just do all the other ranks in array element order.
     i = 1
     DO
      IF (y(i)==0) Exit
      y(i) = -y(i)
      i = i + 1
     END DO
    END IF
   END SELECT
    ...
  CONTAINS
    ...
   SUBROUTINE sequence_assoc_2(a, lb1, ub1, lb2)
    INTEGER, INTENT (IN) :: lb1, ub1, lb2
    REAL a(lb1:ub1,lb2:*)
    j = lb2
 outer: DO
     DO i=lb1,ub1
      IF (a(i,j)==0) EXIT outer
      a(i,j) = a(i,j)**2
     END DO
     j = j + 1
     IF (ANY(a(:,j)==0)) EXIT
     j = j + 1
    END DO outer
   END SUBROUTINE
<b>11.1.11</b> <b>SELECT</b> <b>TYPE</b> <b>construct</b>
<b>11.1.11.1</b> <b>Purpose</b> <b>and</b> <b>form</b> <b>of</b> <b>the</b> <b>SELECT</b> <b>TYPE</b> <b>construct</b>
The SELECT TYPE construct selects for execution at most one of its constituent blocks. The selection is based
on the dynamic type of an expression. A name is associated with the expression or variable (19.4, 19.5.1.6), in
the same way as for the ASSOCIATE construct.
R1154 <i>select-type-construct</i> <b>is</b> <i>select-type-stmt</i>
                   [ <i>type-guard-stmt</i>
                     <i>block</i> ] ...
                   <i>end-select-type-stmt</i>
R1155 <i>select-type-stmt</i> <b>is</b> [ <i>select-construct-name</i> : ] SELECT TYPE
                   ( [ <i>associate-name</i> =<i>></i> ] <i>selector</i> )
C1162 (R1155) If <i>selector</i> is not a named <i>variable</i>, <i>associate-name</i> =<i>></i> shall appear.
C1163 (R1155) If <i>selector</i> is not a <i>variable</i> or is a <i>variable</i> that has a vector subscript, neither <i>associate-name</i>
   nor any subobject thereof shall appear in a variable definition context (19.6.7) or pointer association
   context (19.6.8).
C1164 (R1155) The <i>selector</i> in a <i>select-type-stmt</i> shall be polymorphic.
R1156 <i>type-guard-stmt</i> <b>is</b> TYPE IS ( <i>type-spec</i> ) [ <i>select-construct-name</i> ]
              <b>or</b> CLASS IS ( <i>derived-type-spec</i> ) [ <i>select-construct-name</i> ]
              <b>or</b> CLASS DEFAULT [ <i>select-construct-name</i> ]
C1165 (R1156) The <i>type-spec</i> or <i>derived-type-spec</i> shall specify that each length type parameter is assumed.
C1166 (R1156) The <i>type-spec</i> or <i>derived-type-spec</i> shall not specify a derived type with the BIND attribute or
   the SEQUENCE attribute.
C1167 (R1154) If <i>selector</i> is not unlimited polymorphic, each TYPE IS or CLASS IS <i>type-guard-stmt</i> shall
   specify an extension of the declared type of <i>selector</i>.
C1168 (R1154) For a given <i>select-type-construct</i>, the same type and kind type parameter values shall not be
   specified in more than one TYPE IS <i>type-guard-stmt</i> and shall not be specified in more than one CLASS
   IS <i>type-guard-stmt</i>.
C1169 (R1154) For a given <i>select-type-construct</i>, there shall be at most one CLASS DEFAULT <i>type-guard-stmt</i>.
R1157 <i>end-select-type-stmt</i> <b>is</b> END SELECT [ <i>select-construct-name</i> ]
C1170 (R1154) If the <i>select-type-stmt</i> of a <i>select-type-construct</i> specifies a <i>select-construct-name</i>, the correspond-
   ing <i>end-select-type-stmt</i> shall specify the same <i>select-construct-name</i>. If the <i>select-type-stmt</i> of a <i>select-</i>
   <i>type-construct</i> does not specify a <i>select-construct-name</i>, the corresponding <i>end-select-type-stmt</i> shall not
   specify a <i>select-construct-name</i>. If a <i>type-guard-stmt</i> specifies a <i>select-construct-name</i>, the corresponding
   <i>select-type-stmt</i> shall specify the same <i>select-construct-name</i>.
The associate name of a SELECT TYPE construct is the <i>associate-name</i> if specified; otherwise it is the <i>name</i>
that constitutes the <i>selector</i>.
<b>11.1.11.2</b> <b>Execution</b> <b>of</b> <b>the</b> <b>SELECT</b> <b>TYPE</b> <b>construct</b>
Execution of a SELECT TYPE construct causes evaluation of every expression within a selector that is a variable
designator, or evaluation of a selector that is not a variable designator.
A SELECT TYPE construct selects at most one block to be executed. During execution of that block, the
associate name identifies an entity which is associated (19.5.1.6) with the selector.
A TYPE IS type guard statement matches the selector if the dynamic type and kind type parameter values of
the selector are the same as those specified by the statement. A CLASS IS type guard statement matches the
selector if the dynamic type of the selector is an extension of the type specified by the statement and the kind
type parameter values specified by the statement are the same as the corresponding type parameter values of the
dynamic type of the selector.
The block to be executed is selected as follows.
  (1) If a TYPE IS type guard statement matches the selector, the block following that statement is
     executed.
  (2) Otherwise, if exactly one CLASS IS type guard statement matches the selector, the block following
     that statement is executed.
  (3) Otherwise, if several CLASS IS type guard statements match the selector, one of these statements
     will inevitably specify a type that is an extension of all the types specified in the others; the block
     following that statement is executed.
  (4) Otherwise, if there is a CLASS DEFAULT type guard statement, the block following that statement
     is executed.
  (5) Otherwise, no block is executed.
<b>NOTE</b> <b>1</b>
This algorithm does not examine the type guard statements in source text order when it looks for a match; it
selects the most particular type guard when there are several potential matches.
Within the block following a TYPE IS type guard statement, the associating entity (19.5.5) is not polymorphic
(7.3.2.3), has the type named in the type guard statement, and has the type parameter values of the selector.
Within the block following a CLASS IS type guard statement, the associating entity is polymorphic and has the
declared type named in the type guard statement. The type parameter values of the associating entity are the
corresponding type parameter values of the selector.
Within the block following a CLASS DEFAULT type guard statement, the associating entity is polymorphic and
has the same declared type as the selector. The type parameter values of the associating entity are those of the
declared type of the selector.
<b>NOTE</b> <b>2</b>
If the declared type of the <i>selector</i> is T, specifying CLASS DEFAULT has the same effect as specifying CLASS
IS (T).
The other attributes of the associating entity are described in 11.1.3.3.
It is permissible to branch to an <i>end-select-type-stmt</i> only from within its SELECT TYPE construct.
<b>11.1.11.3</b> <b>Examples</b> <b>of</b> <b>the</b> <b>SELECT</b> <b>TYPE</b> <b>construct</b>
<b>NOTE</b> <b>1</b>
   TYPE POINT
    REAL :: X, Y
   END TYPE POINT
   TYPE, EXTENDS(POINT) :: POINT_3D
    REAL :: Z
   END TYPE POINT_3D
   TYPE, EXTENDS(POINT) :: COLOR_POINT
    INTEGER :: COLOR
   END TYPE COLOR_POINT
   TYPE(POINT), TARGET :: P
   TYPE(POINT_3D), TARGET :: P3
   TYPE(COLOR_POINT), TARGET :: C
   CLASS(POINT), POINTER :: P_OR_C
   P_OR_C => C
   SELECT TYPE ( A => P_OR_C )
   CLASS IS ( POINT )
    ! "CLASS ( POINT ) :: A" implied here
    PRINT *, A%X, A%Y ! This block gets executed
   TYPE IS ( POINT_3D )
    ! "TYPE ( POINT_3D ) :: A" implied here
    PRINT *, A%X, A%Y, A%Z
   END SELECT
<b>NOTE</b> <b>2</b>
The following example illustrates the omission of <i>associate-name</i>. It uses the declarations from NOTE 1.
   P_OR_C => P3
   SELECT TYPE ( P_OR_C )
   CLASS IS ( POINT )
    ! "CLASS ( POINT ) :: P_OR_C" implied here
    PRINT *, P_OR_C%X, P_OR_C%Y
   TYPE IS ( POINT_3D )
    ! "TYPE ( POINT_3D ) :: P_OR_C" implied here
    PRINT *, P_OR_C%X, P_OR_C%Y, P_OR_C%Z ! This block gets executed
   END SELECT
<b>11.1.12</b> <b>EXIT</b> <b>statement</b>
The EXIT statement provides one way of terminating a loop, or completing execution of another construct.
R1158 <i>exit-stmt</i> <b>is</b> EXIT [ <i>construct-name</i> ]
C1171 If a <i>construct-name</i> appears on an EXIT statement, the EXIT statement shall be within that construct;
   otherwise, it shall be within at least one <i>do-construct</i>.
An EXIT statement belongs to a particular construct. If a construct name appears, the EXIT statement belongs
to that construct; otherwise, it belongs to the innermost DO construct in which it appears.
C1172 An <i>exit-stmt</i> shall not appear within a DO CONCURRENT construct if it belongs to that construct or
   an outer construct.
C1173 An <i>exit-stmt</i> shall not appear within a CHANGE TEAM or CRITICAL construct if it belongs to an
   outer construct.
When an EXIT statement that belongs to a DO construct is executed, it terminates the loop (11.1.7.4.5) and
any active loops contained within the terminated loop. When an EXIT statement that belongs to a non-DO
construct is executed, it terminates any active loops contained within that construct, and completes execution
of that construct. If the EXIT statement belongs to a CHANGE TEAM construct, the effect is the same as
transferring control to the END TEAM statement; if that statement contains a STAT= or ERRMSG= specifier,
the <i>stat-variable</i> or <i>errmsg-variable</i> becomes defined as specified for that statement.
<b>11.2</b> <b>Branching</b>
<b>11.2.1</b> <b>Branch</b> <b>concepts</b>
Branchingisusedtoalterthenormalexecutionsequence. Abranchcausesatransferofcontrolfromonestatement
to a labeled branch target statement in the same inclusive scope. Branching can be caused by a GO TO state-
ment, a computed GO TO statement, a CALL statement that has an <i>alt-return-spec</i>, or an input/output statement that has
an END=, EOR=, or ERR= specifier. Although procedure references and control constructs can cause transfer
of control, they are not branches. A branch target statement is an <i>action-stmt</i>, <i>associate-stmt</i>, <i>end-associate-</i>
<i>stmt</i>, <i>if-then-stmt</i>, <i>end-if-stmt</i>, <i>select-case-stmt</i>, <i>end-select-stmt</i>, <i>select-rank-stmt</i>, <i>end-select-rank-stmt</i>, <i>select-</i>
<i>type-stmt</i>, <i>end-select-type-stmt</i>, <i>do-stmt</i>, <i>end-do-stmt</i>, <i>block-stmt</i>, <i>end-block-stmt</i>, <i>critical-stmt</i>, <i>end-critical-stmt</i>,
<i>forall-construct-stmt</i>, <i>forall-stmt</i>, <i>where-construct-stmt</i>, <i>end-function-stmt</i>, <i>end-mp-subprogram-stmt</i>, <i>end-program-</i>
<i>stmt</i>, or <i>end-subroutine-stmt</i>.
<b>11.2.2</b> <b>GO</b> <b>TO</b> <b>statement</b>
R1159 <i>goto-stmt</i> <b>is</b> GO TO <i>label</i>
C1174 (R1159) The <i>label</i> shall be the statement label of a branch target statement that appears in the same
   inclusive scope as the <i>goto-stmt</i>.
Execution of a GO TO statement causes a branch to the branch target statement identified by the label.
<b>11.2.3</b> <b>Computed</b> <b>GO</b> <b>TO</b> <b>statement</b>
R1160 <i>computed-goto-stmt</i> <b>is</b> GO TO ( <i>label-list</i> ) [ , ] <i>scalar-int-expr</i>
C1175 (R1160) Each <i>label</i> in <i>label-list</i> shall be the statement label of a branch target statement that appears in the same inclusive
    scope as the <i>computed-goto-stmt</i>.
Execution of a computed GO TO statement causes evaluation of the scalar integer expression. If this value is <i>i</i> such that 1 <i>i</i> <i>n</i>
where <i>n</i> is the number of labels in <i>label-list</i>, a branch occurs to the branch target statement identified by the <i>i</i>
                                                       <i>th</i>
                                                 label in the list of
labels. If <i>i</i> is less than 1 or greater than <i>n</i>, the execution sequence continues as though a CONTINUE statement were executed.
<b>11.3</b> <b>CONTINUE</b> <b>statement</b>
Execution of a CONTINUE statement has no effect.
R1161 <i>continue-stmt</i> <b>is</b> CONTINUE
<b>11.4</b> <b>STOP</b> <b>and</b> <b>ERROR</b> <b>STOP</b> <b>statements</b>
R1162 <i>stop-stmt</i> <b>is</b> STOP [ <i>stop-code</i> ] [ , QUIET = <i>scalar-logical-expr</i>]
R1163 <i>error-stop-stmt</i> <b>is</b> ERROR STOP [ <i>stop-code</i> ] [ , QUIET = <i>scalar-logical-expr</i>]
R1164 <i>stop-code</i> <b>is</b> <i>scalar-default-char-expr</i>
              <b>or</b> <i>scalar-int-expr</i>
C1176 (R1164) The <i>scalar-int-expr</i> shall be of default kind.
Execution of a STOP statement initiates normal termination of execution. Execution of an ERROR STOP
statement initiates error termination of execution.
When an image is terminated by a STOP or ERROR STOP statement, its stop code, if any, is made available
in a processor-dependent manner. If the <i>stop-code</i> is an integer, it is recommended that the value be used as
the process exit status, if the processor supports that concept. If the <i>stop-code</i> in a STOP statement is of type
character or does not appear, or if an <i>end-program-stmt</i> is executed, it is recommended that the value zero be
supplied as the process exit status, if the processor supports that concept. If the <i>stop-code</i> in an ERROR STOP
statement is of type character or does not appear, it is recommended that a processor-dependent nonzero value
be supplied as the process exit status, if the processor supports that concept.
If QUIET= is omitted or the <i>scalar-logical-expr</i> has the value false:
 if any exception (17) is signaling on that image, the processor shall issue a warning indicating which
  exceptions are signaling, and this warning shall be on the unit identified by the named constant ERROR_-
  UNIT from the intrinsic module ISO_FORTRAN_ENV (16.10.2.9);
 if a stop code is specified, it is recommended that it be made available by formatted output to the same
  unit.
If QUIET= appears and the <i>scalar-logical-expr</i> has the value true, no output of signaling exceptions or stop code
shall be produced.
<b>NOTE</b> <b>1</b>
When normal termination occurs on more than one image, it is expected that a processor-dependent summary
of any stop codes and signaling exceptions will be made available.
<b>NOTE</b> <b>2</b>
If the integer <i>stop-code</i> is used as the process exit status, the processor might be able to interpret only values
within a limited range, or only a limited portion of the integer value (for example, only the least-significant 8
bits).
<b>11.5</b> <b>FAIL</b> <b>IMAGE</b> <b>statement</b>
R1165 <i>fail-image-stmt</i> <b>is</b> FAIL IMAGE
Execution of a FAIL IMAGE statement causes the executing image to cease participating in program execution
without initiating termination. No further statements are executed by that image.
<b>NOTE</b>
The FAIL IMAGE statement enables testing of a recovery algorithm without needing an actual failure.
On a processor that does not have the ability to detect that an image has failed, execution of a FAIL IMAGE
statement might provide a simulated failure environment that provides debug information.
In a piece of code that executes about once a second, invoking this subroutine on an image
   SUBROUTINE FAIL
    REAL :: X
    CALL RANDOM_NUMBER (X)
    IF (X<0.001) FAIL IMAGE
   END SUBROUTINE FAIL
will cause that image to have approximately a 1/1000 chance of failure every second.
Note that FAIL IMAGE is not an image control statement.
<b>11.6</b> <b>NOTIFY</b> <b>WAIT</b> <b>statement</b>
The NOTIFY WAIT statement waits until the value of its <i>notify-variable</i> is greater than or equal to a threshold
value.
R1166 <i>notify-wait-stmt</i> <b>is</b> NOTIFY WAIT ( <i>notify-variable</i> [ , <i>event-wait-spec-list</i> ] )
R1167 <i>notify-variable</i> <b>is</b> <i>scalar-variable</i>
C1177 A <i>notify-variable</i> shall be of type NOTIFY_TYPE from the intrinsic module ISO_FORTRAN_ENV.
C1178 A <i>notify-variable</i> shall not be a coindexed object.
The <i>notify-variable</i> shall not depend on the value of <i>stat-variable</i> or <i>errmsg-variable</i>.
Execution of a NOTIFY WAIT statement consists of the following sequence of actions:
  (1) if the UNTIL_COUNT= specifier appears and its <i>scalar-int-expr</i> is greater than one, the threshold
     value is set to that value, otherwise, the threshold value is set to one;
  (2) the executing image waits until the count of the notify variable is greater than or equal to the
     threshold value or an error condition occurs;
  (3) ifnoerrorconditionoccurs,thecountofthenotifyvariableisatomicallydecrementedbythethreshold
     value.
If an error condition occurs during execution of an NOTIFY WAIT statement, the value of the count of its notify
variable is processor dependent.
Execution of an assignment statement whose variable has a NOTIFY= specifier is initially unsatisfied. Successful
execution of a NOTIFY WAIT statement with a threshold value of <i>k</i> satisfies the first <i>k</i> unsatisfied executions
of assignment statements whose NOTIFY= specifier specifies the same notify variable as the NOTIFY WAIT
statement.
The <i>stat-variable</i> of a NOTIFY WAIT statement shall not depend on the value of the notify variable or the
<i>errmsg-variable</i>. The <i>errmsg-variable</i> of a NOTIFY WAIT statement shall not depend on the value of the notify
variable or the <i>stat-variable</i>.
If a NOTIFY WAIT statement has a STAT= specifier, <i>stat-variable</i> is assigned the value zero if execution of
the statement is successful, and a processor-dependent positive value that is different from the value of STAT_-
FAILED_IMAGE (16.10.2.28) and STAT_STOPPED_IMAGE (16.10.2.31) from the intrinsic module ISO_-
FORTRAN_ENV (16.10.2) if an error condition occurs.
If an error condition occurs during execution of a NOTIFY WAIT statement with no STAT=, error termination
is initiated.
If a NOTIFY WAIT statement has an ERRMSG= specifier and an error condition occurs, <i>errmsg-variable</i> is
assigned an explanatory message, as if by intrinsic assignment. If no such condition occurs, the definition status
and the value of <i>errmsg-variable</i> are unchanged.
ThesetoferrorconditionsthatcanoccurduringexecutionofaNOTIFYWAITstatementisprocessordependent.
<b>11.7</b> <b>Image</b> <b>execution</b> <b>control</b>
<b>11.7.1</b> <b>Image</b> <b>control</b> <b>statements</b>
The execution sequence on each image is specified in 5.3.5.
Execution of an image control statement divides the execution sequence on an image into segments. Each of the
following is an image control statement:
 SYNC ALL statement;
 SYNC IMAGES statement;
 SYNC MEMORY statement;
 SYNC TEAM statement;
 ALLOCATE statement that has a coarray <i>allocate-object</i>;
 DEALLOCATE statement that has an <i>allocate-object</i> that is a coarray or has a coarray potential subobject
  component;
 CHANGE TEAM or END TEAM statement (11.1.5);
 CRITICAL or END CRITICAL statement (11.1.6);
 EVENT POST or EVENT WAIT statement;
 FORM TEAM statement;
 LOCK or UNLOCK statement;
 anystatementthatcompletesexecutionofablockorprocedureandwhichresultsintheimplicitdeallocation
  of a coarray;
 a CALL statement that references the intrinsic subroutine MOVE_ALLOC with coarray arguments;
 STOP statement;
 END statement of a main program.
During an execution of a statement that invokes more than one procedure, at most one invocation shall cause
execution of an image control statement other than CRITICAL or END CRITICAL.
<b>11.7.2</b> <b>Segments</b>
On each image, the sequence of statements executed before the first execution of an image control statement,
between the execution of two image control statements, or after the last execution of an image control statement
is a segment. The segment executed immediately before the execution of an image control statement includes
the evaluation of all expressions within the statement. If an image does not execute any image control statement
before termination of execution, its entire statement execution sequence is a single segment.
By execution of image control statements or user-defined ordering (11.7.5), the program can ensure that the
execution of the <i>i</i>
        <i>th</i>
         segment on image P, <i>P</i>
                    <i>i</i>
                   , either precedes or succeeds the execution of the <i>j</i>
                                             <i>th</i>
                                            segment on
another image Q, <i>Q</i>
         <i>j</i>
         . If the program does not ensure this, segments <i>P</i>
                                <i>i</i>
                               and <i>Q</i>
                                    <i>j</i>
                                  are unordered; depending on the
relative execution speeds of the images, some or all of the execution of the segment <i>P</i>
                                      <i>i</i>
                                     may take place at the same
time as some or all of the execution of the segment <i>Q</i>
                        <i>j</i>
                       .
A coarray may be referenced or defined by execution of an atomic subroutine during the execution of a segment
that is unordered relative to the execution of a segment in which the coarray is referenced or defined by execution
of an atomic subroutine. An event variable or notify variable may be referenced or defined during the execution
of a segment that is unordered relative to the execution of another segment in which that event variable or notify
variable is defined. A variable defined in an unordered segment only by execution of an assignment statement
with a NOTIFY= specifier may be referenced or defined after execution of a NOTIFY WAIT statement that
satisfies that assignment statement execution. Otherwise,
 if a variable is defined or becomes undefined on an image in a segment, it shall not be referenced, defined,
  or become undefined in a segment on another image unless the segments are ordered,
 if the allocation of an allocatable subobject of a coarray or the pointer association of a pointer subobject
  of a coarray is changed on an image in a segment, that subobject shall not be referenced, defined, or have
  its allocation or association status, dynamic type, array bounds, shape, or a deferred type parameter value
  inquired about in a segment on another image unless the segments are ordered, and
 if a procedure invocation on image P is in execution in segments <i>P</i>
                                 <i>i</i>
                               , <i>P</i>
                                  <i>i</i>+1
                                  , ..., <i>P</i>
                                       <i>k</i>
                                      and defines a noncoarray
  dummy argument, the effective argument shall not be referenced, defined, or become undefined on another
  image Q in a segment <i>Q</i>
             <i>j</i>
             unless <i>Q</i>
                  <i>j</i>
                  precedes <i>P</i>
                        <i>i</i>
                       or succeeds <i>P</i>
                               <i>k</i>
                              .
If, by execution of a statement in segment <i>P</i>
                    <i>i</i>
                    on image P,
 a variable X is defined, referenced, becomes undefined, or has its allocation status, pointer association
  status, array bounds, dynamic type, or type parameters changed or inquired about,
 segment <i>P</i>
       <i>i</i>
       on image P precedes segment <i>Q</i>
                      <i>j</i>
                      on image Q, and
 X is defined, referenced, becomes undefined, or has its allocation status, pointer association status, array
  bounds, dynamictype, ortypeparameterschangedorinquiredaboutbyexecutionofastatementinsegment
  <i>Q</i>
   <i>j</i>
    on image Q,
then the action regarding X in segment <i>P</i>
                   <i>i</i>
                  on image P precedes the action regarding X in segment <i>Q</i>
                                              <i>j</i>
                                             on image
Q.
<b>NOTE</b> <b>1</b>
The set of all segments on all images is partially ordered: the segment <i>P</i>
                                  <i>i</i>
                                 precedes segment <i>Q</i>
                                            <i>j</i>
                                          if and only if
there is a sequence of segments starting with <i>P</i>
                      <i>i</i>
                      and ending with <i>Q</i>
                                <i>j</i>
                               such that each segment of the sequence
precedes the next either because they are consecutive segments on the same image or because of the execution
of image control statements.
<b>NOTE</b> <b>2</b>
If the segments <i>S</i>
         1
        , <i>S</i>
           2
          , ..., <i>S</i>
              <i>k</i>
              on the distinct images <i>P</i>
                             1
                         , <i>P</i>
                               2
                           , ..., <i>P</i>
                                <i>k</i>
                               are all unordered with respect to each
other, it is expected that the processor will ensure that each of these images is provided with an equitable share
of resources for executing its segment.
<b>NOTE</b> <b>3</b>
Because of the restrictions on references and definitions in unordered segments, the processor can apply code
motion optimizations within a segment as if it were the only image in execution, provided calls to atomic
subroutines are not involved.
<b>NOTE</b> <b>4</b>
The model upon which the interpretation of a program is based is that there is a permanent memory location
for each coarray and that all images on which it is established can access it.
In practice, apart from executions of atomic subroutines, the processor could make a copy of a nonvolatile
coarray in a segment (in cache or a register, for example) and, as an optimization, defer copying a changed
value back to its permanent memory location while it is still being used. Since the variable is not volatile, it is
safe to defer this copying back until the end of the segment. It might not be safe to defer this action beyond
the end of the segment since another image might reference the variable then.
ThevalueoftheATOMargumentofanatomicsubroutinemightbeaccessedormodifiedbyanotherconcurrently
executing image. Therefore, execution of an atomic subroutine that references the ATOM argument cannot
rely on a local copy, but instead always gets its value from its permanent memory location. Execution of an
atomic subroutine that defines the ATOM argument does not complete until the value of its ATOM argument
has been sent to its permanent memory location.
<b>NOTE</b> <b>5</b>
The incorrect sequencing of image control statements can suspend execution indefinitely. For example, one
image might be executing a SYNC ALL statement while another is executing an ALLOCATE statement for a
coarray.
<b>11.7.3</b> <b>SYNC</b> <b>ALL</b> <b>statement</b>
R1168 <i>sync-all-stmt</i> <b>is</b> SYNC ALL [ ( [ <i>sync-stat-list</i> ] ) ]
R1169 <i>sync-stat</i> <b>is</b> STAT = <i>stat-variable</i>
              <b>or</b> ERRMSG = <i>errmsg-variable</i>
C1179 No specifier shall appear more than once in a given <i>sync-stat-list</i>.
C1180 A <i>stat-variable</i> or <i>errmsg-variable</i> in a <i>sync-stat</i> shall not be a coindexed object.
The STAT= and ERRMSG= specifiers for image control statements are described in 11.7.11.
Successful execution of a SYNC ALL statement performs a synchronization of all images in the current team.
Execution on an image, M, of the segment following the SYNC ALL statement is delayed until each other image
in the current team has executed a SYNC ALL statement as many times as has image M in this team. The
segments that executed before the SYNC ALL statement on an image precede the segments that execute after
the SYNC ALL statement on another image.
<b>NOTE</b>
TheprocessormighthavespecialhardwareoremployanoptimizedalgorithmtomaketheSYNCALLstatement
execute efficiently.
Here is a simple example of its use. Image 1 reads data and broadcasts it to other images:
   REAL :: P[*]
    ...
   SYNC ALL
   IF (THIS_IMAGE()==1) THEN
     READ (*,*) P
                <b>J3/23-007r1</b> <b>217</b>
<b>NOTE</b> <b>(cont.)</b>
     DO I = 2, NUM_IMAGES()
      P[I] = P
     END DO
   END IF
   SYNC ALL
<b>11.7.4</b> <b>SYNC</b> <b>IMAGES</b> <b>statement</b>
R1170 <i>sync-images-stmt</i> <b>is</b> SYNC IMAGES ( <i>image-set</i> [ , <i>sync-stat-list</i> ] )
R1171 <i>image-set</i> <b>is</b> <i>int-expr</i>
              <b>or</b> *
C1181 An <i>image-set</i> that is an <i>int-expr</i> shall be scalar or of rank one.
C1182 The value of <i>image-set</i> shall not depend on the value of <i>stat-variable</i> or <i>errmsg-variable</i>.
If <i>image-set</i> is an array expression, the value of each element shall be positive and not greater than the number
of images in the current team, and there shall be no repeated values.
If <i>image-set</i> is a scalar expression, its value shall be positive and not greater than the number of images in the
current team.
An <i>image-set</i> that is an asterisk specifies all images in the current team.
Execution of a SYNC IMAGES statement performs a synchronization of the image with each of the other images
in the <i>image-set</i>. Executions of SYNC IMAGES statements on images M and T correspond if the number of
times image M has executed a SYNC IMAGES statement in the current team with T in its image set is the same
as the number of times image T has executed a SYNC IMAGES statement with M in its image set in this team.
The segments that executed before the SYNC IMAGES statement on either image precede the segments that
execute after the corresponding SYNC IMAGES statement on the other image.
<b>NOTE</b> <b>1</b>
A SYNC IMAGES statement that specifies the single image index value THIS_IMAGE ( ) in its image set is
allowed. This simplifies writing programs for an arbitrary number of images by allowing correct execution in
the limiting case of the number of images being equal to one.
<b>NOTE</b> <b>2</b>
In a program that uses SYNC ALL as its only synchronization mechanism, every SYNC ALL statement could
be replaced by a SYNC IMAGES (*) statement, but SYNC ALL might give better performance.
SYNC IMAGES statements are not required to specify the entire image set, or even the same image set, on all
images participating in the synchronization. In the following example, image 1 will wait for each of the other
images to execute the statement SYNC IMAGES (1). The other images wait for image 1 to set up the data,
but do not wait on any other image.
   IF (THIS_IMAGE() == 1) then
     ! Set up coarray data needed by all other images.
     SYNC IMAGES(*)
   ELSE
     SYNC IMAGES(1)
     ! Use the data set up by image 1.
   END IF
<b>218</b> <b>J3/23-007r1</b>
<b>NOTE</b> <b>2</b> <b>(cont.)</b>
When the following example runs on five or more images, each image synchronizes with both of its neighbors,
in a circular fashion.
   INTEGER :: up, down
    ...
   IF (NUM_IMAGES () > 1) THEN
     up = THIS_IMAGE () + 1; IF (up>NUM_IMAGES ()) up = 1
     down = THIS_IMAGE () - 1; IF (down==0) down = NUM_IMAGES ()
     SYNC IMAGES ( (/ up, down /) )
   END IF
This might appear to have the same effect as SYNC ALL but there is no ordering between the preceding
and succeeding segments on non-adjacent images. For example, the segment preceding the SYNC IMAGES
statement on image 3 will be ordered before those succeeding it on images 2 and 4, but not those on images 1
and 5.
<b>NOTE</b> <b>3</b>
In the following example, each image synchronizes with its neighbor.
   INTEGER :: ME, NE, STEP, NSTEPS
   NE = NUM_IMAGES()
   ME = THIS_IMAGE()
    ... ! Initial calculation
   SYNC ALL
   DO STEP = 1, NSTEPS
     IF (ME > 1) SYNC IMAGES(ME-1)
       ... ! Perform calculation
     IF (ME < NE) SYNC IMAGES(ME+1)
   END DO
   SYNC ALL
The calculation starts on image 1 since all the others will be waiting on SYNC IMAGES (ME-1). When this
is done, image 2 can start and image 1 can perform its second calculation. This continues until they are all
executing different steps at the same time. Eventually, image 1 will finish and then the others will finish one
by one.
<b>11.7.5</b> <b>SYNC</b> <b>MEMORY</b> <b>statement</b>
Execution of a SYNC MEMORY statement ends one segment and begins another; those two segments can be
ordered by a user-defined way with respect to segments on other images.
R1172 <i>sync-memory-stmt</i> <b>is</b> SYNC MEMORY [ ( [ <i>sync-stat-list</i> ] ) ]
If, by execution of statements on image P,
 a variable X on image Q is defined, referenced, becomes undefined, or has its allocation status, pointer
  association status, array bounds, dynamic type, or type parameters changed or inquired about by execution
  of a statement,
 that statement precedes a successful execution of a SYNC MEMORY statement, and
 a variable Y on image Q is defined, referenced, becomes undefined, or has its allocation status, pointer
  association status, array bounds, dynamic type, or type parameters changed or inquired about by execution
  of a statement that succeeds execution of that SYNC MEMORY statement,
then the action regarding X on image Q precedes the action regarding Y on image Q.
User-defined ordering of segment <i>P</i>
                <i>i</i>
                on image P to precede segment <i>Q</i>
                                <i>j</i>
                               on image Q occurs when
 image P executes an image control statement that ends segment <i>P</i>
                                  <i>i</i>
                                , and then executes statements that
  initiate a cooperative synchronization between images P and Q, and
 image Q executes statements that complete the cooperative synchronization between images P and Q and
  then executes an image control statement that begins segment <i>Q</i>
                                <i>j</i>
                               .
Execution of the cooperative synchronization between images P and Q shall include a dependency that forces
execution on image P of the statements that initiate the synchronization to precede the execution on image Q of
the statements that complete the synchronization. The mechanisms available for creating such a dependency are
processor dependent.
<b>NOTE</b> <b>1</b>
SYNC MEMORY usually suppresses compiler optimizations that might reorder memory operations across the
segment boundary defined by the SYNC MEMORY statement and ensures that all memory operations initiated
in the preceding segments in its image complete before any memory operations in the subsequent segment in
its image are initiated. It needs to do this unless it can establish that failure to do so could not alter processing
on another image.
<b>NOTE</b> <b>2</b>
SYNC MEMORY can be used to implement specialized schemes for segment ordering. For example, the user
might have access to an external procedure that performs synchronization between images. That library pro-
cedure might not be aware of the mechanisms used by the processor to manage remote data references and
definitions, and therefore not, by itself, be able to ensure the correct memory state before and after its refer-
ence. The SYNC MEMORY statement provides the needed memory ordering that enables the safe use of the
external synchronization routine. For example:
   INTEGER :: IAM
   REAL :: X[*]
   IAM = THIS_IMAGE ()
   IF (IAM == 1) X = 1.0
   SYNC MEMORY
   CALL EXTERNAL_SYNC ()
   SYNC MEMORY
   IF (IAM == 2) WRITE (*,*) X[1]
where executing the subroutine EXTERNAL_SYNC has an image synchronization effect similar to executing
a SYNC ALL statement.
<b>11.7.6</b> <b>SYNC</b> <b>TEAM</b> <b>statement</b>
R1173 <i>sync-team-stmt</i> <b>is</b> SYNC TEAM ( <i>team-value</i> [ , <i>sync-stat-list</i> ] )
The <i>team-value</i> shall identify an ancestor team, the current team, or a team whose parent is the current team.
The executing image shall be a member of the specified team.
Successful execution of a SYNC TEAM statement performs a synchronization of the team identified by <i>team-</i>
<i>value</i>. Execution on an image, M, of the segment following the SYNC TEAM statement is delayed until each
other image of the specified team has executed a SYNC TEAM statement specifying the same team as many
times as has image M in this team. The segments that executed before the SYNC TEAM statement on an image
precede the segments that execute after the corresponding SYNC TEAM statement on another image.
<b>NOTE</b>
A SYNC TEAM statement synchronizes a particular team whereas a SYNC ALL statement synchronizes the
current team.
<b>11.7.7</b> <b>EVENT</b> <b>POST</b> <b>statement</b>
The EVENT POST statement posts an event.
R1174 <i>event-post-stmt</i> <b>is</b> EVENT POST ( <i>event-variable</i> [ , <i>sync-stat-list</i> ] )
R1175 <i>event-variable</i> <b>is</b> <i>scalar-variable</i>
C1183 (R1175)An<i>event-variable</i> shallbeoftypeEVENT_TYPEfromtheintrinsicmoduleISO_FORTRAN_-
   ENV (16.10.2).
The <i>event-variable</i> shall not depend on the value of <i>stat-variable</i> or <i>errmsg-variable</i>.
Successful execution of an EVENT POST statement atomically increments the count of the event variable by
one. If an error condition occurs during execution of an EVENT POST statement, the value of the count of the
event variable is processor dependent. The completion of an EVENT POST statement does not depend on the
execution of a corresponding EVENT WAIT statement.
<b>11.7.8</b> <b>EVENT</b> <b>WAIT</b> <b>statement</b>
The EVENT WAIT statement waits until an event is posted.
R1176 <i>event-wait-stmt</i> <b>is</b> EVENT WAIT ( <i>event-variable</i> [ , <i>event-wait-spec-list</i> ] )
R1177 <i>event-wait-spec</i> <b>is</b> <i>until-spec</i>
              <b>or</b> <i>sync-stat</i>
R1178 <i>until-spec</i> <b>is</b> UNTIL_COUNT = <i>scalar-int-expr</i>
C1184 (R1176) The <i>event-variable</i> in an <i>event-wait-stmt</i> shall not be coindexed.
C1185 No specifier shall appear more than once in a given <i>event-wait-spec-list</i>.
The <i>event-variable</i> shall not depend on the value of <i>stat-variable</i> or <i>errmsg-variable</i>.
Execution of an EVENT WAIT statement consists of the following sequence of actions:
 1. iftheUNTIL_COUNT=specifierdoesnotappear, thethresholdvalueissettoone; otherwise, thethreshold
  value is set to the maximum of the value of the <i>scalar-int-expr</i> and one;
 2. the executing image waits until the count of the event variable is greater than or equal to the threshold
  value or an error condition occurs;
 3. if no error condition occurs, the count of the event variable is atomically decremented by the threshold
  value.
If an error condition occurs during execution of an EVENT WAIT statement, the value of the count of its event
variable is processor dependent.
An EVENT POST statement execution is initially unsatisfied. Successful execution of an EVENT WAIT state-
ment with a threshold of <i>k</i> satisfies the first <i>k</i> unsatisfied EVENT POST statement executions for that event
variable. This EVENT WAIT statement execution causes the segment following the EVENT WAIT statement
execution to succeed the segments preceding those <i>k</i> EVENT POST statement executions.
<b>11.7.9</b> <b>FORM</b> <b>TEAM</b> <b>statement</b>
The FORM TEAM statement creates a set of sibling teams whose parent team is the current team.
R1179 <i>form-team-stmt</i> <b>is</b> FORM TEAM ( <i>team-number</i>, <i>team-variable</i>
                   [ , <i>form-team-spec-list</i> ] )
R1180 <i>team-number</i> <b>is</b> <i>scalar-int-expr</i>
R1181 <i>team-variable</i> <b>is</b> <i>scalar-variable</i>
C1186 A <i>team-variable</i> shall be of type TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV.
R1182 <i>form-team-spec</i> <b>is</b> NEW_INDEX = <i>scalar-int-expr</i>
              <b>or</b> <i>sync-stat</i>
C1187 No specifier shall appear more than once in a given <i>form-team-spec-list</i>.
SuccessfulexecutionofaFORMTEAMstatementcreatesanewteamforeachunique <i>team-number</i> valuespecified
by the active images of the current team. The value of <i>team-number</i> shall be positive. Each executing image will
belong to the team whose team number is equal to the value of <i>team-number</i> on that image, and the <i>team-variable</i>
becomes defined with a value that identifies that team.
The value of the <i>scalar-int-expr</i> in a NEW_INDEX= specifier specifies the image index that the executing image
will have in its new team. It shall be positive, less than or equal to the number of images in the team, and
different from the value specified by every other image that belongs to that team.
If the NEW_INDEX= specifier does not appear, the image index of the executing image in the new team is
processor dependent. This image index will be positive, less than or equal to the number of images in the team,
and different from that of every other image in the team.
If the FORM TEAM statement is executed on one image, the same statement shall be executed on all active
images of the current team. When a FORM TEAM statement is executed, there is an implicit synchronization
of all active images in the current team. On those images, execution of the segment following the statement is
delayed until all other active images in the current team have executed the same statement the same number of
times in this team. The segments that executed before the FORM TEAM statement on an active image of this
team precede the segments that execute after the FORM TEAM statement on another active image of this team.
If an error condition other than detection of a failed image occurs, the team variable becomes undefined.
If execution of a FORM TEAM statement assigns the value STAT_FAILED_IMAGE to the <i>stat-variable</i>, the
effect is the same as for the successful execution of FORM TEAM except for the value assigned to <i>stat-variable</i>.
<b>NOTE</b> <b>1</b>
Executing the statement
   FORM TEAM ( 2 - MOD (THIS_IMAGE (), 2), ODD_EVEN )
will create two subteams of the current team, with images whose image index is odd being in the team with
number 1, and those with an even image index being in the team with number 2.
<b>NOTE</b> <b>2</b>
If the current team consists of <i>P</i>
                 2
               images, with corresponding coarrays on each image representing parts of a
larger array spread over a <i>P</i>x<i>P</i> square, the following code will establish teams for the rows with image indices
equal to the column indices.
   USE, INTRINSIC :: ISO_FORTRAN_ENV
   TYPE(TEAM_TYPE) :: ROW
   REAL :: A [P, *]
   INTEGER :: ME (2)
   ME (:) = THIS_IMAGE (A)
   FORM TEAM (ME(1), ROW, NEW_INDEX=ME(2))
<b>11.7.10</b> <b>LOCK</b> <b>and</b> <b>UNLOCK</b> <b>statements</b>
R1183 <i>lock-stmt</i> <b>is</b> LOCK ( <i>lock-variable</i> [ , <i>lock-stat-list</i> ] )
R1184 <i>lock-stat</i> <b>is</b> ACQUIRED_LOCK = <i>scalar-logical-variable</i>
              <b>or</b> <i>sync-stat</i>
C1188 No specifier shall appear more than once in a given <i>lock-stat-list</i>.
R1185 <i>unlock-stmt</i> <b>is</b> UNLOCK ( <i>lock-variable</i> [ , <i>sync-stat-list</i> ] )
R1186 <i>lock-variable</i> <b>is</b> <i>scalar-variable</i>
C1189 (R1186) A<i>lock-variable</i> shall be of type LOCK_TYPE from the intrinsic module ISO_FORTRAN_ENV
   (16.10.2.19).
The <i>lock-variable</i> shall not depend on the value of <i>stat-variable</i>, <i>errmsg-variable</i>, or the <i>scalar-logical-variable</i> in
the ACQUIRED_LOCK= specifier. The <i>scalar-logical-variable</i> shall not depend on the value of the <i>lock-variable</i>,
<i>stat-variable</i>, or <i>errmsg-variable</i>.
A lock variable is unlocked if and only if the value of each component is the same as its default value. If it has any
other value, it is locked. A lock variable is locked by an image if it was locked by execution of a LOCK statement
on that image, has not been subsequently unlocked by execution of an UNLOCK statement on the same image,
and that image has not failed.
Successful execution of a LOCK statement without an ACQUIRED_LOCK= specifier causes the lock variable
to become locked by that image. If the lock variable is already locked by another image, that LOCK statement
causes the lock variable to become locked after the other image causes the lock variable to become unlocked.
Ifthelockvariableisunlocked, successfulexecutionofaLOCKstatementwithanACQUIRED_LOCK=specifier
causes the lock variable to become locked by that image and the scalar logical variable to become defined with the
value true. If the lock variable is already locked by a different image, successful execution of a LOCK statement
with an ACQUIRED_LOCK= specifier leaves the lock variable unchanged and causes the scalar logical variable
to become defined with the value false.
Successful execution of an UNLOCK statement causes the lock variable to become unlocked. Failure of an image
causes all lock variables that are locked by that image to become unlocked.
During execution of the program, the value of a lock variable changes through a sequence of locked and unlocked
states due to the execution of LOCK and UNLOCK statements, and by failure of an image while it is locked by
that image. If a lock variable becomes unlocked by execution of an UNLOCK statement on image M and next
becomes locked by execution of a LOCK statement on image T, the segments preceding the UNLOCK statement
on image M precede the segments following the LOCK statement on image T. Execution of a LOCK statement
that does not cause the lock variable to become locked does not affect segment ordering.
An error condition occurs if the lock variable in a LOCK statement is already locked by the executing image.
An error condition occurs if the lock variable in an UNLOCK statement is not already locked by the executing
image. If an error condition occurs during execution of a LOCK or UNLOCK statement, the value of the lock
variable is not changed and the value of the ACQUIRED_LOCK variable, if any, is not changed.
<b>NOTE</b> <b>1</b>
A lock variable is effectively defined atomically by a LOCK or UNLOCK statement. If LOCK statements on
two images both attempt to acquire a lock, one will succeed and the other will either fail if an ACQUIRED_-
LOCK= specifier appears, or will wait until the lock is later released if an ACQUIRED_LOCK= specifier does
not appear.
<b>NOTE</b> <b>2</b>
An image might wait for a LOCK statement to successfully complete for a long period of time if other images
frequently lock and unlock the same lock variable. This situation might result from executing LOCK statements
with ACQUIRED_LOCK= specifiers inside a spin loop.
<b>NOTE</b> <b>3</b>
The following example illustrates the use of LOCK and UNLOCK statements to manage a work queue:
   USE, INTRINSIC :: ISO_FORTRAN_ENV
   TYPE(LOCK_TYPE) :: queue_lock[*] ! Lock on each image to manage its work queue
   INTEGER :: work_queue_size[*]
   TYPE(Task) :: work_queue(100)[*] ! List of tasks to perform
   TYPE(Task) :: job ! Current task working on
   INTEGER :: me
   me = THIS_IMAGE()
   DO
     ! Process the next item in your work queue
     LOCK (queue_lock) ! New segment A starts
     ! This segment A is ordered with respect to
     ! segment B executed by image me-1 below because of lock exclusion
     IF (work_queue_size>0) THEN
      ! Fetch the next job from the queue
      job = work_queue(work_queue_size)
      work_queue_size = work_queue_size-1
     END IF
     UNLOCK (queue_lock) ! Segment ends
     ... <i>Actually</i> <i>process</i> <i>the</i> <i>task.</i>
     ! Add a new task on neighbors queue:
     LOCK(queue_lock[me+1]) ! Starts segment B
     ! This segment B is ordered with respect to
     ! segment A executed by image me+1 above because of lock exclusion
     IF (work_queue_size[me+1]<SIZE (work_queue)) THEN
      work_queue_size[me+1] = work_queue_size[me+1]+1
      work_queue(work_queue_size[me+1])[me+1] = job
     END IF
     UNLOCK (queue_lock[me+1]) ! Ends segment B
   END DO
<b>11.7.11</b> <b>STAT=</b> <b>and</b> <b>ERRMSG=</b> <b>specifiers</b> <b>in</b> <b>image</b> <b>control</b> <b>statements</b>
In an image control statement, the <i>stat-variable</i> in a <i>sync-stat</i> shall not depend on the value of an <i>errmsg-variable</i>
in a <i>sync-stat</i>, <i>event-variable</i>, <i>lock-variable</i>, <i>team-variable</i>, or the <i>scalar-logical-variable</i> in the ACQUIRED_-
LOCK= specifier. The <i>errmsg-variable</i> in a <i>sync-stat</i> shall not depend on the value of a <i>stat-variable</i> in a
<i>sync-stat</i>, <i>event-variable</i>, <i>lock-variable</i>, <i>team-variable</i>, or the <i>scalar-logical-variable</i> in the ACQUIRED_LOCK=
specifier.
If a STAT= specifier appears in a <i>sync-stat</i> in an image control statement, the <i>stat-variable</i> is assigned the value
zero if execution of the statement is successful.
If the STAT= specifier appears in a <i>sync-stat</i> in an EVENT WAIT or SYNC MEMORY statement and an error
condition occurs, <i>stat-variable</i> is assigned a processor-dependent positive value that is different from the value
of STAT_FAILED_IMAGE (16.10.2.28) and STAT_STOPPED_IMAGE (16.10.2.31) from the intrinsic module
ISO_FORTRAN_ENV (16.10.2).
The images involved in execution of an END TEAM, FORM TEAM, or SYNC ALL statement are those in the
current team. The images involved in execution of a CHANGE TEAM or SYNC TEAM statement are those of
the specified team. The images involved in execution of a SYNC IMAGES statement are the images specified
and the executing image. The images involved in execution of an EVENT POST statement are the image on
which the event variable is located and the executing image.
If the STAT= specifier appears in a <i>sync-stat</i> in a CHANGE TEAM, END TEAM, EVENT POST, FORM
TEAM, SYNC ALL, SYNC IMAGES, or SYNC TEAM statement,
 if one of the images involved has stopped, <i>stat-variable</i> is assigned the value STAT_STOPPED_IMAGE
  (16.10.2.31) from the intrinsic module ISO_FORTRAN_ENV;
 otherwise, if one of the images involved has failed and no other error condition occurs, the intended action
  is performed on the active images involved and <i>stat-variable</i> is assigned the value STAT_FAILED_IMAGE
  (16.10.2.28) from the intrinsic module ISO_FORTRAN_ENV;
 otherwise, if any other error condition occurs, <i>stat-variable</i> is assigned a processor-dependent positive value
  that is different from the values of STAT_STOPPED_IMAGE and STAT_FAILED_IMAGE.
If the STAT= specifier appears in a <i>sync-stat</i> in a SYNC ALL, SYNC IMAGES, or SYNC TEAM statement
and the error condition STAT_STOPPED_IMAGE occurs, the effect is the same as that of executing the SYNC
MEMORY statement, except for defining the <i>stat-variable</i>.
If the STAT= specifier appears in a <i>sync-stat</i> in a LOCK statement,
 if the image on which the lock variable is located has failed, the <i>stat-variable</i> becomes defined with the
  value STAT_FAILED_IMAGE;
 otherwise, if the lock variable is locked by the executing image, the <i>stat-variable</i> becomes defined with the
  value of STAT_LOCKED (16.10.2.29) from the intrinsic module ISO_FORTRAN_ENV;
 otherwise, if the lock variable is unlocked because of the failure of the image that locked it, <i>stat-variable</i>
  becomes defined with the value STAT_UNLOCKED_FAILED_IMAGE (16.10.2.33) from the intrinsic
  module ISO_FORTRAN_ENV.
If the STAT= specifier appears in a <i>sync-stat</i> in an UNLOCK statement,
 if the image on which the lock variable is located has failed, the <i>stat-variable</i> becomes defined with the
  value STAT_FAILED_IMAGE;
 otherwise, if the lock variable has the value unlocked, the <i>stat-variable</i> becomes defined with the value of
  STAT_UNLOCKED (16.10.2.32) from the intrinsic module ISO_FORTRAN_ENV;
 otherwise, if the lock variable is locked by a different image, the <i>stat-variable</i> becomes defined with the
  value STAT_LOCKED_OTHER_IMAGE (16.10.2.30) from the intrinsic module ISO_FORTRAN_ENV.
If the STAT= specifier appears in a <i>sync-stat</i> in a LOCK or UNLOCK statement and any other error condition
occurs during execution of that statement, the <i>stat-variable</i> becomes defined with a processor-dependent positive
value that is different from STAT_LOCKED, STAT_LOCKED_OTHER_IMAGE, STAT_UNLOCKED, and
STAT_UNLOCKED_FAILED_IMAGE.
If an image completes execution of a CRITICAL statement that has a <i>sync-stat</i> that is a STAT= specifier and the
previous image to have entered the construct failed while executing it, the <i>stat-variable</i> becomes defined with the
value STAT_FAILED_IMAGE and execution of the construct continues normally. If any other error condition
occurs during execution of a CRITICAL statement that has a STAT= specifier, the <i>stat-variable</i> becomes defined
with a processor-dependent positive value other than STAT_FAILED_IMAGE.
If an error condition occurs during execution of an image control statement that does not contain the STAT=
specifier in a <i>sync-stat</i>, error termination is initiated.
If an ERRMSG= specifier appears in an image control statement and an error condition occurs, <i>errmsg-variable</i>
is assigned an explanatory message, as if by intrinsic assignment. If no such condition occurs, the definition status
and value of <i>errmsg-variable</i> are unchanged.
The set of error conditions that can occur in an image control statement is processor dependent.
<b>NOTE</b>
A processor might detect communication failure between images and treat it as an error condition. A processor
might also treat an invalid set of images in a SYNC IMAGES statement as an error condition.
<b>12</b> <b>Input/output</b> <b>statements</b>
<b>12.1</b> <b>Input/output</b> <b>concepts</b>
Inputstatementsprovidethemeansoftransferringdatafromexternalmediatointernalstorageorfromaninternal
file to internal storage. This process is called reading. Output statements provide the means of transferring data
from internal storage to external media or from internal storage to an internal file. This process is called writing.
Some input/output statements specify that editing of the data is to be performed.
In addition to the statements that transfer data, there are auxiliary input/output statements to manipulate the
external medium, or to describe or inquire about the properties of the connection to the external medium.
The input/output statements are the BACKSPACE, CLOSE, ENDFILE, FLUSH, INQUIRE, OPEN, PRINT,
READ, REWIND, WAIT, and WRITE statements.
A file is composed of either a sequence of file storage units (12.3.5) or a sequence of records, which provide an
extra level of organization to the file. A file composed of records is called a record file. A file composed of file
storage units is called a stream file. A processor may allow a file to be viewed both as a record file and as a stream
file; in this case the relationship between the file storage units when viewed as a stream file and the records when
viewed as a record file is processor dependent.
A file is either an external file (12.3) or an internal file (12.4).
<b>12.2</b> <b>Records</b>
<b>12.2.1</b> <b>Definition</b> <b>of</b> <b>a</b> <b>record</b>
A record is a sequence of values or a sequence of characters. For example, a line on a terminal is usually considered
to be a record. However, a record does not necessarily correspond to a physical entity. There are three kinds of
records:
  (1) formatted;
  (2) unformatted;
  (3) endfile.
<b>NOTE</b>
What is called a "record" in Fortran is commonly called a "logical record". There is no concept in Fortran of a
"physical record."
<b>12.2.2</b> <b>Formatted</b> <b>record</b>
A formatted record consists of a sequence of characters that are representable in the processor; however, a
processor may prohibit some control characters (6.1.1) from appearing in a formatted record. The length of a
formatted record is measured in characters and depends primarily on the number of characters put into the record
when it is written; however, it may depend on the processor and the external medium. The length may be zero.
Formatted records shall be read or written only by formatted input/output statements.
<b>12.2.3</b> <b>Unformatted</b> <b>record</b>
An unformatted record consists of a sequence of values in a processor-dependent form and may contain data
of any type or may contain no data. The length of an unformatted record is measured in file storage units
(12.3.5) and depends on the output list (12.6.3) used when it is written, as well as on the processor and the
external medium. The length may be zero. Unformatted records shall be read or written only by unformatted
input/output statements.
<b>12.2.4</b> <b>Endfile</b> <b>record</b>
An endfile record is written explicitly by the ENDFILE statement; the file shall be connected for sequential
access. An endfile record is written implicitly to a file connected for sequential access when the most recent data
transfer statement referring to the file is an output statement, no intervening file positioning statement referring
to the file has been executed, and
 a REWIND or BACKSPACE statement references the unit to which the file is connected, or
 the unit is closed, either explicitly by a CLOSE statement, implicitly by normal termination, or implicitly
  by another OPEN statement for the same unit.
An endfile record shall occur only as the last record of a file. An endfile record does not have a length property.
<b>NOTE</b>
An endfile record does not necessarily have any physical embodiment. The processor can use a record count or
any other means to register the position of the file at the time an ENDFILE statement is executed, so that it
can take appropriate action when that position is reached again during a read operation. The endfile record,
however it is implemented, is considered to exist for the BACKSPACE statement (12.8.2).
<b>12.3</b> <b>External</b> <b>files</b>
<b>12.3.1</b> <b>External</b> <b>file</b> <b>concepts</b>
An external file is any file that exists in a medium external to the program.
At any given time, there is a processor-dependent set of allowed access methods, a processor-dependent set of
allowed forms, a processor-dependent set of allowed actions, and a processor-dependent set of allowed record
lengths for a file.
<b>NOTE</b> <b>1</b>
For example, the processor-dependent set of allowed actions for a printer would likely include the write action,
but not the read action.
A file may have a name; a file that has a name is called a named file. The name of a named file is represented by
a character string value. The set of allowable names for a file is processor dependent. Whether a named file on
one image is the same as a file with the same name on another image is processor dependent.
<b>NOTE</b> <b>2</b>
If different files are needed on each image, using a different file name on each image will improve portability of
the code. One technique is to incorporate the image index as part of the name.
An external file that is connected to a unit has a position property (12.3.4).
<b>NOTE</b> <b>3</b>
For more explanatory information on external files, see C.8.1.
<b>12.3.2</b> <b>File</b> <b>existence</b>
At any given time, there is a processor-dependent set of external files that exist for a program. A file may be
known to the processor, yet not exist for a program at a particular time.
To create a file means to cause a file to exist that did not exist previously. To delete a file means to terminate
the existence of the file.
All input/output statements may refer to files that exist. A CLOSE, ENDFILE, FLUSH, INQUIRE, OPEN,
PRINT, REWIND, or WRITE statement is permitted to refer to a file that does not exist. No other input/output
statement shall refer to a file that does not exist. Execution of a WRITE, PRINT, or ENDFILE statement
referring to a preconnected file that does not exist creates the file. This file is a different file from one preconnected
on any other image.
<b>12.3.3</b> <b>File</b> <b>access</b>
<b>12.3.3.1</b> <b>File</b> <b>access</b> <b>methods</b>
There are three methods of accessing the data of an external file: sequential, direct, and stream. Some files may
have more than one allowed access method; other files may be restricted to one access method.
<b>NOTE</b>
For example, a processor might provide only sequential access to a file on magnetic tape. Thus, the set of
allowed access methods depends on the file and the processor.
The method of accessing a file is determined when the file is connected to a unit (12.5.4) or when the file is
created if the file is preconnected (12.5.5).
<b>12.3.3.2</b> <b>Sequential</b> <b>access</b>
Sequential access is a method of accessing the records of an external record file in order.
While connected for sequential access, an external file has the following properties.
 The order of the records is the order in which they were written if the direct access method is not a member
  of the set of allowed access methods for the file. If the direct access method is also a member of the set of
  allowed access methods for the file, the order of the records is the same as that specified for direct access.
  In this case, the first record accessible by sequential access is the record whose record number is 1 for direct
  access. The second record accessible by sequential access is the record whose record number is 2 for direct
  access, etc. A record that has not been written since the file was created shall not be read.
 The records of the file are either all formatted or all unformatted, except that the last record of the file can
  be an endfile record. Unless the previous reference to the file was an output statement, the last record, if
  any, of the file shall be an endfile record.
 The records of the file shall be read or written only by sequential access data transfer statements.
<b>12.3.3.3</b> <b>Direct</b> <b>access</b>
Direct access is a method of accessing the records of an external record file in arbitrary order.
While connected for direct access, an external file has the following properties.
 Each record of the file is uniquely identified by a positive integer called the record number. The record
  number of a record is specified when the record is written. Once established, the record number of a record
  can never be changed. The order of the records is the order of their record numbers.
 The records of the file are either all formatted or all unformatted. If the sequential access method is also a
  member of the set of allowed access methods for the file, its endfile record, if any, is not considered to be
  part of the file while it is connected for direct access. If the sequential access method is not a member of
  the set of allowed access methods for the file, the file shall not contain an endfile record.
 The records of the file shall be read or written only by direct access data transfer statements.
 All records of the file have the same length.
 Records need not be read or written in the order of their record numbers. Any record may be written
  into the file while it is connected to a unit. For example, it is permissible to write record 3, even though
  records 1 and 2 have not been written. Any record may be read from the file while it is connected to a
  unit, provided that the record has been written since the file was created, and if a READ statement for this
  connection is permitted.
 The records of the file shall not be read or written using list-directed formatting (13.10), namelist formatting
  (13.11), or a nonadvancing data transfer statement (12.3.4.2).
<b>NOTE</b>
A record cannot be deleted; however, a record can be rewritten.
<b>12.3.3.4</b> <b>Stream</b> <b>access</b>
Stream access is a method of accessing the file storage units (12.3.5) of an external stream file.
Thepropertiesofanexternalfileconnectedforstreamaccessdependonwhethertheconnectionisforunformatted
or formatted access. While connected for stream access, the file storage units of the file shall be read or written
only by stream access data transfer statements.
While connected for unformatted stream access, an external file has the following properties.
 Each file storage unit in the file is uniquely identified by a positive integer called the position. The first file
  storage unit in the file is at position 1. The position of each subsequent file storage unit is one greater than
  that of its preceding file storage unit.
 If it is possible to position the file, the file storage units need not be read or written in order of their position.
  For example, it might be permissible to write the file storage unit at position 3, even though the file storage
  units at positions 1 and 2 have not been written. Any file storage unit may be read from the file while it is
  connected to a unit, provided that the file storage unit has been written since the file was created, and if a
  READ statement for this connection is permitted.
While connected for formatted stream access, an external file has the following properties.
 Some file storage units of the file can contain record markers; this imposes a record structure on the file
  in addition to its stream structure. There might or might not be a record marker at the end of the file. If
  there is no record marker at the end of the file, the final record is incomplete.
 No maximum length (12.5.6.16) is applicable to these records.
 Writing an empty record with no record marker has no effect.
 Each file storage unit in the file is uniquely identified by a positive integer called the position. The first file
  storage unit in the file is at position 1. The relationship between positions of successive file storage units is
  processor dependent; not all positive integers need correspond to valid positions.
 If it is possible to position the file, the file position can be set to a position that was previously identified
  by the POS= specifier in an INQUIRE statement.
 A processor may prohibit some control characters (6.1.1) from appearing in a formatted stream file.
<b>NOTE</b> <b>1</b>
Becausetherecordstructureisdeterminedfromtherecordmarkersthatarestoredinthefileitself, anincomplete
record at the end of the file is necessarily not empty.
<b>NOTE</b> <b>2</b>
There might be some character positions in the file that do not correspond to characters written; this is because
on some processors a record marker could be written to the file as a carriage-return/line-feed or other sequence.
The means of determining the position in a file connected for stream access is via the POS= specifier in an
INQUIRE statement (12.10.2.23).
<b>12.3.4</b> <b>File</b> <b>position</b>
<b>12.3.4.1</b> <b>General</b>
Execution of certain input/output statements affects the position of an external file. Certain circumstances can
cause the position of a file to become indeterminate.
The initial point of a file is the position just before the first record or file storage unit. The terminal point is the
position just after the last record or file storage unit. If there are no records or file storage units in the file, the
initial point and the terminal point are the same position.
If a record file is positioned within a record, that record is the current record; otherwise, there is no current
record.
Let <i>n</i> be the number of records in the file. If 1<i><i</i><i>n</i> and a file is positioned within the <i>i</i>th record or between
the (<i>i</i>- 1)th record and the <i>i</i>th record, the (<i>i</i>- 1)th record is the preceding record. If <i>n</i> 1 and the file is
positioned at its terminal point, the preceding record is the <i>n</i>th and last record. If <i>n</i> = 0 or if a file is positioned
at its initial point or within the first record, there is no preceding record.
If 1 <i>i</i> <i><</i> <i>n</i> and a file is positioned within the <i>i</i>th record or between the <i>i</i>th and (<i>i</i> + 1)th record, the (<i>i</i> + 1)th
record is the next record. If <i>n</i> 1 and the file is positioned at its initial point, the first record is the next record.
If <i>n</i> = 0 or if a file is positioned at its terminal point or within the <i>n</i>th (last) record, there is no next record.
For a file connected for stream access, the file position is either between two file storage units, at the initial point
of the file, at the terminal point of the file, or undefined.
<b>12.3.4.2</b> <b>Advancing</b> <b>and</b> <b>nonadvancing</b> <b>input/output</b>
An advancing input/output statement always positions a record file after the last record read or written, unless
there is an error condition.
A nonadvancing input/output statement may position a record file at a character position within the current
record, or a subsequent record (13.8.2). Using nonadvancing input/output, it is possible to read or write a record
of the file by a sequence of data transfer statements, each accessing a portion of the record. If a nonadvancing
output statement leaves a file positioned within a current record and no further output statement is executed for
the file before it is closed or a BACKSPACE, ENDFILE, or REWIND statement is executed for it, the effect is
as if the output statement were the corresponding advancing output statement.
<b>12.3.4.3</b> <b>File</b> <b>position</b> <b>prior</b> <b>to</b> <b>data</b> <b>transfer</b>
The positioning of the file prior to data transfer depends on the method of access: sequential, direct, or stream.
For sequential access on input, if there is a current record, the file position is not changed. Otherwise, the file is
positioned at the beginning of the next record and this record becomes the current record. Input shall not occur
if there is no next record or if there is a current record and the last data transfer statement accessing the file
performed output.
If the file contains an endfile record, the file shall not be positioned after the endfile record prior to data transfer.
However, a REWIND or BACKSPACE statement may be used to reposition the file.
For sequential access on output, if there is a current record, the file position is not changed and the current record
becomes the last record of the file. Otherwise, a new record is created as the next record of the file; this new
record becomes the last and current record of the file and the file is positioned at the beginning of this record.
For direct access, the file is positioned at the beginning of the record specified by the REC= specifier. This record
becomes the current record.
For stream access, the file is positioned immediately before the file storage unit specified by the POS= specifier;
if there is no POS= specifier, the file position is not changed.
File positioning for child data transfer statements is described in 12.6.4.8.
<b>12.3.4.4</b> <b>File</b> <b>position</b> <b>after</b> <b>data</b> <b>transfer</b>
If an error condition (12.11) occurred, the position of the file is indeterminate. If no error condition occurred,
but an end-of-file condition (12.11) occurred as a result of reading an endfile record, the file is positioned after
the endfile record.
For unformatted stream input/output, if no error condition occurred, the file position is not changed. For
unformatted stream output, if the file position exceeds the previous terminal point of the file, the terminal point
is set to the file position.
<b>NOTE</b> <b>1</b>
An unformatted stream output statement with a POS= specifier and an empty output list can have the effect
of extending the terminal point of a file without actually writing any data.
For formatted stream input, if an end-of-file condition occurred, the file position is not changed.
For nonadvancing input, if no error condition or end-of-file condition occurred, but an end-of-record condition
(12.11) occurred, the file is positioned after the record just read. If no error condition, end-of-file condition, or
end-of-record condition occurred in a nonadvancing input statement, the file position is not changed. If no error
condition occurred in a nonadvancing output statement, the file position is not changed.
In all other cases, the file is positioned after the record just read or written and that record becomes the preceding
record.
For a formatted stream output statement, if no error condition occurred, the terminal point of the file is set to
the next position after the highest-numbered position to which a datum was transferred by the statement.
<b>NOTE</b> <b>2</b>
The highest-numbered position might not be the current one if the output involved a T, TL, TR, or X edit
descriptor (13.8.1) and the statement is a nonadvancing output statement.
<b>12.3.5</b> <b>File</b> <b>storage</b> <b>units</b>
A file storage unit is the basic unit of storage in a stream file or an unformatted record file. It is the unit of file
position for stream access, the unit of record length for unformatted files, and the unit of file size for all external
files.
Every value in a stream file or an unformatted record file shall occupy an integer number of file storage units; if
the stream or record file is unformatted, this number shall be the same for all scalar values of the same type and
type parameters. The number of file storage units required for an item of a given type and type parameters can
be determined using the IOLENGTH= specifier of the INQUIRE statement (12.10.3).
Forafileconnectedforunformattedstreamaccess, theprocessorshallnothavealignmentrestrictionsthatprevent
a value of any type from being stored at any positive integer file position.
The number of bits in a file storage unit is given by the constant FILE_STORAGE_SIZE (16.10.2.11) defined
in the intrinsic module ISO_FORTRAN_ENV. It is recommended that the file storage unit be an 8-bit octet
where this choice is practical.
<b>NOTE</b>
The requirement that every data value occupy an integer number of file storage units implies that data items
inherently smaller than a file storage unit will require padding. This suggests that the file storage unit be small
to avoid wasted space. Ideally, the file storage unit would be chosen such that padding is never required. A file
storage unit of one bit would always meet this goal, but would likely be impractical because of the alignment
requirements.
<b>232</b> <b>J3/23-007r1</b>
<b>NOTE</b> <b>(cont.)</b>
The prohibition on alignment restrictions prohibits the processor from requiring data alignments larger than
the file storage unit.
The 8-bit octet is recommended as a good compromise that is small enough to accommodate the requirements
of many applications, yet not so small that the data alignment requirements are likely to cause significant
performance problems.
<b>12.4</b> <b>Internal</b> <b>files</b>
Internal files provide a means of transferring and converting data from internal storage to internal storage.
An internal file is a record file with the following properties.
 The file is a variable of default, ASCII, or ISO 10646 character kind that is not an array section with a
  vector subscript.
 A record of an internal file is a scalar character variable.
 If the file is a scalar character variable, it consists of a single record whose length is the same as the length
  of the scalar character variable. If the file is a character array, it is treated as a sequence of character array
  elements. Each array element, if any, is a record of the file. The ordering of the records of the file is the
  same as the ordering of the array elements in the array (9.5.3.3) or the array section (9.5.3.4). Every record
  of the file has the same length, which is the length of an array element in the array.
 A record of the internal file becomes defined by writing the record.
   <b>-</b> Iftheinternalfileisanallocatable,deferred-lengthcharacterscalarvariable,itisassignedthecharacters
    written by intrinsic assignment, allocating or reallocating to have length equal to the number of
    characters written if necessary.
   <b>-</b> Otherwise, if the number of characters written in a record is less than the length of the record, the
    remaining portion of the record is filled with blanks; the number of characters to be written shall not
    exceed the length of the record.
 A record shall be read only if the record is defined.
 A record of an internal file can become defined (or undefined) by means other than an output statement.
  For example, the character variable can become defined by a character assignment statement.
 An internal file is always positioned at the beginning of the first record prior to data transfer, except for
  child data transfer statements (12.6.4.8). This record becomes the current record.
 The initial value of a connection mode (12.5.2) is the value that would be implied by an initial OPEN
  statement without the corresponding keyword.
 Reading and writing records shall be accomplished only by sequential access formatted data transfer state-
  ments.
 An internal file shall not be specified as the unit in a CLOSE, INQUIRE, or OPEN statement.
<b>12.5</b> <b>File</b> <b>connection</b>
<b>12.5.1</b> <b>Referring</b> <b>to</b> <b>a</b> <b>file</b>
A unit, specified by an <i>io-unit</i>, provides a means for referring to a file.
R1201 <i>io-unit</i> <b>is</b> <i>file-unit-number</i>
              <b>or</b> *
              <b>or</b> <i>internal-file-variable</i>
R1202 <i>file-unit-number</i> <b>is</b> <i>scalar-int-expr</i>
R1203 <i>internal-file-variable</i> <b>is</b> <i>char-variable</i>
C1201 (R1203) The <i>char-variable</i> shall not be an array section with a vector subscript.
C1202 (R1203) The <i>char-variable</i> shall be default character, ASCII character, or ISO 10646 character.
A unit is either an external unit or an internal unit. An external unit is used to refer to an external file and
is specified by an asterisk or a <i>file-unit-number</i>. The value of <i>file-unit-number</i> shall be nonnegative, the unit
argument of an active defined input/output procedure (12.6.4.8), a NEWUNIT value (12.5.6.13), or equal to
one of the named constants INPUT_UNIT, OUTPUT_UNIT, or ERROR_UNIT of the intrinsic module ISO_-
FORTRAN_ENV (16.10.2). An internal unit is used to refer to an internal file and is specified by an <i>internal-</i>
<i>file-variable</i> or a <i>file-unit-number</i> whose value is equal to the unit argument of an active defined input/output
procedure. The value of a <i>file-unit-number</i> shall identify a valid unit.
On an image, the external unit identified by a particular value of a <i>scalar-int-expr</i> is the same external unit in
all program units.
<b>NOTE</b> <b>1</b>
In the example:
   SUBROUTINE A
     READ (6) X
     ...
   SUBROUTINE B
     N = 6
     REWIND N
the value 6 used in both program units identifies the same external unit.
In a READ statement, an <i>io-unit</i> that is an asterisk identifies an external unit that is preconnected for sequential
formattedinputonimage1intheinitialteamonly(12.6.4.3); itisnotpreconnectedonanyotherimage. Thisunit
is also identified by the value of the named constant INPUT_UNIT of the intrinsic module ISO_FORTRAN_-
ENV (16.10.2.13). This unit is also used by a READ statement without an <i>io-control-spec-list</i>. In a WRITE
statement, an <i>io-unit</i> that is an asterisk identifies an external unit that is preconnected for sequential formatted
output. This unit is also identified by the value of the named constant OUTPUT_UNIT of the intrinsic module
ISO_FORTRAN_ENV (16.10.2.24). This unit is also used by a PRINT statement.
This document identifies a processor-dependent external unit for the purpose of error reporting. This unit shall
be preconnected for sequential formatted output. The processor may define this to be the same as the output
unit identified by an asterisk. This unit is also identified by a unit number defined by the named constant
ERROR_UNIT of the intrinsic module ISO_FORTRAN_ENV.
<b>NOTE</b> <b>2</b>
Even though OUTPUT_UNIT is connected to a separate file on each image, it is expected that the processor
could merge the sequences of records from these files into a single sequence of records that is sent to the physical
device associated with this unit, such as the user's terminal. If ERROR_UNIT is associated with the same
physical device, the sequences of records from files connected to ERROR_UNIT on each of the images could
be merged into the same sequence generated from the OUTPUT_UNIT files. Otherwise, it is expected that
the sequence of records in the files connected to ERROR_UNIT on each image could be merged into a single
sequence of records that is sent to the physical device associated with ERROR_UNIT.
<b>12.5.2</b> <b>Connection</b> <b>modes</b>
A connection for formatted input/output has several changeable modes: these are the blank interpretation mode
(13.8.7), delimiter mode (13.10.4, 13.11.4.2), sign mode (13.8.4), leading zero mode (13.8.5), decimal edit mode
(13.8.9), input/output rounding mode (13.7.2.3.8), pad mode (12.6.4.5.3), and scale factor (13.8.6). A connection
for unformatted input/output has no changeable modes.
Values for the modes of a connection are established when the connection is initiated. If the connection is initiated
by an OPEN statement, the values are as specified, either explicitly or implicitly, by the OPEN statement. If the
connection is initiated other than by an OPEN statement (that is, if the file is an internal file or preconnected file)
the values established are those that would be implied by an initial OPEN statement without the corresponding
keywords.
The scale factor cannot be explicitly specified in an OPEN statement; it is implicitly 0.
The modes of a connection to an external file can be changed by a subsequent OPEN statement that modifies
the connection.
The modes of a connection can be temporarily changed by a corresponding keyword specifier in a data transfer
statement or by an edit descriptor. Keyword specifiers take effect at the beginning of execution of the data
transfer statement. Edit descriptors take effect when they are encountered in format processing. When a data
transfer statement terminates, the values for the modes are reset to the values in effect immediately before the
data transfer statement was executed.
<b>12.5.3</b> <b>Unit</b> <b>existence</b>
At any given time, there is a processor-dependent set of external units that exist for an image.
All input/output statements are permitted to refer to units that exist. The CLOSE, INQUIRE, and WAIT
statements are also permitted to refer to units that do not exist. No other input/output statement shall refer to
a unit that does not exist.
<b>12.5.4</b> <b>Connection</b> <b>of</b> <b>a</b> <b>file</b> <b>to</b> <b>a</b> <b>unit</b>
An external unit has a property of being connected or not connected. If connected, it refers to an external file. An
external unit may become connected by preconnection or by the execution of an OPEN statement. The property
of connection is symmetric; the unit is connected to a file if and only if the file is connected to the unit.
Every input/output statement except an OPEN, CLOSE, INQUIRE, or WAIT statement shall refer to a unit
that is connected to a file and thereby make use of or affect that file.
A file may be connected and not exist (12.3.2).
<b>NOTE</b> <b>1</b>
An example is a preconnected external file that has not yet been written.
A unit shall not be connected to more than one file at the same time. However, means are provided to change
the status of an external unit and to connect a unit to a different file. It is processor dependent whether a file
can be connected to more than one unit at the same time.
This document defines means of portable interoperation with C. C streams are described in ISO/IEC 9899:2018,
7.21.2. Whether a unit can be connected to a file that is also connected to a C stream is processor dependent.
If a unit is connected to a file that is also connected to a C stream, the results of performing input/output
operations on such a file are processor dependent. It is processor dependent whether the files connected to
the units INPUT_UNIT, OUTPUT_UNIT, and ERROR_UNIT correspond to the predefined C text streams
standard input, standard output, and standard error. If a main program or procedure defined by means of Fortran
and a main program or procedure defined by means other than Fortran perform input/output operations on the
same external file, the results are processor dependent. A main program or procedure defined by means of Fortran
and a main program or procedure defined by means other than Fortran can perform input/output operations on
different external files without interference.
If input/output operations are performed on more than one unit while they are connected to the same external
file, the results are processor dependent.
After an external unit has been disconnected by the execution of a CLOSE statement, it may be connected again
within the same program to the same file or to a different file. After an external file has been disconnected by
the execution of a CLOSE statement, it may be connected again within the same program to the same unit or
to a different unit.
<b>NOTE</b> <b>2</b>
The only means of referencing a file that has been disconnected is by the appearance of its name in an OPEN
or INQUIRE statement. There might be no means of reconnecting an unnamed file once it is disconnected.
An internal unit is always connected to the internal file designated by the variable that identifies the unit.
<b>NOTE</b> <b>3</b>
For more explanatory information on file connection properties, see C.8.4.
<b>12.5.5</b> <b>Preconnection</b>
Preconnectionmeansthattheunitisconnectedtoafileatthebeginningofexecutionoftheprogramandtherefore
it may be specified in input/output statements without the prior execution of an OPEN statement.
<b>12.5.6</b> <b>OPEN</b> <b>statement</b>
<b>12.5.6.1</b> <b>General</b>
An OPEN statement initiates or modifies the connection between an external file and a specified unit. The OPEN
statement can be used to connect an existing file to a unit, create a file that is preconnected, create a file and
connect it to a unit, or change certain modes of a connection between a file and a unit.
An external unit may be connected by an OPEN statement in the main program or any subprogram.
If the file to be connected to the unit does not exist but is the same as the file to which the unit is preconnected,
the modes specified by an OPEN statement become a part of the connection.
If the file to be connected to the unit is not the same as the file to which the unit is connected, the effect is as
if a CLOSE statement without a STATUS= specifier had been executed for the unit immediately prior to the
execution of an OPEN statement.
If a unit is connected to a file that exists, execution of an OPEN statement for that unit is permitted. If the
FILE= specifier is not included in such an OPEN statement, the file to be connected to the unit is the same as
the file to which the unit is already connected.
If the file to be connected to the unit is the same as the file to which the unit is connected, a new connection is not
established and values for any changeable modes (12.5.2) specified come into effect for the established connection;
the current file position is unaffected. Before any effect on changeable modes, a wait operation is performed for
any pending asynchronous data transfer operations for the specified unit. If the POSITION= specifier appears
in such an OPEN statement, the value specified shall not disagree with the current position of the file. If the
STATUS= specifier is included in such an OPEN statement, it shall be specified with the value OLD. Other than
ERR=, IOSTAT=, and IOMSG=, and the changeable modes, the values of all other specifiers in such an OPEN
statement shall not differ from those in effect for the established connection.
A STATUS= specifier with a value of OLD is always allowed when the file to be connected to the unit is the same
as the file to which the unit is connected. In this case, if the status of the file was SCRATCH before execution of
the OPEN statement, the file will still be deleted when the unit is closed, and the file is still considered to have
a status of SCRATCH.
<b>12.5.6.2</b> <b>Syntax</b> <b>of</b> <b>the</b> <b>OPEN</b> <b>statement</b>
R1204 <i>open-stmt</i> <b>is</b> OPEN ( <i>connect-spec-list</i> )
R1205 <i>connect-spec</i> <b>is</b> [ UNIT = ] <i>file-unit-number</i>
              <b>or</b> ACCESS = <i>scalar-default-char-expr</i>
              <b>or</b> ACTION = <i>scalar-default-char-expr</i>
              <b>or</b> ASYNCHRONOUS = <i>scalar-default-char-expr</i>
              <b>or</b> BLANK = <i>scalar-default-char-expr</i>
              <b>or</b> DECIMAL = <i>scalar-default-char-expr</i>
              <b>or</b> DELIM = <i>scalar-default-char-expr</i>
              <b>or</b> ENCODING = <i>scalar-default-char-expr</i>
              <b>or</b> ERR = <i>label</i>
              <b>or</b> FILE = <i>file-name-expr</i>
              <b>or</b> FORM = <i>scalar-default-char-expr</i>
              <b>or</b> IOMSG = <i>iomsg-variable</i>
              <b>or</b> IOSTAT = <i>stat-variable</i>
              <b>or</b> LEADING_ZERO = <i>scalar-default-char-expr</i>
              <b>or</b> NEWUNIT = <i>scalar-int-variable</i>
              <b>or</b> PAD = <i>scalar-default-char-expr</i>
              <b>or</b> POSITION = <i>scalar-default-char-expr</i>
              <b>or</b> RECL = <i>scalar-int-expr</i>
              <b>or</b> ROUND = <i>scalar-default-char-expr</i>
              <b>or</b> SIGN = <i>scalar-default-char-expr</i>
              <b>or</b> STATUS = <i>scalar-default-char-expr</i>
R1206 <i>file-name-expr</i> <b>is</b> <i>scalar-default-char-expr</i>
R1207 <i>iomsg-variable</i> <b>is</b> <i>scalar-default-char-variable</i>
C1203 No specifier shall appear more than once in a given <i>connect-spec-list</i>.
C1204 (R1204) If the NEWUNIT= specifier does not appear, a <i>file-unit-number</i> shall be specified; if the optional
   characters UNIT= are omitted, the <i>file-unit-number</i> shall be the first item in the <i>connect-spec-list</i>.
C1205 (R1204) If a NEWUNIT= specifier appears, a <i>file-unit-number</i> shall not appear.
C1206 (R1204) The <i>label</i> used in the ERR= specifier shall be the statement label of a branch target statement
   that appears in the same inclusive scope as the OPEN statement.
Some specifiers that require a <i>scalar-default-char-expr</i> have a limited list of character values. These values are
listed for each such specifier. Any trailing blanks are ignored. The value specified is without regard to case. Some
specifiers have a default value if the specifier is omitted.
The IOSTAT=, ERR=, and IOMSG= specifiers are described in 12.11.
<b>NOTE</b> <b>1</b>
An example of an OPEN statement is:
   OPEN (10, FILE = 'employee.names', ACTION = 'READ', PAD = 'YES')
<b>NOTE</b> <b>2</b>
For more explanatory information on the OPEN statement, see C.8.3.
<b>12.5.6.3</b> <b>ACCESS=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>OPEN</b> <b>statement</b>
The <i>scalar-default-char-expr</i> shall evaluate to SEQUENTIAL, DIRECT, or STREAM. The ACCESS= specifier
specifies the access method for the connection of the file as being sequential, direct, or stream. If this specifier is
omitted, the default value is SEQUENTIAL. For an existing file, the specified access method shall be included in
the set of allowed access methods for the file. For a new file, the processor creates the file with a set of allowed
access methods that includes the specified method.
<b>12.5.6.4</b> <b>ACTION=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>OPEN</b> <b>statement</b>
The <i>scalar-default-char-expr</i> shall evaluate to READ, WRITE, or READWRITE. READ specifies that the
WRITE, PRINT, and ENDFILE statements shall not refer to this connection. WRITE specifies that READ
statements shall not refer to this connection. READWRITE permits any input/output statements to refer to this
connection. If this specifier is omitted, the default value is processor dependent. If READWRITE is included in
the set of allowable actions for a file, both READ and WRITE also shall be included in the set of allowed actions
for that file. For an existing file, the specified action shall be included in the set of allowed actions for the file.
For a new file, the processor creates the file with a set of allowed actions that includes the specified action.
<b>12.5.6.5</b> <b>ASYNCHRONOUS=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>OPEN</b> <b>statement</b>
The <i>scalar-default-char-expr</i> shall evaluate to YES or NO. If YES is specified, asynchronous input/output on
the unit is allowed. If NO is specified, asynchronous input/output on the unit is not allowed. If this specifier is
omitted, the default value is NO.
<b>12.5.6.6</b> <b>BLANK=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>OPEN</b> <b>statement</b>
The <i>scalar-default-char-expr</i> shall evaluate to NULL or ZERO. The BLANK= specifier is permitted only for a
connection for formatted input/output. It specifies the blank interpretation mode (13.8.7, 12.6.2.6) for input for
this connection. This mode has no effect on output. It is a changeable mode (12.5.2). If this specifier is omitted
in an OPEN statement that initiates a connection, the default value is NULL.
<b>12.5.6.7</b> <b>DECIMAL=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>OPEN</b> <b>statement</b>
The <i>scalar-default-char-expr</i> shall evaluate to COMMA or POINT. The DECIMAL= specifier is permitted only
for a connection for formatted input/output. It specifies the decimal edit mode (13.6, 13.8.9, 12.6.2.7) for this
connection. It is a changeable mode (12.5.2). If this specifier is omitted in an OPEN statement that initiates a
connection, the default value is POINT.
<b>12.5.6.8</b> <b>DELIM=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>OPEN</b> <b>statement</b>
The <i>scalar-default-char-expr</i> shall evaluate to APOSTROPHE, QUOTE, or NONE. The DELIM= specifier is
permitted only for a connection for formatted input/output. It specifies the delimiter mode (12.6.2.8) for list-
directed (13.10.4) and namelist (13.11.4.2) output for the connection. This mode has no effect on input. It is
a changeable mode (12.5.2). If this specifier is omitted in an OPEN statement that initiates a connection, the
default value is NONE.
<b>12.5.6.9</b> <b>ENCODING=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>OPEN</b> <b>statement</b>
The <i>scalar-default-char-expr</i> shall evaluate to UTF-8 or DEFAULT. The ENCODING= specifier is permitted
only for a connection for formatted input/output. The value UTF-8 specifies that the encoding form of the file
is UTF-8 as specified in ISO/IEC 10646. Such a file is called a Unicode file, and all characters therein are of ISO
10646 character kind. The value UTF-8 shall not be specified if the processor does not support the ISO 10646
character kind. The value DEFAULT specifies that the encoding form of the file is processor dependent. If this
specifier is omitted in an OPEN statement that initiates a connection, the default value is DEFAULT.
<b>12.5.6.10</b> <b>FILE=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>OPEN</b> <b>statement</b>
The value of the FILE= specifier is the name of the file to be connected to the specified unit. Any trailing blanks
are ignored. The <i>file-name-expr</i> shall be a name that is allowed by the processor. The interpretation of case is
processor dependent.
This specifier shall appear if the STATUS= specifier has the value NEW or REPLACE. This specifier shall not
appear if the STATUS= specifier has the value SCRATCH. If the STATUS= specifier has the value OLD, this
specifier shall appear unless the unit is connected and the file connected to the unit exists. If this specifier
is omitted and the unit is not connected to a file, the STATUS= specifier shall be specified with a value of
SCRATCH; in this case, the connection is made to a processor-dependent file.
<b>12.5.6.11</b> <b>FORM=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>OPEN</b> <b>statement</b>
The <i>scalar-default-char-expr</i> shall evaluate to FORMATTED or UNFORMATTED. The FORM= specifier de-
termines whether the file is being connected for formatted or unformatted input/output. If this specifier is
omitted, the default value is UNFORMATTED if the file is being connected for direct access or stream access,
and the default value is FORMATTED if the file is being connected for sequential access. For an existing file,
the specified form shall be included in the set of allowed forms for the file. For a new file, the processor creates
the file with a set of allowed forms that includes the specified form.
<b>12.5.6.12</b> <b>LEADING_ZERO=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>OPEN</b> <b>statement</b>
The <i>scalar-default-char-expr</i> shall evaluate to one of PRINT, SUPPRESS, or PROCESSOR_DEFINED. The
LEADING_ZERO= specifier is permitted only for a connection for formatted input/output. It specifies the
leading zero mode (13.8.5, 12.6.2.10) for this connection. It is a changeable mode (12.5.2). If this specifier is
omitted in an OPEN statement that initiates a connection, the default value is PROCESSOR_DEFINED.
<b>12.5.6.13</b> <b>NEWUNIT=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>OPEN</b> <b>statement</b>
IfthisspecifierappearsinanOPENstatement, eithertheFILE=specifiershallappear, ortheSTATUS=specifier
shall appear with a value of SCRATCH.
The variable is defined with a processor determined NEWUNIT value if no error condition occurs during the
execution of the OPEN statement. If an error condition occurs, the processor shall not change the value of the
variable.
A NEWUNIT value is a negative number, and shall not be equal to -1, any of the named constants ER-
ROR_UNIT, INPUT_UNIT, or OUTPUT_UNIT from the intrinsic module ISO_FORTRAN_ENV (16.10.2),
any value used by the processor for the unit argument to a defined input/output procedure, nor any previous
NEWUNIT value that identifies a file that is connected. The unit identified by a NEWUNIT value shall not be
preconnected.
<b>12.5.6.14</b> <b>PAD=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>OPEN</b> <b>statement</b>
The <i>scalar-default-char-expr</i> shall evaluate to YES or NO. The PAD= specifier is permitted only for a connection
for formatted input/output. It specifies the pad mode (12.6.4.5.3, 12.6.2.11) for input for this connection. This
mode has no effect on output. It is a changeable mode (12.5.2). If this specifier is omitted in an OPEN statement
that initiates a connection, the default value is YES.
<b>12.5.6.15</b> <b>POSITION=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>OPEN</b> <b>statement</b>
The <i>scalar-default-char-expr</i> shall evaluate to ASIS, REWIND, or APPEND. The connection shall be for sequen-
tial or stream access. A new file is positioned at its initial point. REWIND positions an existing file at its initial
point. APPEND positions an existing file such that the endfile record is the next record, if it has one. If an
existing file does not have an endfile record, APPEND positions the file at its terminal point. ASIS leaves the
position unchanged if the file exists and already is connected. If the file exists but is not connected, the position
resulting from ASIS is processor dependent. If this specifier is omitted, the default value is ASIS.
<b>12.5.6.16</b> <b>RECL=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>OPEN</b> <b>statement</b>
The value of the RECL= specifier shall be positive. It specifies the length of each record in a file being connected
for direct access, or specifies the maximum length of a record in a file being connected for sequential access. This
specifier shall not appear when a file is being connected for stream access. This specifier shall appear when a
file is being connected for direct access. If this specifier is omitted when a file is being connected for sequential
access, the default value is processor dependent. If the file is being connected for formatted input/output, the
length is the number of characters for all records that contain only characters of default kind. When a record
contains any nondefault characters, the effect of the RECL= specifier is processor dependent. If the file is being
connected for unformatted input/output, the length is measured in file storage units. For an existing file, the
value of the RECL= specifier shall be included in the set of allowed record lengths for the file. For a new file, the
processor creates the file with a set of allowed record lengths that includes the specified value.
<b>12.5.6.17</b> <b>ROUND=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>OPEN</b> <b>statement</b>
The <i>scalar-default-char-expr</i> shall evaluate to one of UP, DOWN, ZERO, NEAREST, COMPATIBLE, or PRO-
CESSOR_DEFINED. The ROUND= specifier is permitted only for a connection for formatted input/output.
It specifies the input/output rounding mode (13.7.2.3.8, 12.6.2.14) for this connection. It is a changeable mode
(12.5.2). If this specifier is omitted in an OPEN statement that initiates a connection, the input/output rounding
mode is processor dependent; it shall be one of the above modes.
<b>NOTE</b>
A processor is free to select any input/output rounding mode for the default mode. The mode might correspond
to UP, DOWN, ZERO, NEAREST, or COMPATIBLE; or it might be a completely different input/output
rounding mode.
<b>12.5.6.18</b> <b>SIGN=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>OPEN</b> <b>statement</b>
The <i>scalar-default-char-expr</i> shall evaluate to one of PLUS, SUPPRESS, or PROCESSOR_DEFINED. The
SIGN= specifier is permitted only for a connection for formatted input/output. It specifies the sign mode
(13.8.4, 12.6.2.15) for this connection. It is a changeable mode (12.5.2). If this specifier is omitted in an OPEN
statement that initiates a connection, the default value is PROCESSOR_DEFINED.
<b>12.5.6.19</b> <b>STATUS=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>OPEN</b> <b>statement</b>
The <i>scalar-default-char-expr</i> shall evaluate to OLD, NEW, SCRATCH, REPLACE, or UNKNOWN. If OLD is
specified, the file shall exist. If NEW is specified, the file shall not exist.
Successful execution of an OPEN statement with NEW specified creates the file and changes the status to OLD.
If REPLACE is specified and the file does not already exist, the file is created and the status is changed to OLD.
If REPLACE is specified and the file does exist, the file is deleted, a new file is created with the same name, and
the status is changed to OLD. If SCRATCH is specified, the file is created and connected to the specified unit
for use by the program but is deleted at the execution of a CLOSE statement referring to the same unit or at
the normal termination of the program.
If UNKNOWN is specified, the status is processor dependent. If this specifier is omitted, the default value is
UNKNOWN.
<b>NOTE</b>
SCRATCH cannot be specified if the FILE= specifier appears (12.5.6.10).
<b>12.5.7</b> <b>CLOSE</b> <b>statement</b>
<b>12.5.7.1</b> <b>General</b>
The CLOSE statement is used to terminate the connection of a specified unit to an external file.
Execution of a CLOSE statement for a unit may occur in any program unit of a program and need not occur in
the same program unit as the execution of an OPEN statement referring to that unit.
ExecutionofaCLOSEstatementperformsawaitoperationforanypendingasynchronousdatatransferoperations
for the specified unit.
Execution of a CLOSE statement specifying a unit that does not exist, exists but is connected to a file that does
not exist, or has no file connected to it, is permitted and affects no file or unit.
After a unit has been disconnected by execution of a CLOSE statement, it may be connected again within the
same program, either to the same file or to a different file. After a named file has been disconnected by execution
of a CLOSE statement, it may be connected again within the same program, either to the same unit or to a
different unit, provided that the file still exists.
During the completion step (5.3.7) of normal termination, all units that are connected are closed. Each unit is
closed with status KEEP unless the file status prior to termination of execution was SCRATCH, in which case
the unit is closed with status DELETE.
<b>NOTE</b>
The effect is as though a CLOSE statement without a STATUS= specifier were executed on each connected
unit.
<b>12.5.7.2</b> <b>Syntax</b>
R1208 <i>close-stmt</i> <b>is</b> CLOSE ( <i>close-spec-list</i> )
R1209 <i>close-spec</i> <b>is</b> [ UNIT = ] <i>file-unit-number</i>
              <b>or</b> IOSTAT = <i>stat-variable</i>
              <b>or</b> IOMSG = <i>iomsg-variable</i>
              <b>or</b> ERR = <i>label</i>
              <b>or</b> STATUS = <i>scalar-default-char-expr</i>
C1207 No specifier shall appear more than once in a given <i>close-spec-list</i>.
C1208 A <i>file-unit-number</i> shall be specified in a <i>close-spec-list</i>; if the optional characters UNIT= are omitted,
   the <i>file-unit-number</i> shall be the first item in the <i>close-spec-list</i>.
C1209 (R1209) The <i>label</i> used in the ERR= specifier shall be the statement label of a branch target statement
   that appears in the same inclusive scope as the CLOSE statement.
The <i>scalar-default-char-expr</i> has a limited list of character values. Any trailing blanks are ignored. The value
specified is without regard to case.
The IOSTAT=, ERR=, and IOMSG= specifiers are described in 12.11.
<b>NOTE</b>
An example of a CLOSE statement is:
   CLOSE (10, STATUS = 'KEEP')
<b>12.5.7.3</b> <b>STATUS=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>CLOSE</b> <b>statement</b>
The <i>scalar-default-char-expr</i> shall evaluate to KEEP or DELETE. The STATUS= specifier determines the dis-
position of the file that is connected to the specified unit. KEEP shall not be specified for a file whose status prior
to execution of a CLOSE statement is SCRATCH. If KEEP is specified for a file that exists, the file continues
to exist after the execution of a CLOSE statement. If KEEP is specified for a file that does not exist, the file
will not exist after the execution of a CLOSE statement. If DELETE is specified, the file will not exist after the
execution of a CLOSE statement. If this specifier is omitted, the default value is KEEP, unless the file status
prior to execution of the CLOSE statement is SCRATCH, in which case the default value is DELETE.
<b>12.6</b> <b>Data</b> <b>transfer</b> <b>statements</b>
<b>12.6.1</b> <b>Form</b> <b>of</b> <b>input</b> <b>and</b> <b>output</b> <b>statements</b>
The READ statement is the data transfer input statement. The WRITE statement and the PRINT statement
are the data transfer output statements.
R1210 <i>read-stmt</i> <b>is</b> READ ( <i>io-control-spec-list</i> ) [ <i>input-item-list</i> ]
              <b>or</b> READ <i>format</i> [ , <i>input-item-list</i> ]
R1211 <i>write-stmt</i> <b>is</b> WRITE ( <i>io-control-spec-list</i> ) [ <i>output-item-list</i> ]
R1212 <i>print-stmt</i> <b>is</b> PRINT <i>format</i> [ , <i>output-item-list</i> ]
<b>NOTE</b> <b>1</b>
Examples of data transfer statements are:
     READ (6, *) SIZE
     READ 10, A, B
     WRITE (6, 10) A, S, J
     PRINT 10, A, S, J
   10 FORMAT (2E16.3, I5)
<b>NOTE</b> <b>2</b>
A statement of the form
   READ (<i>name</i>)
where <i>name</i> is the name of a default character variable is a formatted input statement. The format expression
"(<i>name</i>)" is the <i>format</i>. The statement cannot be an input statement that specifies an internal file because of
C1221.
<b>12.6.2</b> <b>Control</b> <b>information</b> <b>list</b>
<b>12.6.2.1</b> <b>Syntax</b>
A control information list is an <i>io-control-spec-list</i>. It governs data transfer.
R1213 <i>io-control-spec</i> <b>is</b> [ UNIT = ] <i>io-unit</i>
              <b>or</b> [ FMT = ] <i>format</i>
              <b>or</b> [ NML = ] <i>namelist-group-name</i>
              <b>or</b> ADVANCE = <i>scalar-default-char-expr</i>
              <b>or</b> ASYNCHRONOUS = <i>scalar-default-char-constant-expr</i>
              <b>or</b> BLANK = <i>scalar-default-char-expr</i>
              <b>or</b> DECIMAL = <i>scalar-default-char-expr</i>
              <b>or</b> DELIM = <i>scalar-default-char-expr</i>
              <b>or</b> END = <i>label</i>
              <b>or</b> EOR = <i>label</i>
              <b>or</b> ERR = <i>label</i>
              <b>or</b> ID = <i>id-variable</i>
              <b>or</b> IOMSG = <i>iomsg-variable</i>
              <b>or</b> IOSTAT = <i>stat-variable</i>
              <b>or</b> LEADING_ZERO = <i>scalar-default-char-expr</i>
              <b>or</b> PAD = <i>scalar-default-char-expr</i>
              <b>or</b> POS = <i>scalar-int-expr</i>
              <b>or</b> REC = <i>scalar-int-expr</i>
              <b>or</b> ROUND = <i>scalar-default-char-expr</i>
              <b>or</b> SIGN = <i>scalar-default-char-expr</i>
              <b>or</b> SIZE = <i>scalar-int-variable</i>
R1214 <i>id-variable</i> <b>is</b> <i>scalar-int-variable</i>
C1210 No specifier shall appear more than once in a given <i>io-control-spec-list</i>.
C1211 An <i>io-unit</i> shall be specified in an <i>io-control-spec-list</i>; if the optional characters UNIT= are omitted, the
   <i>io-unit</i> shall be the first item in the <i>io-control-spec-list</i>.
C1212 (R1213) A DELIM=, LEADING_ZERO=, or SIGN= specifier shall not appear in a <i>read-stmt</i>.
C1213 (R1213) A BLANK=, PAD=, END=, EOR=, or SIZE= specifier shall not appear in a <i>write-stmt</i>.
C1214 A SIZE= specifier shall not appear in a list-directed or namelist input statement.
C1215 (R1213) The <i>label</i> in the ERR=, EOR=, or END= specifier shall be the statement label of a branch
   target statement that appears in the same inclusive scope as the data transfer statement.
C1216 (R1213) A <i>namelist-group-name</i> shall be the name of a namelist group.
C1217 (R1213) A <i>namelist-group-name</i> shall not appear if a REC= specifier, <i>format</i>, <i>input-item-list</i>, or an
   <i>output-item-list</i> appears in the data transfer statement.
C1218 (R1213) If <i>format</i> appears without a preceding FMT=, it shall be the second item in the <i>io-control-spec-</i>
   <i>list</i> and the first item shall be <i>io-unit</i>.
C1219 (R1213) If <i>namelist-group-name</i> appears without a preceding NML=, it shall be the second item in the
   <i>io-control-spec-list</i> and the first item shall be <i>io-unit</i>.
C1220 (R1213) If <i>io-unit</i> is not a <i>file-unit-number</i>, the <i>io-control-spec-list</i> shall not contain a REC= specifier or
   a POS= specifier.
C1221 (R1213) If <i>io-unit</i> is an <i>internal-file-variable</i>, the <i>io-control-spec-list</i> shall contain a <i>format</i> or a <i>namelist-</i>
   <i>group-name</i>.
C1222 (R1213) If the REC= specifier appears, an END= specifier shall not appear, and the <i>format</i>, if any, shall
   not be an asterisk.
C1223 (R1213) An ADVANCE= specifier shall appear only in a formatted sequential or stream data transfer
   statement with explicit format specification (13.2) whose <i>io-control-spec-list</i> does not contain an <i>internal-</i>
   <i>file-variable</i> as the <i>io-unit</i>.
C1224 (R1213) If an EOR= specifier appears, an ADVANCE= specifier also shall appear.
C1225 (R1213) The <i>scalar-default-char-constant-expr</i> in an ASYNCHRONOUS= specifier shall have the value
   YES or NO.
C1226 (R1213) An ASYNCHRONOUS= specifier with a value YES shall not appear unless <i>io-unit</i> is a <i>file-</i>
   <i>unit-number</i>.
C1227 (R1213) If an ID= specifier appears, an ASYNCHRONOUS= specifier with the value YES shall also
   appear.
C1228 (R1213) If a POS= specifier appears, the <i>io-control-spec-list</i> shall not contain a REC= specifier.
C1229 (R1213) If a DECIMAL=, BLANK=, LEADING_ZERO=, PAD=, SIGN=, or ROUND= specifier ap-
   pears, a <i>format</i> or <i>namelist-group-name</i> shall also appear.
C1230 (R1213) If a DELIM= specifier appears, either <i>format</i> shall be an asterisk or <i>namelist-group-name</i> shall
   appear.
C1231 (R1214) The <i>scalar-int-variable</i> shall have a decimal exponent range no smaller than that of default
   integer.
If an EOR= specifier appears, an ADVANCE= specifier with the value NO shall also appear.
If the data transfer statement contains a <i>format</i> or <i>namelist-group-name</i>, the statement is a formatted in-
put/output statement; otherwise, it is an unformatted input/output statement.
The ADVANCE=, ASYNCHRONOUS=, DECIMAL=, BLANK=, DELIM=, LEADING_ZERO=, PAD=,
SIGN=, and ROUND= specifiers have a limited list of character values. Any trailing blanks are ignored. The
values specified are without regard to case.
The IOSTAT=, ERR=, EOR=, END=, and IOMSG= specifiers are described in 12.11.
<b>NOTE</b>
An example of a READ statement is:
   READ (IOSTAT = IOS, UNIT = 6, FMT = '(10F8.2)') A, B
<b>12.6.2.2</b> <b>Format</b> <b>specification</b> <b>in</b> <b>a</b> <b>data</b> <b>transfer</b> <b>statement</b>
The <i>format</i> specifier supplies a format specification or specifies list-directed formatting for a formatted in-
put/output statement.
R1215 <i>format</i> <b>is</b> <i>default-char-expr</i>
              <b>or</b> <i>label</i>
              <b>or</b> *
C1232 (R1215) The <i>label</i> shall be the label of a FORMAT statement that appears in the same inclusive scope
   as the statement containing the FMT= specifier.
The <i>default-char-expr</i> shall evaluate to a valid format specification (13.2.1 and 13.2.2).
If <i>default-char-expr</i> is an array, it is treated as if all of the elements of the array were specified in array element
order and were concatenated.
If <i>format</i> is *, the statement is a list-directed input/output statement.
<b>NOTE</b>
An example in which the format is a character expression is:
   READ (6, FMT = "(" // CHAR_FMT // ")" ) X, Y, Z
where CHAR_FMT is a default character variable.
<b>12.6.2.3</b> <b>NML=</b> <b>specifier</b> <b>in</b> <b>a</b> <b>data</b> <b>transfer</b> <b>statement</b>
The NML= specifier supplies the <i>namelist-group-name</i> (8.9). This name identifies a particular collection of data
objects on which transfer is to be performed.
If a <i>namelist-group-name</i> appears, the statement is a namelist input/output statement.
<b>12.6.2.4</b> <b>ADVANCE=</b> <b>specifier</b> <b>in</b> <b>a</b> <b>data</b> <b>transfer</b> <b>statement</b>
The <i>scalar-default-char-expr</i> shall evaluate to YES or NO. The ADVANCE= specifier determines whether advan-
cing input/output occurs for a nonchild data transfer statement. If YES is specified for a nonchild data transfer
statement, advancing input/output occurs. If NO is specified, nonadvancing input/output occurs (12.3.4.2). If
this specifier is omitted from a nonchild data transfer statement that allows the specifier, the default value is
YES. A formatted child data transfer statement is a nonadvancing input/output statement, and any ADVANCE=
specifier is ignored.
<b>12.6.2.5</b> <b>ASYNCHRONOUS=</b> <b>specifier</b> <b>in</b> <b>a</b> <b>data</b> <b>transfer</b> <b>statement</b>
The ASYNCHRONOUS= specifier determines whether this data transfer statement is synchronous or asynchron-
ous. If YES is specified, the statement and the input/output operation are asynchronous. If NO is specified or if
the specifier is omitted, the statement and the input/output operation are synchronous.
Asynchronous input/output is permitted only for external files opened with an ASYNCHRONOUS= specifier
with the value YES in the OPEN statement.
<b>NOTE</b> <b>1</b>
Both synchronous and asynchronous input/output are allowed for files opened with an ASYNCHRONOUS=
specifier of YES. For other files, only synchronous input/output is allowed; this includes files opened with an
ASYNCHRONOUS= specifier of NO, files opened without an ASYNCHRONOUS= specifier, preconnected files
accessed without an OPEN statement, and internal files.
The ASYNCHRONOUS= specifier value in a data transfer statement is a constant expression because it effects
compiler optimizations and, therefore, needs to be known at compile time.
The processor may perform an asynchronous data transfer operation asynchronously, but it is not required to do
so. For each external file, records and file storage units read or written by asynchronous data transfer statements
are read, written, and processed in the same order as they would have been if the data transfer statements were
synchronous. The documentation of the Fortran processor should describe when input/output will be performed
asynchronously.
If a variable is used in an asynchronous data transfer statement as
 an item in an input/output list,
 a group object in a namelist, or
 a SIZE= specifier,
the base object of the <i>data-ref</i> is implicitly given the ASYNCHRONOUS attribute in the scoping unit of the data
transfer statement. This attribute may be confirmed by explicit declaration.
When an asynchronous input/output statement is executed, the set of storage units specified by the item list or
NML= specifier, plus the storage units specified by the SIZE= specifier, is defined to be the pending input/output
storage sequence for the data transfer operation.
<b>NOTE</b> <b>2</b>
A pending input/output storage sequence is not necessarily a contiguous set of storage units.
A pending input/output storage sequence affector is a variable of which any part is associated with a storage unit
in a pending input/output storage sequence.
<b>12.6.2.6</b> <b>BLANK=</b> <b>specifier</b> <b>in</b> <b>a</b> <b>data</b> <b>transfer</b> <b>statement</b>
The <i>scalar-default-char-expr</i> shall evaluate to NULL or ZERO. The BLANK= specifier temporarily changes
(12.5.2) the blank interpretation mode (13.8.7, 12.5.6.6) for the connection. If the specifier is omitted, the mode
is not changed.
<b>12.6.2.7</b> <b>DECIMAL=</b> <b>specifier</b> <b>in</b> <b>a</b> <b>data</b> <b>transfer</b> <b>statement</b>
The<i>scalar-default-char-expr</i> shallevaluatetoCOMMAorPOINT.TheDECIMAL=specifiertemporarilychanges
(12.5.2) the decimal edit mode (13.6, 13.8.9, 12.5.6.7) for the connection. If the specifier is omitted, the mode is
not changed.
<b>12.6.2.8</b> <b>DELIM=</b> <b>specifier</b> <b>in</b> <b>a</b> <b>data</b> <b>transfer</b> <b>statement</b>
The <i>scalar-default-char-expr</i> shall evaluate to APOSTROPHE, QUOTE, or NONE. The DELIM= specifier tem-
porarily changes (12.5.2) the delimiter mode (13.10.4, 13.11.4.2, 12.5.6.8) for the connection. If the specifier is
omitted, the mode is not changed.
<b>12.6.2.9</b> <b>ID=</b> <b>specifier</b> <b>in</b> <b>a</b> <b>data</b> <b>transfer</b> <b>statement</b>
Successful execution of an asynchronous data transfer statement containing an ID= specifier causes the variable
specified in the ID= specifier to become defined with a processor determined value. If this value is zero, the
data transfer operation has been completed. A nonzero value is referred to as the identifier of the data transfer
operation. This identifier is different from the identifier of any other pending data transfer operation for this unit.
It can be used in a subsequent WAIT or INQUIRE statement to identify the particular data transfer operation.
If an error condition occurs during the execution of a data transfer statement containing an ID= specifier, the
variable specified in the ID= specifier becomes undefined.
A child data transfer statement shall not specify the ID= specifier.
<b>12.6.2.10</b> <b>LEADING_ZERO=</b> <b>specifier</b> <b>in</b> <b>a</b> <b>data</b> <b>transfer</b> <b>statement</b>
The <i>scalar-default-char-expr</i> shall evaluate to PRINT, SUPPRESS, or PROCESSOR_DEFINED. The LEAD-
ING_ZERO= specifier temporarily changes (12.5.2) the leading zero mode (13.8.5, 12.5.6.12) for the connection.
If the specifier is omitted, the mode is not changed.
<b>12.6.2.11</b> <b>PAD=</b> <b>specifier</b> <b>in</b> <b>a</b> <b>data</b> <b>transfer</b> <b>statement</b>
The <i>scalar-default-char-expr</i> shall evaluate to YES or NO. The PAD= specifier temporarily changes (12.5.2) the
pad mode (12.6.4.5.3, 12.5.6.14) for the connection. If the specifier is omitted, the mode is not changed.
<b>12.6.2.12</b> <b>POS=</b> <b>specifier</b> <b>in</b> <b>a</b> <b>data</b> <b>transfer</b> <b>statement</b>
The POS= specifier specifies the file position in file storage units. This specifier shall not appear in a data transfer
statement unless the statement specifies a unit connected for stream access. A child data transfer statement shall
not specify this specifier.
A processor may prohibit the use of POS= with particular files that do not have the properties necessary to
support random positioning. A processor may also prohibit positioning a particular file to any position prior to
its current file position if the file does not have the properties necessary to support such positioning.
<b>NOTE</b>
A unit that is connected to a device or data stream might not be positionable.
If the file is connected for formatted stream access, the file position specified by POS= shall be equal to either 1
(the beginning of the file) or a value previously returned by a POS= specifier in an INQUIRE statement for the
file.
<b>12.6.2.13</b> <b>REC=</b> <b>specifier</b> <b>in</b> <b>a</b> <b>data</b> <b>transfer</b> <b>statement</b>
The REC= specifier specifies the number of the record that is to be read or written. This specifier shall appear
only in a data transfer statement that specifies a unit connected for direct access; it shall not appear in a child
data transfer statement. If the <i>io-control-spec-list</i> contains a REC= specifier, the statement is a direct access
data transfer statement. A child data transfer statement is a direct access data transfer statement if the parent
is a direct access data transfer statement. Any other data transfer statement is a sequential access data transfer
statement or a stream access data transfer statement, depending on whether the file connection is for sequential
access or stream access.
<b>12.6.2.14</b> <b>ROUND=</b> <b>specifier</b> <b>in</b> <b>a</b> <b>data</b> <b>transfer</b> <b>statement</b>
The <i>scalar-default-char-expr</i> shall evaluate to one of UP, DOWN, ZERO, NEAREST, COMPATIBLE or PRO-
CESSOR_DEFINED. The ROUND= specifier temporarily changes (12.5.2) the input/output rounding mode
(13.7.2.3.8, 12.5.6.17) for the connection. If the specifier is omitted, the mode is not changed.
<b>12.6.2.15</b> <b>SIGN=</b> <b>specifier</b> <b>in</b> <b>a</b> <b>data</b> <b>transfer</b> <b>statement</b>
The <i>scalar-default-char-expr</i> shall evaluate to PLUS, SUPPRESS, or PROCESSOR_DEFINED. The SIGN=
specifier temporarily changes (12.5.2) the sign mode (13.8.4, 12.5.6.18) for the connection. If the specifier is
omitted, the mode is not changed.
<b>12.6.2.16</b> <b>SIZE=</b> <b>specifier</b> <b>in</b> <b>a</b> <b>data</b> <b>transfer</b> <b>statement</b>
The SIZE= specifier in an input statement causes the variable specified to become defined with the count of
the characters transferred from the file by data edit descriptors during the input operation. Blanks inserted as
padding are not counted.
For a synchronous input statement, this definition occurs when execution of the statement completes. For an
asynchronous input statement, this definition occurs when the corresponding wait operation is performed.
<b>12.6.3</b> <b>Data</b> <b>transfer</b> <b>input/output</b> <b>list</b>
An input/output list specifies the entities whose values are transferred by a data transfer statement.
R1216 <i>input-item</i> <b>is</b> <i>variable</i>
              <b>or</b> <i>io-implied-do</i>
R1217 <i>output-item</i> <b>is</b> <i>expr</i>
              <b>or</b> <i>io-implied-do</i>
R1218 <i>io-implied-do</i> <b>is</b> ( <i>io-implied-do-object-list</i> , <i>io-implied-do-control</i> )
R1219 <i>io-implied-do-object</i> <b>is</b> <i>input-item</i>
              <b>or</b> <i>output-item</i>
R1220 <i>io-implied-do-control</i> <b>is</b> <i>do-variable</i> = <i>scalar-int-expr</i> ,
                  <i>scalar-int-expr</i> [ , <i>scalar-int-expr</i> ]
C1233 (R1216) A variable that is an <i>input-item</i> shall not be a whole assumed-size array.
C1234 (R1219) In an <i>input-item-list</i>, an <i>io-implied-do-object</i> shall be an <i>input-item</i>. In an <i>output-item-list</i>, an
   <i>io-implied-do-object</i> shall be an <i>output-item</i>.
C1235 (R1217) An expression that is an <i>output-item</i> shall not have a value that is a procedure pointer.
An <i>input-item</i> shall not appear as, nor be associated with, the <i>do-variable</i> of any <i>io-implied-do</i> that contains the
<i>input-item</i>.
<b>NOTE</b> <b>1</b>
A constant, an expression involving operators or function references that does not have a pointer result, or an
expression enclosed in parentheses cannot appear as an input list item.
If an input item is a pointer, it shall be associated with a definable target and data are transferred from the file to
the associated target. If an output item is a pointer, it shall be associated with a target and data are transferred
from the target to the file.
<b>NOTE</b> <b>2</b>
Data transfers always involve the movement of values between a file and internal storage. A pointer as such
cannot be read or written. Therefore, a pointer shall not appear as an item in an input/output list unless it is
associated with a target that can receive a value (input) or can deliver a value (output).
If an input item or an output item is allocatable, it shall be allocated.
A list item shall not be polymorphic unless it is processed by a defined input/output procedure (12.6.4.8).
A list item that is of an enumeration type shall not appear in a list-directed data transfer statement. In a
formatted data transfer statement, it shall correspond to an I, B, O, or Z edit descriptor.
The <i>do-variable</i> of an <i>io-implied-do</i> that is in another <i>io-implied-do</i> shall not appear as, nor be associated with,
the <i>do-variable</i> of the containing <i>io-implied-do</i>.
The following rules describing whether to expand an input/output list item are re-applied to each expanded list
item until none of the rules apply.
 If an array appears as an input/output list item, it is treated as if the elements, if any, were specified in
  array element order (9.5.3.3). However, no element of that array shall affect the value of any expression in
  the <i>input-item</i>, nor shall any element appear more than once in a given <i>input-item</i>.
<b>NOTE</b> <b>3</b>
For example:
   INTEGER A (100), J (100)
    ...
   READ *, A (A) ! Not allowed
   READ *, A (LBOUND (A, 1) : UBOUND (A, 1)) ! Allowed
   READ *, A (J) ! Allowed if no two elements
                         ! of J have the same value
   A(1) = 1; A(10) = 10
   READ *, A (A (1) : A (10)) ! Not allowed
 If an effective item of derived type in an unformatted input/output statement is not processed by a defined
  input/output procedure (12.6.4.8), and if any subobject of that effective item would be processed by a
  defined input/output procedure, the effective item is treated as if all of the components of the object were
  specified in component order (7.5.4.7); those components shall be accessible in the scoping unit containing
  the data transfer statement and shall not be pointers or allocatable.
 An effective item of derived type in an unformatted input/output statement is treated as a single value
  in a processor-dependent form unless the effective item or a subobject thereof is processed by a defined
  input/output procedure (12.6.4.8).
<b>NOTE</b> <b>4</b>
The appearance of a derived-type object as an input/output list item in an unformatted input/output statement
is not equivalent to the list of its components.
Unformatted input/output involving derived-type list items forms the single exception to the rule that the
appearance of an aggregate list item (such as an array) is equivalent to the appearance of its expanded list of
component parts. This exception permits the processor greater latitude in improving efficiency or in matching
the processor-dependent sequence of values for a derived-type object to similar sequences for aggregate ob-
jects used by means other than Fortran. However, formatted input/output of all list items and unformatted
input/output of list items other than those of derived types adhere to the above rule.
 If an effective item of derived type in a formatted input/output statement is not processed by a defined
  input/output procedure, that effective item is treated as if all of the components of the effective item
  were specified in component order; those components shall be accessible in the scoping unit containing the
  input/output statement and shall not be pointers or allocatable.
 If a derived-type list item is not processed by a defined input/output procedure and is not treated as a list
  of its individual components, all the subcomponents of that list item shall be accessible in the scoping unit
  containing the data transfer statement and shall not be pointers or allocatable.
 For an <i>io-implied-do</i>, the loop initialization and execution are the same as for a DO construct (11.1.7.4).
<b>NOTE</b> <b>5</b>
An example of an output list with an implied DO is:
   WRITE (LP, FMT = '(10F8.2)') (LOG (A (I)), I = 1, N + 9, K), G
The scalar objects resulting when a data transfer statement's list items are expanded according to the rules in
this subclause for handling array and derived-type list items are called effective items. Zero-sized arrays and
<i>io-implied-do</i>s with an iteration count of zero do not contribute to the list of effective items. A scalar character
item of zero length is an effective item.
<b>NOTE</b> <b>6</b>
In a formatted input/output statement, edit descriptors are associated with effective items, which are always
scalar. The rules in 12.6.3 determine the set of effective items corresponding to each actual list item in the
statement. These rules might have to be applied repetitively until all of the effective items are scalar items.
An input/output list shall not contain an effective item of nondefault character kind if the data transfer statement
specifies an internal file of default character kind. An input/output list shall not contain an effective item that is
nondefault character except for ISO 10646 or ASCII character if the data transfer statement specifies an internal
file of ISO 10646 character kind. An input/output list shall not contain an effective item of type character of any
kind other than ASCII if the data transfer statement specifies an ASCII character internal file.
An output list shall not contain an effective item that is a <i>boz-literal-constant</i>.
<b>12.6.4</b> <b>Execution</b> <b>of</b> <b>a</b> <b>data</b> <b>transfer</b> <b>input/output</b> <b>statement</b>
<b>12.6.4.1</b> <b>Data</b> <b>transfer</b> <b>sequence</b> <b>of</b> <b>operations</b>
Execution of a WRITE or PRINT statement for a unit connected to a file that does not exist creates the file
unless an error condition occurs.
Theeffectofexecutingasynchronousdatatransferstatementshallbeasifthefollowingoperationswereperformed
in the order specified.
  (1) Determine the direction of data transfer (12.6.4.2).
  (2) Identify the unit (12.6.4.3).
  (3) Perform a wait operation for all pending input/output operations for the unit. If an error, end-of-file,
     or end-of-record condition occurs during any of the wait operations, steps 4 through 8 are skipped.
  (4) Establish the format if one is specified.
  (5) If the statement is not a child data transfer statement (12.6.4.8),
     (a) position the file prior to data transfer (12.3.4.3), and
     (b) for formatted data transfer, set the left tab limit (13.8.1.2).
  (6) Transfer data between the file and the entities specified by the input/output list (if any) or namelist,
     possibly mediated by defined input/output procedures (12.6.4.8).
  (7) Determine whether an error, end-of-file, or end-of-record condition has occurred.
  (8) Position the file after data transfer (12.3.4.4) unless the statement is a child data transfer statement
     (12.6.4.8).
  (9) Cause any variable specified in a SIZE= specifier to become defined.
  (10) If an error, end-of-file, or end-of-record condition occurred, processing continues as specified in 12.11;
     otherwise, any variable specified in an IOSTAT= specifier is assigned the value zero.
The effect of executing an asynchronous data transfer statement shall be as if the following operations were
performed in the order specified.
  (1) Determine the direction of data transfer (12.6.4.2).
  (2) Identify the unit (12.6.4.3).
  (3) Optionally, perform wait operations for one or more pending input/output operations for the unit.
     If an error, end-of-file, or end-of-record condition occurs during any of the wait operations, steps 4
     through 9 are skipped.
  (4) Establish the format if one is specified.
  (5) Position the file prior to data transfer (12.3.4.3) and, for formatted data transfer, set the left tab
     limit (13.8.1.2).
  (6) Establish the set of storage units identified by the input/output list. For an input statement, this
     might require some or all of the data in the file to be read if an input variable is used as a <i>scalar-</i>
     <i>int-expr</i> in an <i>io-implied-do-control</i> in the input/output list, as a <i>subscript</i>, <i>substring-range</i>, <i>stride</i>,
     or is otherwise referenced.
  (7) Initiate an asynchronous data transfer between the file and the entities specified by the input/output
     list (if any) or namelist. The asynchronous data transfer may complete (and an error, end-of-file, or
     end-of-record condition may occur) during the execution of this data transfer statement or during a
     later wait operation.
  (8) Determine whether an error, end-of-file, or end-of-record condition has occurred. The conditions
     may occur during the execution of this data transfer statement or during the corresponding wait
     operation, but not both.
  (9) Position the file as if the data transfer had finished (12.3.4.4).
  (10) Cause any variable specified in a SIZE= specifier to become undefined.
  (11) If an error, end-of-file, or end-of-record condition occurred, processing continues as specified in 12.11;
     otherwise, any variable specified in an IOSTAT= specifier is assigned the value zero.
For an asynchronous data transfer statement, the data transfers may occur during execution of the statement,
during execution of the corresponding wait operation, or anywhere between. The data transfer operation is
considered to be pending until a corresponding wait operation is performed.
For asynchronous output, a pending input/output storage sequence affector (12.6.2.5) shall not be redefined,
become undefined, or have its pointer association status changed.
Forasynchronousinput, apendinginput/outputstoragesequenceaffectorshallnotbereferenced, becomedefined,
become undefined, become associated with a dummy argument that has the VALUE attribute, or have its pointer
association status changed.
Error, end-of-file, and end-of-record conditions in an asynchronous data transfer operation may occur during
execution of either the data transfer statement or the corresponding wait operation. If an ID= specifier does not
appear in the initiating data transfer statement, the conditions may occur during the execution of any subsequent
datatransferorwaitoperationforthesameunit. Whenaconditionoccursforapreviouslyexecutedasynchronous
data transfer statement, a wait operationis performed for all pending data transfer operations on that unit. When
a condition occurs during a subsequent statement, any actions specified by IOSTAT=, IOMSG=, ERR=, END=,
and EOR= specifiers for that statement are taken.
If execution of the program is terminated during execution of an output statement, the contents of the file become
undefined.
<b>NOTE</b>
Because end-of-file and error conditions for asynchronous data transfer statements without an ID= specifier
can be reported by the processor during the execution of a subsequent data transfer statement, it might be
impossible for the user to determine which data transfer statement caused the condition. Reliably detecting
which input statement caused an end-of-file condition requires that all asynchronous input statements for the
unit include an ID= specifier.
<b>12.6.4.2</b> <b>Direction</b> <b>of</b> <b>data</b> <b>transfer</b>
Execution of a READ statement causes values to be transferred from a file to the entities specified by the input
list, if any, or specified within the file itself for namelist input. Execution of a WRITE or PRINT statement
causes values to be transferred to a file from the entities specified by the output list and format specification, if
any, or by the <i>namelist-group-name</i> for namelist output.
<b>12.6.4.3</b> <b>Identifying</b> <b>a</b> <b>unit</b>
A data transfer statement that contains an input/output control list includes a UNIT= specifier that identifies
an external or internal unit. A READ statement that does not contain an input/output control list specifies a
particular processor-dependent unit, which is the same as the unit identified by * in a READ statement that
contains an input/output control list (12.5.1) and is the same as the unit identified by the value of the named
constant INPUT_UNIT of the intrinsic module ISO_FORTRAN_ENV (16.10.2.13). The PRINT statement
specifies some other processor-dependent unit, which is the same as the unit identified by * in a WRITE statement
and is the same as the unit identified by the value of the named constant OUTPUT_UNIT of the intrinsic module
ISO_FORTRAN_ENV (16.10.2.24). Thus, each data transfer statement identifies an external or internal unit.
The unit identified by a data transfer statement shall be connected to a file when execution of the statement
begins.
<b>NOTE</b>
The unit could be preconnected.
<b>12.6.4.4</b> <b>Establishing</b> <b>a</b> <b>format</b>
If the input/output control list contains * as a format, list-directed formatting is established. If <i>namelist-group-</i>
<i>name</i> appears, namelist formatting is established. If no <i>format</i> or <i>namelist-group-name</i> is specified, unformatted
data transfer is established. Otherwise, the format specified by <i>format</i> is established.
For output to an internal file, a format specification that is in the file or is associated with the file shall not be
specified.
An input list item, or an entity associated with it, shall not contain any portion of an established format spe-
cification.
<b>12.6.4.5</b> <b>Data</b> <b>transfer</b>
<b>12.6.4.5.1</b> <b>General</b>
Data are transferred between the file and the entities specified by the input/output list or namelist. The list items
are processed in the order of the input/output list for all data transfer statements except namelist data transfer
statements. The list items for a namelist input statement are processed in the order of the entities specified
within the input records. The list items for a namelist output statement are processed in the order in which the
variables are specified in the <i>namelist-group-object-list</i>. Effective items are derived from the input/output list
items as described in 12.6.3.
All values needed to determine which entities are specified by an input/output list item are determined at the
beginning of the processing of that item.
All values are transmitted to or from the entities specified by a list item prior to the processing of any succeeding
list item for all data transfer statements.
<b>NOTE</b>
In the example
   READ (N) N, X (N)
the old value of N identifies the unit, but the new value of N is the subscript of X.
All values following the <i>name</i>= part of the namelist entity (13.11) within the input records are transmitted to
the matching entity specified in the <i>namelist-group-object-list</i> prior to processing any succeeding entity within
the input record for namelist input statements. If an entity is specified more than once within the input record
during a namelist input statement, the last occurrence of the entity specifies the value or values to be used for
that entity.
If the input/output item is a pointer, data are transferred between the file and the associated target.
If an internal file has been specified, an input/output list item shall not be in the file or associated with the file.
During the execution of an output statement that specifies an internal file, no part of that internal file shall be
referenced, defined, or become undefined as the result of evaluating any output list item.
During the execution of an input statement that specifies an internal file, no part of that internal file shall be
defined or become undefined as the result of transferring a value to any input list item.
A DO variable becomes defined and its iteration count established at the beginning of processing of the <i>io-implied-</i>
<i>do-object-list</i> an <i>io-implied-do</i>.
On output, every entity whose value is to be transferred shall be defined.
<b>12.6.4.5.2</b> <b>Unformatted</b> <b>data</b> <b>transfer</b>
If the file is not connected for unformatted input/output, unformatted data transfer is prohibited.
During unformatted data transfer, data are transferred without editing between the file and the entities specified
by the input/output list. If the file is connected for sequential or direct access, exactly one record is read or
written.
A value in the file is stored in a contiguous sequence of file storage units, beginning with the file storage unit
immediately following the current file position.
After each value is transferred, the current file position is moved to a point immediately after the last file storage
unit of the value.
On input from a file connected for sequential or direct access, the number of file storage units required by the
input list shall be less than or equal to the number of file storage units in the record.
On input, if the file storage units transferred do not contain a value with the same type and type parameters as
the input list entity, then the resulting value of the entity is processor dependent except in the following cases.
 A complex entity may correspond to two real values with the same kind type parameter as the complex
  entity.
 Adefaultcharacterlistentityoflength<i>n</i>maycorrespondto<i>n</i>defaultcharactersstoredinthefile, regardless
  of the length parameters of the entities that were written to these storage units of the file. If the file is
  connected for stream input, the characters may have been written by formatted stream output.
On output to a file connected for unformatted direct access, the output list shall not specify more values than
can fit into the record. If the file is connected for direct access and the values specified by the output list do not
fill the record, the remainder of the record is undefined.
If the file is connected for unformatted sequential access, the record is created with a length sufficient to hold
the values from the output list. This length shall be one of the set of allowed record lengths for the file and
shall not exceed the value specified in the RECL= specifier, if any, of the OPEN statement that established the
connection.
<b>12.6.4.5.3</b> <b>Formatted</b> <b>data</b> <b>transfer</b>
If the file is not connected for formatted input/output, formatted data transfer is prohibited.
During formatted data transfer, data are transferred with editing between the file and the entities specified by
the input/output list or by the <i>namelist-group-name</i>. Format control is initiated and editing is performed as
described in Clause 13.
The current record and possibly additional records are read or written.
During advancing input when the pad mode has the value NO, the input list and format specification shall not
require more characters from the record than the record contains.
During advancing input when the pad mode has the value YES, blank characters are supplied by the processor
if the input list and format specification require more characters from the record than the record contains.
During nonadvancing input when the pad mode has the value NO, an end-of-record condition (12.11) occurs if
the input list and format specification require more characters from the record than the record contains, and the
recordiscomplete(12.3.3.4). Iftherecordisincomplete, anend-of-fileconditionoccursinsteadofanend-of-record
condition.
During nonadvancing input when the pad mode has the value YES, blank characters are supplied by the processor
if an effective item and its corresponding data edit descriptors require more characters from the record than the
record contains. If the record is incomplete, an end-of-file condition occurs; otherwise, an end-of-record condition
occurs.
If the file is connected for direct access, the record number is increased by one as each succeeding record is read
or written.
On output, if the file is connected for direct access or is an internal file and the characters specified by the output
list and format do not fill a record, blank characters are added to fill the record.
On output, the output list and format specification shall not specify more characters for a record than have been
specified by a RECL= specifier in the OPEN statement or the record length of an internal file.
<b>12.6.4.6</b> <b>List-directed</b> <b>formatting</b>
If list-directed formatting has been established, editing is performed as described in 13.10.
<b>12.6.4.7</b> <b>Namelist</b> <b>formatting</b>
If namelist formatting has been established, editing is performed as described in 13.11.
Every allocatable <i>namelist-group-object</i> in the namelist group shall be allocated and every <i>namelist-group-object</i>
that is a pointer shall be associated with a target. If a <i>namelist-group-object</i> is polymorphic or has an ultimate
component that is allocatable or a pointer, that object shall be processed by a defined input/output procedure
(12.6.4.8).
<b>12.6.4.8</b> <b>Defined</b> <b>input/output</b>
<b>12.6.4.8.1</b> <b>General</b>
Defined input/output allows a program to override the default handling of derived-type objects and values in
data transfer statements described in 12.6.3.
A defined input/output procedure is a procedure accessible by a <i>defined-io-generic-spec</i> (15.4.3.2). A particular
defined input/output procedure is selected as described in 12.6.4.8.4.
<b>12.6.4.8.2</b> <b>Defined</b> <b>input/output</b> <b>procedures</b>
For a particular derived type and a particular set of kind type parameter values, there are four possible sets of
characteristics for defined input/output procedures; one each for formatted input, formatted output, unformatted
input, and unformatted output. The program need not supply all four procedures. The procedures are specified
to be used for derived-type input/output by interface blocks (15.4.3.2) or by generic bindings (7.5.5), with a
<i>defined-io-generic-spec</i> (R1509). The <i>defined-io-generic-spec</i>s for these procedures are READ (FORMATTED),
READ (UNFORMATTED), WRITE (FORMATTED), and WRITE (UNFORMATTED), for formatted input,
unformatted input, formatted output, and unformatted output respectively.
In the four interfaces, which specify the characteristics of defined input/output procedures, the following syntax
term is used:
R1221 <i>dtv-type-spec</i> <b>is</b> TYPE( <i>derived-type-spec</i> )
              <b>or</b> CLASS( <i>derived-type-spec</i> )
C1236 (R1221) If <i>derived-type-spec</i> specifies an extensible type, the CLASS keyword shall be used; otherwise,
   the TYPE keyword shall be used.
C1237 (R1221) All length type parameters of <i>derived-type-spec</i> shall be assumed.
If the <i>defined-io-generic-spec</i> is READ (FORMATTED), the characteristics shall be the same as those specified
by the following interface:
   SUBROUTINE my_read_routine_formatted (dtv, &
                      unit, &
                      iotype, v_list, &
                      iostat, iomsg)
    ! the derived-type variable
    <i>dtv-type-spec</i>, INTENT(INOUT) :: dtv
    INTEGER, INTENT(IN) :: unit ! unit number
    ! the edit descriptor string
    CHARACTER (LEN=*), INTENT(IN) :: iotype
    INTEGER, INTENT(IN) :: v_list(:)
    INTEGER, INTENT(OUT) :: iostat
    CHARACTER (LEN=*), INTENT(INOUT) :: iomsg
   END
Ifthe<i>defined-io-generic-spec</i> isREAD(UNFORMATTED),thecharacteristicsshallbethesameasthosespecified
by the following interface:
   SUBROUTINE my_read_routine_unformatted (dtv, &
                       unit, &
                       iostat, iomsg)
    ! the derived-type variable
    <i>dtv-type-spec</i>, INTENT(INOUT) :: dtv
    INTEGER, INTENT(IN) :: unit
    INTEGER, INTENT(OUT) :: iostat
    CHARACTER (LEN=*), INTENT(INOUT) :: iomsg
   END
If the <i>defined-io-generic-spec</i> is WRITE (FORMATTED), the characteristics shall be the same as those specified
by the following interface:
   SUBROUTINE my_write_routine_formatted (dtv, &
                       unit, &
                       iotype, v_list, &
                       iostat, iomsg)
    ! the derived-type value/variable
    <i>dtv-type-spec</i>, INTENT(IN) :: dtv
    INTEGER, INTENT(IN) :: unit
    ! the edit descriptor string
    CHARACTER (LEN=*), INTENT(IN) :: iotype
    INTEGER, INTENT(IN) :: v_list(:)
    INTEGER, INTENT(OUT) :: iostat
    CHARACTER (LEN=*), INTENT(INOUT) :: iomsg
   END
If the <i>defined-io-generic-spec</i> is WRITE (UNFORMATTED), the characteristics shall be the same as those
specified by the following interface:
   SUBROUTINE my_write_routine_unformatted (dtv, &
                       unit, &
                       iostat, iomsg)
    ! the derived-type value/variable
    <i>dtv-type-spec</i>, INTENT(IN) :: dtv
    INTEGER, INTENT(IN) :: unit
    INTEGER, INTENT(OUT) :: iostat
    CHARACTER (LEN=*), INTENT(INOUT) :: iomsg
   END
The actual specific procedure names (the my_..._routine_... procedure names above) are not significant. In
the discussion here and elsewhere, the dummy arguments in these interfaces are referred to by the names given
above; the names are, however, arbitrary.
<b>12.6.4.8.3</b> <b>Executing</b> <b>defined</b> <b>input/output</b> <b>data</b> <b>transfers</b>
If a defined input/output procedure is selected for an effective item as specified in 12.6.4.8.4, the processor shall
call the selected defined input/output procedure for that effective item. The defined input/output procedure
controls the actual data transfer operations for the effective item.
A data transfer statement that includes a derived-type list item and that causes a defined input/output procedure
to be invoked is called a parent data transfer statement. A data transfer statement that is executed while a parent
datatransferstatementisbeingprocessedandthatspecifiestheunitpassedintoadefinedinput/outputprocedure
is called a child data transfer statement. As a child data transfer statement and its corresponding parent data
transfer statement use the same file connection (12.5), the connection modes at the beginning of execution of the
child data transfer statement are those in effect in the parent data transfer statement at the moment when the
defined input/output procedure was invoked.
<b>NOTE</b> <b>1</b>
A defined input/output procedure will usually contain child data transfer statements that read values from or
write values to the current record or at the current file position. The effect of executing the defined input/output
procedure is similar to that of substituting the list items from any child data transfer statements into the parent
data transfer statement's list items, along with similar substitutions in the format specification.
<b>NOTE</b> <b>2</b>
A particular execution of a READ, WRITE or PRINT statement can be both a parent and a child data
transfer statement. A defined input/output procedure can indirectly call itself or another defined input/output
procedure by executing a child data transfer statement containing a list item of derived type, where a matching
interface is accessible for that derived type. If a defined input/output procedure calls itself indirectly in this
manner, it cannot be declared NON_RECURSIVE.
A child data transfer statement is processed differently from a nonchild data transfer statement in the following
ways.
 Executing a child data transfer statement does not position the file prior to data transfer.
 An unformatted child data transfer statement does not position the file after data transfer is complete.
 Any ADVANCE= specifier in a child input/output statement is ignored.
When a defined input/output procedure is invoked, the processor shall pass a unit argument that has a value as
follows.
 If the parent data transfer statement uses a <i>file-unit-number</i>, the value of the unit argument shall be that
  of the <i>file-unit-number</i>.
 If the parent data transfer statement is a WRITE statement with an asterisk unit or a PRINT statement,
  the unit argument shall have the same value as the named constant OUTPUT_UNIT of the intrinsic
  module ISO_FORTRAN_ENV (16.10.2).
 If the parent data transfer statement is a READ statement with an asterisk unit or a READ statement
  without an <i>io-control-spec-list</i>, the unit argument shall have the same value as the INPUT_UNIT named
  constant of the intrinsic module ISO_FORTRAN_ENV (16.10.2).
 Otherwise the parent data transfer statement accesses an internal file, in which case the unit argument
  shall have a processor-dependent negative value.
<b>NOTE</b> <b>3</b>
The unit argument passed to a defined input/output procedure will be negative when the parent data transfer
statement specified an internal unit, or specified an external unit that is a NEWUNIT value. When an internal
unit is used with the INQUIRE statement, an error condition will occur, and any variable specified in an IO-
STAT= specifier will be assigned the value IOSTAT_INQUIRE_INTERNAL_UNIT from the intrinsic module
ISO_FORTRAN_ENV (16.10.2).
For formatted data transfer, the processor shall pass an iotype argument that has the value
 "LISTDIRECTED" if the parent data transfer statement specified list directed formatting,
 "NAMELIST" if the parent data transfer statement specified namelist formatting, or
 "DT"concatenatedwiththe<i>char-literal-constant</i>, ifany, oftheDTeditdescriptorintheformatspecification
  of the parent data transfer statement.
If the parent data transfer statement is an input statement, the dtv dummy argument is argument associated
with the effective item that caused the defined input procedure to be invoked, as if the effective item were an
actual argument in this procedure reference (5.4.5).
If the parent data transfer statement is an output statement, the processor shall provide the value of the effective
item in the dtv dummy argument.
If the <i>v-list</i> of the edit descriptor appears in the parent data transfer statement, the processor shall provide the
values from it in the v_list dummy argument, with the same number of elements in the same order as <i>v-list</i>.
If there is no <i>v-list</i> in the edit descriptor or if the data transfer statement specifies list-directed or namelist
formatting, the processor shall provide v_list as a zero-sized array.
<b>NOTE</b> <b>4</b>
The user's procedure might choose to interpret an element of the v_list argument as a field width, but this is
not required. If it does, it would be appropriate to fill an output field with "*"s if the width is too small.
The iostat argument is used to report whether an error, end-of-record, or end-of-file condition (12.11) occurs.
If an error condition occurs, the defined input/output procedure shall assign a positive value to the iostat
argument. Otherwise, if an end-of-file condition occurs, the defined input procedure shall assign the value of the
named constant IOSTAT_END (16.10.2.16) to the iostat argument. Otherwise, if an end-of-record condition
occurs, the defined input procedure shall assign the value of the named constant IOSTAT_EOR (16.10.2.17) to
iostat. Otherwise, the defined input/output procedure shall assign the value zero to the iostat argument.
If the defined input/output procedure returns a nonzero value for the iostat argument, the procedure shall also
return an explanatory message in the iomsg argument. Otherwise, the procedure shall not change the value of
the iomsg argument.
<b>NOTE</b> <b>5</b>
The values of the iostat and iomsg arguments set in a defined input/output procedure need not be passed to
all of the parent data transfer statements.
If the iostat argument of the defined input/output procedure has a nonzero value when that procedure returns,
and the processor therefore terminates execution of the program as described in 12.11, the processor shall make
the value of the iomsg argument available in a processor-dependent manner.
While a parent READ statement is active, an input/output statement shall not read from any external unit other
than the one specified by the unit dummy argument and shall not perform output to any external unit.
While a parent WRITE or PRINT statement is active, an input/output statement shall not perform output to
any external unit other than the one specified by the unit dummy argument and shall not read from any external
unit.
While a parent data transfer statement is active, a data transfer statement that specifies an internal file is
permitted.
OPEN, CLOSE, BACKSPACE, ENDFILE, and REWIND statements shall not be executed while a parent data
transfer statement is active.
A defined input/output procedure may use a format specification with a DT edit descriptor for handling a
component of the derived type that is itself of a derived type. A child data transfer statement that is a list
directed or namelist input/output statement may contain a list item of derived type.
Because a child data transfer statement does not position the file prior to data transfer, the child data transfer
statement starts transferring data from where the file was positioned by the parent data transfer statement's
most recently processed effective item or edit descriptor. This is not necessarily at the beginning of a record.
The edit descriptors T and TL used on unit by a child data transfer statement shall not cause the file to be
positioned before the file position at the time the defined input/output procedure was invoked.
<b>NOTE</b> <b>6</b>
A defined input/output procedure could use INQUIRE to determine the settings of BLANK=, PAD=,
ROUND=, DECIMAL=, and DELIM= for an external unit. The INQUIRE statement provides values as
specified in 12.10.
Neither a parent nor child data transfer statement shall be asynchronous.
A defined input/output procedure, and any procedures invoked therefrom, shall not define, nor cause to become
undefined, any storage unit referenced by any input/output list item, the corresponding format, or any specifier
in any active parent data transfer statement, except through the dtv argument.
<b>NOTE</b> <b>7</b>
A data transfer statement with an ID=, POS=, or REC= specifier cannot be a child data transfer statement
in a standard-conforming program.
<b>NOTE</b> <b>8</b>
A simple example of derived type formatted output follows. The derived type variable chairman has two
components. The type and an associated write formatted procedure are defined in a module so as to be
accessible from wherever they might be needed. It would also be possible to check that iotype indeed has the
value 'DT' and to set iostat and iomsg accordingly.
                <b>J3/23-007r1</b> <b>257</b>
<b>NOTE</b> <b>8</b> <b>(cont.)</b>
   MODULE p
    TYPE :: person
     CHARACTER (LEN=20) :: name
     INTEGER :: age
    CONTAINS
     PROCEDURE,PRIVATE :: pwf
     GENERIC :: WRITE(FORMATTED) => pwf
    END TYPE person
   CONTAINS
    SUBROUTINE pwf (dtv,unit,iotype,vlist,iostat,iomsg)
   ! argument definitions
     CLASS(person), INTENT(IN) :: dtv
     INTEGER, INTENT(IN) :: unit
     CHARACTER (LEN=*), INTENT(IN) :: iotype
     INTEGER, INTENT(IN) :: vlist(:)
     INTEGER, INTENT(OUT) :: iostat
     CHARACTER (LEN=*), INTENT(INOUT) :: iomsg
   ! local variable
     CHARACTER (LEN=9) :: pfmt
   ! vlist(1) and (2) are to be used as the field widths of the two
   ! components of the derived type variable. First set up the format to
   ! be used for output.
     WRITE(pfmt,'(A,I2,A,I2,A)' ) '(A', vlist(1), ',I', vlist(2), ')'
   ! now the basic output statement
     WRITE(unit, FMT=pfmt, IOSTAT=iostat) dtv%name, dtv%age
    END SUBROUTINE pwf
   END MODULE p
   PROGRAM committee
    USE p
    INTEGER id, members
    TYPE (person) :: chairman
     ...
    WRITE(6, FMT="(I2, DT (15,6), I5)" ) id, chairman, members
   ! this writes a record with four fields, with lengths 2, 15, 6, 5
   ! respectively
   END PROGRAM
<b>NOTE</b> <b>9</b>
In the following example, the variables of the derived type node form a linked list, with a single value at each
node. The subroutine pwf is used to write the values in the list, one per line.
   MODULE p
    TYPE node
     INTEGER :: value = 0
<b>258</b> <b>J3/23-007r1</b>
<b>NOTE</b> <b>9</b> <b>(cont.)</b>
     TYPE (NODE), POINTER :: next_node => NULL ( )
    CONTAINS
     PROCEDURE,PRIVATE :: pwf
     GENERIC :: WRITE(FORMATTED) => pwf
    END TYPE node
   CONTAINS
    SUBROUTINE pwf (dtv,unit,iotype,vlist,iostat,iomsg)
   ! Write the chain of values, each on a separate line in I9 format.
     CLASS(node), INTENT(IN) :: dtv
     INTEGER, INTENT(IN) :: unit
     CHARACTER (LEN=*), INTENT(IN) :: iotype
     INTEGER, INTENT(IN) :: vlist(:)
     INTEGER, INTENT(OUT) :: iostat
     CHARACTER (LEN=*), INTENT(INOUT) :: iomsg
     WRITE(unit,'(i9 /)', IOSTAT = iostat) dtv%value
     IF(iostat/=0) RETURN
     IF(ASSOCIATED(dtv%next_node)) WRITE(unit,'(dt)', IOSTAT=iostat) dtv%next_node
    END SUBROUTINE pwf
   END MODULE p
<b>12.6.4.8.4</b> <b>Resolving</b> <b>defined</b> <b>input/output</b> <b>procedure</b> <b>references</b>
A suitable generic interface for defined input/output of an effective item is one that has a <i>defined-io-generic-spec</i>
that is appropriate to the direction (read or write) and form (formatted or unformatted) of the data transfer
as specified in 12.6.4.8.2, and has a specific interface whose dtv argument is compatible with the effective item
according to the rules for argument association in 15.5.2.5.
When an effective item (12.6.3) that is of derived type is encountered during a data transfer, defined input/output
occurs if both of the following conditions are true.
  (1) The circumstances of the input/output are such that defined input/output is permitted; that is,
     either
     (a) the transfer was initiated by a list-directed, namelist, or unformatted input/output statement,
        or
     (b) a format specification is supplied for the data transfer statement, and the edit descriptor
        corresponding to the effective item is a DT edit descriptor.
  (2) A suitable defined input/output procedure is available; that is, either
     (a) the declared type of the effective item has a suitable generic type-bound procedure, or
     (b) a suitable generic interface is accessible.
If (2a) is true, the procedure referenced is determined as for explicit type-bound procedure references (15.5); that
is, the binding with the appropriate specific interface is located in the declared type of the effective item, and the
corresponding binding in the dynamic type of the effective item is selected.
If (2a) is false and (2b) is true, the reference is to the procedure identified by the appropriate specific interface
in the interface block.
<b>12.6.5</b> <b>Termination</b> <b>of</b> <b>data</b> <b>transfer</b> <b>statements</b>
Termination of a data transfer statement occurs when
 format processing encounters a colon or data edit descriptor and there are no remaining elements in the
  <i>input-item-list</i> or <i>output-item-list</i>,
 unformatted or list-directed data transfer exhausts the <i>input-item-list</i> or <i>output-item-list</i>,
 namelist output exhausts the <i>namelist-group-object-list</i>,
 an error condition occurs,
 an end-of-file condition occurs,
 a slash (/) is encountered as a value separator (13.10, 13.11) in the record being read during list-directed
  or namelist input, or
 an end-of-record condition occurs during execution of a nonadvancing input statement (12.11).
<b>12.7</b> <b>Waiting</b> <b>on</b> <b>pending</b> <b>data</b> <b>transfer</b>
<b>12.7.1</b> <b>Wait</b> <b>operation</b>
Execution of an asynchronous data transfer statement in which neither an error, end-of-record, nor end-of-file
condition occurs initiates a pending data transfer operation. There may be multiple pending data transfer
operations for the same or multiple units simultaneously. A pending data transfer operation remains pending
until a corresponding wait operation is performed. A wait operation can be performed by a BACKSPACE,
CLOSE, ENDFILE, FLUSH, INQUIRE, PRINT, READ, REWIND, WAIT, or WRITE statement.
A wait operation completes the processing of a pending data transfer operation. Each wait operation completes
only a single data transfer operation, although a single statement may perform multiple wait operations.
If the actual data transfer is not yet complete, the wait operation first waits for its completion. If the data
transfer operation is an input operation that completed without error, the storage units of the input/output
storage sequence then become defined with the values as described in 12.6.2.16 and 12.6.4.5.
If any error, end-of-file, or end-of-record conditions occur, the applicable actions specified by the IOSTAT=,
IOMSG=, ERR=, END=, and EOR= specifiers of the statement that performs the wait operation are taken.
If an error or end-of-file condition occurs during a wait operation for a unit, the processor performs a wait
operation for all pending data transfer operations for that unit.
<b>NOTE</b>
Error, end-of-file, and end-of-record conditions can be raised either during the data transfer statement that
initiates asynchronous input/output, a subsequent asynchronous data transfer statement for the same unit, or
during the wait operation. If raised during a data transfer statement, they trigger actions according to the
IOSTAT=, ERR=, END=, and EOR= specifiers of that statement; if raised during the wait operation, the
actions are in accordance with the specifiers of the statement that performs the wait operation.
After completion of the wait operation, the data transfer operation and its input/output storage sequence are no
longer considered to be pending.
<b>12.7.2</b> <b>WAIT</b> <b>statement</b>
A WAIT statement performs a wait operation for specified pending asynchronous data transfer operations.
R1222 <i>wait-stmt</i> <b>is</b> WAIT (<i>wait-spec-list</i>)
R1223 <i>wait-spec</i> <b>is</b> [ UNIT = ] <i>file-unit-number</i>
              <b>or</b> END = <i>label</i>
              <b>or</b> EOR = <i>label</i>
              <b>or</b> ERR = <i>label</i>
              <b>or</b> ID = <i>scalar-int-expr</i>
              <b>or</b> IOMSG = <i>iomsg-variable</i>
              <b>or</b> IOSTAT = <i>stat-variable</i>
C1238 No specifier shall appear more than once in a given <i>wait-spec-list</i>.
C1239 A <i>file-unit-number</i> shall be specified in a <i>wait-spec-list</i>; if the optional characters UNIT= are omitted,
   the <i>file-unit-number</i> shall be the first item in the <i>wait-spec-list</i>.
C1240 (R1223) The <i>label</i> in the ERR=, EOR=, or END= specifier shall be the statement label of a branch
   target statement that appears in the same inclusive scope as the WAIT statement.
The IOSTAT=, ERR=, EOR=, END=, and IOMSG= specifiers are described in 12.11.
The value of the expression specified in the ID= specifier shall be zero or the identifier of a pending data transfer
operation for the specified unit. If the ID= specifier appears, a wait operation for the specified data transfer
operation, if any, is performed. If the ID= specifier is omitted, wait operations for all pending data transfers for
the specified unit are performed.
Execution of a WAIT statement specifying a unit that does not exist, has no file connected to it, or is not open
for asynchronous input/output is permitted, provided that the WAIT statement has no ID= specifier; such a
WAIT statement does not cause an error or end-of-file condition to occur.
<b>NOTE</b>
An EOR= specifier has no effect if the pending data transfer operation is not a nonadvancing read. An END=
specifier has no effect if the pending data transfer operation is not a READ.
<b>12.8</b> <b>File</b> <b>positioning</b> <b>statements</b>
<b>12.8.1</b> <b>Syntax</b>
R1224 <i>backspace-stmt</i> <b>is</b> BACKSPACE <i>file-unit-number</i>
              <b>or</b> BACKSPACE ( <i>position-spec-list</i> )
R1225 <i>endfile-stmt</i> <b>is</b> ENDFILE <i>file-unit-number</i>
              <b>or</b> ENDFILE ( <i>position-spec-list</i> )
R1226 <i>rewind-stmt</i> <b>is</b> REWIND <i>file-unit-number</i>
              <b>or</b> REWIND ( <i>position-spec-list</i> )
A unit that is connected for direct access shall not be referred to by a BACKSPACE, ENDFILE, or REWIND
statement. A unit that is connected for unformatted stream access shall not be referred to by a BACKSPACE
statement. A unit that is connected with an ACTION= specifier having the value READ shall not be referred
to by an ENDFILE statement.
R1227 <i>position-spec</i> <b>is</b> [ UNIT = ] <i>file-unit-number</i>
              <b>or</b> IOMSG = <i>iomsg-variable</i>
              <b>or</b> IOSTAT = <i>stat-variable</i>
              <b>or</b> ERR = <i>label</i>
C1241 No specifier shall appear more than once in a given <i>position-spec-list</i>.
C1242 A <i>file-unit-number</i> shall be specified in a <i>position-spec-list</i>; if the optional characters UNIT= are omitted,
   the <i>file-unit-number</i> shall be the first item in the <i>position-spec-list</i>.
C1243 (R1227) The <i>label</i> in the ERR= specifier shall be the statement label of a branch target statement that
   appears in the same inclusive scope as the file positioning statement.
The IOSTAT=, ERR=, and IOMSG= specifiers are described in 12.11.
Execution of a file positioning statement performs a wait operation for all pending asynchronous data transfer
operations for the specified unit.
<b>12.8.2</b> <b>BACKSPACE</b> <b>statement</b>
Execution of a BACKSPACE statement causes the file connected to the specified unit to be positioned before
the current record if there is a current record, or before the preceding record if there is no current record. If the
file is at its initial point, the position of the file is not changed.
<b>NOTE</b> <b>1</b>
If the preceding record is an endfile record, the file is positioned before the endfile record.
If a BACKSPACE statement causes the implicit writing of an endfile record, the file is positioned before the
record that precedes the endfile record.
Backspacing a file that is connected but does not exist is prohibited.
Backspacing over records written using list-directed or namelist formatting is prohibited.
<b>NOTE</b> <b>2</b>
An example of a BACKSPACE statement is:
   BACKSPACE (10, IOSTAT = N)
<b>12.8.3</b> <b>ENDFILE</b> <b>statement</b>
Execution of an ENDFILE statement for a file connected for sequential access writes an endfile record as the next
record of the file. The file is then positioned after the endfile record, which becomes the last record of the file.
If the file can also be connected for direct access, only those records before the endfile record are considered to
have been written. Thus, only those records shall be read during subsequent direct access connections to the file.
After execution of an ENDFILE statement for a file connected for sequential access, a BACKSPACE or REWIND
statement shall be used to reposition the file prior to execution of any data transfer input/output statement or
ENDFILE statement.
Execution of an ENDFILE statement for a file connected for stream access causes the terminal point of the file
to become equal to the current file position. Only file storage units before the current position are considered
to have been written; thus only those file storage units shall be subsequently read. Subsequent stream output
statements may be used to write further data to the file.
Execution of an ENDFILE statement for a file that is connected but does not exist creates the file; if the file is
connected for sequential access, it is created prior to writing the endfile record.
<b>NOTE</b>
An example of an ENDFILE statement is:
   ENDFILE K
<b>12.8.4</b> <b>REWIND</b> <b>statement</b>
Execution of a REWIND statement causes the specified file to be positioned at its initial point.
<b>NOTE</b> <b>1</b>
If the file is already positioned at its initial point, execution of this statement has no effect on the position of
the file.
Execution of a REWIND statement for a file that is connected but does not exist is permitted and has no effect
on any file.
<b>NOTE</b> <b>2</b>
An example of a REWIND statement is:
   REWIND 10
<b>12.9</b> <b>FLUSH</b> <b>statement</b>
R1228 <i>flush-stmt</i> <b>is</b> FLUSH <i>file-unit-number</i>
              <b>or</b> FLUSH ( <i>flush-spec-list</i> )
R1229 <i>flush-spec</i> <b>is</b> [UNIT =] <i>file-unit-number</i>
              <b>or</b> IOSTAT = <i>stat-variable</i>
              <b>or</b> IOMSG = <i>iomsg-variable</i>
              <b>or</b> ERR = <i>label</i>
C1244 No specifier shall appear more than once in a given <i>flush-spec-list</i>.
C1245 A <i>file-unit-number</i> shall be specified in a <i>flush-spec-list</i>; if the optional characters UNIT= are omitted
   from the unit specifier, the <i>file-unit-number</i> shall be the first item in the <i>flush-spec-list</i>.
C1246 (R1229) The <i>label</i> in the ERR= specifier shall be the statement label of a branch target statement that
   appears in the same inclusive scope as the FLUSH statement.
The IOSTAT=, IOMSG= and ERR= specifiers are described in 12.11.
Execution of a FLUSH statement causes data written to an external file to be available to other processes, or
causes data placed in an external file by means other than Fortran to be available to a READ statement. These
actions are processor dependent.
Execution of a FLUSH statement for a file that is connected but does not exist is permitted and has no effect on
any file. A FLUSH statement has no effect on file position.
Execution of a FLUSH statement performs a wait operation for all pending asynchronous data transfer operations
for the specified unit.
<b>NOTE</b> <b>1</b>
Because this document does not specify the mechanism of file storage, the exact meaning of the flush operation
is not precisely defined. It is expected that the flush operation will make all data written to a file available to
other processes or devices, or make data recently added to a file by other processes or devices available to the
program via a subsequent read operation. This is commonly called "flushing input/output buffers".
<b>NOTE</b> <b>2</b>
An example of a FLUSH statement is:
   FLUSH (10, IOSTAT = N)
<b>12.10</b> <b>File</b> <b>inquiry</b> <b>statement</b>
<b>12.10.1</b> <b>Forms</b> <b>of</b> <b>the</b> <b>INQUIRE</b> <b>statement</b>
The INQUIRE statement can be used to inquire about properties of a particular named file, of the connection
to a particular unit, or the number of file storage units required for an output list. There are three forms of the
INQUIRE statement: inquire by file, which uses the FILE= specifier, inquire by unit, which uses the UNIT=
specifier, andinquirebyoutputlist, whichusesonlytheIOLENGTH=specifier. Assignmentstospecifiervariables
are converted, truncated, or padded according to the rules of intrinsic assignment.
For inquiry by unit, the unit specified need not exist or be connected to a file. If it is connected to a file, the
inquiry is being made about the connection and about the file connected.
For inquiry by file, the file specified need not exist or be connected to a unit. If it is connected to a unit, the
inquiry is being made about the connection as well as about the file.
An INQUIRE statement may be executed before, while, or after a file is connected to a unit. All values assigned
by an INQUIRE statement are those that are current at the time the statement is executed.
R1230 <i>inquire-stmt</i> <b>is</b> INQUIRE ( <i>inquire-spec-list</i> )
              <b>or</b> INQUIRE ( IOLENGTH = <i>scalar-int-variable</i> )
                  <i>output-item-list</i>
<b>NOTE</b>
Examples of INQUIRE statements are:
   INQUIRE (IOLENGTH = IOL) A (1:N)
   INQUIRE (UNIT = JOAN, OPENED = LOG_01, NAMED = LOG_02, &
        FORM = CHAR_VAR, IOSTAT = IOS)
<b>12.10.2</b> <b>Inquiry</b> <b>specifiers</b>
<b>12.10.2.1</b> <b>Syntax</b>
Unless constrained, the following inquiry specifiers may be used in either of the inquire by file or inquire by unit
forms of the INQUIRE statement.
R1231 <i>inquire-spec</i> <b>is</b> [ UNIT = ] <i>file-unit-number</i>
              <b>or</b> FILE = <i>file-name-expr</i>
              <b>or</b> ACCESS = <i>scalar-default-char-variable</i>
              <b>or</b> ACTION = <i>scalar-default-char-variable</i>
              <b>or</b> ASYNCHRONOUS = <i>scalar-default-char-variable</i>
              <b>or</b> BLANK = <i>scalar-default-char-variable</i>
              <b>or</b> DECIMAL = <i>scalar-default-char-variable</i>
              <b>or</b> DELIM = <i>scalar-default-char-variable</i>
              <b>or</b> DIRECT = <i>scalar-default-char-variable</i>
              <b>or</b> ENCODING = <i>scalar-default-char-variable</i>
              <b>or</b> ERR = <i>label</i>
              <b>or</b> EXIST = <i>scalar-logical-variable</i>
              <b>or</b> FORM = <i>scalar-default-char-variable</i>
              <b>or</b> FORMATTED = <i>scalar-default-char-variable</i>
              <b>or</b> ID = <i>scalar-int-expr</i>
              <b>or</b> IOMSG = <i>iomsg-variable</i>
              <b>or</b> IOSTAT = <i>stat-variable</i>
              <b>or</b> LEADING_ZERO = <i>scalar-default-char-variable</i>
              <b>or</b> NAME = <i>scalar-default-char-variable</i>
              <b>or</b> NAMED = <i>scalar-logical-variable</i>
              <b>or</b> NEXTREC = <i>scalar-int-variable</i>
              <b>or</b> NUMBER = <i>scalar-int-variable</i>
              <b>or</b> OPENED = <i>scalar-logical-variable</i>
              <b>or</b> PAD = <i>scalar-default-char-variable</i>
              <b>or</b> PENDING = <i>scalar-logical-variable</i>
              <b>or</b> POS = <i>scalar-int-variable</i>
              <b>or</b> POSITION = <i>scalar-default-char-variable</i>
              <b>or</b> READ = <i>scalar-default-char-variable</i>
              <b>or</b> READWRITE = <i>scalar-default-char-variable</i>
              <b>or</b> RECL = <i>scalar-int-variable</i>
              <b>or</b> ROUND = <i>scalar-default-char-variable</i>
              <b>or</b> SEQUENTIAL = <i>scalar-default-char-variable</i>
              <b>or</b> SIGN = <i>scalar-default-char-variable</i>
              <b>or</b> SIZE = <i>scalar-int-variable</i>
              <b>or</b> STREAM = <i>scalar-default-char-variable</i>
              <b>or</b> UNFORMATTED = <i>scalar-default-char-variable</i>
              <b>or</b> WRITE = <i>scalar-default-char-variable</i>
C1247 No specifier shall appear more than once in a given <i>inquire-spec-list</i>.
C1248 An <i>inquire-spec-list</i> shall contain one FILE= specifier or one <i>file-unit-number</i>, but not both.
C1249 In the inquire by unit form of the INQUIRE statement, if the optional characters UNIT= are omitted,
   the <i>file-unit-number</i> shall be the first item in the <i>inquire-spec-list</i>.
C1250 If an ID= specifier appears in an <i>inquire-spec-list</i>, a PENDING= specifier shall also appear.
C1251 (R1229) The <i>label</i> in the ERR= specifier shall be the statement label of a branch target statement that
   appears in the same inclusive scope as the INQUIRE statement.
If <i>file-unit-number</i> identifies an internal unit (12.6.4.8.2), an error condition occurs.
When a returned value of a specifier other than the NAME= specifier is of type character, the value returned is
in upper case.
If an error condition occurs during execution of an INQUIRE statement, all of the inquiry specifier variables
become undefined, except for variables in the IOSTAT= and IOMSG= specifiers (if any).
The IOSTAT=, ERR=, and IOMSG= specifiers are described in 12.11.
<b>12.10.2.2</b> <b>FILE=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>INQUIRE</b> <b>statement</b>
The value of the <i>file-name-expr</i> in the FILE= specifier specifies the name of the file being inquired about. The
named file need not exist or be connected to a unit. The value of the <i>file-name-expr</i> shall be of a form acceptable
to the processor as a file name. Any trailing blanks are ignored. The interpretation of case is processor dependent.
<b>12.10.2.3</b> <b>ACCESS=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>INQUIRE</b> <b>statement</b>
The <i>scalar-default-char-variable</i> in the ACCESS= specifier is assigned the value SEQUENTIAL if the connection
is for sequential access, DIRECT if the connection is for direct access, or STREAM if the connection is for stream
access. If there is no connection, it is assigned the value UNDEFINED.
<b>12.10.2.4</b> <b>ACTION=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>INQUIRE</b> <b>statement</b>
The <i>scalar-default-char-variable</i> in the ACTION= specifier is assigned the value READ if the connection is for
input only, WRITE if the connection is for output only, and READWRITE if the connection is for both input
and output. If there is no connection, the <i>scalar-default-char-variable</i> is assigned the value UNDEFINED.
<b>12.10.2.5</b> <b>ASYNCHRONOUS=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>INQUIRE</b> <b>statement</b>
The <i>scalar-default-char-variable</i> in the ASYNCHRONOUS= specifier is assigned the value YES if the connection
allows asynchronous input/output; it is assigned the value NO if the connection does not allow asynchronous
input/output. If there is no connection, the <i>scalar-default-char-variable</i> is assigned the value UNDEFINED.
<b>12.10.2.6</b> <b>BLANK=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>INQUIRE</b> <b>statement</b>
The <i>scalar-default-char-variable</i> in the BLANK= specifier is assigned the value ZERO or NULL, corresponding
to the blank interpretation mode in effect for a connection for formatted input/output. If there is no connection,
or if the connection is not for formatted input/output, the <i>scalar-default-char-variable</i> is assigned the value
UNDEFINED.
<b>12.10.2.7</b> <b>DECIMAL=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>INQUIRE</b> <b>statement</b>
The <i>scalar-default-char-variable</i> in the DECIMAL= specifier is assigned the value COMMA or POINT, corres-
ponding to the decimal edit mode in effect for a connection for formatted input/output. If there is no connection,
or if the connection is not for formatted input/output, the <i>scalar-default-char-variable</i> is assigned the value
UNDEFINED.
<b>12.10.2.8</b> <b>DELIM=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>INQUIRE</b> <b>statement</b>
The <i>scalar-default-char-variable</i> in the DELIM= specifier is assigned the value APOSTROPHE, QUOTE, or
NONE, corresponding to the delimiter mode in effect for a connection for formatted input/output. If there is no
connection or if the connection is not for formatted input/output, the <i>scalar-default-char-variable</i> is assigned the
value UNDEFINED.
<b>12.10.2.9</b> <b>DIRECT=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>INQUIRE</b> <b>statement</b>
The <i>scalar-default-char-variable</i> in the DIRECT= specifier is assigned the value YES if DIRECT is included in
the set of allowed access methods for the file, NO if DIRECT is not included in the set of allowed access methods
for the file, and UNKNOWN if the processor is unable to determine whether DIRECT is included in the set of
allowed access methods for the file or if the unit identified by <i>file-unit-number</i> is not connected to a file.
<b>12.10.2.10</b> <b>ENCODING=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>INQUIRE</b> <b>statement</b>
The <i>scalar-default-char-variable</i> in the ENCODING= specifier is assigned the value UTF-8 if the connection is
for formatted input/output with an encoding form of UTF-8, and is assigned the value UNDEFINED if the
connection is for unformatted input/output. If there is no connection, it is assigned the value UTF-8 if the
processor is able to determine that the encoding form of the file is UTF-8; if the processor is unable to determine
the encoding form of the file or if the unit identified by <i>file-unit-number</i> is not connected to a file, the variable is
assigned the value UNKNOWN.
<b>NOTE</b>
The value assigned could be something other than UTF-8, UNDEFINED, or UNKNOWN if the processor
supports other specific encoding forms (e.g. UTF-16BE).
<b>12.10.2.11</b> <b>EXIST=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>INQUIRE</b> <b>statement</b>
Execution of an INQUIRE by file statement causes the <i>scalar-logical-variable</i> in the EXIST= specifier to be
assigned the value true if there exists a file with the specified name; otherwise, false is assigned. Execution of an
INQUIRE by unit statement causes true to be assigned if the specified unit exists; otherwise, false is assigned.
<b>12.10.2.12</b> <b>FORM=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>INQUIRE</b> <b>statement</b>
The <i>scalar-default-char-variable</i> in the FORM= specifier is assigned the value FORMATTED if the connection
is for formatted input/output, and is assigned the value UNFORMATTED if the connection is for unformatted
input/output. If there is no connection, it is assigned the value UNDEFINED.
<b>12.10.2.13</b> <b>FORMATTED=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>INQUIRE</b> <b>statement</b>
The <i>scalar-default-char-variable</i> in the FORMATTED= specifier is assigned the value YES if FORMATTED is
included in the set of allowed forms for the file, NO if FORMATTED is not included in the set of allowed forms
for the file, and UNKNOWN if the processor is unable to determine whether FORMATTED is included in the
set of allowed forms for the file or if the unit identified by <i>file-unit-number</i> is not connected to a file.
<b>12.10.2.14</b> <b>ID=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>INQUIRE</b> <b>statement</b>
ThevalueoftheexpressionspecifiedintheID=specifiershallbetheidentifierofapendingdatatransferoperation
for the specified unit. This specifier interacts with the PENDING= specifier (12.10.2.22).
<b>12.10.2.15</b> <b>LEADING_ZERO=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>INQUIRE</b> <b>statement</b>
The <i>scalar-default-char-variable</i> in the LEADING_ZERO= specifier is assigned the value PRINT, SUPPRESS,
or PROCESSOR_DEFINED, corresponding to the leading zero mode in effect for a connection for formatted
input/output. If there is no connection, or if the connection is not for formatted input/output, the <i>scalar-default-</i>
<i>char-variable</i> is assigned the value UNDEFINED.
<b>12.10.2.16</b> <b>NAME=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>INQUIRE</b> <b>statement</b>
The <i>scalar-default-char-variable</i> in the NAME= specifier is assigned the value of the name of the file if the file
has a name; otherwise, it becomes undefined. The value assigned shall be suitable for use as the value of the
<i>file-name-expr</i> in the FILE= specifier in an OPEN statement.
<b>NOTE</b>
If this specifier appears in an INQUIRE by file statement, its value is not necessarily the same as the name
given in the FILE= specifier.
The processor could assign a file name qualified by a user identification, device, directory, or other relevant
information.
The case of the characters assigned to <i>scalar-default-char-variable</i> is processor dependent.
<b>12.10.2.17</b> <b>NAMED=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>INQUIRE</b> <b>statement</b>
The <i>scalar-logical-variable</i> in the NAMED= specifier is assigned the value true if the file has a name; otherwise,
it is assigned the value false.
<b>12.10.2.18</b> <b>NEXTREC=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>INQUIRE</b> <b>statement</b>
The <i>scalar-int-variable</i> in the NEXTREC= specifier is assigned the value <i>n</i> + 1, where <i>n</i> is the record number of
the last record read from or written to the connection for direct access. If there is a connection but no records have
been read or written since the connection, the <i>scalar-int-variable</i> is assigned the value 1. If there is no connection,
the connection is not for direct access, or the position is indeterminate because of a previous error condition, the
<i>scalar-int-variable</i> becomes undefined. If there are pending data transfer operations for the specified unit, the
value assigned is computed as if all the pending data transfers had already completed.
<b>12.10.2.19</b> <b>NUMBER=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>INQUIRE</b> <b>statement</b>
Execution of an INQUIRE by file statement causes the <i>scalar-int-variable</i> in the NUMBER= specifier to be
assigned the value of the external unit number of the unit that is connected to the file. If more than one unit
on an image is connected to the file, which of the connected external unit numbers is assigned to the <i>scalar-int-</i>
<i>variable</i> is processor dependent. If there is no unit connected to the file, the value-1 is assigned. Execution of
an INQUIRE by unit statement causes the <i>scalar-int-variable</i> to be assigned the value of <i>file-unit-number</i>.
<b>12.10.2.20</b> <b>OPENED=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>INQUIRE</b> <b>statement</b>
Execution of an INQUIRE by file statement causes the <i>scalar-logical-variable</i> in the OPENED= specifier to be
assigned the value true if the file specified is connected to a unit; otherwise, false is assigned. Execution of an
INQUIRE by unit statement causes the <i>scalar-logical-variable</i> to be assigned the value true if the specified unit
is connected to a file; otherwise, false is assigned.
<b>12.10.2.21</b> <b>PAD=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>INQUIRE</b> <b>statement</b>
The <i>scalar-default-char-variable</i> in the PAD= specifier is assigned the value YES or NO, corresponding to the
pad mode in effect for a connection for formatted input/output. If there is no connection or if the connection is
not for formatted input/output, the <i>scalar-default-char-variable</i> is assigned the value UNDEFINED.
<b>12.10.2.22</b> <b>PENDING=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>INQUIRE</b> <b>statement</b>
The PENDING= specifier is used to determine whether previously pending asynchronous data transfers are
complete. A data transfer operation is previously pending if it is pending at the beginning of execution of the
INQUIRE statement.
If an ID= specifier appears and the specified data transfer operation is complete, then the variable specified in
the PENDING= specifier is assigned the value false and the INQUIRE statement performs the wait operation
for the specified data transfer.
If the ID= specifier is omitted and all previously pending data transfer operations for the specified unit are
complete, then the variable specified in the PENDING= specifier is assigned the value false and the INQUIRE
statement performs wait operations for all previously pending data transfers for the specified unit.
In all other cases, the variable specified in the PENDING= specifier is assigned the value true, no wait operations
are performed, and the previously pending data transfers remain pending after the execution of the INQUIRE
statement.
<b>NOTE</b>
The processor has considerable flexibility in defining when it considers a transfer to be complete. Any of the
following approaches could be used:
  The INQUIRE statement could consider an asynchronous data transfer to be incomplete until after the
  corresponding wait operation. In this case PENDING= would always return true unless there were no
  previously pending data transfers for the unit.
  The INQUIRE statement could wait for all specified data transfers to complete and then always return
  false for PENDING=.
  The INQUIRE statement could actually test the state of the specified data transfer operations.
<b>12.10.2.23</b> <b>POS=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>INQUIRE</b> <b>statement</b>
The <i>scalar-int-variable</i> in the POS= specifier is assigned the number of the file storage unit immediately following
the current position of a file connected for stream access. If the file is positioned at its terminal position, the
variable is assigned a value one greater than the number of the highest-numbered file storage unit in the file.
If there are pending data transfer operations for the specified unit, the value assigned is computed as if all the
pending data transfers had already completed. If there is no connection, the file is not connected for stream
access, or if the position of the file is indeterminate because of previous error conditions, the variable becomes
undefined.
<b>12.10.2.24</b> <b>POSITION=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>INQUIRE</b> <b>statement</b>
The <i>scalar-default-char-variable</i> in the POSITION= specifier is assigned the value REWIND if the connection
was opened for positioning at its initial point, APPEND if the connection was opened for positioning before its
endfile record or at its terminal point, and ASIS if the connection was opened without changing its position.
If there is no connection or if the file is connected for direct access, the <i>scalar-default-char-variable</i> is assigned
the value UNDEFINED. If the file has been repositioned since the connection, the <i>scalar-default-char-variable</i>
is assigned a processor-dependent value, which shall not be REWIND unless the file is positioned at its initial
point and shall not be APPEND unless the file is positioned so that its endfile record is the next record or at its
terminal point if it has no endfile record.
<b>12.10.2.25</b> <b>READ=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>INQUIRE</b> <b>statement</b>
The <i>scalar-default-char-variable</i> in the READ= specifier is assigned the value YES if READ is included in the
set of allowed actions for the file, NO if READ is not included in the set of allowed actions for the file, and
UNKNOWN if the processor is unable to determine whether READ is included in the set of allowed actions for
the file or if the unit identified by <i>file-unit-number</i> is not connected to a file.
<b>12.10.2.26</b> <b>READWRITE=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>INQUIRE</b> <b>statement</b>
The <i>scalar-default-char-variable</i> in the READWRITE= specifier is assigned the value YES if READWRITE is
included in the set of allowed actions for the file, NO if READWRITE is not included in the set of allowed actions
for the file, and UNKNOWN if the processor is unable to determine whether READWRITE is included in the
set of allowed actions for the file or if the unit identified by <i>file-unit-number</i> is not connected to a file.
<b>12.10.2.27</b> <b>RECL=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>INQUIRE</b> <b>statement</b>
The <i>scalar-int-variable</i> in the RECL= specifier is assigned the value of the record length of a connection for direct
access, or the value of the maximum record length of a connection for sequential access. If the connection is for
formatted input/output, the length is the number of characters for all records that contain only characters of
default kind. If the connection is for unformatted input/output, the length is measured in file storage units. If
there is no connection, the <i>scalar-int-variable</i> is assigned the value-1, and if the connection is for stream access,
the <i>scalar-int-variable</i> is assigned the value-2.
<b>12.10.2.28</b> <b>ROUND=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>INQUIRE</b> <b>statement</b>
The <i>scalar-default-char-variable</i> in the ROUND= specifier is assigned the value UP, DOWN, ZERO, NEAREST,
COMPATIBLE, or PROCESSOR_DEFINED, corresponding to the input/output rounding mode in effect for
a connection for formatted input/output. If there is no connection or if the connection is not for formatted
input/output, the <i>scalar-default-char-variable</i> is assigned the value UNDEFINED. The processor shall return the
value PROCESSOR_DEFINED only if the behavior of the input/output rounding mode is different from that
of the UP, DOWN, ZERO, NEAREST, and COMPATIBLE modes.
<b>12.10.2.29</b> <b>SEQUENTIAL=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>INQUIRE</b> <b>statement</b>
The <i>scalar-default-char-variable</i> in the SEQUENTIAL= specifier is assigned the value YES if SEQUENTIAL is
included in the set of allowed access methods for the file, NO if SEQUENTIAL is not included in the set of allowed
access methods for the file, and UNKNOWN if the processor is unable to determine whether SEQUENTIAL is
included in the set of allowed access methods for the file or if the unit identified by <i>file-unit-number</i> is not
connected to a file.
<b>12.10.2.30</b> <b>SIGN=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>INQUIRE</b> <b>statement</b>
The <i>scalar-default-char-variable</i> in the SIGN= specifier is assigned the value PLUS, SUPPRESS, or PRO-
CESSOR_DEFINED, corresponding to the sign mode in effect for a connection for formatted input/output.
If there is no connection, or if the connection is not for formatted input/output, the <i>scalar-default-char-variable</i>
is assigned the value UNDEFINED.
<b>12.10.2.31</b> <b>SIZE=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>INQUIRE</b> <b>statement</b>
The <i>scalar-int-variable</i> in the SIZE= specifier is assigned the size of the file in file storage units. If the file size
cannot be determined or if the unit identified by <i>file-unit-number</i> is not connected to a file, the variable is assigned
the value-1.
For a file that can be connected for stream access, the file size is the number of the highest-numbered file storage
unit in the file.
For a file that can be connected for sequential or direct access, the file size may be different from the number of
storage units implied by the data in the records; the exact relationship is processor dependent.
If there are pending data transfer operations for the specified unit, the value assigned is computed as if all the
pending data transfers had already completed.
<b>12.10.2.32</b> <b>STREAM=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>INQUIRE</b> <b>statement</b>
The <i>scalar-default-char-variable</i> in the STREAM= specifier is assigned the value YES if STREAM is included in
the set of allowed access methods for the file, NO if STREAM is not included in the set of allowed access methods
for the file, and UNKNOWN if the processor is unable to determine whether STREAM is included in the set of
allowed access methods for the file or if the unit identified by <i>file-unit-number</i> is not connected to a file.
<b>12.10.2.33</b> <b>UNFORMATTED=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>INQUIRE</b> <b>statement</b>
The <i>scalar-default-char-variable</i> in the UNFORMATTED= specifier is assigned the value YES if UNFORMAT-
TED is included in the set of allowed forms for the file, NO if UNFORMATTED is not included in the set of
allowed forms for the file, and UNKNOWN if the processor is unable to determine whether UNFORMATTED is
included in the set of allowed forms for the file or if the unit identified by <i>file-unit-number</i> is not connected to a
file.
<b>12.10.2.34</b> <b>WRITE=</b> <b>specifier</b> <b>in</b> <b>the</b> <b>INQUIRE</b> <b>statement</b>
The <i>scalar-default-char-variable</i> in the WRITE= specifier is assigned the value YES if WRITE is included in the
set of allowed actions for the file, NO if WRITE is not included in the set of allowed actions for the file, and
UNKNOWN if the processor is unable to determine whether WRITE is included in the set of allowed actions for
the file or if the unit identified by <i>file-unit-number</i> is not connected to a file.
<b>12.10.3</b> <b>Inquire</b> <b>by</b> <b>output</b> <b>list</b>
The <i>scalar-int-variable</i> in the IOLENGTH= specifier is assigned the processor-dependent number of file storage
units that would be required to store the data of the output list in an unformatted file. The value shall be suitable
as a RECL= specifier in an OPEN statement that connects a file for unformatted direct access if data will be
read from or written to the file using data transfer statements with an input/output list that specifies transfer of
a sequence of objects having the same types, type parameters, and extents, in the same order as the output list
in the INQUIRE statement.
The output list in an INQUIRE statement shall not contain any derived-type list items that require a defined
input/output procedure as described in 12.6.3. If a derived-type list item appears in the output list, the value
returned for the IOLENGTH= specifier assumes that no defined input/output procedure will be invoked.
<b>12.11</b> <b>Error,</b> <b>end-of-record,</b> <b>and</b> <b>end-of-file</b> <b>conditions</b>
<b>12.11.1</b> <b>Occurrence</b> <b>of</b> <b>input/output</b> <b>conditions</b>
The set of input/output error conditions is processor dependent. Except as otherwise specified, when an error
condition occurs or is detected is processor dependent.
Anend-of-recordconditionoccurswhenanonadvancinginputstatementattemptstotransferdatafromaposition
beyond the end of the current record, unless the file is a stream file and the current record is at the end of the
file (an end-of-file condition occurs instead).
An end-of-file condition occurs when
 an endfile record is encountered during the reading of a file connected for sequential access,
 an attempt is made to read a record beyond the end of an internal file, or
 an attempt is made to read beyond the end of a stream file.
An end-of-file condition may occur at the beginning of execution of an input statement. An end-of-file condition
also may occur during execution of a formatted input statement when more than one record is required by the
interaction of the input list and the format. An end-of-file condition also may occur during execution of a stream
input statement.
<b>12.11.2</b> <b>Error</b> <b>conditions</b> <b>and</b> <b>the</b> <b>ERR=</b> <b>specifier</b>
If an error condition occurs during execution of an input/output statement, the position of the file becomes
indeterminate.
If an error condition occurs during execution of an input/output statement that contains neither an ERR= nor
IOSTAT=specifier,errorterminationisinitiated. Ifanerrorconditionoccursduringexecutionofaninput/output
statement that contains either an ERR= specifier or an IOSTAT= specifier then:
  (1) processing of the input/output list, if any, terminates;
  (2) if the statement is a data transfer statement or the error condition occurs during a wait operation,
     all <i>do-variable</i>s in the statement that initiated the transfer become undefined;
  (3) if an IOSTAT= specifier appears, the <i>stat-variable</i> in the IOSTAT= specifier becomes defined as
     specified in 12.11.5;
  (4) if an IOMSG= specifier appears, the <i>iomsg-variable</i> becomes defined as specified in 12.11.6;
  (5) if the statement is a READ statement and it contains a SIZE= specifier, the <i>scalar-int-variable</i> in
     the SIZE= specifier becomes defined as specified in 12.6.2.16;
  (6) if the statement is a READ statement or the error condition occurs in a wait operation for a transfer
     initiated by a READ statement, all input items or namelist group objects in the statement that
     initiated the transfer become undefined;
  (7) if an ERR= specifier appears, a branch to the statement labeled by the <i>label</i> in the ERR= specifier
     occurs.
<b>12.11.3</b> <b>End-of-file</b> <b>condition</b> <b>and</b> <b>the</b> <b>END=</b> <b>specifier</b>
If an end-of-file condition occurs during execution of an input/output statement that contains neither an END=
specifier nor an IOSTAT= specifier, error termination is initiated. If an end-of-file condition occurs during
execution of an input/output statement that contains either an END= specifier or an IOSTAT= specifier, and
an error condition does not occur then:
  (1) processing of the input list, if any, terminates;
  (2) ifthestatementisadatatransferstatementortheend-of-fileconditionoccursduringawaitoperation,
     all <i>do-variable</i>s in the statement that initiated the transfer become undefined;
  (3) if the statement is an input statement or the end-of-file condition occurs during a wait operation
     for a transfer initiated by an input statement, all effective items resulting from the expansion of list
     items or the namelist group in the statement that initiated the transfer become undefined;
  (4) if the file specified in the input statement is an external record file, it is positioned after the endfile
     record;
  (5) if an IOSTAT= specifier appears, the <i>stat-variable</i> in the IOSTAT= specifier becomes defined as
     specified in 12.11.5;
  (6) if an IOMSG= specifier appears, the <i>iomsg-variable</i> becomes defined as specified in 12.11.6;
  (7) if an END= specifier appears, a branch to the statement labeled by the <i>label</i> in the END= specifier
     occurs.
<b>12.11.4</b> <b>End-of-record</b> <b>condition</b> <b>and</b> <b>the</b> <b>EOR=</b> <b>specifier</b>
If an end-of-record condition occurs during execution of an input/output statement that contains neither an
EOR= specifier nor an IOSTAT= specifier, error termination is initiated. If an end-of-record condition occurs
during execution of an input/output statement that contains either an EOR= specifier or an IOSTAT= specifier,
and an error condition does not occur then:
  (1) if the pad mode has the value
     (a) YES, the record is padded with blanks to satisfy the effective item (12.6.4.5.3) and correspond-
        ing data edit descriptors that require more characters than the record contains,
     (b) NO, the effective item becomes undefined;
  (2) processing of the input list, if any, terminates;
  (3) if the statement is a data transfer statement or the end-of-record condition occurs during a wait
     operation, all <i>do-variable</i>s in the statement that initiated the transfer become undefined;
  (4) the file specified in the input statement is positioned after the current record;
  (5) if an IOSTAT= specifier appears, the <i>stat-variable</i> in the IOSTAT= specifier becomes defined as
     specified in 12.11.5;
  (6) if an IOMSG= specifier appears, the <i>iomsg-variable</i> becomes defined as specified in 12.11.6;
  (7) if a SIZE= specifier appears, the <i>scalar-int-variable</i> in the SIZE= specifier becomes defined as spe-
     cified in (12.6.2.16);
  (8) if an EOR= specifier appears, a branch to the statement labeled by the <i>label</i> in the EOR= specifier
     occurs.
<b>12.11.5</b> <b>IOSTAT=</b> <b>specifier</b>
Execution of an input/output statement containing the IOSTAT= specifier causes the <i>stat-variable</i> in the IO-
STAT= specifier to become defined with
 a zero value if neither an error condition, an end-of-file condition, nor an end-of-record condition occurs,
 the processor-dependent positive integer value of the constant IOSTAT_INQUIRE_INTERNAL_UNIT
  from the intrinsic module ISO_FORTRAN_ENV (16.10.2) if a unit number in an INQUIRE statement
  identifies an internal file,
 a processor-dependent positive integer value different from IOSTAT_INQUIRE_INTERNAL_UNIT if any
  other error condition occurs,
 theprocessor-dependentnegativeintegervalueoftheconstantIOSTAT_END(16.10.2.16)fromtheintrinsic
  module ISO_FORTRAN_ENV if an end-of-file condition occurs and no error condition occurs,
 theprocessor-dependentnegativeintegervalueoftheconstantIOSTAT_EOR(16.10.2.17)fromtheintrinsic
  module ISO_FORTRAN_ENV if an end-of-record condition occurs and no error condition or end-of-file
  condition occurs, or
 a processor-dependent negative integer value different from IOSTAT_EOR and IOSTAT_END, if the IO-
  STAT= specifier appears in a FLUSH statement and the processor does not support the flush operation for
  the specified unit.
<b>NOTE</b>
An end-of-file condition can occur only for sequential or stream input and an end-of-record condition can occur
only for nonadvancing input. For example,
   READ (FMT = "(E8.3)", UNIT = 3, IOSTAT = IOSS) X
   IF (IOSS < 0) THEN
     ! Perform end-of-file processing on the file connected to unit 3.
     CALL END_PROCESSING
   ELSE IF (IOSS > 0) THEN
     ! Perform error processing
     CALL ERROR_PROCESSING
   END IF
<b>12.11.6</b> <b>IOMSG=</b> <b>specifier</b>
If an error, end-of-file, or end-of-record condition occurs during execution of an input/output statement, <i>iomsg-</i>
<i>variable</i> is assigned an explanatory message, as if by intrinsic assignment. If no such condition occurs, the
definition status and value of <i>iomsg-variable</i> are unchanged.
<b>12.12</b> <b>Restrictions</b> <b>on</b> <b>input/output</b> <b>statements</b>
If a unit, or a file connected to a unit, does not have all of the properties required for the execution of certain
input/output statements, those statements shall not refer to the unit.
An input/output statement that is executed while another input/output statement is being executed is a recursive
input/output statement. A recursive input/output statement shall not identify an external unit that is identified
by another input/output statement being executed except that a child data transfer statement may identify its
parent data transfer statement external unit.
An input/output statement shall not cause the value of any established format specification to be modified.
A recursive input/output statement shall not modify the value of any internal unit except that a recursive WRITE
statement may modify the internal unit identified by that recursive WRITE statement.
The value of a specifier in an input/output statement shall not depend on the definition or evaluation of any other
specifier in the <i>io-control-spec-list</i> or <i>inquire-spec-list</i> in that statement. The value of an <i>internal-file-variable</i> or
of a FMT=, ID=, IOMSG=, IOSTAT=, or SIZE= specifier shall not depend on the value of any <i>input-item</i> or
<i>io-implied-do</i> <i>do-variable</i> in the same statement.
The value of any subscript or substring bound of a variable that appears in a specifier in an input/output
statement shall not depend on any <i>input-item</i>, <i>io-implied-do</i> <i>do-variable</i>, or on the definition or evaluation of any
other specifier in the <i>io-control-spec-list</i> or <i>inquire-spec-list</i> in that statement.
In a data transfer statement, the variable specified in an IOSTAT=, IOMSG=, or SIZE= specifier, if any, shall
not be associated with any entity in the data transfer input/output list (12.6.3) or <i>namelist-group-object-list</i>, nor
with a <i>do-variable</i> of an <i>io-implied-do</i> in the data transfer input/output list.
In a data transfer statement, if a variable specified in an IOSTAT=, IOMSG=, or SIZE= specifier is an array
element reference, its subscript values shall not be affected by the data transfer, the <i>io-implied-do</i> processing, or
the definition or evaluation of any other specifier in the <i>io-control-spec-list</i>.
A variable that can become defined or undefined as a result of its use in a specifier in an INQUIRE statement,
or any associated entity, shall not appear in another specifier in the same INQUIRE statement.
<b>NOTE</b>
Restrictions on the evaluation of expressions (10.1.4) prohibit certain side effects.
<b>13</b> <b>Input/output</b> <b>editing</b>
<b>13.1</b> <b>Format</b> <b>specifications</b>
A format used in conjunction with a data transfer statement provides information that directs the editing between
the internal representation of data and the characters of a sequence of formatted records.
A <i>format</i> (12.6.2.2) in a data transfer statement can refer to a FORMAT statement or to a character expression
that contains a format specification. A format specification provides explicit editing information. The <i>format</i>
alternatively can be an asterisk (*), which indicates list-directed formatting (13.10). Namelist formatting (13.11)
is indicated by specifying a <i>namelist-group-name</i> instead of a <i>format</i>.
<b>13.2</b> <b>Explicit</b> <b>format</b> <b>specification</b> <b>methods</b>
<b>13.2.1</b> <b>FORMAT</b> <b>statement</b>
R1301 <i>format-stmt</i> <b>is</b> FORMAT <i>format-specification</i>
R1302 <i>format-specification</i> <b>is</b> ( [ <i>format-items</i> ] )
              <b>or</b> ( [ <i>format-items</i>, ] <i>unlimited-format-item</i> )
C1301 (R1301) The <i>format-stmt</i> shall be labeled.
Blank characters may precede the initial left parenthesis of the format specification. Additional blank characters
may appear at any point within the format specification, with no effect on the interpretation of the format
specification, except within a character string edit descriptor (13.9).
<b>NOTE</b>
Examples of FORMAT statements are:
   5 FORMAT (1PE12.4, I10)
   9 FORMAT (I12, /, ' Dates: ', 2 (2I3, I5))
<b>13.2.2</b> <b>Character</b> <b>format</b> <b>specification</b>
A character expression used as a <i>format</i> in a formatted input/output statement shall evaluate to a character
string whose leading part is a valid format specification.
<b>NOTE</b> <b>1</b>
The format specification begins with a left parenthesis and ends with a right parenthesis.
All character positions up to and including the final right parenthesis of the format specification shall be defined
at the time the data transfer statement is executed, and shall not become redefined or undefined during the
execution of the statement. Character positions, if any, following the right parenthesis that ends the format
specification need not be defined and may contain any character data with no effect on the interpretation of the
format specification.
If the <i>format</i> is a character array, it is treated as if all of the elements of the array were specified in array element
order and were concatenated. However, if a <i>format</i> is a character array element, the format specification shall be
entirely within that array element.
<b>NOTE</b> <b>2</b>
If a character constant is used as a <i>format</i> in data transfer statement, care needs to be taken that the value
of the character constant is a valid format specification. In particular, if a format specification delimited by
apostrophes contains a character constant edit descriptor delimited with apostrophes, two apostrophes are
needed to delimit the edit descriptor and four apostrophes are needed for each apostrophe that occurs within
the edit descriptor. For example, the text:
2 ISN'T 3
can be written by various combinations of output statements and format specifications:
     WRITE (6, 100) 2, 3
   100 FORMAT (1X, I1, 1X, 'ISN''T', 1X, I1)
     WRITE (6, '(1X, I1, 1X, ''ISN''''T'', 1X, I1)') 2, 3
     WRITE (6, '(A)') ' 2 ISN''T 3'
Doubling of internal apostrophes usually can be avoided by using quotation marks to delimit the format spe-
cification and doubling of internal quotation marks usually can be avoided by using apostrophes as delimiters.
<b>13.3</b> <b>Form</b> <b>of</b> <b>a</b> <b>format</b> <b>item</b> <b>list</b>
<b>13.3.1</b> <b>Syntax</b>
R1303 <i>format-items</i> <b>is</b> <i>format-item</i> [ [ , ] <i>format-item</i> ] ...
R1304 <i>format-item</i> <b>is</b> [ <i>r</i> ] <i>data-edit-desc</i>
              <b>or</b> <i>control-edit-desc</i>
              <b>or</b> <i>char-string-edit-desc</i>
              <b>or</b> [ <i>r</i> ] ( <i>format-items</i> )
R1305 <i>unlimited-format-item</i> <b>is</b> * ( <i>format-items</i> )
R1306 <i>r</i> <b>is</b> <i>int-literal-constant</i>
C1302 (R1303) The optional comma shall not be omitted except
   between a P edit descriptor and an immediately following F, E, EN, ES, EX, D, or G edit descriptor
     (13.8.6), possibly preceded by a repeat specification,
   before a slash edit descriptor when the optional repeat specification does not appear (13.8.2),
   after a slash edit descriptor, or
   before or after a colon edit descriptor (13.8.3)
C1303 (R1305) An <i>unlimited-format-item</i> shall contain at least one data edit descriptor.
C1304 (R1306) <i>r</i> shall be positive.
C1305 (R1306) A kind parameter shall not be specified for <i>r</i>.
The integer literal constant <i>r</i> is called a repeat specification.
<b>13.3.2</b> <b>Edit</b> <b>descriptors</b>
Aneditdescriptorisadataeditdescriptor(<i>data-edit-desc</i>), controleditdescriptor(<i>control-edit-desc</i>), orcharacter
string edit descriptor (<i>char-string-edit-desc</i>).
R1307 <i>data-edit-desc</i> <b>is</b> I <i>w</i> [ . <i>m</i> ]
              <b>or</b> B <i>w</i> [ . <i>m</i> ]
              <b>or</b> O <i>w</i> [ . <i>m</i> ]
              <b>or</b> Z <i>w</i> [ . <i>m</i> ]
              <b>or</b> F <i>w</i> . <i>d</i>
              <b>or</b> E <i>w</i> . <i>d</i> [ E <i>e</i> ]
              <b>or</b> EN <i>w</i> . <i>d</i> [ E <i>e</i> ]
              <b>or</b> ES <i>w</i> . <i>d</i> [ E <i>e</i> ]
              <b>or</b> EX <i>w</i> . <i>d</i> [ E <i>e</i> ]
              <b>or</b> G <i>w</i> [ . <i>d</i> [ E <i>e</i> ] ]
              <b>or</b> L <i>w</i>
              <b>or</b> A [ <i>w</i> ]
              <b>or</b> AT
              <b>or</b> D <i>w</i> . <i>d</i>
              <b>or</b> DT [ <i>char-literal-constant</i> ] [ ( <i>v-list</i> ) ]
R1308 <i>w</i> <b>is</b> <i>int-literal-constant</i>
R1309 <i>m</i> <b>is</b> <i>int-literal-constant</i>
R1310 <i>d</i> <b>is</b> <i>int-literal-constant</i>
R1311 <i>e</i> <b>is</b> <i>int-literal-constant</i>
R1312 <i>v</i> <b>is</b> <i>signed-int-literal-constant</i>
C1306 (R1308) <i>w</i> shall be zero or positive for the I, B, O, Z, D, E, EN, ES, EX, F, and G edit descriptors. <i>w</i>
   shall be positive for all other edit descriptors.
C1307 (R1307) For the G edit descriptor, <i>d</i> shall be specified if <i>w</i> is not zero.
C1308 (R1307) For the G edit descriptor, <i>e</i> shall not be specified if <i>w</i> is zero.
C1309 (R1307) A kind parameter shall not be specified for the <i>char-literal-constant</i> in the DT edit descriptor,
   or for <i>w</i>, <i>m</i>, <i>d</i>, <i>e</i>, and <i>v</i>.
An I, B, O, Z, F, E, EN, ES, EX, G, L, A, AT, D, or DT edit descriptor indicates the manner of editing.
R1313 <i>control-edit-desc</i> <b>is</b> <i>blank-interp-edit-desc</i>
              <b>or</b> <i>decimal-edit-desc</i>
              <b>or</b> <i>leading-zero-edit-desc</i>
              <b>or</b> <i>position-edit-desc</i>
              <b>or</b> <i>round-edit-desc</i>
              <b>or</b> <i>sign-edit-desc</i>
              <b>or</b> <i>k</i> P
              <b>or</b> :
              <b>or</b> [ <i>r</i> ] /
R1314 <i>k</i> <b>is</b> <i>signed-int-literal-constant</i>
C1310 (R1314) A kind parameter shall not be specified for <i>k</i>.
In <i>k</i> P, <i>k</i> is called the scale factor.
R1315 <i>position-edit-desc</i> <b>is</b> T <i>n</i>
              <b>or</b> TL <i>n</i>
              <b>or</b> TR <i>n</i>
              <b>or</b> <i>n</i> X
R1316 <i>n</i> <b>is</b> <i>int-literal-constant</i>
C1311 (R1316) <i>n</i> shall be positive.
C1312 (R1316) A kind parameter shall not be specified for <i>n</i>.
R1317 <i>blank-interp-edit-desc</i> <b>is</b> BN
              <b>or</b> BZ
R1318 <i>decimal-edit-desc</i> <b>is</b> DC
              <b>or</b> DP
R1319 <i>leading-zero-edit-desc</i> <b>is</b> LZS
              <b>or</b> LZP
              <b>or</b> LZ
R1320 <i>round-edit-desc</i> <b>is</b> RU
              <b>or</b> RD
              <b>or</b> RZ
              <b>or</b> RN
              <b>or</b> RC
              <b>or</b> RP
R1321 <i>sign-edit-desc</i> <b>is</b> SS
              <b>or</b> SP
              <b>or</b> S
A T, TL, TR, X, slash, colon, SS, SP, S, LZS, LZP, LZ, P, BN, BZ, RU, RD, RZ, RN, RC, RP, DC, or DP edit
descriptor indicates the manner of editing.
R1322 <i>char-string-edit-desc</i> <b>is</b> <i>char-literal-constant</i>
C1313 (R1322) A kind parameter shall not be specified for the <i>char-literal-constant</i>.
Each <i>rep-char</i> in a character string edit descriptor shall be capable of representation by the processor.
A character string edit descriptor provides constant data to be output, and is not valid for input.
The edit descriptors are without regard to case except within a character string edit descriptor.
<b>13.3.3</b> <b>Fields</b>
A field is a part of a record that is read on input or written on output when format control encounters a data
edit descriptor or a character string edit descriptor. The field width is the size in characters of the field.
<b>13.4</b> <b>Interaction</b> <b>between</b> <b>input/output</b> <b>list</b> <b>and</b> <b>format</b>
The start of formatted data transfer using a format specification initiates format control (12.6.4.5.3). Each action
of format control depends on information jointly provided by the next edit descriptor in the format specification
and the next effective item in the input/output list, if one exists.
If an input/output list specifies at least one effective item, at least one data edit descriptor shall exist in the
format specification.
<b>NOTE</b> <b>1</b>
An empty format specification of the form ( ) can be used only if the input/output list has no effective item
(12.6.4.5). A zero length character item is an effective item, but a zero sized array and an implied DO list with
an iteration count of zero is not.
A format specification is interpreted from left to right. The exceptions are format items preceded by a repeat
specification <i>r</i>, and format reversion (described below).
A format item preceded by a repeat specification is processed as a list of <i>r</i> items, each identical to the format
item but without the repeat specification and separated by commas.
<b>NOTE</b> <b>2</b>
An omitted repeat specification is treated in the same way as a repeat specification whose value is one.
To each data edit descriptor interpreted in a format specification, there corresponds one effective item specified
by the input/output list (12.6.3), except that an effective item of type complex requires the interpretation of two
F, E, EN, ES, EX, D, or G edit descriptors. For each control edit descriptor or character edit descriptor, there is
no corresponding item specified by the input/output list, and format control communicates information directly
with the record.
Whenever format control encounters a data edit descriptor in a format specification, it determines whether
there is a corresponding effective item specified by the input/output list. If there is such an item, it transmits
appropriately edited information between the item and the record, and then format control proceeds. If there is
no such item, format control terminates.
If format control encounters a colon edit descriptor in a format specification and another effective item is not
specified, format control terminates.
If format control encounters the rightmost parenthesis of an unlimited format item, control reverts to the leftmost
parenthesis of that unlimited format item. This reversion of format control has no effect on the changeable modes
(12.5.2).
If format control encounters the rightmost parenthesis of a complete format specification and another effective
item is not specified, format control terminates. However, if another effective item is specified, format control
then reverts to the beginning of the format item terminated by the last preceding right parenthesis that is not
part of a DT edit descriptor. If there is no such preceding right parenthesis, format control reverts to the first
left parenthesis of the format specification. If any reversion occurs, the reused portion of the format specification
shall contain at least one data edit descriptor. If format control reverts to a parenthesis that is preceded by a
repeat specification, the repeat specification is reused. Reversion of format control, of itself, has no effect on
the changeable modes. The file is positioned in a manner identical to the way it is positioned when a slash edit
descriptor is processed (13.8.2).
<b>NOTE</b> <b>3</b>
Example: The format specification:
   10 FORMAT (1X, 2(F10.3, I5))
with the output statement
   WRITE (10,10) 10.1, 3, 4.7, 1, 12.4, 5, 5.2, 6
produces the same output as the format specification:
   10 FORMAT (1X, F10.3, I5, F10.3, I5/F10.3, I5, F10.3, I5)
<b>NOTE</b> <b>4</b>
The effect of an <i>unlimited-format-item</i> is as if its enclosed list were preceded by a very large repeat count. There
is no file positioning implied by <i>unlimited-format-item</i> reversion. This can be used to write what is commonly
called a comma separated value record.
For example,
   WRITE( 10, '( "IARRAY =", *( I0, :, ","))') IARRAY
produces a single record with a header and a comma separated list of integer values.
<b>13.5</b> <b>Positioning</b> <b>by</b> <b>format</b> <b>control</b>
After each data edit descriptor or character string edit descriptor is processed, the file is positioned after the last
character read or written in the current record.
After each T, TL, TR, or X edit descriptor is processed, the file is positioned as described in 13.8.1.1. After each
slash edit descriptor is processed, the file is positioned as described in 13.8.2.
During formatted stream output, processing of an A or AT edit descriptor can cause file positioning to occur
(13.7.4).
If format control reverts as described in 13.4, the file is positioned in a manner identical to the way it is positioned
when a slash edit descriptor is processed (13.8.2).
During a read operation, any unprocessed characters of the current record are skipped whenever the next record
is read.
<b>13.6</b> <b>Decimal</b> <b>symbol</b>
The decimal symbol is the character that separates the whole and fractional parts in the decimal representation
of a real number in an internal or external file. When the decimal edit mode is POINT, the decimal symbol is a
decimal point. When the decimal edit mode is COMMA, the decimal symbol is a comma.
If the decimal edit mode is COMMA during list-directed input/output, the character used as a value separator
is a semicolon in place of a comma.
<b>13.7</b> <b>Data</b> <b>edit</b> <b>descriptors</b>
<b>13.7.1</b> <b>Purpose</b> <b>of</b> <b>data</b> <b>edit</b> <b>descriptors</b>
A data edit descriptor causes the conversion of data to or from its internal representation; during formatted
stream output, an A or AT data edit descriptor can also cause file positioning. On input, the specified variable
becomes defined unless an error condition, an end-of-file condition, or an end-of-record condition occurs. On
output, the specified expression is evaluated.
During input from a Unicode file,
 characters in the record that correspond to an ASCII character variable shall have a position in the ISO
  10646 character collating sequence of 127 or less, and
 characters in the record that correspond to a default character variable shall be representable as default
  characters.
During input from a non-Unicode file,
 characters in the record that correspond to a character variable shall have the kind of the character variable,
  and
 characters in the record that correspond to a numeric or logical variable shall be default characters.
During output to a Unicode file, all characters transmitted to the record are of ISO 10646 character kind. If a
character effective item or character string edit descriptor contains a character that is not representable as an
ISO 10646 character, the result is processor dependent.
During output to a non-Unicode file, characters transmitted to the record as a result of processing a character
string edit descriptor or as a result of evaluating a numeric, logical, or default character data entity, are of default
kind.
<b>13.7.2</b> <b>Numeric</b> <b>editing</b>
<b>13.7.2.1</b> <b>General</b> <b>rules</b>
The I, B, O, Z, F, E, EN, ES, EX, D, and G edit descriptors can be used to specify the input/output of integer,
real, and complex data. The I, B, O, Z and G edit descriptors can be used to specify the input/output of enum
type data. The I, B, O, and Z edit descriptors can be used to specify input/output of enumeration type data.
The following general rules apply.
  (1) On input, leading blanks are not significant. When the input field is not an IEEE exceptional
     specification or hexadecimal-significand number (13.7.2.3.2), the interpretation of blanks, other than
     leading blanks, is determined by the blank interpretation mode (13.8.7). Plus signs may be omitted.
     A field containing only blanks is considered to be zero.
  (2) On input, with F, E, EN, ES, EX, D, and G editing, a decimal symbol appearing in the input field
     overrides the portion of an edit descriptor that specifies the decimal symbol location. The input field
     may have more digits than the processor uses to approximate the value of the datum.
  (3) On output with I, F, E, EN, ES, EX, D, and G editing, the representation of a nonnegative internal
     value in the field may be prefixed with a plus sign, as controlled by the S, SP, and SS edit descriptors
     or the processor. The representation of a negative internal value in the field shall be prefixed with a
     minus sign.
  (4) On output, the representation is right justified in the field. If the number of characters produced by
     the editing is smaller than the field width, leading blanks are inserted in the field.
  (5) On output, if an exponent exceeds its specified or implied width using the E, EN, ES, EX, D, or G
     edit descriptor, or the number of characters produced exceeds the field width, the processor shall fill
     the entire field of width <i>w</i> with asterisks. However, the processor shall not produce asterisks if the
     field width is not exceeded when optional characters are omitted.
<b>NOTE</b>
When the sign mode is PLUS, a plus sign is not optional.
  (6) On output, with I, B, O, Z, D, E, EN, ES, EX, F, and G editing, the specified value of the field width
     <i>w</i> may be zero. In such cases, the processor selects the smallest positive actual field width that does
     not result in a field filled with asterisks. The specified value of <i>w</i> shall not be zero on input.
  (7) On output of a real zero value, the digits in the exponent field shall all be zero.
<b>13.7.2.2</b> <b>Integer</b> <b>editing</b>
The I<i>w</i> and I<i>w</i>.<i>m</i> edit descriptors indicate that the field to be edited occupies <i>w</i> positions, except when <i>w</i> is zero.
When <i>w</i> is zero, the processor selects the field width. On input, <i>w</i> shall not be zero. The corresponding effective
item shall be of type integer or of enum or enumeration type. The G, B, O, and Z edit descriptors also may be
used to edit integer data (13.7.5.2.2, 13.7.2.4).
On input, <i>m</i> has no effect.
In the standard form of the input field for the I edit descriptor, the character string is a <i>signed-digit-string</i> (R710),
except for the interpretation of blanks. If the input field does not have the standard form and is not acceptable
to the processor, an error condition occurs.
The output field for the I<i>w</i> edit descriptor consists of zero or more leading blanks followed by a minus sign if the
internal value is negative, or an optional plus sign otherwise, followed by the magnitude of the internal value as
a <i>digit-string</i> without leading zeros.
<b>NOTE</b>
A <i>digit-string</i> always consists of at least one digit.
The output field for the I<i>w</i>.<i>m</i> edit descriptor is the same as for the I<i>w</i> edit descriptor, except that the <i>digit-string</i>
consists of at least <i>m</i> digits. If necessary, sufficient leading zeros are included to achieve the minimum of <i>m</i> digits.
The value of <i>m</i> shall not exceed the value of <i>w</i>, except when <i>w</i> is zero. If <i>m</i> is zero and the internal value is zero,
the output field consists of only blank characters, regardless of the sign control in effect. When <i>m</i> and <i>w</i> are both
zero, and the internal value is zero, one blank character is produced.
If the effective item for output is of enumeration type, the value output is its ordinal position. If the effective
item for input is of enumeration type, the value of the input field shall be positive and less than or equal to
the number of enumerators; the value assigned to the effective item is the enumeration value with that ordinal
position.
If the effective item for output is of enum type, the value output is its corresponding integer value. If the effective
item for input is of enum type, the value assigned is the enum value corresponding to the value of the input field.
<b>13.7.2.3</b> <b>Real</b> <b>and</b> <b>complex</b> <b>editing</b>
<b>13.7.2.3.1</b> <b>General</b>
The F, E, EN, ES, EX, and D edit descriptors specify the editing of real and complex data. An effective item
corresponding to an F, E, EN, ES, EX, or D edit descriptor shall be real or complex. The G, B, O, and Z edit
descriptors also may be used to edit real and complex data (13.7.5.2.3, 13.7.2.4).
<b>13.7.2.3.2</b> <b>F</b> <b>editing</b>
The F<i>w</i>.<i>d</i> edit descriptor indicates that the field occupies <i>w</i> positions, except when <i>w</i> is zero in which case the
processor selects the field width. The fractional part of the field consists of <i>d</i> digits. On input, <i>w</i> shall not be
zero.
A lower-case letter is equivalent to the corresponding upper-case letter in an IEEE exceptional specification or
the exponent in a numeric input field.
The standard form of the input field is an IEEE exceptional specification, a hexadecimal-significand number, or
consists of a mantissa optionally followed by an exponent. The form of the mantissa is an optional sign, followed
by a string of one or more digits optionally containing a decimal symbol, including any blanks interpreted as
zeros. The <i>d</i> has no effect on input if the input field contains a decimal symbol. If the decimal symbol is omitted,
the rightmost <i>d</i> digits of the string, with leading zeros assumed if necessary, are interpreted as the fractional part
of the value represented. The string of digits may contain more digits than a processor uses to approximate the
value. The form of the exponent is one of the following:
 a <i>sign</i> followed by a <i>digit-string</i>;
 the letter E followed by zero or more blanks, followed by a <i>signed-digit-string</i>;
 the letter D followed by zero or more blanks, followed by a <i>signed-digit-string</i>.
An exponent containing a D is processed identically to an exponent containing an E.
<b>NOTE</b> <b>1</b>
If the input field does not contain an exponent, the effect is as if the basic form were followed by an exponent
with a value of-<i>k</i>, where <i>k</i> is the established scale factor (13.8.6).
An input field that is an IEEE exceptional specification consists of optional blanks, followed by either
 an optional sign, followed by the string 'INF' or the string 'INFINITY', or
 an optional sign, followed by the string 'NAN', optionally followed by zero or more alphanumeric characters
  enclosed in parentheses,
optionally followed by blanks.
The value specified by 'INF' or 'INFINITY' is an IEEE infinity; this form shall not be used if the processor does
not support IEEE infinities for the input variable. The value specified by 'NAN' is an IEEE NaN; this form shall
not be used if the processor does not support IEEE NaNs for the input variable. The NaN value is a quiet NaN if
the only nonblank characters in the field are 'NAN' or 'NAN()'; otherwise, the NaN value is processor dependent.
The interpretation of a sign in a NaN input field is processor dependent.
An input field that is a hexadecimal-significand number consists of an optional sign, followed by the hexadecimal
indicator which is the digit 0 immediately followed by the letter X, followed by a hexadecimal significand followed
byahexadecimalexponent. Ahexadecimalsignificandisastringofoneormorehexadecimalcharactersoptionally
containing a decimal symbol. The decimal symbol indicates the position of the hexadecimal point; if no decimal
symbol appears, the hexadecimal point implicitly follows the last hexadecimal symbol. A hexadecimal exponent
is the letter P followed by a (decimal) <i>signed-digit-string</i>. Embedded blanks are not permitted in a hexadecimal-
significand number; trailing blanks are ignored. The value is equal to the significand multiplied by two raised to
the power of the exponent, negated if the optional sign is minus.
If the input field does not have one of the standard forms, and is not acceptable to the processor, an error
condition occurs.
For an internal value that is an IEEE infinity, the output field consists of blanks, if necessary, followed by a minus
sign for negative infinity or an optional plus sign otherwise, followed by the letters 'Inf' or 'Infinity', right justified
within the field. The minimum field width required for output of the form 'Inf' is 3 if no sign is produced, and
4 otherwise. The minimum field width required for output of the form 'Infinity' is 8 if no sign is produced, and
9 otherwise. If <i>w</i> is greater than or equal to the minimum required for the form 'Infinity', the form 'Infinity' is
output. If <i>w</i> is zero or <i>w</i> is less than the minimum required for the form 'Infinity' and greater than or equal to
the minimum required for the form 'Inf', the form 'Inf' is output. Otherwise (<i>w</i> is greater than zero but less than
the minimum required for any form), the field is filled with asterisks.
For an internal value that is an IEEE NaN, the output field consists of blanks, if necessary, followed by the
letters 'NaN' and optionally followed by one to <i>w</i>-5 alphanumeric processor-dependent characters enclosed in
parentheses, right justified within the field. If <i>w</i> is greater than zero and less than 3, the field is filled with
asterisks. If <i>w</i> is zero, the output field is 'NaN'.
<b>NOTE</b> <b>2</b>
The processor-dependent characters following 'NaN' might convey additional information about that particular
NaN.
For an internal value that is neither an IEEE infinity nor a NaN, the output field consists of blanks, if necessary,
followed by a minus sign if the internal value is negative, or an optional plus sign otherwise, followed by a string
of digits that contains a decimal symbol and represents the magnitude of the internal value, as modified by the
established scale factor and rounded (13.7.2.3.8) to <i>d</i> fractional digits. Leading zeros are not permitted except
for an optional zero immediately to the left of the decimal symbol if the magnitude of the value in the output
field is less than one. The optional zero shall appear if there would otherwise be no digits in the output field.
<b>13.7.2.3.3</b> <b>E</b> <b>and</b> <b>D</b> <b>editing</b>
The E<i>w</i>.<i>d</i>, D<i>w</i>.<i>d</i>, and E<i>w</i>.<i>d</i> E<i>e</i> edit descriptors indicate that the external field occupies <i>w</i> positions, except when
<i>w</i> is zero in which case the processor selects the field width. The fractional part of the field contains <i>d</i> digits,
unless a scale factor greater than one is in effect. If <i>e</i> is positive the exponent part contains <i>e</i> digits, otherwise it
contains the minimum number of digits required to represent the exponent value. The <i>e</i> has no effect on input.
The form and interpretation of the input field is the same as for F<i>w</i>.<i>d</i> editing (13.7.2.3.2).
For an internal value that is an IEEE infinity or NaN, the form of the output field is the same as for F<i>w</i>.<i>d</i>.
For an internal value that is neither an IEEE infinity nor a NaN, the form of the output field for a scale factor
of zero is
   [ ] [0].<i>x</i>
       1
     <i>x</i>
        2
      <i>...x</i>
          <i>d</i>
        <i>exp</i>
where:
  signifies a plus sign or a minus sign;
 . signifies a decimal symbol (13.6);
 <i>x</i>
   1
  <i>x</i>
    2
   <i>...x</i>
       <i>d</i>
       are the <i>d</i> most significant digits of the internal value after rounding (13.7.2.3.8);
 <i>exp</i> is a decimal exponent having one of the forms specified in Table 13.1.
            <b>Table</b> <b>13.1</b> <b>-</b> <b>E</b> <b>and</b> <b>D</b> <b>exponent</b> <b>forms</b>
       Edit Descriptor Absolute Value of Exponent Form of Exponent
                                              1
      E<i>w</i>.<i>d</i> with <i>w</i> <i>></i> 0 |<i>exp</i>| 99 E<i>z</i>
                                       1
                             <i>z</i>
                                        2
                                   or0<i>z</i>
                                            1
                                 <i>z</i>
                                             2
                                 99<i><</i>|<i>exp</i>| 999 <i>z</i>
                                         1
                              <i>z</i>
                                          2
                               <i>z</i>
                                           3
      E<i>w</i>.<i>d</i> E<i>e</i> with <i>e></i> 0 |<i>exp</i>| 10
                        <i>e</i>
            - 1 E<i>z</i>
                                        1
                              <i>z</i>
                                         2
                               <i>...z</i>
                                         <i>e</i>
       E<i>w</i>.<i>d</i> E0 or E0.<i>d</i> any E<i>z</i>
                                        1
                              <i>z</i>
                                         2
                               <i>...z</i>
                                         <i>s</i>
      D<i>w</i>.<i>d</i> with <i>w></i> 0 |<i>exp</i>| 99 D<i>z</i>
                                       1
                             <i>z</i>
                                        2
                                   or E<i>z</i>
                                             1
                                 <i>z</i>
                                              2
                                  or0<i>z</i>
                                          1
                               <i>z</i>
                                           2
                                 99<i><</i>|<i>exp</i>| 999 <i>z</i>
                                         1
                              <i>z</i>
                                          2
                               <i>z</i>
                                           3
         D0.<i>d</i> any D<i>z</i>
                                    1
                           <i>z</i>
                                     2
                            <i>...z</i>
                                     <i>s</i>
                                   or E<i>z</i>
                                             1
                                 <i>z</i>
                                              2
                                  <i>...z</i>
                                            <i>s</i>
      (1) where each <i>z</i> is a digit, and <i>s</i> is the minimum number of digits required to
      represent the exponent. A plus sign is produced if the exponent value is zero.
The scale factor <i>k</i> controls the decimal normalization (13.3.2, 13.8.6). If-<i>d</i> <i><</i> <i>k</i> 0, the output field contains
exactly|<i>k</i>| leading zeros and <i>d</i>-|<i>k</i>| significant digits after the decimal symbol. If 0<i><k</i> <i><d</i> + 2, the output field
contains exactly <i>k</i> significant digits to the left of the decimal symbol and <i>d</i>-<i>k</i> + 1 significant digits to the right
of the decimal symbol. Other values of <i>k</i> are not permitted.
<b>13.7.2.3.4</b> <b>EN</b> <b>editing</b>
The EN edit descriptor produces an output field in the form of a real number in engineering notation such that
the decimal exponent is divisible by three and the absolute value of the significand (R715) is greater than or
equal to 1 and less than 1000, except when the output value is zero. The scale factor has no effect on output.
The forms of the edit descriptor are EN<i>w</i>.<i>d</i> and EN<i>w</i>.<i>d</i> E<i>e</i> indicating that the external field occupies <i>w</i> positions,
except when <i>w</i> is zero in which case the processor selects the field width. The fractional part of the field contains
<i>d</i> digits. If <i>e</i> is positive the exponent part contains <i>e</i> digits, otherwise it contains the minimum number of digits
required to represent the exponent value.
The form and interpretation of the input field is the same as for F<i>w</i>.<i>d</i> editing (13.7.2.3.2).
For an internal value that is an IEEE infinity or NaN, the form of the output field is the same as for F<i>w</i>.<i>d</i>.
For an internal value that is neither an IEEE infinity nor a NaN, the form of the output field is
   [ ] <i>yyy</i> . <i>x</i>
        1
      <i>x</i>
         2
       <i>...x</i>
           <i>d</i>
           <i>exp</i>
where:
  signifies a plus sign or a minus sign;
 <i>yyy</i> are the 1 to 3 decimal digits representative of the most significant digits of the internal value after
  rounding (13.7.2.3.8);
 <i>yyy</i> is an integer such that 1<i>yyy</i> <i><</i> 1000 or, if the output value is zero, <i>yyy</i> = 0;
 . signifies a decimal symbol (13.6);
 <i>x</i>
   1
  <i>x</i>
    2
   <i>...x</i>
       <i>d</i>
       are the <i>d</i> next most significant digits of the internal value after rounding;
 <i>exp</i> is a decimal exponent, divisible by three, having one of the forms specified in Table 13.2.
             <b>Table</b> <b>13.2</b> <b>-</b> <b>EN</b> <b>exponent</b> <b>forms</b>
        Edit Descriptor Absolute Value of Exponent Form of Exponent
                                              1
        EN<i>w</i>.<i>d</i> with <i>w></i> 0 |<i>exp</i>| 99 E<i>z</i>
                                       1
                             <i>z</i>
                                         2
                                    or0<i>z</i>
                                             1
                                 <i>z</i>
                                              2
                                     99<i><</i>|<i>exp</i>| 999 <i>z</i>
                                         1
                              <i>z</i>
                                          2
                               <i>z</i>
                                           3
       EN<i>w</i>.<i>d</i> E<i>e</i> with <i>e></i> 0 |<i>exp</i>| 10
                          <i>e</i>
             - 1 E<i>z</i>
                                         1
                              <i>z</i>
                                          2
                               <i>...z</i>
                                         <i>e</i>
       EN<i>w</i>.<i>d</i> E0 or EN0.<i>d</i> any E<i>z</i>
                                         1
                              <i>z</i>
                                          2
                               <i>...z</i>
                                         <i>s</i>
       (1) where each <i>z</i> is a digit, and <i>s</i> is the minimum number of digits required to
       represent the exponent. A plus sign is produced if the exponent value is zero.
<b>NOTE</b>
Examples:
   <b>Internal</b> <b>value</b> <b>Output</b> <b>field</b> <b>using</b> <b>SS,</b> <b>EN12.3</b>
      6.421 6.421E+00
      -.5 -500.000E-03
      .00217 2.170E-03
    4721.3 4.721E+03
<b>13.7.2.3.5</b> <b>ES</b> <b>editing</b>
The ES edit descriptor produces an output field in the form of a real number in scientific notation such that the
absolute value of the significand (R715) is greater than or equal to 1 and less than 10, except when the output
value is zero. The scale factor has no effect on output.
The forms of the edit descriptor are ES<i>w</i>.<i>d</i> and ES<i>w</i>.<i>d</i> E<i>e</i> indicating that the external field occupies <i>w</i> positions,
except when <i>w</i> is zero in which case the processor selects the field width. The fractional part of the field contains
<i>d</i> digits. If <i>e</i> is positive the exponent part contains <i>e</i> digits, otherwise it contains the minimum number of digits
required to represent the exponent value.
The form and interpretation of the input field is the same as for F<i>w</i>.<i>d</i> editing (13.7.2.3.2).
For an internal value that is an IEEE infinity or NaN, the form of the output field is the same as for F<i>w</i>.<i>d</i>.
For an internal value that is neither an IEEE infinity nor a NaN, the form of the output field is
   [ ] <i>y</i> . <i>x</i>
       1
     <i>x</i>
        2
      <i>...x</i>
          <i>d</i>
          <i>exp</i>
where:
  signifies a plus sign or a minus sign;
 <i>y</i> isadecimaldigitrepresentativeofthemostsignificantdigitoftheinternalvalueafterrounding(13.7.2.3.8);
 . signifies a decimal symbol (13.6);
 <i>x</i>
   1
  <i>x</i>
    2
   <i>...x</i>
       <i>d</i>
       are the <i>d</i> next most significant digits of the internal value after rounding;
 <i>exp</i> is a decimal exponent having one of the forms specified in Table 13.3.
              <b>Table</b> <b>13.3</b> <b>-</b> <b>ES</b> <b>exponent</b> <b>forms</b>
        Edit Descriptor Absolute Value of Exponent Form of Exponent
                                              1
        ES<i>w</i>.<i>d</i> with <i>w></i> 0 |<i>exp</i>| 99 E<i>z</i>
                                       1
                             <i>z</i>
                                        2
                                    or0<i>z</i>
                                             1
                                 <i>z</i>
                                              2
                                    99<i><</i>|<i>exp</i>| 999 <i>z</i>
                                         1
                              <i>z</i>
                                          2
                               <i>z</i>
                                           3
       ES<i>w</i>.<i>d</i> E<i>e</i> with <i>e></i> 0 |<i>exp</i>| 10
                          <i>e</i>
            - 1 E<i>z</i>
                                         1
                              <i>z</i>
                                          2
                               <i>...z</i>
                                         <i>e</i>
       ES<i>w</i>.<i>d</i> E0 or ES0.<i>d</i> any E<i>z</i>
                                         1
                              <i>z</i>
                                          2
                               <i>...z</i>
                                         <i>s</i>
       (1) where each <i>z</i> is a digit, and <i>s</i> is the minimum number of digits required to
       represent the exponent. A plus sign is produced if the exponent value is zero.
<b>NOTE</b>
Examples:
   <b>Internal</b> <b>value</b> <b>Output</b> <b>field</b> <b>using</b> <b>SS,</b> <b>ES12.3</b>
      6.421 6.421E+00
      -.5 -5.000E-01
      .00217 2.170E-03
    4721.3 4.721E+03
<b>13.7.2.3.6</b> <b>EX</b> <b>editing</b>
The EX edit descriptor produces an output field in the form of a hexadecimal-significand number.
The EX<i>w</i>.<i>d</i> and EX<i>w</i>.<i>d</i>E<i>e</i> edit descriptors indicate that the external field occupies <i>w</i> positions, except when <i>w</i>
is zero in which case the processor selects the field width. The fractional part of the field contains <i>d</i> hexadecimal
digits, except when <i>d</i> is zero in which case the processor selects the number of hexadecimal digits to be the
minimum required so that the output field is equal to the internal value; <i>d</i> shall not be zero if the radix of the
internal value is not a power of two. The hexadecimal point, represented by a decimal symbol, appears after
the first hexadecimal digit. For the form EX<i>w</i>.<i>d</i>, and for EX<i>w</i>.<i>d</i>E0, the exponent part contains the minimum
number of digits needed to represent the exponent; otherwise the exponent contains <i>e</i> digits. The <i>e</i> has no effect
on input. The scale factor has no effect on output.
The form and interpretation of the input field is the same as for F<i>w</i>.<i>d</i> editing (13.7.2.3.2).
For an internal value that is an IEEE infinity or NaN, the form of the output field is the same as for F<i>w</i>.<i>d</i>.
For an internal value that is neither an IEEE infinity nor a NaN, the form of the output field is
   [ ] 0X <i>x</i>
       0
       . <i>x</i>
         1
       <i>x</i>
          2
        <i>...</i> <i>exp</i>
where:
  signifies a plus sign or a minus sign;
 . signifies a decimal symbol (13.6);
 <i>x</i>
   0
  <i>x</i>
    1
   <i>x</i>
     2
    <i>...</i> are the most significant hexadecimal digits of the internal value, after rounding if <i>d</i> is not zero
  (13.7.2.3.8);
 <i>exp</i> is a binary exponent expressed as a decimal integer; for EX<i>w</i>.<i>d</i> and EX<i>w</i>.<i>d</i>E0, the form is P<i>z</i>
                                                    1
                                       <i>...z</i>
                                                   <i>n</i>
                                                ,
  where <i>n</i> is the minimum number of digits needed to represent <i>exp</i>, and for EX<i>w</i>.<i>d</i>E<i>e</i> with <i>e</i> greater than
  zero the form is P<i>z</i>
             1
          <i>...z</i>
               <i>e</i>
              . The choice of binary exponent is processor dependent. If the most significant
  binary digits of the internal value are <i>b</i>
                      0
                <i>b</i>
                       1
                 <i>b</i>
                        2
                  <i>...</i>, the binary exponent might make the value of <i>x</i>
                                                  0
                                            be that of
  <i>b</i>
   0
   , <i>b</i>
     0
    <i>b</i>
      1
     , <i>b</i>
       0
      <i>b</i>
        1
      <i>b</i>
         2
         , or <i>b</i>
            0
         <i>b</i>
              1
          <i>b</i>
               2
           <i>b</i>
                3
              . A plus sign is produced if the exponent value is zero.
<b>NOTE</b>
Examples:
    <b>Internal</b> <b>value</b> <b>Edit</b> <b>descriptor</b> <b>Possible</b> <b>output</b> <b>with</b> <b>SS</b> <b>in</b> <b>effect</b>
             1<i>.</i>375 EX0.1 0X1.6P+0
   -15<i>.</i>625 EX14.4E3 -0X1.F400P+003
           1048580<i>.</i>0 EX0.0 0X1.00004P+20
             2<i>.</i>375 EX0.1 0X2.6P+0
<b>13.7.2.3.7</b> <b>Complex</b> <b>editing</b>
A complex datum consists of a pair of separate real data. The editing of a scalar datum of complex type is
specified by two edit descriptors each of which specifies the editing of real data. The first edit descriptor specifies
the editing for the real part; the second specifies it for the imaginary part. The two edit descriptors may be
different. Control and character string edit descriptors may be processed between the edit descriptor for the real
part and the edit descriptor for the imaginary part.
<b>13.7.2.3.8</b> <b>Input/output</b> <b>rounding</b> <b>mode</b>
The input/output rounding mode can be specified by an OPEN statement (12.5.2), a data transfer statement
(12.6.2.14), or an edit descriptor (13.8.8).
In what follows, the term "decimal value" means the exact decimal number as given by the character string, while
the term "internal value" means the number actually stored in the processor. For example, in dealing with the
decimal constant 0.1, the decimal value is the mathematical quantity 1/10, which has no exact representation
in binary form. Formatted output of real data involves conversion from an internal value to a decimal value;
formatted input involves conversion from a decimal value to an internal value.
When the input/output rounding mode is UP, the value resulting from conversion shall be the smallest represent-
able value that is greater than or equal to the original value. When the input/output rounding mode is DOWN,
the value resulting from conversion shall be the largest representable value that is less than or equal to the original
value. When the input/output rounding mode is ZERO, the value resulting from conversion shall be the value
closesttotheoriginalvalueandnogreaterinmagnitude than the original value. When the input/output rounding
mode is NEAREST, the value resulting from conversion shall be the closer of the two nearest representable values
if one is closer than the other. If the two nearest representable values are equidistant from the original value, it is
processor dependent which one of them is chosen. When the input/output rounding mode is COMPATIBLE, the
value resulting from conversion shall be the closer of the two nearest representable values or the value away from
zero if halfway between them. When the input/output rounding mode is PROCESSOR_DEFINED, rounding
during conversion shall be a processor-dependent default mode, which may correspond to one of the other modes.
OnprocessorsthatsupportIEEEroundingonconversions(17.4), NEARESTshallcorrespondtoroundtonearest,
as specified in ISO/IEC 60559:2020.
<b>NOTE</b>
On processors that support IEEE rounding on conversions, the input/output rounding modes COMPATIBLE
and NEAREST will produce the same results except when the datum is halfway between the two nearest
representable values. In that case, NEAREST will pick the even value, but COMPATIBLE will pick the
value away from zero. The input/output rounding modes UP, DOWN, and ZERO have the same effect as those
specified in ISO/IEC 60559:2020 for round toward +, round toward-, and round toward zero, respectively.
<b>13.7.2.4</b> <b>B,</b> <b>O,</b> <b>and</b> <b>Z</b> <b>editing</b>
The B<i>w</i>, B<i>w</i>.<i>m</i>, O<i>w</i>, O<i>w</i>.<i>m</i>, Z<i>w</i>, and Z<i>w</i>.<i>m</i> edit descriptors indicate that the field to be edited occupies <i>w</i>
positions, except when <i>w</i> is zero. When <i>w</i> is zero, the processor selects the field width. On input, <i>w</i> shall not be
zero. The corresponding effective item shall be of type integer, real, or complex, or of enum or enumeration type.
On input, <i>m</i> has no effect.
In the standard form of the input field for the B, O, and Z edit descriptors the character string consists of binary,
octal, or hexadecimal digits (as in R773, R774, R775) in the respective input field. The lower-case hexadecimal
digits a through f in a hexadecimal input field are equivalent to the corresponding upper-case hexadecimal digits.
If the input field does not have the standard form, and is not acceptable to the processor, an error condition
occurs.
Input editing produces the value INT (X) if the effective item is of type integer and REAL (X) if the effective
item is of type real or complex, where X is a <i>boz-literal-constant</i> that specifies the same bit sequence as the digits
of the input field. If the effective item is of enum or enumeration type ET, the value is ET (INT (X)).
The output field for the B<i>w</i>, O<i>w</i>, and Z<i>w</i> descriptors consists of zero or more leading blanks followed by the
internal value in a form identical to the digits of a binary, octal, or hexadecimal constant, respectively, that
specifies the same bit sequence but without leading zero bits.
<b>NOTE</b>
A binary, octal, or hexadecimal constant always consists of at least one digit or hexadecimal digit.
R1323 <i>hex-digit-string</i> <b>is</b> <i>hex-digit</i> [ <i>hex-digit</i> ] ...
The output field for the B<i>w</i>.<i>m</i>, O<i>w</i>.<i>m</i>, and Z<i>w</i>.<i>m</i> edit descriptor is the same as for the B<i>w</i>, O<i>w</i>, and Z<i>w</i> edit
descriptor, except that the <i>digit-string</i> or <i>hex-digit-string</i> consists of at least <i>m</i> digits. If necessary, sufficient
leading zeros are included to achieve the minimum of <i>m</i> digits. The value of <i>m</i> shall not exceed the value of <i>w</i>,
except when <i>w</i> is zero. If <i>m</i> is zero and the internal value consists of all zero bits, the output field consists of
only blank characters. When <i>m</i> and <i>w</i> are both zero, and the internal value consists of all zero bits, one blank
character is produced.
<b>13.7.3</b> <b>Logical</b> <b>editing</b>
The L<i>w</i> edit descriptor indicates that the field occupies <i>w</i> positions. The corresponding effective item shall be of
type logical. The G edit descriptor also may be used to edit logical data (13.7.5.3).
The standard form of the input field consists of optional blanks, optionally followed by a period, followed by a T
for true or F for false. The T or F may be followed by additional characters in the field, which are ignored. If the
input field does not have the standard form, and is not acceptable to the processor, an error condition occurs.
A lower-case letter is equivalent to the corresponding upper-case letter in a logical input field.
<b>NOTE</b>
The logical constants .TRUE. and .FALSE. are acceptable input forms.
The output field consists of <i>w</i>-1 blanks followed by a T or F, depending on whether the internal value is true or
false, respectively.
<b>13.7.4</b> <b>Character</b> <b>editing</b>
The A[<i>w</i>] edit descriptor is used with an effective item of type character. The AT edit descriptor is used with
an effective item of type character in an output statement; it shall not be used for input. The G edit descriptor
also may be used to edit character data (13.7.5.4). The kind type parameter of all characters transferred and
converted under control of one A, AT, or G edit descriptor is implied by the kind of the corresponding effective
item.
If a field width <i>w</i> is specified with the A edit descriptor, the field consists of <i>w</i> characters. If a field width <i>w</i> is
not specified with the A edit descriptor, the number of characters in the field is the length of the corresponding
effective item, regardless of the value of the kind type parameter.
Let <i>len</i> be the length of the effective item. If the specified field width <i>w</i> for an A edit descriptor corresponding
to an effective item on input is greater than or equal to <i>len</i>, the rightmost <i>len</i> characters will be taken from the
input field. If the specified field width <i>w</i> is less than <i>len</i>, the <i>w</i> characters will appear left justified with <i>len</i>-<i>w</i>
trailing blanks in the internal value.
If the specified field width <i>w</i> for an A edit descriptor corresponding to an effective item on output is greater than
<i>len</i>, the output field will consist of <i>w</i>-<i>len</i> blanks followed by the <i>len</i> characters from the internal value. If the
specified field width <i>w</i> is less than or equal to <i>len</i>, the output field will consist of the leftmost <i>w</i> characters from
the internal value.
The field width for an AT edit descriptor is the length of the value of the effective item after any trailing blanks
are removed. The output field consists of the value of the effective item after any trailing blanks are removed; if
the value of the effective item is all blanks, no output is produced by the edit descriptor.
<b>NOTE</b> <b>1</b>
For nondefault character kinds, the blank padding character is processor dependent.
If the file is connected for stream access, the output may be split across more than one record if it contains
newline characters. A newline character is a nonblank character returned by the intrinsic function NEW_LINE.
Beginning with the first character of the output field, each character that is not a newline is written to the current
record in successive positions; each newline character causes file positioning at that point as if by slash editing
(the current record is terminated at that point, a new empty record is created following the current record, this
new record becomes the last and current record of the file, and the file is positioned at the beginning of this new
record).
<b>NOTE</b> <b>2</b>
IftheintrinsicfunctionNEW_LINEreturnsablankcharacterforaparticularcharacterkind, thentheprocessor
does not support using a character of that kind to cause record termination in a formatted stream file.
<b>13.7.5</b> <b>Generalized</b> <b>editing</b>
<b>13.7.5.1</b> <b>Overview</b>
The G<i>w</i>, G<i>w</i>.<i>d</i> and G<i>w</i>.<i>d</i> E<i>e</i> edit descriptors are used with an effective item of enum type or any intrinsic type.
When<i>w</i> is nonzero, these edit descriptors indicate that the external field occupies <i>w</i> positions. For real or complex
data the fractional part consists of a maximum of <i>d</i> digits and the exponent part consists of <i>e</i> digits. When these
edit descriptors are used to specify the input/output of integer, logical, or character data, <i>d</i> and <i>e</i> have no effect.
When <i>w</i> is zero the processor selects the field width. On input, <i>w</i> shall not be zero.
<b>13.7.5.2</b> <b>Generalized</b> <b>numeric</b> <b>editing</b>
<b>13.7.5.2.1</b> <b>Overview</b>
When used to specify the input/output of integer, real, complex, and enum data, the G<i>w</i>, G<i>w</i>.<i>d</i> and G<i>w</i>.<i>d</i> E<i>e</i>
edit descriptors follow the general rules for numeric editing (13.7.2).
<b>NOTE</b>
The G<i>w</i>.<i>d</i> E<i>e</i> edit descriptor follows any additional rules for the E<i>w</i>.<i>d</i> E<i>e</i> edit descriptor.
<b>13.7.5.2.2</b> <b>Generalized</b> <b>integer</b> <b>and</b> <b>enum</b> <b>editing</b>
When used to specify the input/output of integer or enum data, the G<i>w</i>, G<i>w</i>.<i>d</i>, and G<i>w</i>.<i>d</i> E<i>e</i> edit descriptors
follow the rules for the I<i>w</i> edit descriptor (13.7.2.2). Note that <i>w</i> cannot be zero for input editing (13.7.5.1).
<b>13.7.5.2.3</b> <b>Generalized</b> <b>real</b> <b>and</b> <b>complex</b> <b>editing</b>
The form and interpretation of the input field for G<i>w</i>.<i>d</i> and G<i>w</i>.<i>d</i> E<i>e</i> editing is the same as for F<i>w</i>.<i>d</i> editing
(13.7.2.3.2). The rest of this subclause applies only to output editing.
If<i>w</i> is nonzero and <i>d</i> is zero, <i>k</i>PE<i>w</i>.0 or<i>k</i>PE<i>w</i>.0E<i>e</i> editing is used for G<i>w</i>.0 editing or G<i>w</i>.0E<i>e</i> editing respectively.
When used to specify the output of real or complex data that is not an IEEE infinity or NaN, the G0 and G0.<i>d</i>
edit descriptors follow the rules for the G<i>w</i>.<i>d</i>E<i>e</i> edit descriptor, except that any leading or trailing blanks are
removed. Reasonable processor-dependent values of <i>w</i>, <i>d</i> (if not specified), and <i>e</i> are used with each output value.
For an internal value that is an IEEE infinity or NaN, the form of the output field for the G<i>w</i>.<i>d</i> and G<i>w</i>.<i>d</i> E<i>e</i>
edit descriptors is the same as for F<i>w</i>.<i>d</i>, and the form of the output field for the G0 and G0.<i>d</i> edit descriptors is
the same as for F0.0.
Otherwise, the method of representation in the output field depends on the magnitude of the internal value
being edited. If the internal value is zero, let <i>s</i> be one. If the internal value is a number other than zero, let <i>N</i>
be the decimal value that is the result of converting the internal value to <i>d</i> significant digits according to the
input/output rounding mode and let <i>s</i> be the integer such that 10
                              <i>s</i>-1
               |<i>N</i>|<i><</i> 10
                                     <i>s</i>
                                   . If <i>s<</i> 0 or <i>s></i> <i>d</i>, <i>k</i>PE<i>w</i>.<i>d</i> or
<i>k</i>PE<i>w</i>.<i>d</i>E<i>e</i> editing is used for G<i>w</i>.<i>d</i> editing or G<i>w</i>.<i>d</i>E<i>e</i> editing respectively, where <i>k</i> is the scale factor (13.8.6).
If 0<i>s</i> <i>d</i>, the scale factor has no effect and F(<i>w</i>-<i>n</i>).(<i>d</i>-<i>s</i>),<i>n</i>('<i>b</i>') editing is used where <i>b</i> is a blank and <i>n</i> is
4 for G<i>w</i>.<i>d</i> editing, <i>e</i> + 2 for G<i>w</i>.<i>d</i>E<i>e</i> editing if <i>e></i> 0, and 4 for G<i>w</i>.<i>d</i>E0 editing.
The value of <i>w</i>-<i>n</i> shall be positive.
<b>NOTE</b>
The scale factor has no effect on output unless the magnitude of the datum to be edited is outside the range
that permits effective use of F editing.
<b>13.7.5.3</b> <b>Generalized</b> <b>logical</b> <b>editing</b>
When used to specify the input/output of logical data, the G<i>w</i>.<i>d</i> and G<i>w</i>.<i>d</i> E<i>e</i> edit descriptors with nonzero <i>w</i>
follow the rules for the L<i>w</i> edit descriptor (13.7.3). When used to specify the output of logical data, the G0 and
G0.<i>d</i> edit descriptors follow the rules for the L1 edit descriptor.
<b>13.7.5.4</b> <b>Generalized</b> <b>character</b> <b>editing</b>
When used to specify the input/output of character data, the G<i>w</i>.<i>d</i> and G<i>w</i>.<i>d</i> E<i>e</i> edit descriptors with nonzero
<i>w</i> follow the rules for the A<i>w</i> edit descriptor (13.7.4). When used to specify the output of character data, the G0
and G0.<i>d</i> edit descriptors follow the rules for the A edit descriptor with no field width.
<b>13.7.6</b> <b>User-defined</b> <b>derived-type</b> <b>editing</b>
The DT edit descriptor specifies that a user-provided procedure shall be used instead of the processor's default
input/output formatting for processing an effective item of derived type.
The DT edit descriptor may include a character literal constant. The character value "DT" concatenated with the
character literal constant is passed to the defined input/output procedure as the iotype argument (12.6.4.8). The
<i>v</i> values of the edit descriptor are passed to the defined input/output procedure as the v_list array argument.
<b>NOTE</b>
For the edit descriptor DT'Link List'(10, 4, 2), iotype is "DTLink List" and v_list is [10, 4, 2].
If a derived-type variable or value corresponds to a DT edit descriptor, there shall be an accessible interface to
a corresponding defined input/output procedure for that derived type (12.6.4.8). A DT edit descriptor shall not
correspond to an effective item that is not of a derived type.
<b>13.8</b> <b>Control</b> <b>edit</b> <b>descriptors</b>
<b>13.8.1</b> <b>Position</b> <b>edit</b> <b>descriptors</b>
<b>13.8.1.1</b> <b>Position</b> <b>editing</b>
The position edit descriptors T, TL, TR, and X, specify the position at which the next character will be transmit-
ted to or from the record. If any character skipped by a position edit descriptor is of type nondefault character,
and the unit is a default character internal file or an external non-Unicode file, the result of that position editing
is processor dependent.
On input, if the position specified by a position edit descriptor is before the current position, portions of a record
can be processed more than once, possibly with different editing.
On input, a position beyond the last character of the record may be specified if no characters are transmitted
from such positions.
On output, a position edit descriptor does not by itself cause characters to be transmitted and therefore does not
by itself affect the length of the record. If characters are transmitted to positions at or after the position specified
by a position edit descriptor, positions skipped and not previously filled are filled with blanks. The result is as if
the entire record were initially filled with blanks.
On output, a character in the record can be replaced. A position edit descriptor never directly causes a character
already placed in the record to be replaced, but it might result in positioning such that subsequent editing causes
a replacement.
<b>13.8.1.2</b> <b>T,</b> <b>TL,</b> <b>and</b> <b>TR</b> <b>editing</b>
The left tab limit affects file positioning by the T and TL edit descriptors. Immediately prior to nonchild data
transfer (12.6.4.8.3), the left tab limit becomes defined as the character position of the current record or the
current position of the stream file. If, during data transfer, the file is positioned to another record, the left tab
limit becomes defined as character position one of that record.
The T<i>n</i> edit descriptor indicates that the transmission of the next character to or from a record is to occur at
the <i>n</i>th character position of the record, relative to the left tab limit. This position can be in either direction
from the current position.
The TL<i>n</i> edit descriptor indicates that the transmission of the next character to or from the record is to occur at
thecharacterposition<i>n</i> charactersbackwardfromthecurrentposition. However, if <i>n</i> isgreaterthanthedifference
between the current position and the left tab limit, the TL<i>n</i> edit descriptor indicates that the transmission of
the next character to or from the record is to occur at the left tab limit.
The TR<i>n</i> edit descriptor indicates that the transmission of the next character to or from the record is to occur
at the character position <i>n</i> characters forward from the current position.
<b>13.8.1.3</b> <b>X</b> <b>editing</b>
The <i>n</i>X edit descriptor indicates that the transmission of the next character to or from a record is to occur at
the character position <i>n</i> characters forward from the current position.
<b>NOTE</b>
An <i>n</i>X edit descriptor has the same effect as a TR<i>n</i> edit descriptor.
<b>13.8.2</b> <b>Slash</b> <b>editing</b>
The slash edit descriptor indicates the end of data transfer to or from the current record.
On input from a file connected for sequential or stream access, the remaining portion of the current record is
skipped and the file is positioned at the beginning of the next record. This record becomes the current record.
On output to a file connected for sequential or stream access, a new empty record is created following the current
record; this new record then becomes the last and current record of the file and the file is positioned at the
beginning of this new record.
For a file connected for direct access, the record number is increased by one and the file is positioned at the
beginning of the record that has that record number, if there is such a record, and this record becomes the
current record.
<b>NOTE</b>
A record that contains no characters can be written on output; if the file is an internal file or a file connected
for direct access, the record is filled with blank characters.
An entire record can be skipped on input.
The repeat specification is optional in the slash edit descriptor. If it is not specified, the default value is one.
<b>13.8.3</b> <b>Colon</b> <b>editing</b>
The colon edit descriptor terminates format control if there are no more effective items in the input/output list
(12.6.3). The colon edit descriptor has no effect if there are more effective items in the input/output list.
<b>13.8.4</b> <b>SS,</b> <b>SP,</b> <b>and</b> <b>S</b> <b>editing</b>
The SS, SP, and S edit descriptors temporarily change (12.5.2) the sign mode (12.5.6.18, 12.6.2.15) for the
connection. The edit descriptors SS, SP, and S set the sign mode corresponding to the SIGN= specifier values
SUPPRESS, PLUS, and PROCESSOR_DEFINED, respectively.
The sign mode controls optional plus characters in numeric output fields. When the sign mode is PLUS, the
processor shall produce a plus sign in any position that normally contains an optional plus sign. When the
sign mode is SUPPRESS, the processor shall not produce a plus sign in such positions. When the sign mode is
PROCESSOR_DEFINED, the processor has the option of producing a plus sign or not in such positions, subject
to 13.7.2(5).
The SS, SP, and S edit descriptors affect only I, F, E, EN, ES, EX, D, and G editing during the execution of an
output statement. The SS, SP, and S edit descriptors have no effect during the execution of an input statement.
<b>13.8.5</b> <b>LZS,</b> <b>LZP</b> <b>and</b> <b>LZ</b> <b>editing</b>
The LZS, LZP, and LZ edit descriptors temporarily change (12.5.2) the leading zero mode (12.5.6.12, 12.6.2.10)
for the connection. The edit descriptors LZS, LZP, and LZ set the leading zero mode corresponding to the
LEADING_ZERO= specifier values SUPPRESS, PRINT, and PROCESSOR_DEFINED, respectively.
The leading zero mode controls optional leading zero characters in numeric output fields. When the leading zero
mode is PRINT, the processor shall produce a leading zero in any position that normally contains an optional
leading zero. When the leading zero mode is SUPPRESS, the processor shall not produce a leading zero in such
positions. When the leading zero mode is PROCESSOR_DEFINED, the processor has the option of producing
a leading zero or not in such positions, subject to 13.7.2(5).
The LZS, LZP, and LZ edit descriptors affect only F, E, D, and G editing during the execution of an output
statement. The LZS, LZP, and LZ edit descriptors have no effect during the execution of an input statement.
<b>13.8.6</b> <b>P</b> <b>editing</b>
The <i>k</i>P edit descriptor temporarily changes (12.5.2) the scale factor for the connection to <i>k</i>. The scale factor
affects the editing done by the F, E, EN, ES, EX, D, and G edit descriptors for real and complex quantities.
The scale factor <i>k</i> affects the appropriate editing in the following manner.
 On input, with F, E, EN, ES, EX, D, and G editing (provided that no exponent exists in the field), the
  effect is that the externally represented number equals the internally represented number multiplied by 10
                                                   <i>k</i>
                                                ;
  the scale factor is applied to the external decimal value and then this is converted using the input/output
  rounding mode.
 On input, with F, E, EN, ES, EX, D, and G editing, the scale factor has no effect if there is an exponent
  in the field.
 On output, with F output editing, the effect is that the externally represented number equals the internally
  represented number multiplied by 10
                    <i>k</i>
                   ; the internal value is converted using the input/output rounding
  mode and then the scale factor is applied to the converted decimal value.
 On output, with E and D editing, the effect is that the significand (R715) part of the quantity to be
  produced is multiplied by 10
               <i>k</i>
               and the exponent is reduced by <i>k</i>.
 On output, with G editing, the effect is suspended unless the magnitude of the datum to be edited is outside
  the range that permits the use of F editing. If the use of E editing is required, the scale factor has the same
  effect as with E output editing.
 On output, with EN, ES, and EX editing, the scale factor has no effect.
<b>13.8.7</b> <b>BN</b> <b>and</b> <b>BZ</b> <b>editing</b>
The BN and BZ edit descriptors temporarily change (12.5.2) the blank interpretation mode (12.5.6.6, 12.6.2.6)
for the connection. The edit descriptors BN and BZ set the blank interpretation mode corresponding to the
BLANK= specifier values NULL and ZERO, respectively.
The blank interpretation mode controls the interpretation of nonleading blanks in numeric input fields. Such
blank characters are interpreted as zeros when the blank interpretation mode has the value ZERO; they are
ignored when the blank interpretation mode has the value NULL. The effect of ignoring blanks is to treat the
input field as if blanks had been removed, the remaining portion of the field right justified, and the blanks replaced
as leading blanks. However, a field containing only blanks has the value zero.
The blank interpretation mode affects only numeric editing (13.7.2) and generalized numeric editing (13.7.5.2)
on input. It has no effect on output.
<b>13.8.8</b> <b>RU,</b> <b>RD,</b> <b>RZ,</b> <b>RN,</b> <b>RC,</b> <b>and</b> <b>RP</b> <b>editing</b>
The round edit descriptors temporarily change (12.5.2) the connection's input/output rounding mode (12.5.6.17,
12.6.2.14, 13.7.2.3.8). The round edit descriptors RU, RD, RZ, RN, RC, and RP set the input/output rounding
mode corresponding to the ROUND= specifier values UP, DOWN, ZERO, NEAREST, COMPATIBLE, and
PROCESSOR_DEFINED, respectively. The input/output rounding mode affects the conversion of real and
complex values in formatted input/output. It affects only D, E, EN, ES, EX, F, and G editing.
<b>13.8.9</b> <b>DC</b> <b>and</b> <b>DP</b> <b>editing</b>
The decimal edit descriptors temporarily change (12.5.2) the decimal edit mode (12.5.6.7, 12.6.2.7, 13.6) for
the connection. The edit descriptors DC and DP set the decimal edit mode corresponding to the DECIMAL=
specifier values COMMA and POINT, respectively.
The decimal edit mode controls the representation of the decimal symbol (13.6) during conversion of real and
complex values in formatted input/output. The decimal edit mode affects only D, E, EN, ES, EX, F, and G
editing.
<b>13.9</b> <b>Character</b> <b>string</b> <b>edit</b> <b>descriptors</b>
A character string edit descriptor shall not be used on input.
The character string edit descriptor causes characters to be written from the enclosed characters of the edit
descriptor itself, including blanks. For a character string edit descriptor, the width of the field is the number of
characters between the delimiting characters. Within the field, two consecutive delimiting characters are counted
as a single character.
<b>NOTE</b>
A delimiter for a character string edit descriptor is either an apostrophe or quote.
<b>13.10</b> <b>List-directed</b> <b>formatting</b>
<b>13.10.1</b> <b>Purpose</b> <b>of</b> <b>list-directed</b> <b>formatting</b>
List-directed input/output allows data editing according to the type of the effective item instead of by a format
specification. It also allows data to be free-field, that is, separated by commas (or semicolons) or blanks.
<b>13.10.2</b> <b>Values</b> <b>and</b> <b>value</b> <b>separators</b>
The characters in one or more list-directed records constitute a sequence of values and value separators. The end
of a record has the same effect as a blank character, unless it is within a character constant. Any sequence of two
or more consecutive blanks is treated as a single blank, unless it is within a character constant.
Each value is either a null value, <i>c</i>, <i>r</i>*<i>c</i>, or <i>r</i>*, where <i>c</i> is a literal constant, optionally signed if integer or real, or
an undelimited character constant and <i>r</i> is an unsigned, nonzero, integer literal constant. Neither <i>c</i> nor <i>r</i> shall
have kind type parameters specified. The constant <i>c</i> is interpreted as though it had the same kind type parameter
as the corresponding effective item. The <i>r</i>*<i>c</i> form is equivalent to <i>r</i> successive appearances of the constant <i>c</i>,
and the <i>r</i>* form is equivalent to <i>r</i> successive appearances of the null value. Neither of these forms shall contain
embedded blanks, except where permitted within the constant <i>c</i>.
A value separator is
 a comma optionally preceded by one or more contiguous blanks and optionally followed by one or more
  contiguous blanks, unless the decimal edit mode is COMMA, in which case a semicolon is used in place of
  the comma,
 a slash optionally preceded by one or more contiguous blanks and optionally followed by one or more
  contiguous blanks, or
 one or more contiguous blanks between two nonblank values or following the last nonblank value, where a
  nonblank value is a constant, an <i>r</i>*<i>c</i> form, or an <i>r</i>* form.
<b>NOTE</b> <b>1</b>
Although a slash encountered in an input record is referred to as a separator, it actually causes termination of
list-directed and namelist input statements; it does not actually separate two values.
<b>NOTE</b> <b>2</b>
If no effective item is specified in a list-directed input/output statement, one input record is skipped or one
empty output record is written.
<b>13.10.3</b> <b>List-directed</b> <b>input</b>
<b>13.10.3.1</b> <b>List-directed</b> <b>input</b> <b>forms</b>
Input forms acceptable to edit descriptors for a given type are acceptable for list-directed formatting, except as
noted below. If the form of the input value is not acceptable to the processor for the type of the next effective
item in the list, an error condition occurs. Blanks are never used as zeros, and embedded blanks are not permitted
in constants, except within character constants and complex constants as specified below.
For the <i>r</i>*<i>c</i> form of an input value, the constant <i>c</i> is interpreted as an undelimited character constant if the first
effective item corresponding to this value is default, ASCII, or ISO 10646 character, there is a nonblank character
immediately after <i>r</i>*, and that character is not an apostrophe or a quotation mark; otherwise, <i>c</i> is interpreted as
a literal constant.
<b>NOTE</b> <b>1</b>
The end of a record has the effect of a blank, except when it appears within a character constant.
When the next effective item is of type integer or of an enum type, the value in the input record is interpreted as
if an I<i>w</i> edit descriptor with a suitable value of <i>w</i> were used.
When the next effective item is of type real, the input form is that of a numeric input field. A numeric input field
is a field suitable for F editing (13.7.2.3.2) that is assumed to have no fractional digits unless a decimal symbol
appears within the field.
When the next effective item is of type complex, the input form consists of a left parenthesis followed by an
ordered pair of numeric input fields separated by a comma (if the decimal edit mode is POINT) or semicolon
(if the decimal edit mode is COMMA), and followed by a right parenthesis. The first numeric input field is the
real part of the complex constant and the second is the imaginary part. Each of the numeric input fields may be
preceded or followed by any number of blanks and ends of records. The end of a record may occur after the real
part or before the imaginary part.
When the next effective item is of type logical, the input form shall not include value separators among the
optional characters permitted for L editing.
When the next effective item is of type character, the input form consists of a possibly delimited sequence of zero
or more <i>rep-char</i>s whose kind type parameter is implied by the kind of the effective item. Character sequences
may be continued from the end of one record to the beginning of the next record, but the end of record shall
not occur between a doubled apostrophe in an apostrophe-delimited character sequence, nor between a doubled
quote in a quote-delimited character sequence. The end of the record does not cause a blank or any other
character to become part of the character sequence. The character sequence may be continued on as many
records as needed. The characters blank, comma, semicolon, and slash may appear in default, ASCII, or ISO
10646 character sequences.
If the next effective item is default, ASCII, or ISO 10646 character and
 the character sequence does not contain value separators,
 the character sequence does not cross a record boundary,
 the first nonblank character is not a quotation mark or an apostrophe,
 the leading characters are not <i>digit</i>s followed by an asterisk, and
 the character sequence contains at least one character,
the delimiting apostrophes or quotation marks are not required. If the delimiters are omitted, the character
sequence is terminated by the first blank, comma (if the decimal edit mode is POINT), semicolon (if the decimal
edit mode is COMMA), slash, or end of record; in this case apostrophes and quotation marks within the datum
are not to be doubled.
Let <i>len</i> be the current length of the next effective item, and let <i>w</i> be the length of the character sequence. If <i>len</i>
is less than or equal to <i>w</i>, the leftmost <i>len</i> characters of the sequence are transmitted to the next effective item.
If <i>len</i> is greater than <i>w</i>, the sequence is transmitted to the leftmost <i>w</i> characters of the next effective item and
the remaining <i>len</i>-<i>w</i> characters of the next effective item are filled with blanks.
<b>NOTE</b> <b>2</b>
An allocatable, deferred-length character effective item does not have its allocation status or allocated length
changed as a result of list-directed input.
<b>13.10.3.2</b> <b>Null</b> <b>values</b>
A null value is specified by
 the <i>r</i>* form,
 no characters between consecutive value separators, or
 no characters before the first value separator in the first record read by each execution of a list-directed
  input statement.
<b>NOTE</b> <b>1</b>
The end of a record following any other value separator, with or without separating blanks, does not specify a
null value in list-directed input.
A null value has no effect on the definition status of the next effective item. A null value shall not be used for
either the real or imaginary part of a complex constant, but a single null value may represent an entire complex
constant.
A slash encountered as a value separator during execution of a list-directed input statement causes termination
of execution of that input statement after the transference of the previous value. Any characters remaining in the
current record are ignored. If there are additional effective items, the effect is as if null values had been supplied
for them. Any <i>do-variable</i> in the input list becomes defined as if enough null values had been supplied for any
remaining effective items.
<b>NOTE</b> <b>2</b>
All blanks encountered during list-directed input are considered to be part of some value separator except for
  blanks embedded in a character sequence,
  embedded blanks surrounding the real or imaginary part of a complex constant, and
  leading blanks in the first record read by each execution of a list-directed input statement, unless imme-
  diately followed by a slash or comma.
<b>NOTE</b> <b>3</b>
List-directed input example:
   INTEGER I; REAL X (8); CHARACTER (11) P; COMPLEX Z; LOGICAL G
    ...
   READ *, I, X, P, Z, G
The input data records are:
   12345,12345,,2*1.5,4*
   ISN'T_BOB'S,(123,0),.TEXAS$
The results are:
   <b>Variable</b> <b>Value</b>
    I 12345
    X (1) 12345.0
    X (2) unchanged
    X (3) 1.5
    X (4) 1.5
    X (5) - X (8) unchanged
    P ISN'T_BOB'S
    Z (123.0,0.0)
    G true
<b>13.10.4</b> <b>List-directed</b> <b>output</b>
The form of the values produced is the same as that required for input, except as noted otherwise. With the
exception of adjacent undelimited character sequences, the values are separated by one or more blanks or by a
comma, or a semicolon if the decimal edit mode is COMMA, optionally preceded by one or more blanks and
optionally followed by one or more blanks. Two undelimited character sequences are considered adjacent when
both were written using list-directed input/output, no intervening data transfer or file positioning operations on
that unit occurred, and both were written either by a single data transfer statement, or during the execution of
a parent data transfer statement along with its child data transfer statements. The form of the values produced
by defined output (12.6.4.8) is determined by the defined output procedure; this form need not be compatible
with list-directed input.
The processor may begin new records as necessary, but the end of record shall not occur within a constant except
as specified for complex constants and character sequences. The processor shall not insert blanks within character
sequences or within constants, except as specified for complex constants.
Logical output values are T for the value true and F for the value false.
Integer output constants are produced with the effect of an I<i>w</i> edit descriptor.
Real constants are produced with the effect of either an F edit descriptor or an E edit descriptor, depending on
the magnitude <i>x</i> of the value and a range 10
                    <i>d</i>1
          <i>x<</i> 10
                          <i>d</i>2
                         , where <i>d</i>
                                  1
                              and <i>d</i>
                                     2
                                 are processor-dependent integers. If
the magnitude <i>x</i> is within this range or is zero, the constant is produced using 0PF<i>w</i>.<i>d</i>; otherwise, 1PE<i>w</i>.<i>d</i> E<i>e</i> is
used.
For numeric output, reasonable processor-dependent values of <i>w</i>, <i>d</i>, and <i>e</i> are used for each of the numeric
constants output.
Complex constants are enclosed in parentheses with a separator between the real and imaginary parts, each
produced as defined above for real constants. The separator is a comma if the decimal edit mode is POINT; it is
a semicolon if the decimal edit mode is COMMA. The end of a record shall not occur between the separator and
the imaginary part unless the entire constant is as long as, or longer than, an entire record. The only embedded
blanks permitted within a complex constant are between the separator and the end of a record and one blank at
the beginning of the next record.
Character sequences produced when the delimiter mode has a value of NONE
 are not delimited by apostrophes or quotation marks,
 are not separated from each other by value separators,
 have each internal apostrophe or quotation mark represented externally by one apostrophe or quotation
  mark, and
 have a blank character inserted by the processor at the beginning of any record that begins with the
  continuation of a character sequence from the preceding record.
Character sequences produced when the delimiter mode has a value of QUOTE are delimited by quotes, are
preceded and followed by a value separator, and have each internal quote represented on the external medium by
two contiguous quotes.
Character sequences produced when the delimiter mode has a value of APOSTROPHE are delimited by apo-
strophes, are preceded and followed by a value separator, and have each internal apostrophe represented on the
external medium by two contiguous apostrophes.
Iftwoormoresuccessivevaluesinanoutputrecordhaveidenticalvalues, theprocessorhastheoptionofproducing
a repeated constant of the form <i>r</i>*<i>c</i> instead of the sequence of identical values.
Slashes, as value separators, and null values are not produced as output by list-directed formatting.
Except for new records created by explicit formatting within a defined output procedure or by continuation of
delimited character sequences, each output record begins with a blank character.
<b>NOTE</b>
The length of the output records is not specified and is processor dependent.
<b>13.11</b> <b>Namelist</b> <b>formatting</b>
<b>13.11.1</b> <b>Purpose</b> <b>of</b> <b>namelist</b> <b>formatting</b>
Namelist input/output allows data editing with name-value subsequences. This facilitates documentation of input
and output files and more flexibility on input.
<b>13.11.2</b> <b>Name-value</b> <b>subsequences</b>
The characters in one or more namelist records constitute a sequence of name-value subsequences, each of which
consists of an object designator followed by an equals and followed by one or more values and value separators.
The equals may optionally be preceded or followed by one or more contiguous blanks. The end of a record has the
same effect as a blank character, unless it is within a character constant. Any sequence of two or more consecutive
blanks is treated as a single blank, unless it is within a character constant.
Each object designator shall begin with a name from the <i>namelist-group-object-list</i> (8.9) and shall follow the
syntax of <i>designator</i> (R901). It shall not contain a vector subscript or an <i>image-selector</i> and shall not designate a
zero-sized array, a zero-sized array section, or a zero-length character string. Each subscript, stride, and substring
range expression shall be an optionally signed integer literal constant with no kind type parameter specified. If
a section subscript list appears, the number of section subscripts shall be equal to the rank of the object. If
the namelist group object is of derived type, the designator in the input record may be either the name of the
variable or the designator of one of its components, indicated by qualifying the variable name with the appropriate
component name. Successive qualifications may be applied as appropriate to the shape and type of the variable
represented. Each designator may be preceded and followed by one or more optional blanks but shall not contain
embedded blanks.
A value separator for namelist formatting is the same as for list-directed formatting (13.10.2), or one or more
contiguous blanks between a nonblank value and the following object designator or namelist comment (13.11.3.6).
<b>13.11.3</b> <b>Namelist</b> <b>input</b>
<b>13.11.3.1</b> <b>Overall</b> <b>syntax</b>
Input for a namelist input statement consists of
  (1) optional blanks and namelist comments,
  (2) the character & followed immediately by the <i>namelist-group-name</i> as specified in the NAMELIST
     statement,
  (3) one or more blanks,
  (4) a sequence of zero or more name-value subsequences separated by value separators, and
  (5) a slash to terminate the namelist input.
<b>NOTE</b>
A slash encountered in a namelist input record causes the input statement to terminate. A slash cannot be used
to separate two values in a namelist input statement.
The order of the name-value subsequences in the input records need not match the order of the <i>namelist-group-</i>
<i>object-list</i>. The input records need not specify all objects in the <i>namelist-group-object-list</i>. They may specify a
part of an object more than once.
A group name or object name is without regard to case.
<b>13.11.3.2</b> <b>Namelist</b> <b>input</b> <b>processing</b>
The name-value subsequences are evaluated serially, in left-to-right order. A namelist group object designator
may appear in more than one name-value subsequence. The definition status of an object that is not a subobject
of a designator in any name-value subsequence remains unchanged.
When the designator in the input record represents an array variable or a variable of derived type, the effect is
as if the variable represented were expanded into a sequence of scalar list items (effective items), in the same way
that formatted input/output list items are expanded (12.6.3). The number of values following the equals shall
not exceed the number of effective items, but may be less; in the latter case, the effect is as if sufficient null values
had been appended to match any remaining effective items. Except as noted elsewhere in this subclause, if an
input value is not acceptable to the processor for the type of the corresponding effective item, an error condition
occurs.
<b>NOTE</b>
For example, if the designator in the input record designates an integer array of size 100, at most 100 values,
each of which is either a digit string or a null value, can follow the equals; these values would then be assigned
to the elements of the array in array element order.
A slash encountered as a value separator during the execution of a namelist input statement causes termination
of execution of that input statement after transference of the previous value. If there are additional items in the
namelist group object being transferred, the effect is as if null values had been supplied for them.
Successive namelist records are read by namelist input until a slash is encountered; the remainder of the record
is ignored.
A namelist comment may appear after any value separator except a slash (which terminates namelist input). A
namelist comment is also permitted to start in the first nonblank position of an input record except within a
character literal constant.
<b>13.11.3.3</b> <b>Namelist</b> <b>input</b> <b>values</b>
Each value is either a null value (13.11.3.4), <i>c</i>, <i>r</i>*<i>c</i>, or <i>r</i>*, where <i>c</i> is a literal constant, optionally signed if integer
or real, and <i>r</i> is an unsigned, nonzero, integer literal constant. A kind type parameter shall not be specified for <i>c</i>
or <i>r</i>. The constant <i>c</i> is interpreted as though it had the same kind type parameter as the corresponding effective
item. The <i>r</i>*<i>c</i> form is equivalent to <i>r</i> successive appearances of the constant <i>c</i>, and the <i>r</i>* form is equivalent to
<i>r</i> successive null values. Neither of these forms shall contain embedded blanks, except where permitted within
the constant <i>c</i>.
The datum <i>c</i> (13.11) is any input value acceptable to format specifications for a given type, except for restrictions
on the form of input values specified in this subclause. The form of a real or complex value is dependent on the
decimaleditmodeineffect(13.6). Theformof an input value shall be acceptable for the type of the corresponding
effective item. The number and forms of the input values that may follow the equals in a name-value subsequence
depend on the shape and type of the object represented by the name in the input record. When the name in
the input record is that of a scalar variable of an intrinsic type, the equals shall not be followed by more than
one value. Blanks are never used as zeros, and embedded blanks are not permitted in constants except within
character constants and complex constants as specified in this subclause.
When the next effective item is of type real, the input form of the input value is that of a numeric input field. A
numeric input field is a field suitable for F editing (13.7.2.3.2) that is assumed to have no fractional digits unless
a decimal symbol appears within the field.
When the next effective item is of type complex, the input form of the input value consists of a left parenthesis
followed by an ordered pair of numeric input fields separated by a comma (if the decimal edit mode is POINT) or
a semicolon (if the decimal edit mode is COMMA), and followed by a right parenthesis. The first numeric input
field is the real part of the complex constant and the second field is the imaginary part. Each of the numeric
input fields may be preceded or followed by any number of blanks and ends of records. The end of a record may
occur between the real part and the comma or semicolon, or between the comma or semicolon and the imaginary
part.
When the next effective item is of type logical, the input form of the input value shall not include equals or value
separators among the optional characters permitted for L editing (13.7.3).
When the next effective item is of type integer or of an enum type, the value in the input record is interpreted as
if an I<i>w</i> edit descriptor with a suitable value of <i>w</i> were used.
When the next effective item is of type character, the input form consists of a sequence of zero or more <i>rep-char</i>s
whose kind type parameter is implied by the kind of that effective item, delimited by apostrophes or quotes.
Such a sequence may be continued from the end of one record to the beginning of the next record, but the end of
record shall not occur between a doubled apostrophe in an apostrophe-delimited sequence, nor between a doubled
quote in a quote-delimited sequence. The end of the record does not cause a blank or any other character to
become part of the sequence. The sequence may be continued on as many records as needed. The characters
blank, comma, semicolon, and slash may appear in such character sequences.
<b>NOTE</b>
The delimiters in the input form for a namelist input item of type character avoid the ambiguity that could
arise between undelimited character sequences and object names. The value of the DELIM= specifier, if any,
in the OPEN statement for an external file is ignored during namelist input (12.5.6.8).
Let <i>len</i> be the length of the next effective item, and let <i>w</i> be the length of the character sequence. If <i>len</i> is less
than or equal to <i>w</i>, the leftmost <i>len</i> characters of the sequence are transmitted to the next effective item. If <i>len</i>
is greater than <i>w</i>, the constant is transmitted to the leftmost <i>w</i> characters of the next effective item and the
remaining <i>len</i>-<i>w</i> characters of the next effective item are filled with blanks. The effect is as though the sequence
were assigned to the next effective item in an intrinsic assignment statement (10.2.1.3).
<b>13.11.3.4</b> <b>Null</b> <b>values</b>
A null value is specified by
 the <i>r</i>* form,
 blanks between two consecutive nonblank value separators following an equals,
 a value separator that is the first nonblank character following an equals, or
 two consecutive nonblank value separators.
A null value has no effect on the definition status of the corresponding effective item. If the effective item is
defined, it retains its previous value; if it is undefined, it remains undefined. A null value shall not be used as
either the real or imaginary part of a complex constant, but a single null value may represent an entire complex
constant.
<b>NOTE</b>
The end of a record following a value separator, with or without intervening blanks, does not specify a null
value in namelist input.
<b>13.11.3.5</b> <b>Blanks</b>
All blanks in a namelist input record are considered to be part of some value separator except for
 blanks embedded in a character constant,
 embedded blanks surrounding the real or imaginary part of a complex constant,
 leading blanks following the equals unless followed immediately by a slash or comma, or a semicolon if the
  decimal edit mode is COMMA, and
 blanks between a name and the following equals.
<b>13.11.3.6</b> <b>Namelist</b> <b>comments</b>
Except within a character literal constant, a "!" character after a value separator or in the first nonblank position
of a namelist input record initiates a comment. The comment extends to the end of the record and may contain
any graphic character in the processor-dependent character set. The comment is ignored. A slash within the
namelist comment does not terminate execution of the namelist input statement. Namelist comments are not
allowed in stream input because comments depend on record structure.
<b>NOTE</b>
Namelist input example:
   INTEGER I; REAL X (8); CHARACTER (11) P; COMPLEX Z; LOGICAL G
   NAMELIST / TODAY / G, I, P, Z, X
   READ (*, NML = TODAY)
The input data records are:
   &TODAY I = 12345, X(1) = 12345, X(3:4) = 2*1.5, I=6, ! This is a comment.
   P = ''ISN'T_BOB'S'', Z = (123,0)/
The results stored are:
   <b>Variable</b> <b>Value</b>
    I 6
    X (1) 12345.0
    X (2) unchanged
    X (3) 1.5
    X (4) 1.5
    X (5) - X (8) unchanged
    P ISN'T_BOB'S
    Z (123.0,0.0)
    G unchanged
<b>13.11.4</b> <b>Namelist</b> <b>output</b>
<b>13.11.4.1</b> <b>Form</b> <b>of</b> <b>namelist</b> <b>output</b>
The form of the output produced by intrinsic namelist output shall be suitable for input, except for character
output. The names in the output are in upper case. With the exception of adjacent undelimited character
values, the values are separated by one or more blanks or by a comma, or a semicolon if the decimal edit mode is
COMMA, optionally preceded by one or more blanks and optionally followed by one or more blanks. The form
of the output produced by defined output (12.6.4.8) is determined by the defined output procedure; this form
need not be compatible with namelist input.
Namelist output shall not include namelist comments.
The processor may begin new records as necessary. However, except for complex constants and character values,
the end of a record shall not occur within a constant, character value, or name, and blanks shall not appear
within a constant, character value, or name.
<b>NOTE</b>
The length of the output records is not specified exactly and is processor dependent.
<b>13.11.4.2</b> <b>Namelist</b> <b>output</b> <b>editing</b>
Values in namelist output records are edited as for list-directed output (13.10.4).
<b>NOTE</b>
NamelistoutputrecordsproducedwithaDELIM=specifierwithavalueofNONEandwhichcontainacharacter
sequence might not be acceptable as namelist input records.
<b>13.11.4.3</b> <b>Namelist</b> <b>output</b> <b>records</b>
If two or more successive values for the same <i>namelist-group-object</i> in an output record produced have identical
values, the processor has the option of producing a repeated constant of the form <i>r</i>*<i>c</i> instead of the sequence of
identical values.
The name of each <i>namelist-group-object</i> is placed in the output record followed by an equals and a list of values
of that <i>namelist-group-object</i>.
An ampersand character followed immediately by a <i>namelist-group-name</i> is placed at the start of the first output
record to indicate which particular group of data objects is being output. A slash is placed in the output record
to indicate the end of the namelist formatting.
A null value is not produced by namelist formatting.
Except for new records created by explicit formatting within a defined output procedure or by continuation of
delimited character sequences, each output record begins with a blank character.
<b>14</b> <b>Program</b> <b>units</b>
<b>14.1</b> <b>Main</b> <b>program</b>
A Fortran main program is a program unit that does not contain a SUBROUTINE, FUNCTION, MODULE,
SUBMODULE, or BLOCK DATA statement as its first statement.
R1401 <i>main-program</i> <b>is</b> [ <i>program-stmt</i> ]
                   [ <i>specification-part</i> ]
                   [ <i>execution-part</i> ]
                   [ <i>internal-subprogram-part</i> ]
                   <i>end-program-stmt</i>
R1402 <i>program-stmt</i> <b>is</b> PROGRAM <i>program-name</i>
R1403 <i>end-program-stmt</i> <b>is</b> END [ PROGRAM [ <i>program-name</i> ] ]
C1401 (R1401) The <i>program-name</i> shall not be included in the <i>end-program-stmt</i> unless the optional <i>program-</i>
   <i>stmt</i> is used. If included, it shall be identical to the <i>program-name</i> specified in the <i>program-stmt</i>.
<b>NOTE</b> <b>1</b>
The program name is global to the program (19.2). For explanatory information about uses for the program
name, see C.10.1.
<b>NOTE</b> <b>2</b>
An example of a main program is:
   PROGRAM ANALYZE
     REAL A, B, C (10,10) ! Specification part
     CALL FIND ! Execution part
   CONTAINS
     SUBROUTINE FIND ! Internal subprogram
     ...
     END SUBROUTINE FIND
   END PROGRAM ANALYZE
The main program may be defined by means other than Fortran; in that case, the program shall not contain a
<i>main-program</i> program unit.
A reference to a Fortran <i>main-program</i> shall not appear in any program unit in the program, including itself.
<b>14.2</b> <b>Modules</b>
<b>14.2.1</b> <b>Module</b> <b>syntax</b> <b>and</b> <b>semantics</b>
A module contains declarations, specifications, and definitions. Public identifiers of module entities are accessible
to other program units by use association as specified in 14.2.2. A module that is provided as an inherent part
of the processor is an intrinsic module. A nonintrinsic module is defined by a module program unit or a means
other than Fortran.
Procedures and types defined in an intrinsic module are not themselves intrinsic.
R1404 <i>module</i> <b>is</b> <i>module-stmt</i>
                   [ <i>specification-part</i> ]
                   [ <i>module-subprogram-part</i> ]
                   <i>end-module-stmt</i>
R1405 <i>module-stmt</i> <b>is</b> MODULE <i>module-name</i>
R1406 <i>end-module-stmt</i> <b>is</b> END [ MODULE [ <i>module-name</i> ] ]
R1407 <i>module-subprogram-part</i> <b>is</b> <i>contains-stmt</i>
                                   [ <i>module-subprogram</i> ] ...
R1408 <i>module-subprogram</i> <b>is</b> <i>function-subprogram</i>
              <b>or</b> <i>subroutine-subprogram</i>
              <b>or</b> <i>separate-module-subprogram</i>
C1402 (R1404) If the <i>module-name</i> is specified in the <i>end-module-stmt</i>, it shall be identical to the <i>module-name</i>
   specified in the <i>module-stmt</i>.
C1403 (R1404) A module <i>specification-part</i> shall not contain a <i>stmt-function-stmt</i>, an <i>entry-stmt</i>, or a <i>format-stmt</i>.
If a procedure declared in the scoping unit of a module has an implicit interface, it shall be given the EXTERNAL
attribute in that scoping unit; if it is a function, its type and type parameters shall be explicitly declared in a
type declaration statement in that scoping unit.
If an intrinsic procedure is declared in the scoping unit of a module, it shall explicitly be given the INTRINSIC
attribute in that scoping unit or be used as an intrinsic procedure in that scoping unit.
<b>NOTE</b> <b>1</b>
The module name is global to the program (19.2).
<b>NOTE</b> <b>2</b>
Although statement function definitions, ENTRY statements, and FORMAT statements cannot appear in the specific-
ation part of a module, they can appear in the specification part of a module subprogram in the module.
<b>NOTE</b> <b>3</b>
For a discussion of the impact of modules on dependent compilation, see C.10.2.
<b>NOTE</b> <b>4</b>
For examples of the use of modules, see C.10.3.
<b>14.2.2</b> <b>The</b> <b>USE</b> <b>statement</b> <b>and</b> <b>use</b> <b>association</b>
The USE statement specifies use association. A USE statement is a reference to the module it specifies. At the
time a USE statement is processed, the public portions of the specified module shall be available. A module shall
not reference itself, either directly or indirectly.
The USE statement provides the means by which a scoping unit accesses named data objects, nonintrinsic types,
procedures, abstract interfaces, generic identifiers, and namelist groups in a module. The entities in the scoping
unit are use associated with the entities in the module. The accessed entities have the attributes specified
in the module, except that an accessed entity may have a different accessibility attribute, it may have the
ASYNCHRONOUS attribute even if the associated module entity does not, and if it is not a coarray it may have
theVOLATILEattributeeveniftheassociated module entity does not. The entities made accessible are identified
by the names or generic identifiers used to identify them in the module. By default, the accessed entities are
identified by the same identifiers in the scoping unit containing the USE statement, but it is possible to specify
that different identifiers are used. A use-associated variable is considered to have been previously declared; any
other use-associated entity is considered to have been previously defined.
<b>NOTE</b> <b>1</b>
The accessibility of module entities can be controlled by accessibility attributes (7.5.2.2, 8.5.2), and the ONLY
option of the USE statement. Definability of module entities can be controlled by the PROTECTED attribute
(8.5.15).
R1409 <i>use-stmt</i> <b>is</b> USE [ [ , <i>module-nature</i> ] :: ] <i>module-name</i> [ , <i>rename-list</i> ]
              <b>or</b> USE [ [ , <i>module-nature</i> ] :: ] <i>module-name</i> ,
                   ONLY : [ <i>only-list</i> ]
R1410 <i>module-nature</i> <b>is</b> INTRINSIC
              <b>or</b> NON_INTRINSIC
R1411 <i>rename</i> <b>is</b> <i>local-name</i> =<i>></i> <i>use-name</i>
              <b>or</b> OPERATOR (<i>local-defined-operator</i>) =<i>></i>
                   OPERATOR (<i>use-defined-operator</i>)
R1412 <i>only</i> <b>is</b> <i>generic-spec</i>
              <b>or</b> <i>only-use-name</i>
              <b>or</b> <i>rename</i>
R1413 <i>only-use-name</i> <b>is</b> <i>use-name</i>
C1404 (R1409) If <i>module-nature</i> is INTRINSIC, <i>module-name</i> shall be the name of an intrinsic module.
C1405 (R1409) If <i>module-nature</i> is NON_INTRINSIC, <i>module-name</i> shall be the name of a nonintrinsic module.
C1406 (R1409) A scoping unit shall not directly reference an intrinsic module and a nonintrinsic module of the
   same name.
C1407 (R1411) OPERATOR (<i>use-defined-operator</i>) shall not identify a type-bound generic interface.
C1408 (R1412) The <i>generic-spec</i> shall not identify a type-bound generic interface.
<b>NOTE</b> <b>2</b>
Constraints C1407 and C1408 do not prevent accessing a <i>generic-spec</i> that is declared by an interface block,
even if a type-bound generic interface has the same <i>generic-spec</i>.
C1409 Each <i>generic-spec</i>, <i>use-name</i>, and <i>use-defined-operator</i> in a USE statement shall be a public identifier of
   the module.
C1410 An <i>only-use-name</i> shall be a nongeneric name.
R1414 <i>local-defined-operator</i> <b>is</b> <i>defined-unary-op</i>
              <b>or</b> <i>defined-binary-op</i>
R1415 <i>use-defined-operator</i> <b>is</b> <i>defined-unary-op</i>
              <b>or</b> <i>defined-binary-op</i>
A <i>use-stmt</i> without a <i>module-nature</i> provides access either to an intrinsic or to a nonintrinsic module. If the
<i>module-name</i> is the name of both an intrinsic and a nonintrinsic module, the nonintrinsic module is accessed.
The USE statement without the ONLY option provides access to all public entities in the specified module.
A USE statement with the ONLY option provides access only to those entities that appear as <i>generic-spec</i>s,
<i>use-name</i>s, or <i>use-defined-operator</i>s in the <i>only-list</i>.
More than one USE statement for a given module may appear in a specification part. If one of the USE statements
is without an ONLY option, all public entities in the module are accessible. If all the USE statements have ONLY
options, only those entities in one or more of the <i>only-list</i>s are accessible.
An accessible entity in the referenced module is associated with one or more accessed entities, each with its own
identifier. These identifiers are
 the identifier of the entity in the referenced module if that identifier appears as an <i>only-use-name</i> or as the
  <i>defined-operator</i> of a <i>generic-spec</i> in any <i>only</i> for that module,
 each of the <i>local-name</i>s or <i>local-defined-operator</i>s that the entity is given in any <i>rename</i> for that module,
  and
 the identifier of the entity in the referenced module if that identifier does not appear as a <i>use-name</i> or
  <i>use-defined-operator</i> in any <i>rename</i> for that module.
An ultimate entity is a module entity that is not accessed by use association. An accessed entity shall not be
associated with two or more ultimate entities unless its identifier is not used, or the ultimate entities are generic
interfaces. Generic interfaces are handled as described in 15.4.3.4.
<b>NOTE</b> <b>3</b>
There is no prohibition against a <i>use-name</i> or <i>use-defined-operator</i> appearing multiple times in one USE state-
ment or in multiple USE statements involving the same module. As a result, it is possible for one use-associated
entity to be accessible by more than one local identifier.
The local identifier of an entity made accessible by a USE statement shall not appear in any other nonexecutable
statement that would cause any attribute (8.5) of the entity to be specified in the scoping unit that contains the
USE statement, except that it may appear in a PUBLIC or PRIVATE statement in the scoping unit of a module
and it may be given the ASYNCHRONOUS or VOLATILE attribute.
An entity in a scoping unit that is accessed by use association through more than one use path, has the ASYN-
CHRONOUS or VOLATILE attribute in any of those use paths, and is not given that attribute in that scoping
unit, shall have that attribute in all use paths.
<b>NOTE</b> <b>4</b>
The constraints in 8.10.1, 8.10.2, and 8.9 prohibit the <i>local-name</i> from appearing as a <i>common-block-object</i> in a
COMMON statement, an <i>equivalence-object</i> in an EQUIVALENCE statement, or a <i>namelist-group-name</i> in a NAMELIST
statement, respectively. There is no prohibition against the <i>local-name</i> appearing as a <i>common-block-name</i> or a
<i>namelist-group-object</i>.
<b>NOTE</b> <b>5</b>
For a discussion of the impact of the ONLY option and renaming on dependent compilation, see C.10.2.2.
<b>NOTE</b> <b>6</b>
Examples:
   USE STATS_LIB
provides access to all public entities in the module STATS_LIB.
   USE MATH_LIB; USE STATS_LIB, SPROD => PROD
provides access to all public identifiers in both MATH_LIB and STATS_LIB. If MATH_LIB contains an entity
named PROD, it can be accessed by that name, while the entity PROD of STATS_LIB can be accessed by the
name SPROD.
   USE STATS_LIB, ONLY: YPROD; USE STATS_LIB, ONLY : PROD
provides access to YPROD and PROD in STAT_LIB.
                <b>J3/23-007r1</b> <b>305</b>
<b>NOTE</b> <b>6</b> <b>(cont.)</b>
   USE STATS_LIB, ONLY : YPROD; USE STATS_LIB
provides access to all public identifiers in STAT_LIB.
<b>14.2.3</b> <b>Submodules</b>
A submodule is a program unit that extends a module or another submodule. The program unit that it extends
is its host, and is specified by the <i>parent-identifier</i> in the <i>submodule-stmt</i>.
A module or submodule is an ancestor program unit of all of its descendants, which are its submodules and their
descendants. The submodule identifier is the ordered pair whose first element is the ancestor module name and
whose second element is the submodule name; the submodule name by itself is not a local or global identifier.
<b>NOTE</b>
A module and its submodules stand in a tree-like relationship one to another, with the module at the root.
Therefore, a submodule has exactly one ancestor module and can have one or more ancestor submodules.
A submodule may provide implementations for separate module procedures (15.6.2.5), each of which is declared
(15.4.3.2) within that submodule or one of its ancestors, and declarations and definitions of other entities that
are accessible by host association in its descendants.
R1416 <i>submodule</i> <b>is</b> <i>submodule-stmt</i>
                    [ <i>specification-part</i> ]
                    [ <i>module-subprogram-part</i> ]
                   <i>end-submodule-stmt</i>
R1417 <i>submodule-stmt</i> <b>is</b> SUBMODULE ( <i>parent-identifier</i> ) <i>submodule-name</i>
R1418 <i>parent-identifier</i> <b>is</b> <i>ancestor-module-name</i> [ : <i>parent-submodule-name</i> ]
R1419 <i>end-submodule-stmt</i> <b>is</b> END [ SUBMODULE [ <i>submodule-name</i> ] ]
C1411 (R1416) A submodule <i>specification-part</i> shall not contain a <i>format-stmt</i>, <i>entry-stmt</i>, or <i>stmt-function-stmt</i>.
C1412 (R1418) The <i>ancestor-module-name</i> shall be the name of a nonintrinsic module that declares a separate
   module procedure; the <i>parent-submodule-name</i> shall be the name of a descendant of that module.
C1413 (R1416) If a <i>submodule-name</i> appears in the <i>end-submodule-stmt</i>, it shall be identical to the one in the
   <i>submodule-stmt</i>.
<b>14.3</b> <b>Block</b> <b>data</b> <b>program</b> <b>units</b>
A block data program unit is used to provide initial values for data objects in named common blocks.
R1420 <i>block-data</i> <b>is</b> <i>block-data-stmt</i>
                       [ <i>specification-part</i> ]
                      <i>end-block-data-stmt</i>
R1421 <i>block-data-stmt</i> <b>is</b> BLOCK DATA [ <i>block-data-name</i> ]
R1422 <i>end-block-data-stmt</i> <b>is</b> END [ BLOCK DATA [ <i>block-data-name</i> ] ]
C1414 (R1420) The <i>block-data-name</i> shall be included in the <i>end-block-data-stmt</i> only if it was provided in the <i>block-data-stmt</i>
    and, if included, shall be identical to the <i>block-data-name</i> in the <i>block-data-stmt</i>.
C1415 (R1420) A <i>block-data</i> <i>specification-part</i> shall contain only derived-type definitions and ASYNCHRONOUS, BIND, COM-
    MON, DATA, DIMENSION, EQUIVALENCE, IMPLICIT, INTRINSIC, PARAMETER, POINTER, SAVE, TARGET,
    USE, VOLATILE, and type declaration statements.
C1416 (R1420) A type declaration statement in a <i>block-data</i> <i>specification-part</i> shall not contain ALLOCATABLE, EXTERNAL,
    or BIND attribute specifiers.
If an object in a named common block is initially defined, all storage units in the common block storage sequence shall be specified
even if they are not all initially defined. More than one named common block may have objects initially defined in a single block
data program unit.
An object that is initially defined in a block data program unit shall be in a named common block.
The same named common block shall not be specified in more than one block data program unit in a program.
There shall not be more than one unnamed block data program unit in a program.
<b>15</b> <b>Procedures</b>
<b>15.1</b> <b>Concepts</b>
The concept of a procedure was introduced in 5.2.3. This clause contains a complete description of procedures.
The actions specified by a procedure are performed when the procedure is invoked by execution of a reference to
it.
The sequence of actions encapsulated by a procedure has access to entities in the procedure reference by way of
argument association (15.5.2). A name that appears as a <i>dummy-arg-name</i> in the SUBROUTINE, FUNCTION,
or ENTRY statement in the declaration of a procedure (R1539) is a dummy argument. Dummy arguments are
also specified for intrinsic procedures and procedures in intrinsic modules in Clauses 16, 17, and 18.
<b>15.2</b> <b>Procedure</b> <b>classifications</b>
<b>15.2.1</b> <b>Procedure</b> <b>classification</b> <b>by</b> <b>reference</b>
The definition of a procedure specifies it to be a function or a subroutine. A reference to a function either appears
explicitly as a primary within an expression, or is implied by a defined operation (10.1.6) within an expression.
A reference to a subroutine is a CALL statement, a defined assignment statement (10.2.1.4), the appearance of
an object processed by defined input/output (12.6.4.8) in an input/output list, or finalization (7.5.6).
A procedure is classified as elemental if it is a procedure that can be referenced elementally (15.9).
<b>15.2.2</b> <b>Procedure</b> <b>classification</b> <b>by</b> <b>means</b> <b>of</b> <b>definition</b>
<b>15.2.2.1</b> <b>Intrinsic</b> <b>procedures</b>
A procedure that is provided as an inherent part of the processor is an intrinsic procedure.
<b>15.2.2.2</b> <b>External,</b> <b>internal,</b> <b>and</b> <b>module</b> <b>procedures</b>
An external procedure is a procedure that is defined by an external subprogram or by a means other than Fortran.
An internal procedure is a procedure that is defined by an internal subprogram. Internal subprograms may
appear in the main program, in an external subprogram, or in a module subprogram. Internal subprograms shall
not appear in other internal subprograms. Internal subprograms are the same as external subprograms except
that the name of the internal procedure is not a global identifier, an internal subprogram shall not contain an ENTRY
statement, and the internal subprogram has access to host entities by host association.
A module procedure is a procedure that is defined by a module subprogram, or a specific procedure provided by
an intrinsic module.
A subprogram defines a procedure for the SUBROUTINE or FUNCTION statement. If the subprogram has one or
more ENTRY statements, it also defines a procedure for each of them.
<b>15.2.2.3</b> <b>Dummy</b> <b>procedures</b>
A dummy argument that is specified to be a procedure or appears as the procedure designator in a procedure
reference is a dummy procedure. A dummy procedure with the POINTER attribute is a dummy procedure
pointer.
<b>15.2.2.4</b> <b>Procedure</b> <b>pointers</b>
A procedure pointer is a procedure that has the POINTER attribute. A procedure pointer can be pointer
associated with an external, internal, intrinsic, or module procedure.
<b>15.2.2.5</b> <b>Statement</b> <b>functions</b>
A function that is defined by a single statement is a statement function (15.6.4).
<b>15.3</b> <b>Characteristics</b>
<b>15.3.1</b> <b>Characteristics</b> <b>of</b> <b>procedures</b>
The characteristics of a procedure are the classification of the procedure as a function or subroutine, whether it
is pure, whether it is simple, whether it is elemental, whether it has the BIND attribute, the characteristics of its
dummy arguments, and the characteristics of its function result if it is a function.
<b>15.3.2</b> <b>Characteristics</b> <b>of</b> <b>dummy</b> <b>arguments</b>
<b>15.3.2.1</b> <b>General</b>
Each dummy argument has the characteristic that it is a dummy data object, a dummy procedure, or an asterisk
(alternate return indicator).
<b>15.3.2.2</b> <b>Characteristics</b> <b>of</b> <b>dummy</b> <b>data</b> <b>objects</b>
The characteristics of a dummy data object are its declared type, its type parameters, its shape (unless it is
assumed-rank), its corank, its codimensions, its intent (8.5.10, 8.6.9), whether it is optional (8.5.12, 8.6.10),
whether it is allocatable (8.5.3), whether it has the ASYNCHRONOUS (8.5.4), CONTIGUOUS (8.5.7), VALUE
(8.5.19), or VOLATILE (8.5.20) attributes, whether it is polymorphic, and whether it is a pointer (8.5.14, 8.6.12)
or a target (8.5.18, 8.6.15). If a type parameter of an object or a bound of an array is not a constant expression,
the exact dependence on the entities in the expression is a characteristic. If a rank, shape, size, type, or type
parameter is assumed or deferred, it is a characteristic.
<b>15.3.2.3</b> <b>Characteristics</b> <b>of</b> <b>dummy</b> <b>procedures</b>
The characteristics of a dummy procedure are the explicitness of its interface (15.4.2), its characteristics as a
procedure if the interface is explicit, whether it is a pointer, and whether it is optional (8.5.12, 8.6.10).
<b>15.3.2.4</b> <b>Characteristics</b> <b>of</b> <b>asterisk</b> <b>dummy</b> <b>arguments</b>
A dummy argument that is an asterisk has no other characteristic.
<b>15.3.3</b> <b>Characteristics</b> <b>of</b> <b>function</b> <b>results</b>
The characteristics of a function result are its declared type, type parameters, rank, whether it is polymorphic,
whether it is allocatable, whether it is a pointer, whether it has the CONTIGUOUS attribute, and whether it is a
procedure pointer. If a function result is an array that is not allocatable or a pointer, its shape is a characteristic.
If a type parameter of a function result or a bound of a function result array is not a constant expression, the
exact dependence on the entities in the expression is a characteristic. If type parameters of a function result are
deferred, which parameters are deferred is a characteristic. Whether the length of a character function result is assumed
is a characteristic.
<b>15.4</b> <b>Procedure</b> <b>interface</b>
<b>15.4.1</b> <b>Interface</b> <b>and</b> <b>abstract</b> <b>interface</b>
The interface of a procedure determines the forms of reference through which it can be invoked. The procedure's
interface consists of its name, binding label, generic identifiers, characteristics, and the names of its dummy
arguments. The characteristics and binding label of a procedure are fixed, but the remainder of the interface may
differ in differing contexts, except that for a separate module procedure body (15.6.2.5), the dummy argument
names and whether it has the NON_RECURSIVE attribute shall be the same as in its corresponding module
procedure interface body (15.4.3.2).
An abstract interface is a set of procedure characteristics with the dummy argument names.
<b>15.4.2</b> <b>Implicit</b> <b>and</b> <b>explicit</b> <b>interfaces</b>
<b>15.4.2.1</b> <b>Interfaces</b> <b>and</b> <b>scopes</b>
The interface of a procedure is either explicit or implicit. It is explicit if it is
 an internal procedure, module procedure, or intrinsic procedure,
 a subroutine, or a function with a separate result name, within the scoping unit that defines it, or
 a procedure declared by a procedure declaration statement that specifies an explicit interface, or by an
  interface body.
Otherwise, the interface of the identifier is implicit. The interface of a statement function is always implicit.
<b>NOTE</b>
For example, the subroutine LLS of C.10.3.4 has an explicit interface.
<b>15.4.2.2</b> <b>Explicit</b> <b>interface</b>
Within the scope of a procedure identifier, the procedure shall have an explicit interface if it is not a statement
function and
  (1) a reference to the procedure appears with an argument keyword (15.5.2),
  (2) the procedure is used in a context that requires it to be pure (15.7),
  (3) the procedure is used in a context that requires it to be simple (15.8),
  (4) the procedure has a dummy argument that
     (a) has the ALLOCATABLE, ASYNCHRONOUS, OPTIONAL, POINTER, TARGET, VALUE,
        or VOLATILE attribute,
     (b) is an assumed-shape array,
     (c) is assumed-rank,
     (d) is a coarray,
     (e) is of a parameterized derived type, or
     (f) is polymorphic,
  (5) the procedure has a result that
     (a) is an array,
     (b) is a pointer or is allocatable, or
     (c) has a nonassumed type parameter value that is not a constant expression,
  (6) the procedure is elemental, or
  (7) the procedure has the BIND attribute.
<b>15.4.3</b> <b>Specification</b> <b>of</b> <b>the</b> <b>procedure</b> <b>interface</b>
<b>15.4.3.1</b> <b>General</b>
The interface for an internal, external, module, or dummy procedure is specified by a FUNCTION, SUB-
ROUTINE, or ENTRY statement and by specification statements for the dummy arguments and the result of
a function. These statements may appear in the procedure definition, in an interface body, or both, except that
the ENTRY statement shall not appear in an interface body.
<b>NOTE</b>
An interface body cannot be used to describe the interface of an internal procedure, a module procedure that
is not a separate module procedure, or an intrinsic procedure because the interfaces of such procedures are
already explicit. However, the name of a procedure can appear in a PROCEDURE statement in an interface
block (15.4.3.2).
<b>15.4.3.2</b> <b>Interface</b> <b>block</b>
R1501 <i>interface-block</i> <b>is</b> <i>interface-stmt</i>
                   [ <i>interface-specification</i> ] ...
                   <i>end-interface-stmt</i>
R1502 <i>interface-specification</i> <b>is</b> <i>interface-body</i>
              <b>or</b> <i>procedure-stmt</i>
R1503 <i>interface-stmt</i> <b>is</b> INTERFACE [ <i>generic-spec</i> ]
              <b>or</b> ABSTRACT INTERFACE
R1504 <i>end-interface-stmt</i> <b>is</b> END INTERFACE [ <i>generic-spec</i> ]
R1505 <i>interface-body</i> <b>is</b> <i>function-stmt</i>
                   [ <i>specification-part</i> ]
                   <i>end-function-stmt</i>
              <b>or</b> <i>subroutine-stmt</i>
                   [ <i>specification-part</i> ]
                   <i>end-subroutine-stmt</i>
R1506 <i>procedure-stmt</i> <b>is</b> [ MODULE ] PROCEDURE [ :: ] <i>specific-procedure-list</i>
R1507 <i>specific-procedure</i> <b>is</b> <i>procedure-name</i>
R1508 <i>generic-spec</i> <b>is</b> <i>generic-name</i>
              <b>or</b> OPERATOR ( <i>defined-operator</i> )
              <b>or</b> ASSIGNMENT ( = )
              <b>or</b> <i>defined-io-generic-spec</i>
R1509 <i>defined-io-generic-spec</i> <b>is</b> READ (FORMATTED)
              <b>or</b> READ (UNFORMATTED)
              <b>or</b> WRITE (FORMATTED)
              <b>or</b> WRITE (UNFORMATTED)
C1501 (R1501) An <i>interface-block</i> in a subprogram shall not contain an <i>interface-body</i> for a procedure defined
   by that subprogram.
C1502 (R1501) If the <i>end-interface-stmt</i> includes a <i>generic-spec</i>, the <i>interface-stmt</i> shall specify the same
   <i>generic-spec</i>, except that if one <i>generic-spec</i> has a <i>defined-operator</i> that is .LT., .LE., .GT., .GE., .EQ.,
   or .NE., the other <i>generic-spec</i> may have a <i>defined-operator</i> that is the corresponding operator <i><</i>, <i><</i>=,
   <i>></i>, <i>></i>=, ==, or /=.
C1503 (R1503) If the <i>interface-stmt</i> is ABSTRACT INTERFACE, then the <i>function-name</i> in the <i>function-stmt</i>
   or the <i>subroutine-name</i> in the <i>subroutine-stmt</i> shall not be the same as a keyword that specifies an
   intrinsic type.
C1504 (R1502) A <i>procedure-stmt</i> is allowed only in an interface block that has a <i>generic-spec</i>.
C1505 (R1505) An <i>interface-body</i> of a pure procedure shall specify the intents of all dummy arguments except
    alternate return indicators, dummy procedures, and arguments with the POINTER or VALUE attribute.
C1506 (R1505) An <i>interface-body</i> shall not contain a <i>data-stmt</i>, <i>format-stmt</i>, <i>entry-stmt</i>, or <i>stmt-function-stmt</i>.
C1507 (R1506) If MODULE appears in a <i>procedure-stmt</i>, each <i>procedure-name</i> in that statement shall denote a
   module procedure.
C1508 (R1507) A <i>procedure-name</i> shall denote a nonintrinsic procedure that has an explicit interface.
C1509 (R1501) An <i>interface-specification</i> in a generic interface block shall not specify a procedure that was
   specified previously in any accessible interface with the same generic identifier.
An external or module subprogram specifies a specific interface for each procedure defined in that subprogram.
An interface block introduced by ABSTRACT INTERFACE is an abstract interface block. An interface body
in an abstract interface block specifies an abstract interface. An interface block with a generic specification is
a generic interface block. An interface block with neither ABSTRACT nor a generic specification is a specific
interface block.
The name of the entity declared by an interface body is the <i>function-name</i> in the <i>function-stmt</i> or the <i>subroutine-</i>
<i>name</i> in the <i>subroutine-stmt</i> that begins the interface body.
A module procedure interface body is an interface body whose initial statement contains the keyword MODULE.
It specifies the interface for a separate module procedure (15.6.2.5). A separate module procedure is accessible
by use association if and only if its interface body is declared in the specification part of a module and is public.
If a corresponding (15.6.2.5) separate module procedure is not defined, the interface may be used to specify an
explicit specific interface but the procedure shall not be used in any other way.
An interface body in a generic or specific interface block specifies the EXTERNAL attribute and an explicit
specific interface for an external procedure, dummy procedure, or procedure pointer. If the name of the declared
procedure is that of a dummy argument in the subprogram containing the interface body, the procedure is a
dummy procedure. If the procedure has the POINTER attribute, it is a procedure pointer. If it is not a dummy
procedure or procedure pointer, it is an external procedure.
An interface body specifies all of the characteristics of the explicit specific interface or abstract interface. The
specification part of an interface body may specify attributes or define values for data entities that do not
determine characteristics of the procedure. Such specifications have no effect.
Ifanexplicitspecificinterfaceforanexternalprocedureisspecifiedbyaninterfacebodyoraproceduredeclaration
statement (15.4.3.6), the characteristics shall be consistent with those specified in the procedure definition, except
that the interface may specify a procedure that is not pure even if the procedure is defined to be pure, and the
interface may specify a procedure that is not simple even if the procedure is defined to be simple. An interface for
a procedure defined by an ENTRY statement may be specified by using the entry name as the procedure name in the interface body.
If an external procedure does not exist in the program, an interface body for it may be used to specify an explicit
specific interface but the procedure shall not be used in any other way. A procedure shall not have more than
one explicit specific interface in a given scoping unit, except that if the interface is accessed by use association,
there may be more than one local name for the procedure. If a procedure is accessed by use association, each
access shall be to the same procedure declaration or definition.
<b>NOTE</b> <b>1</b>
The dummy argument names in an interface body can be different from the corresponding dummy argument
names in the procedure definition because the name of a dummy argument is not a characteristic.
<b>NOTE</b> <b>2</b>
An example of a specific interface block is:
   INTERFACE
     SUBROUTINE EXT1 (X, Y, Z)
      REAL, DIMENSION (100, 100) :: X, Y, Z
     END SUBROUTINE EXT1
     SUBROUTINE EXT2 (X, Z)
      REAL X
      COMPLEX (KIND = 4) Z (2000)
     END SUBROUTINE EXT2
     FUNCTION EXT3 (P, Q)
      LOGICAL EXT3
      INTEGER P (1000)
      LOGICAL Q (1000)
     END FUNCTION EXT3
   END INTERFACE
This interface block specifies explicit interfaces for the three external procedures EXT1, EXT2, and EXT3.
Invocations of these procedures can use argument keywords (15.5.2); for example:
   PRINT *, EXT3 (Q = P_MASK (N+1 : N+1000), P = ACTUAL_P)
<b>15.4.3.3</b> <b>GENERIC</b> <b>statement</b>
A GENERIC statement specifies a generic identifier for one or more specific procedures, in the same way as a
generic interface block that does not contain interface bodies.
R1510 <i>generic-stmt</i> <b>is</b> GENERIC [ , <i>access-spec</i> ] :: <i>generic-spec</i> =<i>></i> <i>specific-procedure-list</i>
C1510 (R1510) A <i>specific-procedure</i> in a GENERIC statement shall not specify a procedure that was specified
   previously in any accessible interface with the same generic identifier.
If <i>access-spec</i> appears, it specifies the accessibility (8.5.2) of <i>generic-spec</i>.
<b>15.4.3.4</b> <b>Generic</b> <b>interfaces</b>
<b>15.4.3.4.1</b> <b>Generic</b> <b>identifiers</b>
A generic interface block specifies a generic interface for each of the procedures in the interface block. The
PROCEDURE statement lists nonintrinsic procedures with explicit interfaces that have this generic interface. A
GENERIC statement specifies a generic interface for each of the procedures named in its <i>specific-procedure-list</i>.
A generic interface is always explicit.
The <i>generic-spec</i> in an <i>interface-stmt</i> is a generic identifier for all the procedures in the interface block. The
<i>generic-spec</i> in a GENERIC statement is a generic identifier for all of the procedures named in its <i>specific-</i>
<i>procedure-list</i>. The rules specifying how any two procedures with the same generic identifier shall differ are given
in 15.4.3.4.5. They ensure that any generic invocation applies to at most one specific procedure. If a specific
procedure in a generic interface has a function dummy argument, that argument shall have its type and type
parameters explicitly declared in the specific interface.
A generic name is a generic identifier that refers to all of the procedure names in the generic interface. A generic
name may be the same as any one of the procedure names in the generic interface, or the same as any accessible
generic name.
A generic name may be the same as a derived-type name, in which case all of the procedures in the generic
interface shall be functions.
An <i>interface-stmt</i> having a <i>defined-io-generic-spec</i> is an interface for a defined input/output procedure (12.6.4.8).
<b>NOTE</b> <b>1</b>
An example of a generic procedure interface is:
   INTERFACE SWITCH
     SUBROUTINE INT_SWITCH (X, Y)
      INTEGER, INTENT (INOUT) :: X, Y
     END SUBROUTINE INT_SWITCH
     SUBROUTINE REAL_SWITCH (X, Y)
      REAL, INTENT (INOUT) :: X, Y
     END SUBROUTINE REAL_SWITCH
     SUBROUTINE COMPLEX_SWITCH (X, Y)
      COMPLEX, INTENT (INOUT) :: X, Y
     END SUBROUTINE COMPLEX_SWITCH
   END INTERFACE SWITCH
Any of these three subroutines (INT_SWITCH, REAL_SWITCH, COMPLEX_SWITCH) can be referenced
with the generic name SWITCH, as well as by its specific name. For example, a reference to INT_SWITCH
could take the form:
   CALL SWITCH (MAX_VAL, LOC_VAL) ! MAX_VAL and LOC_VAL are of type INTEGER
<b>NOTE</b> <b>2</b>
A <i>type-bound-generic-stmt</i> within a derived-type definition (7.5.5) specifies a generic identifier for a set of type-
bound procedures.
<b>15.4.3.4.2</b> <b>Defined</b> <b>operations</b>
If OPERATOR is specified in a generic specification, all of the procedures specified in the generic interface shall
be functions that can be referenced as defined operations (10.1.6, 15.5). In the case of functions of two arguments,
infix binary operator notation is implied. In the case of functions of one argument, prefix operator notation is
implied. OPERATOR shall not be specified for functions with no arguments or for functions with more than two
arguments. The dummy arguments shall be nonoptional dummy data objects and shall have the INTENT (IN)
or VALUE attribute. The function result shall not have assumed character length. If the operator is an <i>intrinsic-operator</i>
(R608), the number of dummy arguments shall be consistent with the intrinsic uses of that operator, and the
types, kind type parameters, or ranks of the dummy arguments shall differ from those required for the intrinsic
operation (10.1.5), treating a CLASS (*) dummy argument as not differing in type or kind.
A defined operation is treated as a reference to the function. For a unary defined operation, the operand
corresponds to the function's dummy argument; for a binary operation, the left-hand operand corresponds to the
first dummy argument of the function and the right-hand operand corresponds to the second dummy argument.
All restrictions and constraints that apply to actual arguments in a reference to the function also apply to the
corresponding operands in the expression as if they were used as actual arguments.
A given defined operator may, as with generic names, apply to more than one function, in which case it is generic
in exact analogy to generic procedure names. For intrinsic operator symbols, the generic properties include the
intrinsic operations they represent. Because both forms of each relational operator have the same interpretation
(10.1.6.2), extending one form (such as <i><</i>=) has the effect of defining both forms (<i><</i>= and .LE.).
<b>NOTE</b>
An example of the use of the OPERATOR generic specification is:
   INTERFACE OPERATOR ( * )
<b>314</b> <b>J3/23-007r1</b>
<b>NOTE</b> <b>(cont.)</b>
     FUNCTION BOOLEAN_AND (B1, B2)
      LOGICAL, INTENT (IN) :: B1 (:), B2 (SIZE (B1))
      LOGICAL :: BOOLEAN_AND (SIZE (B1))
     END FUNCTION BOOLEAN_AND
   END INTERFACE OPERATOR ( * )
This allows, for example
   SENSOR (1:N) * ACTION (1:N)
as an alternative to the function reference
   BOOLEAN_AND (SENSOR (1:N), ACTION (1:N)) ! SENSOR and ACTION are of type LOGICAL
<b>15.4.3.4.3</b> <b>Defined</b> <b>assignments</b>
If ASSIGNMENT ( = ) is specified in a generic specification, all the procedures in the generic interface shall
be subroutines that can be referenced as defined assignments (10.2.1.4, 10.2.1.5). Defined assignment may, as
with generic names, apply to more than one subroutine, in which case it is generic in exact analogy to generic
procedure names.
Each of these subroutines shall have exactly two dummy arguments. The dummy arguments shall be nonoptional
dummy data objects. The first argument shall have INTENT (OUT) or INTENT (INOUT) and the second
argument shall have the INTENT (IN) or VALUE attribute. Either the second argument shall be an array whose
rank differs from that of the first argument, the declared types and kind type parameters of the arguments shall
not conform as specified in Table 10.8, or the first argument shall be of derived type. A defined assignment is
treated as a reference to the subroutine, with the left-hand side as the first argument and the right-hand side
enclosed in parentheses as the second argument. All restrictions and constraints that apply to actual arguments
in a reference to the subroutine also apply to the left-hand-side and to the right-hand-side enclosed in parentheses
as if they were used as actual arguments. The ASSIGNMENT generic specification specifies that assignment is
extended or redefined.
<b>NOTE</b> <b>1</b>
An example of the use of the ASSIGNMENT generic specification is:
   INTERFACE ASSIGNMENT ( = )
     SUBROUTINE LOGICAL_TO_NUMERIC (N, B)
      INTEGER, INTENT (OUT) :: N
      LOGICAL, INTENT (IN) :: B
     END SUBROUTINE LOGICAL_TO_NUMERIC
     SUBROUTINE CHAR_TO_STRING (S, C)
      USE STRING_MODULE ! Contains definition of type STRING
      TYPE (STRING), INTENT (OUT) :: S ! A variable-length string
      CHARACTER (*), INTENT (IN) :: C
     END SUBROUTINE CHAR_TO_STRING
   END INTERFACE ASSIGNMENT ( = )
Example assignments are:
   KOUNT = SENSOR (J) ! CALL LOGICAL_TO_NUMERIC (KOUNT, (SENSOR (J)))
   NOTE = '89AB' ! CALL CHAR_TO_STRING (NOTE, ('89AB'))
<b>NOTE</b> <b>2</b>
A procedure which has a generic identifier of ASSIGNMENT ( = ) and whose second dummy argument has the
ALLOCATABLE or POINTER attribute cannot be directly invoked by defined assignment. This is because
the actual argument associated with that dummy argument is the right-hand side of the assignment enclosed
                <b>J3/23-007r1</b> <b>315</b>
<b>NOTE</b> <b>2</b> <b>(cont.)</b>
in parentheses, which makes the actual argument an expression that does not have the ALLOCATABLE,
POINTER, or TARGET attribute.
<b>15.4.3.4.4</b> <b>Defined</b> <b>input/output</b> <b>procedure</b> <b>interfaces</b>
All of the procedures specified in an interface block for a defined input/output procedure shall be subroutines
that have interfaces as described in 12.6.4.8.2.
<b>15.4.3.4.5</b> <b>Restrictions</b> <b>on</b> <b>generic</b> <b>declarations</b>
This subclause contains the rules that shall be satisfied by every pair of specific procedures that have the same
generic identifier within the scope of the identifier. If a generic procedure is accessed from a module, the rules
apply to all the specific versions even if some of them are inaccessible by their specific names.
<b>NOTE</b> <b>1</b>
In most scoping units, the possible sources of procedures with a particular generic identifier are the accessible
generic identifiers specified by generic interface blocks or GENERIC statements and the generic bindings other
than names for the accessible objects in that scoping unit. In a type definition, they are the generic bindings,
including those from a parent type.
A dummy argument is type, kind, and rank compatible, or TKR compatible, with another dummy argument if
the first is type compatible with the second, the kind type parameters of the first have the same values as the
corresponding kind type parameters of the second, and both have the same rank or either is assumed-rank.
Two dummy arguments are distinguishable if
 one is a procedure and the other is a data object,
 they are both data objects or known to be functions, and neither is TKR compatible with the other,
 one has the ALLOCATABLE attribute and the other has the POINTER attribute and not the INTENT
  (IN) attribute, or
 one is a function with nonzero rank and the other is not known to be a function.
C1511 Within the scope of a generic operator, if two procedures with that identifier have the same number of
   arguments, one shall have a dummy argument that corresponds by position in the argument list to a
   dummy argument of the other that is distinguishable from it.
C1512 Within the scope of the generic ASSIGNMENT (=) identifier, if two procedures have that identifier, one
   shall have a dummy argument that corresponds by position in the argument list to a dummy argument
   of the other that is distinguishable from it.
C1513 Within the scope of a <i>defined-io-generic-spec</i>, if two procedures have that generic identifier, their dtv
   arguments (12.6.4.8.2) shall be distinguishable.
C1514 Within the scope of a generic name, each pair of procedures identified by that name shall both be
   subroutines or both be functions, and
   (1) there is a non-passed-object dummy data object in one or the other of them such that
      (a) the number of dummy data objects in one that are nonoptional, are not passed-object, and
         with which that dummy data object is TKR compatible, possibly including that dummy
         data object itself,
      exceeds
      (b) the number of non-passed-object dummy data objects, both optional and nonoptional, in
         the other that are not distinguishable from that dummy data object,
   (2) the number of nonoptional dummy procedures in one of them exceeds the number of dummy
      procedures in the other,
   (3) both have passed-object dummy arguments and the passed-object dummy arguments are distin-
      guishable, or
   (4) at least one of them shall have both
      (a) a nonoptional non-passed-object dummy argument at an effective position such that either
         the other procedure has no dummy argument at that effective position or the dummy argu-
         ment at that position is distinguishable from it, and
      (b) a nonoptional non-passed-object dummy argument whose name is such that either the other
         procedure has no dummy argument with that name or the dummy argument with that name
         is distinguishable from it,
      and the dummy argument that disambiguates by position shall either be the same as or occur
      earlier in the argument list than the one that disambiguates by name.
The effective position of a dummy argument is its position in the argument list after any passed-object dummy
argument has been removed.
Within the scope of a generic name that is the same as the generic name of an intrinsic procedure, the intrinsic
procedure is not accessible by its generic name if the procedures in the interface and the intrinsic procedure are
not all functions or not all subroutines. If a generic invocation is consistent with both a specific procedure from
an interface and an accessible intrinsic procedure, it is the specific procedure from the interface that is referenced.
<b>NOTE</b> <b>2</b>
An extensive explanation of the application of these rules is in C.11.6.
<b>15.4.3.5</b> <b>EXTERNAL</b> <b>statement</b>
An EXTERNAL statement specifies the EXTERNAL attribute (8.5.9) for a list of names.
R1511 <i>external-stmt</i> <b>is</b> EXTERNAL [ :: ] <i>external-name-list</i>
The appearance of the name of a block data program unit in an EXTERNAL statement confirms that the block
data program unit is a part of the program.
<b>NOTE</b> <b>1</b>
For explanatory information on potential portability problems with external procedures, see C.11.1.
<b>NOTE</b> <b>2</b>
An example of an EXTERNAL statement is:
   EXTERNAL FOCUS
<b>15.4.3.6</b> <b>Procedure</b> <b>declaration</b> <b>statement</b>
A procedure declaration statement declares procedure pointers, dummy procedures, and external procedures. It
specifies the EXTERNAL attribute (8.5.9) for all entities in the <i>proc-decl-list</i>.
R1512 <i>procedure-declaration-stmt</i> <b>is</b> PROCEDURE ( [ <i>proc-interface</i> ] )
                   [ [ , <i>proc-attr-spec</i> ] ... :: ] <i>proc-decl-list</i>
R1513 <i>proc-interface</i> <b>is</b> <i>interface-name</i>
              <b>or</b> <i>declaration-type-spec</i>
R1514 <i>proc-attr-spec</i> <b>is</b> <i>access-spec</i>
              <b>or</b> <i>proc-language-binding-spec</i>
              <b>or</b> INTENT ( <i>intent-spec</i> )
              <b>or</b> OPTIONAL
              <b>or</b> POINTER
              <b>or</b> PROTECTED
              <b>or</b> SAVE
R1515 <i>proc-decl</i> <b>is</b> <i>procedure-entity-name</i> [ =<i>></i> <i>proc-pointer-init</i> ]
R1516 <i>interface-name</i> <b>is</b> <i>name</i>
R1517 <i>proc-pointer-init</i> <b>is</b> <i>null-init</i>
              <b>or</b> <i>initial-proc-target</i>
R1518 <i>initial-proc-target</i> <b>is</b> <i>procedure-name</i>
C1515 (R1516) The <i>name</i> shall be the name of an abstract interface or of a procedure that has an explicit
   interface. If <i>name</i> is declared by a <i>procedure-declaration-stmt</i> it shall be previously declared. If <i>name</i>
    denotes an intrinsic procedure it shall be one that is listed in Table 16.2.
C1516 (R1516) The <i>name</i> shall not be the same as a keyword that specifies an intrinsic type.
C1517 (R1512) If a <i>proc-interface</i> describes an elemental procedure, each <i>procedure-entity-name</i> shall specify an
   external procedure.
C1518 (R1515) If =<i>></i> appears in <i>proc-decl</i>, the procedure entity shall have the POINTER attribute.
C1519 (R1518) The <i>procedure-name</i> shall be the name of a nonelemental external or module procedure, or a
    specific intrinsic function listed in Table 16.2.
C1520 (R1512) If <i>proc-language-binding-spec</i> with NAME= is specified, then <i>proc-decl-list</i> shall contain exactly
   one <i>proc-decl</i>, which shall neither have the POINTER attribute nor be a dummy procedure.
C1521 (R1512) If <i>proc-language-binding-spec</i> is specified, the <i>proc-interface</i> shall appear, it shall be an <i>interface-</i>
   <i>name</i>, and <i>interface-name</i> shall be declared with a <i>proc-language-binding-spec</i>.
If <i>proc-interface</i> appears and consists of <i>interface-name</i>, it specifies an explicit specific interface (15.4.3.2) for the
declared procedure entities. The abstract interface (15.4) is that specified by the interface named by <i>interface-</i>
<i>name</i>. The interface specified by <i>interface-name</i> shall not depend on any characteristic of a procedure identified
by a <i>procedure-entity-name</i> in the <i>proc-decl-list</i> of the same procedure declaration statement.
If <i>proc-interface</i> appears and consists of <i>declaration-type-spec</i>, it specifies that the declared procedure entities are
functions having implicit interfaces and the specified result type. If a type is specified for an external function,
its function definition (15.6.2.2) shall specify the same result type and type parameters.
If <i>proc-interface</i> does not appear, the procedure declaration statement does not specify whether the declared
procedure entities are subroutines or functions.
Ifa<i>proc-attr-spec</i> otherthan a<i>proc-language-binding-spec</i> appears, it specifies that the declared procedure entities
have that attribute. These attributes are described in 8.5. If a <i>proc-language-binding-spec</i> with NAME= appears,
it specifies a binding label or its absence, as described in 18.10.2. A <i>proc-language-binding-spec</i> without NAME=
is allowed, but is redundant with the <i>proc-interface</i> required by C1521.
If =<i>></i> appears in a <i>proc-decl</i> in a <i>procedure-declaration-stmt</i> it specifies the initial association status of the
correspondingprocedureentity, andimpliesthe SAVE attribute, which may be confirmed by explicit specification.
If =<i>></i> <i>null-init</i> appears, the procedure entity is initially disassociated. If =<i>></i> <i>initial-proc-target</i> appears, the
procedure entity is initially associated with the target.
If <i>procedure-entity-name</i> has an explicit interface, its characteristics shall be the same as <i>initial-proc-target</i> except
that <i>initial-proc-target</i> may be pure even if <i>procedure-entity-name</i> is not pure, <i>initial-proc-target</i> may be simple
even if <i>procedure-entity-name</i> is not simple, and <i>initial-proc-target</i> may be an elemental intrinsic procedure.
If the characteristics of <i>procedure-entity-name</i> or <i>initial-proc-target</i> are such that an explicit interface is required,
both <i>procedure-entity-name</i> and <i>initial-proc-target</i> shall have an explicit interface.
If <i>procedure-entity-name</i> has an implicit interface and is explicitly typed or referenced as a function, <i>initial-proc-</i>
<i>target</i> shall be a function. If <i>procedure-entity-name</i> has an implicit interface and is referenced as a subroutine,
<i>initial-proc-target</i> shall be a subroutine.
If <i>initial-proc-target</i> and <i>procedure-entity-name</i> are functions, their results shall have the same characteristics.
<b>NOTE</b>
The following code illustrates procedure declaration statements. 10.2.2.5, NOTE 1 illustrates the use of the P
and BESSEL defined by this code.
   ABSTRACT INTERFACE
    FUNCTION REAL_FUNC (X)
     REAL, INTENT (IN) :: X
     REAL :: REAL_FUNC
    END FUNCTION REAL_FUNC
   END INTERFACE
   INTERFACE
    SUBROUTINE SUB (X)
     REAL, INTENT (IN) :: X
    END SUBROUTINE SUB
   END INTERFACE
   !-- Some external or dummy procedures with explicit interface.
   PROCEDURE (REAL_FUNC) :: BESSEL, GFUN
   PROCEDURE (SUB) :: PRINT_REAL
   !-- Some procedure pointers with explicit interface,
   !-- one initialized to NULL().
   PROCEDURE (REAL_FUNC), POINTER :: P, R => NULL ()
   PROCEDURE (REAL_FUNC), POINTER :: PTR_TO_GFUN
   !-- A derived type with a procedure pointer component ...
   TYPE STRUCT_TYPE
     PROCEDURE (REAL_FUNC), POINTER, NOPASS :: COMPONENT
   END TYPE STRUCT_TYPE
   !-- ... and a variable of that type.
   TYPE(STRUCT_TYPE) :: STRUCT
   !-- An external or dummy function with implicit interface
   PROCEDURE (REAL) :: PSI
<b>15.4.3.7</b> <b>INTRINSIC</b> <b>statement</b>
An INTRINSIC statement specifies the INTRINSIC attribute (8.5.11) for a list of names.
R1519 <i>intrinsic-stmt</i> <b>is</b> INTRINSIC [ :: ] <i>intrinsic-procedure-name-list</i>
C1522 (R1519) Each <i>intrinsic-procedure-name</i> shall be the name of an intrinsic procedure.
<b>15.4.3.8</b> <b>Implicit</b> <b>interface</b> <b>specification</b>
If the interface of a function is implicit, the type and type parameters of the function result are specified by an
implicit or explicit type specification of the function name. The type, type parameters, and shape of the dummy
arguments of a procedure invoked from where the interface of the procedure is implicit shall be such that each
actual argument is consistent with the characteristics of the corresponding dummy argument.
<b>15.5</b> <b>Procedure</b> <b>reference</b>
<b>15.5.1</b> <b>Syntax</b> <b>of</b> <b>a</b> <b>procedure</b> <b>reference</b>
The form of a procedure reference is dependent on the interface of the procedure or procedure pointer, but is
independent of the means by which the procedure is defined. The forms of procedure references are as follows.
R1520 <i>function-reference</i> <b>is</b> <i>procedure-designator</i> ( [ <i>actual-arg-spec-list</i> ] )
C1523 (R1520) The <i>procedure-designator</i> shall designate a function.
C1524 (R1520) The <i>actual-arg-spec-list</i> shall not contain an <i>alt-return-spec</i>.
R1521 <i>call-stmt</i> <b>is</b> CALL <i>procedure-designator</i> [ ( [ <i>actual-arg-spec-list</i> ] ) ]
C1525 (R1521) The <i>procedure-designator</i> shall designate a subroutine.
R1522 <i>procedure-designator</i> <b>is</b> <i>procedure-name</i>
              <b>or</b> <i>proc-component-ref</i>
              <b>or</b> <i>data-ref</i> % <i>binding-name</i>
C1526 (R1522) A <i>procedure-name</i> shall be a generic name or the name of a procedure.
C1527 (R1522) A <i>binding-name</i> shall be a binding name (7.5.5) of the declared type of <i>data-ref</i>.
C1528 (R1522) A <i>data-ref</i> shall not be a polymorphic subobject of a coindexed object.
C1529 (R1522) If <i>data-ref</i> is an array, the referenced type-bound procedure shall have the PASS attribute.
The <i>data-ref</i> in a <i>procedure-designator</i> shall not be an unallocated allocatable variable or a pointer that is not
associated.
Resolving references to type-bound procedures is described in 15.5.6.
A function may also be referenced as a defined operation (10.1.6). A subroutine may also be referenced as a
defined assignment (10.2.1.4, 10.2.1.5), by defined input/output (12.6.4.8), or by finalization (7.5.6).
<b>NOTE</b> <b>1</b>
When resolving type-bound procedure references, constraints on the use of coindexed objects ensure that the
coindexed object (on the remote image) has the same dynamic type as the corresponding object on the local
image. Thus a processor can resolve the type-bound procedure using the coarray variable on its own image and
pass the coindexed object as the actual argument.
R1523 <i>actual-arg-spec</i> <b>is</b> [ <i>keyword</i> = ] <i>actual-arg</i>
R1524 <i>actual-arg</i> <b>is</b> <i>expr</i>
              <b>or</b> <i>variable</i>
              <b>or</b> <i>procedure-name</i>
              <b>or</b> <i>proc-component-ref</i>
              <b>or</b> <i>conditional-arg</i>
              <b>or</b> <i>alt-return-spec</i>
R1525 <i>alt-return-spec</i> <b>is</b> * <i>label</i>
C1530 (R1523) The <i>keyword</i> = shall not appear if the interface of the procedure is implicit.
C1531 (R1523) The <i>keyword</i> = shall not be omitted from an <i>actual-arg-spec</i> unless it has been omitted from
   each preceding <i>actual-arg-spec</i> in the argument list.
C1532 (R1523) Each <i>keyword</i> shall be the name of a dummy argument in the explicit interface of the procedure.
C1533 (R1524) A nonintrinsic elemental procedure shall not be used as an actual argument.
C1534 (R1524) A <i>procedure-name</i> shall be the name of an external, internal, module, or dummy procedure, a
    specific intrinsic function listed in Table 16.2, or a procedure pointer.
C1535 An <i>actual-arg</i> that is an <i>expr</i> shall not be a variable or a <i>conditional-arg</i>.
C1536 (R1525) The <i>label</i> shall be the statement label of a branch target statement that appears in the same inclusive scope as the
    <i>call-stmt</i>.
C1537 An actual argument that is a coindexed object shall not have a pointer ultimate component.
R1526 <i>conditional-arg</i> <b>is</b> ( <i>scalar-logical-expr</i> ? <i>consequent</i>
                   [ : <i>scalar-logical-expr</i> ? <i>consequent</i> ]... : <i>consequent</i> )
R1527 <i>consequent</i> <b>is</b> <i>consequent-arg</i>
              <b>or</b> .NIL.
R1528 <i>consequent-arg</i> <b>is</b> <i>expr</i>
              <b>or</b> <i>variable</i>
C1538 Each <i>consequent-arg</i> of a <i>conditional-arg</i> shall have the same declared type, and kind type parameters.
C1539 Either all <i>consequent-arg</i>s in a <i>conditional-arg</i> shall have the same rank, or be assumed-rank.
C1540 At least one <i>consequent</i> in a <i>conditional-arg</i> shall be a <i>consequent-arg</i>. If the corresponding dummy
   argument is not optional, .NIL. shall not appear.
C1541 If its corresponding dummy argument is INTENT (OUT) or INTENT (INOUT), each <i>consequent-arg</i> in
   a <i>conditional-arg</i> shall be a variable.
C1542 If its corresponding dummy argument is allocatable, a pointer, or a coarray, the attributes of each
   <i>consequent-arg</i> in a <i>conditional-arg</i> shall satisfy the requirements of that dummy argument.
C1543 A <i>consequent-arg</i> shall not be assumed-rank unless its corresponding dummy argument is assumed-rank.
C1544 A <i>consequent-arg</i> that is an <i>expr</i> shall not be a variable.
C1545 In a reference to a generic procedure, each <i>consequent-arg</i> in a <i>conditional-arg</i> shall have the same corank,
   and if any <i>consequent-arg</i> of a <i>conditional-arg</i> has the ALLOCATABLE or POINTER attribute, each
   <i>consequent-arg</i> shall have that attribute.
<b>NOTE</b> <b>2</b>
Examples of procedure reference using procedure pointers:
   P => BESSEL
   WRITE (*, *) P(2.5) !-- BESSEL(2.5)
   S => PRINT_REAL
   CALL S(3.14)
<b>NOTE</b> <b>3</b>
An internal procedure cannot be invoked using a procedure pointer from either Fortran or C after the host
instance completes execution, because the pointer is then undefined. While the host instance is active, however,
if an internal procedure was passed as an actual argument or is the target of a procedure pointer, it could be
invoked from outside of the host subprogram.
Assume there is a procedure with the following interface that calculates
                    R
                                  <i>b</i>
                                  <i>a</i>
                            <i>f</i>(<i>x</i>)<i>dx</i>.
                <b>J3/23-007r1</b> <b>321</b>
<b>NOTE</b> <b>3</b> <b>(cont.)</b>
   INTERFACE
     FUNCTION INTEGRATE(F, A, B) RESULT(INTEGRAL) BIND(C)
      USE ISO_C_BINDING
      INTERFACE
        FUNCTION F(X) BIND(C) ! Integrand
         USE ISO_C_BINDING
         REAL(C_FLOAT), VALUE :: X
         REAL(C_FLOAT) :: F
        END FUNCTION
      END INTERFACE
      REAL(C_FLOAT), VALUE :: A, B ! Bounds
      REAL(C_FLOAT) :: INTEGRAL
     END FUNCTION INTEGRATE
   END INTERFACE
This procedure can be called from Fortran or C, and could be written in either Fortran or C. The argument F
representing the mathematical function <i>f</i>(<i>x</i>) can be written as an internal procedure; this internal procedure
will have access to any host instance local variables necessary to actually calculate <i>f</i>(<i>x</i>). For example:
   REAL FUNCTION MY_INTEGRATION(N, A, B) RESULT(INTEGRAL)
     ! Integrate f(x)=x^n over [a,b]
     USE ISO_C_BINDING
     INTEGER, INTENT(IN) :: N
     REAL, INTENT(IN) :: A, B
     INTEGRAL = INTEGRATE(MY_F, REAL (A, C_FLOAT), REAL (B, C_FLOAT))
      ! This will call the internal function MY_F to calculate f(x).
      ! The above interface of INTEGRATE needs to be explicit and available.
   CONTAINS
     REAL(C_FLOAT) FUNCTION MY_F(X) BIND(C) ! Integrand
      REAL(C_FLOAT), VALUE :: X
      MY_F = X**N ! N is taken from the host instance of MY_INTEGRATION.
     END FUNCTION
   END FUNCTION MY_INTEGRATION
The function INTEGRATE cannot retain a function pointer to MY_F and use it after INTEGRATE has
finished execution, because the host instance of MY_F might no longer exist, making the pointer undefined. If
such a pointer is retained, then it can only be used to invoke MY_F during the execution of the instance of
MY_INTEGRATION that called INTEGRATE.
<b>15.5.2</b> <b>Actual</b> <b>arguments,</b> <b>dummy</b> <b>arguments,</b> <b>and</b> <b>argument</b> <b>association</b>
<b>15.5.2.1</b> <b>Argument</b> <b>correspondence</b>
In either a subroutine reference or a function reference, the actual argument list identifies the correspondence
between the actual arguments and the dummy arguments of the procedure. This correspondence can be estab-
lished either by keyword or by position. If an argument keyword appears, the actual argument corresponds to
the dummy argument whose name is the same as the argument keyword (using the dummy argument names from
the interface accessible by the procedure reference). In the absence of an argument keyword, an actual argument
corresponds to the dummy argument occupying the corresponding position in the reduced dummy argument list;
that is, the first actual argument corresponds to the first dummy argument in the reduced list, the second actual
argument corresponds to the second dummy argument in the reduced list, etc. The reduced dummy argument
list is either the full dummy argument list or, if there is a passed-object dummy argument (7.5.4.5), the dummy
argument list with the passed-object dummy argument omitted. Exactly one actual argument shall correspond
to each nonoptional dummy argument. At most one actual argument shall correspond to each optional dummy
argument. Each actual argument shall correspond to a dummy argument.
<b>NOTE</b>
For example, the procedure defined by
   SUBROUTINE SOLVE (FUNCT, SOLUTION, METHOD, STRATEGY, PRINT)
     INTERFACE
      FUNCTION FUNCT (X)
        REAL FUNCT, X
      END FUNCTION FUNCT
     END INTERFACE
     REAL SOLUTION
     INTEGER, OPTIONAL :: METHOD, STRATEGY, PRINT
     ...
can be invoked with
   CALL SOLVE (FUN, SOL, PRINT = 6)
provided its interface is explicit, and if the interface is specified by an interface body, the name of the last
argument is PRINT.
<b>15.5.2.2</b> <b>The</b> <b>passed-object</b> <b>dummy</b> <b>argument</b> <b>and</b> <b>argument</b> <b>correspondence</b>
In a reference to a type-bound procedure, or a procedure pointer component, that has a passed-object dummy
argument (7.5.4.5), the <i>data-ref</i> of the <i>function-reference</i> or <i>call-stmt</i> corresponds, as an actual argument, with
the passed-object dummy argument.
<b>15.5.2.3</b> <b>Conditional</b> <b>argument</b> <b>correspondence</b>
If an <i>actual-arg</i> is a <i>conditional-arg</i>, each <i>scalar-logical-expr</i> is evaluated in order, until the value of a <i>scalar-</i>
<i>logical-expr</i> is true, or there are no more <i>scalar-logical-expr</i>s. If the value of a <i>scalar-logical-expr</i> is true, its
subsequent <i>consequent</i> is chosen; otherwise, the last <i>consequent</i> is chosen.
If the chosen <i>consequent</i> is a <i>consequent-arg</i>, its <i>expr</i> or <i>variable</i> is the actual argument for the corresponding
dummy argument, and if it is an <i>expr</i>, it is evaluated. If the chosen <i>consequent</i> is .NIL., the actual argument for
that dummy argument is not present.
Each <i>consequent-arg</i> in a <i>conditional-arg</i> shall satisfy any requirements of the dummy argument on declared type,
kind type parameters, attributes, and properties that do not depend on evaluation of the <i>consequent-arg</i> or any
contained expressions.
The declared type, kind type parameters, and rank of a <i>conditional-arg</i> are those of its <i>consequent-arg</i>s. It has
the ALLOCATABLE or POINTER attribute if and only if all of its <i>consequent-arg</i>s have that attribute. It is
polymorphic if and only if one or more of its <i>consequent-arg</i>s is polymorphic. If all of its <i>consequent-arg</i>s have
the same corank, it has that corank; otherwise it has corank zero. It is simply contiguous if and only if all of its
<i>consequent-arg</i>s are simply contiguous.
<b>NOTE</b>
An example of conditional arguments in a procedure reference is:
   CALL sub ( ( x>0 ? x : y>0 ? y : z ), &
         ( edge>0 ? edge : mode==3 ? 1.0 : .NIL.), &
         some, other, arguments)
<b>15.5.2.4</b> <b>Argument</b> <b>association</b>
Except in references to intrinsic inquiry functions, a pointer actual argument that corresponds to a nonoptional
nonpointer dummy argument shall be pointer associated with a target.
If a nonpointer dummy argument without the VALUE attribute corresponds to a pointer actual argument that
is pointer associated with a target,
 if the dummy argument is polymorphic, it becomes argument associated with that target;
 if the dummy argument is nonpolymorphic, it becomes argument associated with the declared type part of
  that target.
If a present nonpointer dummy argument without the VALUE attribute corresponds to a nonpointer actual
argument,
 if the dummy argument is polymorphic, it becomes argument associated with that actual argument;
 if the dummy argument is nonpolymorphic, it becomes argument associated with the declared type part of
  that actual argument.
A present dummy argument with the VALUE attribute becomes argument associated with a definable anonymous
data object whose initial value is the value of the actual argument.
A present pointer dummy argument that corresponds to a pointer actual argument becomes argument associated
with that actual argument. A present pointer dummy argument that does not correspond to a pointer actual
argument is not argument associated.
The entity that is argument associated with a dummy argument is called its effective argument.
The ultimate argument is the effective argument if the effective argument is not a dummy argument or a subobject
of a dummy argument. If the effective argument is a dummy argument, the ultimate argument is the ultimate
argument of that dummy argument. If the effective argument is a subobject of a dummy argument, the ultimate
argument is the corresponding subobject of the ultimate argument of that dummy argument.
<b>NOTE</b> <b>1</b>
For the sequence of subroutine calls
   INTEGER :: X(100)
   CALL SUBA (X)
   ...
   SUBROUTINE SUBA(A)
   INTEGER :: A(:)
   CALL SUBB (A(1:5), A(5:1:-1))
   ...
   SUBROUTINE SUBB(B, C)
   INTEGER :: B(:), C(:)
the ultimate argument of B is X(1:5). The ultimate argument of C is X(5:1:-1) and this is not the same object
as the ultimate argument of B.
<b>NOTE</b> <b>2</b>
Fortran argument association is usually similar to call by reference and call by value-result. If the VALUE
attribute is specified, the effect is as if the actual argument were assigned to a temporary variable, and that
variablewerethenargumentassociatedwiththedummyargument. Subsequentchangestothevalueordefinition
status of the dummy argument do not affect the actual argument. The actual mechanism by which this happens
is determined by the processor.
<b>15.5.2.5</b> <b>Ordinary</b> <b>dummy</b> <b>variables</b>
The requirements in this subclause apply to actual arguments that correspond to nonallocatable nonpointer
dummy data objects.
Thedummyargumentshallbetypecompatiblewiththeactualargument. Iftheactualargumentisapolymorphic
coindexed object, the dummy argument shall not be polymorphic. If the actual argument is a polymorphic
assumed-size array, the dummy argument shall be polymorphic. If the actual argument is of a derived type that
has type parameters, type-bound procedures, or final subroutines, the dummy argument shall not be assumed-
type.
The kind type parameter values of the actual argument shall agree with the corresponding ones of the dummy
argument. The length type parameter values of a present actual argument shall agree with the corresponding
ones of the dummy argument that are not assumed, except for the case of the character length parameter of
an actual argument of type character with default kind or C character kind (18.2.2) associated with a dummy
argument that is not assumed-shape or assumed-rank.
If a present scalar dummy argument is of type character with default kind or C character kind, the length <i>len</i> of
the dummy argument shall be less than or equal to the length of the actual argument. The dummy argument
becomes associated with the leftmost <i>len</i> characters of the actual argument. If a present array dummy argument
is of type character with default kind or C character kind and is not assumed-shape or assumed-rank, it becomes
associated with the leftmost characters of the actual argument element sequence (15.5.2.12).
The values of assumed type parameters of a dummy argument are assumed from the corresponding type para-
meters of its effective argument.
If the actual argument is a coindexed object with an allocatable ultimate component, the dummy argument shall
have the INTENT (IN) or the VALUE attribute.
<b>NOTE</b> <b>1</b>
If the actual argument is a coindexed object, a processor that uses distributed memory might create a copy
on the executing image of the actual argument, including copies of any allocated allocatable subobjects, and
associate the dummy argument with that copy. If necessary, on return from the procedure, the value of the
copy would be copied back to the actual argument.
Except in references to intrinsic inquiry functions, if the dummy argument is nonoptional and the actual argument
is allocatable, the corresponding actual argument shall be allocated.
IfthedummyargumentdoesnothavetheTARGETattribute, anypointersassociatedwiththeeffectiveargument
do not become associated with the corresponding dummy argument on invocation of the procedure. If such a
dummy argument is used as an actual argument that corresponds to a dummy argument with the TARGET
attribute, whetheranypointersassociatedwiththeoriginaleffectiveargumentbecomeassociatedwiththedummy
argument with the TARGET attribute is processor dependent.
If the dummy argument has the TARGET attribute, does not have the VALUE attribute, and either the effective
argument is simply contiguous or the dummy argument is scalar, assumed-rank, or assumed-shape, and does not
have the CONTIGUOUS attribute, and the effective argument has the TARGET attribute but is not a coindexed
object or an array section with a vector subscript then
 any pointers associated with the effective argument become associated with the corresponding dummy
  argument on invocation of the procedure, and
 when execution of the procedure completes, any pointers that do not become undefined (19.5.2.5) and are
  associated with the dummy argument remain associated with the effective argument.
If the dummy argument has the TARGET attribute and is an explicit-shape array, an assumed-shape array with
the CONTIGUOUS attribute, an assumed-rank object with the CONTIGUOUS attribute, or an assumed-size
array, and the effective argument has the TARGET attribute but is not simply contiguous and is not an array
section with a vector subscript then
 on invocation of the procedure, whether any pointers associated with the effective argument become asso-
  ciated with the corresponding dummy argument is processor dependent, and
 when execution of the procedure completes, the pointer association status of any pointer that is pointer
  associated with the dummy argument is processor dependent.
If the dummy argument has the TARGET attribute and the effective argument does not have the TARGET
attribute or is an array section with a vector subscript, any pointers associated with the dummy argument
become undefined when execution of the procedure completes.
If the dummy argument has the TARGET attribute and the VALUE attribute, any pointers associated with the
dummy argument become undefined when execution of the procedure completes.
If the actual argument is a coindexed scalar, the corresponding dummy argument shall be scalar.
If the actual argument is a noncoindexed scalar, the corresponding dummy argument shall be scalar unless
 the actual argument is default character, of type character with the C character kind (18.2.2), or is an
  element or substring of an element of an array that is not an assumed-shape, pointer, or polymorphic array,
 the dummy argument has assumed-rank, or
 the dummy argument is an assumed-type assumed-size array.
Iftheprocedureisnonelementalandisreferencedbyagenericnameorasadefinedoperatorordefinedassignment,
the ranks of the actual arguments and corresponding dummy arguments shall agree.
If a dummy argument is an assumed-shape array, the rank of the actual argument shall be the same as the rank
of the dummy argument, and the actual argument shall not be an assumed-size array.
An actual argument of any rank may correspond to an assumed-rank dummy argument. The rank and extents of
the dummy argument are the rank and extents of the corresponding actual argument. The lower bound of each
dimension of the dummy argument is equal to one. The upper bound is equal to the extent, except for the last
dimension when the actual argument is assumed-size.
Except when a procedure reference is elemental (15.9), each element of an array actual argument or of a sequence
in a sequence association (15.5.2.12) is associated with the element of the dummy array that has the same position
in array element order (9.5.3.3).
<b>NOTE</b> <b>2</b>
For default character sequence associations, the interpretation of element is provided in 15.5.2.12.
A scalar dummy argument of a nonelemental procedure shall correspond only to a scalar actual argument.
If a dummy argument has INTENT (OUT) or INTENT (INOUT), the actual argument shall be definable. If a
dummy argument has INTENT (OUT), the effective argument becomes undefined at the time the association is
established, except for direct components of an object of derived type for which default initialization has been
specified.
If the procedure is nonelemental, the dummy argument does not have the VALUE attribute, and the actual
argument is an array section having a vector subscript, the dummy argument is not definable and shall not have
the ASYNCHRONOUS, INTENT (OUT), INTENT (INOUT), or VOLATILE attributes.
If the dummy argument has a coarray potential subobject component, the corresponding actual argument shall
have the VOLATILE attribute if and only if the dummy argument has the VOLATILE attribute. If the dummy
argument is an array with a coarray potential subobject component, the corresponding actual argument shall be
simply contiguous or an element of a simply contiguous array.
<b>NOTE</b> <b>3</b>
Argument intent specifications serve several purposes. See 8.5.10, NOTE 4.
<b>NOTE</b> <b>4</b>
For more explanatory information on targets as dummy arguments, see C.11.4.
C1546 An actual argument that is a coindexed object with the ASYNCHRONOUS or VOLATILE attribute
   shall not correspond to a dummy argument that has the ASYNCHRONOUS attribute, unless the dummy
   argument has the VALUE attribute.
C1547 An actual argument that is a coindexed object with the ASYNCHRONOUS or VOLATILE attribute
   shall not correspond to a dummy argument that has the VOLATILE attribute.
C1548 (R1524) If an actual argument is a nonpointer array that has the ASYNCHRONOUS or VOLATILE
   attribute but is not simply contiguous (9.5.4), and the corresponding dummy argument has either the
   ASYNCHRONOUS or VOLATILE attribute, but does not have the VALUE attribute, that dummy
   argument shall be assumed-shape or assumed-rank and shall not have the CONTIGUOUS attribute.
C1549 (R1524) If an actual argument is an array pointer that has the ASYNCHRONOUS or VOLATILE
   attribute but does not have the CONTIGUOUS attribute, and the corresponding dummy argument
   has either the ASYNCHRONOUS or VOLATILE attribute, but does not have the VALUE attribute,
   that dummy argument shall be an array pointer, an assumed-shape array without the CONTIGUOUS
   attribute, or an assumed-rank entity without the CONTIGUOUS attribute.
<b>NOTE</b> <b>5</b>
The constraints on an actual argument with the ASYNCHRONOUS or VOLATILE attribute that corresponds
to a dummy argument with either the ASYNCHRONOUS or VOLATILE attribute are designed to avoid forcing
a processor to use the so-called copy-in/copy-out argument passing mechanism. Making a copy of an actual
argument whose value is likely to change due to an asynchronous input/output operation completing or in some
unpredictable manner will cause the new value to be lost when a called procedure returns and the copy-out
overwrites the actual argument.
<b>NOTE</b> <b>6</b>
If an effective argument is a discontiguous array, and the dummy argument is an assumed-shape array with the
CONTIGUOUS attribute, an assumed-rank dummy data object with the CONTIGUOUS attribute, an explicit-
shape array, or an assumed-size array, the processor might need to use the so-called copy-in/copy-out argument
passing mechanism, so as to ensure that the dummy array is contiguous even when the actual argument is not.
<b>15.5.2.6</b> <b>Allocatable</b> <b>and</b> <b>pointer</b> <b>dummy</b> <b>variables</b>
TherequirementsinthissubclauseapplytoanactualargumentwiththeALLOCATABLEorPOINTERattribute
that corresponds to a dummy argument with the same attribute.
The actual argument shall be polymorphic if and only if the associated dummy argument is polymorphic, and
either both the actual and dummy arguments shall be unlimited polymorphic, or the declared type of the actual
argument shall be the same as the declared type of the dummy argument.
<b>NOTE</b>
The dynamic type of a polymorphic allocatable or pointer dummy argument can change as a result of execution
of an ALLOCATE statement or pointer assignment in the subprogram. Because of this the corresponding
actual argument needs to be polymorphic and have a declared type that is the same as the declared type of the
dummy argument or an extension of that type. However, type compatibility requires that the declared type
of the dummy argument be the same as, or an extension of, the type of the actual argument. Therefore, the
dummy and actual arguments need to have the same declared type.
Dynamic type information is not maintained for a nonpolymorphic allocatable or pointer dummy argument.
However, allocating or pointer-assigning such a dummy argument would require maintenance of this information
if the corresponding actual argument is polymorphic. Therefore, the corresponding actual argument needs to
be nonpolymorphic.
The rank of the actual argument shall be the same as that of the dummy argument, unless the dummy argument
is assumed-rank. The type parameter values of the actual argument shall agree with the corresponding ones of
the dummy argument that are not assumed or deferred. The values of assumed type parameters of the dummy
argument are assumed from the corresponding type parameters of its effective argument.
The actual argument shall have deferred the same type parameters as the dummy argument.
<b>15.5.2.7</b> <b>Allocatable</b> <b>dummy</b> <b>variables</b>
The requirements in this subclause apply to actual arguments that correspond to allocatable dummy data objects.
The actual argument shall be allocatable. It is permissible for the actual argument to have an allocation status
of unallocated.
The corank of the actual argument shall be the same as that of the dummy argument.
If the actual argument is a coindexed object, the dummy argument shall have the INTENT (IN) attribute.
If the dummy argument does not have the TARGET attribute, any pointers associated with the actual argument
do not become associated with the corresponding dummy argument on invocation of the procedure. If such a
dummy argument is used as an actual argument that is associated with a dummy argument with the TARGET
attribute, whether any pointers associated with the original actual argument become associated with the dummy
argument with the TARGET attribute is processor dependent.
If the dummy argument has the TARGET attribute, does not have the INTENT (OUT) or VALUE attribute,
and the corresponding actual argument has the TARGET attribute then
 any pointers associated with the actual argument become associated with the corresponding dummy argu-
  ment on invocation of the procedure, and
 when execution of the procedure completes, any pointers that do not become undefined (19.5.2.5) and are
  associated with the dummy argument remain associated with the actual argument.
If a dummy argument has INTENT (OUT) or INTENT (INOUT), the actual argument shall be definable. If a
dummy argument has INTENT (OUT) and its associated actual argument is allocated, the actual argument is
deallocated on procedure invocation (9.7.3.2).
<b>15.5.2.8</b> <b>Pointer</b> <b>dummy</b> <b>variables</b>
The requirements in this subclause apply to actual arguments that correspond to dummy data pointers.
C1550 The actual argument corresponding to a dummy pointer with the CONTIGUOUS attribute shall be
   simply contiguous (9.5.4).
C1551 The actual argument corresponding to a dummy pointer shall not be a coindexed object.
<b>NOTE</b> <b>1</b>
Constraint C1551 does not apply to any intrinsic procedure because an intrinsic procedure is defined in terms
of its actual arguments.
If the dummy argument does not have INTENT (IN), the actual argument shall be a pointer. Otherwise, the
actual argument shall be a pointer or a valid target for the dummy pointer in a pointer assignment statement. If
the actual argument is not a pointer, the dummy pointer becomes pointer associated with the actual argument.
If the dummy argument has INTENT (OUT), the pointer association status of the actual argument becomes
undefined on invocation of the procedure.
<b>NOTE</b> <b>2</b>
For more explanatory information on pointers as dummy arguments, see C.11.4.
<b>15.5.2.9</b> <b>Coarray</b> <b>dummy</b> <b>variables</b>
If the dummy argument is a coarray, the corresponding actual argument shall be a coarray and shall have the
VOLATILE attribute if and only if the dummy argument has the VOLATILE attribute.
If the dummy argument is an array coarray that has the CONTIGUOUS attribute or is not of assumed shape,
the corresponding actual argument shall be simply contiguous or an element of a simply contiguous array.
<b>NOTE</b> <b>1</b>
The requirements on an actual argument that corresponds to a dummy coarray that is not of assumed-shape or
has the CONTIGUOUS attribute are designed to avoid forcing a processor to use the so-called copy-in/copy-out
argument passing mechanism.
<b>NOTE</b> <b>2</b>
Consider the invocation of a procedure on a particular image. Each dummy coarray is associated with its
ultimate argument on the image. In addition, during this execution of the procedure, this image can access the
coarray corresponding to the ultimate argument on any other image. For example, consider
   INTERFACE
     SUBROUTINE SUB(X)
      REAL :: X[*]
     END SUBROUTINE SUB
   END INTERFACE
   REAL :: A(1000)[*]
    ...
   CALL SUB(A(10))
During execution of this invocation of SUB, the executing image has access through the syntax X[P] to A(10)
on image P.
<b>NOTE</b> <b>3</b>
Each invocation of a procedure with a nonallocatable coarray dummy argument establishes a dummy coarray
for the image with its own bounds and cobounds. During this execution of the procedure, this image can use its
own bounds and cobounds to access the coarray corresponding to the ultimate argument on any other image.
For example, consider
   INTERFACE
     SUBROUTINE SUB(X,N)
      INTEGER :: N
      REAL :: X(N,N)[N,*]
     END SUBROUTINE SUB
   END INTERFACE
   REAL :: A(1000)[*]
    ...
   CALL SUB(A,10)
During execution of this invocation of SUB, the executing image has access through the syntax X(1,2)[3,4] to
A(11) on the image with image index 33.
<b>15.5.2.10</b> <b>Actual</b> <b>arguments</b> <b>associated</b> <b>with</b> <b>dummy</b> <b>procedure</b> <b>entities</b>
If the interface of a dummy procedure is explicit, its characteristics as a procedure (15.3.1) shall be the same as
those of its effective argument, except that a pure effective argument may be associated with a dummy argument
that is not pure, a simple effective argument may be associated with a dummy argument that is not simple, and
an elemental intrinsic actual procedure may be associated with a dummy procedure (which cannot be elemental).
If the interface of a dummy procedure is implicit and either the dummy argument is explicitly typed or referenced
as afunction, it shall not be referencedas a subroutine and any corresponding actual argument shall be a function,
function procedure pointer, or dummy procedure. If both the actual argument and dummy argument are known
to be functions, they shall have the same type and type parameters. If only the dummy argument is known to
be a function, the function that would be invoked by a reference to the dummy argument shall have the same
type and type parameters, except that an external function with assumed character length may be associated with a dummy
argument with explicit character length.
If the interface of a dummy procedure is implicit and a reference to it appears as a subroutine reference, any
corresponding actual argument shall be a subroutine, subroutine procedure pointer, or dummy procedure.
If a dummy argument is a dummy procedure without the POINTER attribute, its effective argument shall be an
external, internal, module, or dummy procedure, or a specific intrinsic procedure listed in Table 16.2. If the specific name
is also a generic name, only the specific procedure is associated with the dummy argument.
If a dummy argument is a procedure pointer, the corresponding actual argument shall be a procedure pointer, a
reference to a function that returns a procedure pointer, a reference to the intrinsic function NULL, or a valid
target for the dummy pointer in a pointer assignment statement. If the actual argument is not a pointer, the
dummy argument shall have INTENT (IN); if the actual argument is not a dummy argument it becomes pointer
associated with the actual argument, otherwise it becomes pointer associated with the ultimate argument of the
actual argument.
When the actual argument is a procedure, the host instance of the dummy argument is the host instance of the
actual argument (15.6.2.4).
If an external procedure or a dummy procedure is used as an actual argument, its interface shall be explicit or it
shall be explicitly declared to have the EXTERNAL attribute.
<b>15.5.2.11</b> <b>Actual</b> <b>arguments</b> <b>and</b> <b>alternate</b> <b>return</b> <b>indicators</b>
If a dummy argument is an asterisk (15.6.2.3), the corresponding actual argument shall be an alternate return specifier (R1525).
<b>15.5.2.12</b> <b>Sequence</b> <b>association</b>
Sequence association only applies when the dummy argument is an explicit-shape or assumed-size array. The
rest of this subclause only applies in that case.
An actual argument represents an element sequence if it is an array expression, an array element designator, a
default character scalar, or a scalar of type character with the C character kind (18.2.2).
If the dummy argument is not of type character with default or C character kind:
 if the actual argument is an array expression, the element sequence consists of the elements in array element
  order;
 if the actual argument is an array element designator of a simply contiguous array, the element sequence
  consists of that array element and each element that follows it in array element order;
 otherwise, if the actual argument is scalar, the element sequence consists of that scalar.
If the dummy argument is of type character with default or C character kind, and has nonzero character length,
the storage unit sequence is as follows:
 if the actual argument is an array expression, the storage units of the array;
 if the actual argument is an array element or array element substring designator of a simply contiguous
  array, the storage units starting from the first storage unit of the designator and continuing to the end of
  the array;
 otherwise, if the actual argument is scalar, the storage units of the scalar object.
The element sequence is the sequence of consecutive groups of storage units in the storage unit sequence, grouped
by the character length of the dummy array. The sequence terminates when the number of storage units left is
less than the character length of the dummy array.
<b>NOTE</b>
Some of the elements in the element sequence might consist of storage units from different elements of the
original array.
If the dummy argument is of type character with default or C character kind, and has zero character length,
the element sequence consists of a sequence of elements each with zero character length, the number of elements
being the maximum number that is supported by the processor.
An actual argument that represents an element sequence and corresponds to a dummy argument that is an array
is sequence associated with the dummy argument. The rank and shape of the actual argument need not agree
with the rank and shape of the dummy argument, but the number of elements in the dummy argument shall
not exceed the number of elements in the element sequence of the actual argument. If the dummy argument is
assumed-size, the number of elements in the dummy argument is exactly the number of elements in the element
sequence.
<b>15.5.2.13</b> <b>Argument</b> <b>presence</b> <b>and</b> <b>restrictions</b> <b>on</b> <b>arguments</b> <b>not</b> <b>present</b>
A dummy argument or an entity that is host associated with a dummy argument is not present if the dummy
argument
 does not correspond to an actual argument,
 corresponds to an actual argument that is not present, or
 does not have the ALLOCATABLE or POINTER attribute, and corresponds to an actual argument that
   <b>-</b> has the ALLOCATABLE attribute and is not allocated, or
   <b>-</b> has the POINTER attribute and is disassociated;
otherwise, it is present.
A nonoptional dummy argument shall be present. If an optional nonpointer dummy argument corresponds to a
present pointer actual argument, the pointer association status of the actual argument shall not be undefined.
An optional dummy argument that is not present is subject to the following restrictions.
  (1) If it is a data object, it shall not be referenced or be defined. If it is of a type that has default
     initialization, the initialization has no effect.
  (2) It shall not be used as the <i>data-target</i> or <i>proc-target</i> of a pointer assignment.
  (3) If it is a procedure or procedure pointer, it shall not be invoked.
  (4) It shall not be supplied as an actual argument corresponding to a nonoptional dummy argument
     other than as the argument of the intrinsic function PRESENT or as an argument of a function
     reference that is a constant expression.
  (5) A designator with it as the base object and with one or more subobject selectors shall not be supplied
     as an actual argument.
  (6) If it is an array, it shall not be supplied as an actual argument to an elemental procedure unless an
     array of the same rank is supplied as an actual argument corresponding to a nonoptional dummy
     argument of that elemental procedure.
  (7) If it is a pointer, it shall not be allocated, deallocated, nullified, pointer-assigned, or supplied as an
     actual argument corresponding to an optional nonpointer dummy argument.
  (8) If it is allocatable, it shall not be allocated, deallocated, or supplied as an actual argument corres-
     ponding to an optional nonallocatable dummy argument.
  (9) If it has length type parameters, they shall not be the subject of an inquiry.
  (10) Itshallnotbeusedasa<i>selector</i> inanASSOCIATE,CHANGETEAM,SELECTRANK,orSELECT
     TYPE construct.
  (11) It shall not be supplied as the <i>data-ref</i> in a <i>procedure-designator</i>.
  (12) If shall not be supplied as the <i>scalar-variable</i> in a <i>proc-component-ref</i>.
Except as noted in the list above, it may be supplied as an actual argument corresponding to an optional dummy
argument, which is then also considered not to be present.
<b>15.5.2.14</b> <b>Restrictions</b> <b>on</b> <b>entities</b> <b>associated</b> <b>with</b> <b>dummy</b> <b>arguments</b>
While an entity is associated with a dummy argument, the following restrictions hold.
  (1) Action that affects the allocation status of the entity or a subobject thereof shall be taken through
     the dummy argument.
  (2) If the allocation status of the entity or a subobject thereof is affected through the dummy argument,
     then at any time during the invocation and execution of the procedure, either before or after the
     allocation or deallocation, it shall be referenced only through the dummy argument.
  (3) Action that affects the value of the entity or any subobject of it shall be taken only through the
     dummy argument unless
     (a) the dummy argument has the POINTER attribute,
     (b) the dummy argument is a scalar, assumed-shape, or assumed-rank object, and has the TAR-
        GET attribute but not the INTENT (IN) or CONTIGUOUS attributes, and the actual argu-
        ment is a target other than a coindexed object or an array section with a vector subscript,
     (c) the dummy argument is an assumed-rank object with the TARGET attribute and not the
        INTENT (IN) attribute, and the actual argument is a scalar target,
     (d) the dummy argument is a coarray and the action is a coindexed definition of the corresponding
        ultimate argument coarray by a different image, or
     (e) the dummy argument has a coarray potential subobject component and the action is a coin-
        dexed definition of the corresponding coarray by a different image.
  (4) If the value of the entity or any subobject of it is affected through the dummy argument, then at
     any time during the invocation and execution of the procedure, either before or after the definition,
     it shall be referenced only through that dummy argument unless
     (a) the dummy argument has the POINTER attribute,
     (b) the dummy argument is a scalar, assumed-shape, or assumed-rank object, and has the TAR-
        GET attribute but not the INTENT (IN) or CONTIGUOUS attributes, and the actual argu-
        ment is a target other than a coindexed object or an array section with a vector subscript,
     (c) the dummy argument is an assumed-rank object with the TARGET attribute and not the
        INTENT (IN) attribute, and the actual argument is a scalar target,
     (d) thedummyargumentisacoarrayandthereferenceisacoindexedreferenceofitscorresponding
        ultimate argument coarray by a different image, or
     (e) the dummy argument has a coarray potential subobject component and the reference is a
        coindexed reference of the corresponding coarray by a different image.
<b>NOTE</b> <b>1</b>
In
   SUBROUTINE OUTER
     REAL, POINTER :: A (:)
     ...
     ALLOCATE (A (1:N))
     ...
     CALL INNER (A)
     ...
   CONTAINS
     SUBROUTINE INNER (B)
      REAL :: B (:)
<b>332</b> <b>J3/23-007r1</b>
<b>NOTE</b> <b>1</b> <b>(cont.)</b>
       ...
     END SUBROUTINE INNER
     SUBROUTINE SET (C, D)
      REAL, INTENT (OUT) :: C
      REAL, INTENT (IN) :: D
      C = D
     END SUBROUTINE SET
   END SUBROUTINE OUTER
an assignment statement such as
   A (1) = 1.0
would not be permitted during the execution of INNER because this would be changing A without using B,
but statements such as
   B (1) = 1.0
or
   CALL SET (B (1), 1.0)
would be allowed. Similarly,
   DEALLOCATE (A)
would not be allowed because this affects the allocation of B without using B. In this case,
   DEALLOCATE (B)
also would not be permitted. If B were declared with the POINTER attribute, either of the statements
   DEALLOCATE (A)
and
   DEALLOCATE (B)
would be permitted, but not both.
<b>NOTE</b> <b>2</b>
If there is a partial or complete overlap between the effective arguments of two different dummy arguments
of the same procedure and the dummy arguments have neither the POINTER nor TARGET attribute, the
overlapped portions cannot be defined, redefined, or become undefined during the execution of the procedure.
For example, in
   CALL SUB (A (1:5), A (3:9))
the array section A (3:5) cannot be defined, redefined, or become undefined through the first dummy argument
becauseitispartoftheargumentassociatedwiththeseconddummyargumentandcannotbedefined, redefined,
or become undefined through the second dummy argument because it is part of the argument associated with
the first dummy argument. The array section A (1:2) remains definable through the first dummy argument and
A (6:9) remains definable through the second dummy argument.
This restriction applies equally to pointer targets. In
   REAL, DIMENSION (10), TARGET :: A
   REAL, DIMENSION (:), POINTER :: B, C
   B => A (1:5)
   C => A (3:9)
   CALL SUB (B, C) ! The dummy arguments of SUB are neither pointers nor targets.
the array section B (3:5) cannot be defined because it is part of the argument associated with the second dummy
argument. The array section C (1:3) cannot be defined because it is part of the argument associated with the
first dummy argument. The array section A (1:2), which is associated with B (1:2), remains definable through
                <b>J3/23-007r1</b> <b>333</b>
<b>NOTE</b> <b>2</b> <b>(cont.)</b>
the first dummy argument and A (6:9), which is associated with C (4:7), remains definable through the second
dummy argument.
<b>NOTE</b> <b>3</b>
In
   MODULE DATA
     REAL :: W, X, Y, Z
   END MODULE DATA
   PROGRAM MAIN
     USE DATA
      ...
     CALL INIT (X)
      ...
   END PROGRAM MAIN
   SUBROUTINE INIT (V)
     USE DATA
      ...
     READ (*, *) V
      ...
   END SUBROUTINE INIT
variable X cannot be directly referenced at any time during the execution of INIT because it is being defined
through the dummy argument V. X can be (indirectly) referenced through V. W, Y, and Z can be directly
referenced. X can, of course, be directly referenced once execution of INIT is complete.
<b>NOTE</b> <b>4</b>
Therestrictionsonentitiesassociatedwithdummyargumentsareintendedtofacilitateavarietyofoptimizations
in the translation of the subprogram, including implementations of argument association in which the value of
an actual argument that is neither a pointer nor a target is maintained in a register or in local storage.
<b>NOTE</b> <b>5</b>
The exceptions to the aliasing restrictions for dummy arguments that are coarrays or have coarray potential
subobject components enable cross-image access while the procedure is executing. Because nonatomic accesses
from different images typically need to be separated by an image control statement, code optimization within
segments is not unduly inhibited.
<b>15.5.3</b> <b>Function</b> <b>reference</b>
A function is invoked during expression evaluation by a <i>function-reference</i> or by a defined operation (10.1.6).
When it is invoked, all actual argument expressions are evaluated, then the arguments are associated, and then
the function is executed. When execution of the function is complete, the value of the function result is available
for use in the expression that caused the function to be invoked. The characteristics of the function result (15.3.3)
are determined by the interface of the function. If a reference to an elemental function (15.9) is an elemental
reference, all array arguments shall have the same shape.
<b>15.5.4</b> <b>Subroutine</b> <b>reference</b>
AsubroutineisinvokedbyexecutionofaCALLstatement, executionofadefinedassignmentstatement(10.2.1.4),
defined input/output (12.6.4.8.3), or finalization(7.5.6). When a subroutine is invoked, all actual argument
expressions are evaluated, then the arguments are associated, and then the subroutine is executed. When the
actions specified by the subroutine are completed, the execution of the CALL statement, the execution of the
defined assignment statement, the processing of an effective item, or finalization of an object is also completed. If
a CALL statement includes one or more alternate return specifiers among its arguments, a branch to one of the statements indicated
might occur, depending on the action specified by the subroutine. If a reference to an elemental subroutine (15.9) is an
elemental reference, at least one actual argument shall correspond to an INTENT (OUT) or INTENT (INOUT)
dummy argument, all such actual arguments shall be arrays, and all actual arguments shall be conformable.
<b>15.5.5</b> <b>Resolving</b> <b>named</b> <b>procedure</b> <b>references</b>
<b>15.5.5.1</b> <b>Establishment</b> <b>of</b> <b>procedure</b> <b>names</b>
The rules for interpreting a procedure reference depend on whether the procedure name in the reference is
established by the available declarations and specifications to be generic in the scoping unit containing the
reference, is established to be only specific in the scoping unit containing the reference, or is not established.
A procedure name is established to be generic in a scoping unit
  (1) if that scoping unit contains an interface block with that name;
  (2) if that scoping unit contains a GENERIC statement with a <i>generic-spec</i> that is that name;
  (3) if that scoping unit contains an INTRINSIC attribute specification for that name and it is the generic
     name of an intrinsic procedure;
  (4) if that scoping unit contains a USE statement that makes that procedure name accessible and the
     corresponding name in the module is established to be generic; or
  (5) if that scoping unit contains no declarations of that name, that scoping unit has a host scoping unit,
     and that name is established to be generic in the host scoping unit.
A procedure name is established to be only specific in a scoping unit if it is established to be specific and not
established to be generic. It is established to be specific
  (1) if that scoping unit contains a module subprogram, internal subprogram, or statement function statement
     that defines a procedure with that name;
  (2) if that scoping unit is of a subprogram that defines a procedure with that name;
  (3) if that scoping unit contains an INTRINSIC attribute specification for that name and it is the name of a specific
      intrinsic procedure;
  (4) if that scoping unit contains an explicit EXTERNAL attribute specification for that name;
  (5) if that scoping unit contains a USE statement that makes that procedure name accessible and the
     corresponding name in the module is established to be specific; or
  (6) if that scoping unit contains no declarations of that name, that scoping unit has a host scoping unit,
     and that name is established to be specific in the host scoping unit.
A procedure name is not established in a scoping unit if it is neither established to be generic nor established to
be specific.
<b>15.5.5.2</b> <b>Resolving</b> <b>procedure</b> <b>references</b> <b>to</b> <b>names</b> <b>established</b> <b>to</b> <b>be</b> <b>generic</b>
If the reference is consistent with a nonelemental reference to one of the specific interfaces of a generic interface
that has that name and either is defined in the scoping unit in which the reference appears or is made accessible
by a USE statement in the scoping unit, the reference is to the specific procedure in the interface block that
provides that interface. The rules in 15.4.3.4.5 ensure that there can be at most one such specific procedure.
Otherwise, if the reference is consistent with an elemental reference to one of the specific interfaces of a generic
interface that has that name and either is defined in the scoping unit in which the reference appears or is made
accessible by a USE statement in the scoping unit, the reference is to the specific elemental procedure in the
interface block that provides that interface. The rules in 15.4.3.4.5 ensure that there can be at most one such
specific elemental procedure.
Otherwise, if the scoping unit contains either an INTRINSIC attribute specification for that name or a USE
statement that makes that name accessible from a module in which the corresponding name is specified to have
the INTRINSIC attribute, and if the reference is consistent with the interface of that intrinsic procedure, the
reference is to that intrinsic procedure.
Otherwise, if the scoping unit has a host scoping unit, the name is established to be generic in that host scoping
unit, and there is agreement between the scoping unit and the host scoping unit as to whether the name is a
function name or a subroutine name, the name is resolved by applying the rules in this subclause to the host
scoping unit as if the reference appeared there.
Otherwise,ifthenameisthatofanintrinsicprocedureandthereferenceisconsistentwiththatintrinsicprocedure,
the reference is to that intrinsic procedure.
<b>NOTE</b> <b>1</b>
Because of the renaming facility of the USE statement, the name in the reference can be different from the
usual name of the intrinsic procedure.
<b>NOTE</b> <b>2</b>
These rules allow particular specific procedures with the same generic identifier to be used for particular array
ranks and a general elemental version to be used for other ranks. For example, given an interface block such as
   INTERFACE RANF
     ELEMENTAL FUNCTION SCALAR_RANF(X)
      REAL, INTENT(IN) :: X
     END FUNCTION SCALAR_RANF
     FUNCTION VECTOR_RANDOM(X)
      REAL X(:)
      REAL VECTOR_RANDOM(SIZE(X))
     END FUNCTION VECTOR_RANDOM
   END INTERFACE RANF
and a declaration such as:
   REAL A(10,10), AA(10,10)
then the statement
   A = RANF(AA)
is an elemental reference to SCALAR_RANF. The statement
   A(6:10,2) = RANF(AA(6:10,2))
is a nonelemental reference to VECTOR_RANDOM.
<b>15.5.5.3</b> <b>Resolving</b> <b>procedure</b> <b>references</b> <b>to</b> <b>names</b> <b>established</b> <b>to</b> <b>be</b> <b>only</b> <b>specific</b>
If the name has the EXTERNAL attribute,
 if it is a procedure pointer, the reference is to its target;
 if it is a dummy procedure that is not a procedure pointer, the reference is to the effective argument
  corresponding to that name;
 otherwise, the reference is to the external procedure with that name.
If the name is that of an accessible external procedure, internal procedure, module procedure, intrinsic procedure,
or statement function, the reference is to that procedure.
<b>NOTE</b>
Because of the renaming facility of the USE statement, the name in the reference can be different from the
original name of the procedure.
<b>15.5.5.4</b> <b>Resolving</b> <b>procedure</b> <b>references</b> <b>to</b> <b>names</b> <b>not</b> <b>established</b>
If the name is the name of a dummy argument of the scoping unit, the dummy argument is a dummy procedure
and the reference is to that dummy procedure. That is, the procedure invoked by executing that reference is the
effective argument corresponding to that dummy procedure.
Otherwise, if the name is the name of an intrinsic procedure, and if there is agreement between the reference and
the status of the intrinsic procedure as being a function or subroutine, the reference is to that intrinsic procedure.
Otherwise, the reference is to an external procedure with that name.
<b>15.5.6</b> <b>Resolving</b> <b>type-bound</b> <b>procedure</b> <b>references</b>
If the <i>binding-name</i> in a <i>procedure-designator</i> (R1522) is that of a specific type-bound procedure, the procedure
referenced is the one bound to that name in the dynamic type of the <i>data-ref</i>.
If the <i>binding-name</i> in a <i>procedure-designator</i> is that of a generic type-bound procedure, the generic binding with
that name in the declared type of the <i>data-ref</i> is used to select a specific binding using the following criteria.
 If the reference is consistent with one of the specific bindings of that generic binding, that specific binding
  is selected.
 Otherwise, the reference shall be consistent with an elemental reference to one of the specific bindings of
  that generic binding; that specific binding is selected.
The reference is to the procedure bound to the same name as the selected specific binding in the dynamic type
of the <i>data-ref</i>.
<b>15.6</b> <b>Procedure</b> <b>definition</b>
<b>15.6.1</b> <b>Intrinsic</b> <b>procedure</b> <b>definition</b>
Intrinsic procedures are defined as an inherent part of the processor. A standard-conforming processor shall
include the intrinsic procedures described in Clause 16, but may include others. However, a standard-conforming
program shall not make use of intrinsic procedures other than those described in Clause 16.
<b>15.6.2</b> <b>Procedures</b> <b>defined</b> <b>by</b> <b>subprograms</b>
<b>15.6.2.1</b> <b>General</b>
A procedure is defined by the initial SUBROUTINE or FUNCTION statement of a subprogram, and each ENTRY
statement defines an additional procedure (15.6.2.6).
A subprogram is specified to have the NON_RECURSIVE attribute, or to be elemental (15.9), pure (15.7), or a
separate module subprogram (15.6.2.5) by a <i>prefix</i> in its initial SUBROUTINE or FUNCTION statement.
R1529 <i>prefix</i> <b>is</b> <i>prefix-spec</i> [ <i>prefix-spec</i> ] ...
R1530 <i>prefix-spec</i> <b>is</b> <i>declaration-type-spec</i>
              <b>or</b> ELEMENTAL
              <b>or</b> IMPURE
              <b>or</b> MODULE
              <b>or</b> NON_RECURSIVE
              <b>or</b> PURE
              <b>or</b> RECURSIVE
              <b>or</b> SIMPLE
C1552 (R1529) A <i>prefix</i> shall contain at most one of each <i>prefix-spec</i>.
C1553 (R1529) A <i>prefix</i> that specifies IMPURE shall specify neither PURE nor SIMPLE.
C1554 (R1529) A <i>prefix</i> shall not specify both NON_RECURSIVE and RECURSIVE.
C1555 An elemental procedure shall not have the BIND attribute.
C1556 (R1529) MODULE shall appear only in the <i>function-stmt</i> or <i>subroutine-stmt</i> of a module subprogram or
   of a nonabstract interface body that is declared in the scoping unit of a module or submodule.
C1557 (R1529) If MODULE appears in the <i>prefix</i> of a module subprogram, it shall have been declared to be a
   separate module procedure in the containing program unit or an ancestor of that program unit.
C1558 (R1529) If MODULE appears in the <i>prefix</i> of a module subprogram, the subprogram shall specify the
   same characteristics and dummy argument names as its corresponding module procedure interface body.
C1559 (R1529) If MODULE appears in the <i>prefix</i> of a module subprogram and a binding label is specified, it
   shall be the same as the binding label specified in the corresponding module procedure interface body.
C1560 (R1529) If MODULE appears in the <i>prefix</i> of a module subprogram, NON_RECURSIVE shall appear
   if and only if NON_RECURSIVE appears in the <i>prefix</i> in the corresponding module procedure interface
   body.
The NON_RECURSIVE <i>prefix-spec</i> shall not appear if any procedure defined by the subprogram directly or
indirectly invokes itself or any other procedure defined by the subprogram. If a subprogram defines a function whose name is
declared with an asterisk <i>type-param-value</i>, no procedure defined by the subprogram shall directly or indirectly invoke itself or any
other procedure defined by the subprogram. The RECURSIVE <i>prefix-spec</i> is advisory only.
If the <i>prefix-spec</i> PURE or the <i>prefix-spec</i> SIMPLE appears, or the <i>prefix-spec</i> ELEMENTAL appears and IM-
PURE does not appear, the subprogram is a pure subprogram and shall meet the additional constraints of 15.7. If
the<i>prefix-spec</i> SIMPLEappears, thesubprogram isasimplesubprogramandshallmeettheadditionalconstraints
of 15.8.
Ifthe<i>prefix-spec</i> ELEMENTALappears,thesubprogramisanelementalsubprogramandshallmeettheadditional
constraints of 15.9.1.
R1531 <i>proc-language-binding-spec</i> <b>is</b> <i>language-binding-spec</i>
A <i>proc-language-binding-spec</i> specifies that the procedure defined or declared by the statement is interoperable
(18.3.7).
C1561 A <i>proc-language-binding-spec</i> with a NAME= specifier shall not be specified in the <i>function-stmt</i> or
   <i>subroutine-stmt</i> of an internal procedure, or of an interface body for an abstract interface or a dummy
   procedure.
C1562 If<i>proc-language-binding-spec</i> is specified for a function, the function result shall be an interoperable scalar
   variable.
C1563 If <i>proc-language-binding-spec</i> is specified for a procedure, each of its dummy arguments shall be an inter-
   operable procedure (18.3.7) or a variable that is interoperable (18.3.5, 18.3.6), assumed-shape, assumed-
   rank, assumed-type, of type CHARACTER with assumed length, or that has the ALLOCATABLE or
   POINTER attribute.
C1564 If <i>proc-language-binding-spec</i> is specified for a procedure, each dummy argument of type CHARACTER
   with the ALLOCATABLE or POINTER attribute shall have deferred character length.
C1565 A variable that is a dummy argument of a procedure that has a <i>proc-language-binding-spec</i> shall be
   assumed-type or of interoperable type and kind type parameters.
C1566 If <i>proc-language-binding-spec</i> is specified for a procedure, it shall not have a default-initialized dummy
   argument with the ALLOCATABLE or POINTER attribute.
C1567 If <i>proc-language-binding-spec</i> is specified for a procedure, it shall not have a dummy argument that is a
   coarray.
C1568 If <i>proc-language-binding-spec</i> is specified for a procedure, it shall not have an array dummy argument
   with the VALUE attribute.
<b>15.6.2.2</b> <b>Function</b> <b>subprogram</b>
A function subprogram is a subprogram that has a FUNCTION statement as its first statement.
R1532 <i>function-subprogram</i> <b>is</b> <i>function-stmt</i>
                   [ <i>specification-part</i> ]
                   [ <i>execution-part</i> ]
                   [ <i>internal-subprogram-part</i> ]
                   <i>end-function-stmt</i>
R1533 <i>function-stmt</i> <b>is</b> [ <i>prefix</i> ] FUNCTION <i>function-name</i>
                   ( [ <i>dummy-arg-name-list</i> ] ) [ <i>suffix</i> ]
C1569 (R1533) If RESULT appears, <i>result-name</i> shall not be the same as <i>function-name</i> and shall not be the same
    as the <i>entry-name</i> in any ENTRY statement in the subprogram.
C1570 (R1533) If RESULT appears, the <i>function-name</i> shall not appear in any specification statement in the
   scoping unit of the function subprogram.
R1534 <i>dummy-arg-name</i> <b>is</b> <i>name</i>
C1571 (R1534) A <i>dummy-arg-name</i> shall be the name of a dummy argument.
R1535 <i>suffix</i> <b>is</b> <i>proc-language-binding-spec</i> [ RESULT ( <i>result-name</i> ) ]
              <b>or</b> RESULT ( <i>result-name</i> ) [ <i>proc-language-binding-spec</i> ]
R1536 <i>end-function-stmt</i> <b>is</b> END [ FUNCTION [ <i>function-name</i> ] ]
C1572 (R1532) An internal function subprogram shall not contain an <i>internal-subprogram-part</i>.
C1573 (R1536) If a <i>function-name</i> appears in the <i>end-function-stmt</i>, it shall be identical to the <i>function-name</i>
   specified in the <i>function-stmt</i>.
The name of the function is <i>function-name</i>.
The type and type parameters (if any) of the result of the function defined by a function subprogram may be
specified by a type specification in the FUNCTION statement or by the name of the function result appearing
in a type declaration statement in the specification part of the function subprogram. They shall not be specified
both ways. If they are not specified either way, they are determined by the implicit typing rules in effect within
the function subprogram. If the function result is an array, allocatable, or a pointer, this shall be specified by
specifications of the name of the function result within the function body. The specifications of the function result
attributes, the specification of dummy argument attributes, and the information in the FUNCTION statement
collectively define the characteristics of the function (15.3.1).
If RESULT appears, the name of the function result of the function is <i>result-name</i> and all occurrences of the
function name in <i>execution-part</i> statements in its scope refer to the function itself. If RESULT does not appear,
the name of the function result is <i>function-name</i> and all occurrences of the function name in <i>execution-part</i>
statements in its scope are references to the function result. On completion of execution of the function, the value
returned is that of its function result. If the function result is a data pointer, the shape of the value returned by
the function is determined by the shape of the function result when the execution of the function is completed. If
the function result is not a pointer, its value shall be defined by the function. If the function result is a pointer,
on return the pointer association status of the function result shall not be undefined.
<b>NOTE</b> <b>1</b>
The function result is similar to any other entity (variable or procedure pointer) local to a function subprogram.
Its existence begins when execution of the function is initiated and ends when execution of the function is
terminated. However, because the final value of this entity is used subsequently in the evaluation of the
expression that invoked the function, an implementation might defer releasing the storage occupied by that
entity until after its value has been used in expression evaluation.
<b>NOTE</b> <b>2</b>
The following is an example of the declaration of an interface body with the BIND attribute, and a reference
to the procedure declared.
   USE, INTRINSIC :: ISO_C_BINDING
   INTERFACE
    FUNCTION JOE (I, J, R) BIND(C,NAME="FrEd")
     USE, INTRINSIC :: ISO_C_BINDING
     INTEGER(C_INT) :: JOE
     INTEGER(C_INT), VALUE :: I, J
     REAL(C_FLOAT), VALUE :: R
    END FUNCTION JOE
   END INTERFACE
   INT = JOE(1_C_INT, 3_C_INT, 4.0_C_FLOAT)
   END PROGRAM
The invocation of the function JOE results in a reference to a function with a binding label "FrEd". FrEd could
be a C function described by the C prototype
   int FrEd(int n, int m, float x);
<b>15.6.2.3</b> <b>Subroutine</b> <b>subprogram</b>
A subroutine subprogram is a subprogram that has a SUBROUTINE statement as its first statement.
R1537 <i>subroutine-subprogram</i> <b>is</b> <i>subroutine-stmt</i>
                   [ <i>specification-part</i> ]
                   [ <i>execution-part</i> ]
                   [ <i>internal-subprogram-part</i> ]
                   <i>end-subroutine-stmt</i>
R1538 <i>subroutine-stmt</i> <b>is</b> [ <i>prefix</i> ] SUBROUTINE <i>subroutine-name</i>
                   [ ( [ <i>dummy-arg-list</i> ] ) [ <i>proc-language-binding-spec</i> ] ]
C1574 (R1538) The <i>prefix</i> of a <i>subroutine-stmt</i> shall not contain a <i>declaration-type-spec</i>.
R1539 <i>dummy-arg</i> <b>is</b> <i>dummy-arg-name</i>
              <b>or</b> *
R1540 <i>end-subroutine-stmt</i> <b>is</b> END [ SUBROUTINE [ <i>subroutine-name</i> ] ]
C1575 (R1537) An internal subroutine subprogram shall not contain an <i>internal-subprogram-part</i>.
C1576 (R1540) If a <i>subroutine-name</i> appears in the <i>end-subroutine-stmt</i>, it shall be identical to the <i>subroutine-</i>
   <i>name</i> specified in the <i>subroutine-stmt</i>.
The name of the subroutine is <i>subroutine-name</i>.
<b>15.6.2.4</b> <b>Instances</b> <b>of</b> <b>a</b> <b>subprogram</b>
When a procedure defined by a subprogram is invoked, an instance of that subprogram is created. Each instance
has an independent sequence of execution and an independent set of dummy arguments, unsaved local variables,
and unsaved local procedure pointers. Saved local entities are shared by all instances of the subprogram.
When a statement function is invoked, an instance of that statement function is created.
When execution of an instance completes it ceases to exist.
The caller of an instance of a procedure is the instance of the main program, subprogram, or statement function
that invoked it. The call sequence of an instance of a procedure is its caller, followed by the call sequence of its
caller. The call sequence of the main program is empty. The host instance of an instance of a statement function
or an internal procedure that is invoked by its name is the first element of the call sequence that is an instance
of the host of the statement function or internal subprogram. The host instance of an internal procedure that is
invoked via a dummy procedure or procedure pointer is the host instance of the associating entity from when the
argument association or pointer association was established (19.5.5). The host instance of a module procedure is
the module or submodule in which it is defined. A main program or external subprogram has no host instance.
<b>15.6.2.5</b> <b>Separate</b> <b>module</b> <b>procedures</b>
A separate module procedure is a module procedure defined by a <i>separate-module-subprogram</i>, by a <i>function-</i>
<i>subprogram</i> whose initial statement contains the keyword MODULE, or by a <i>subroutine-subprogram</i> whose initial
statement contains the keyword MODULE.
R1541 <i>separate-module-subprogram</i> <b>is</b> <i>mp-subprogram-stmt</i>
                   [ <i>specification-part</i> ]
                   [ <i>execution-part</i> ]
                   [ <i>internal-subprogram-part</i> ]
                   <i>end-mp-subprogram-stmt</i>
R1542 <i>mp-subprogram-stmt</i> <b>is</b> MODULE PROCEDURE <i>procedure-name</i>
R1543 <i>end-mp-subprogram-stmt</i> <b>is</b> END [PROCEDURE [<i>procedure-name</i>]]
C1577 (R1541)The<i>procedure-name</i> shallhavebeendeclaredtobeaseparatemoduleprocedureinthecontaining
   program unit or an ancestor of that program unit.
C1578 (R1543)Ifa<i>procedure-name</i> appearsinthe<i>end-mp-subprogram-stmt</i>, itshallbeidenticaltothe<i>procedure-</i>
   <i>name</i> in the <i>mp-subprogram-stmt</i>.
A separate module procedure shall not be defined more than once.
Theinterfaceofaproceduredefinedbya <i>separate-module-subprogram</i> isexplicitlydeclaredbythe <i>mp-subprogram-</i>
<i>stmt</i> to be the same as its module procedure interface body. It has the NON_RECURSIVE attribute if and only
if it was declared to have that attribute by the interface body. If it is a function its result name is determined
by the FUNCTION statement in the interface body.
<b>NOTE</b>
A separate module procedure can be accessed by use association only if its interface body is declared in the
specification part of a module and is public.
<b>15.6.2.6</b> <b>ENTRY</b> <b>statement</b>
AnENTRYstatementpermitsaprocedurereferencetobeginwithaparticularexecutablestatementwithinthefunctionorsubroutine
subprogram in which the ENTRY statement appears.
R1544 <i>entry-stmt</i> <b>is</b> ENTRY <i>entry-name</i> [ ( [ <i>dummy-arg-list</i> ] ) [ <i>suffix</i> ] ]
C1579 (R1544) If RESULT appears, the <i>entry-name</i> shall not appear in any specification or type declaration statement in the
    scoping unit of the function subprogram.
C1580 (R1544) An <i>entry-stmt</i> shall appear only in an <i>external-subprogram</i> or a <i>module-subprogram</i> that does not define a separate
    module procedure. An <i>entry-stmt</i> shall not appear within an <i>executable-construct</i>.
C1581 (R1544) RESULT shall appear only if the <i>entry-stmt</i> is in a function subprogram.
C1582 (R1544) A <i>dummy-arg</i> shall not be an alternate return indicator if the ENTRY statement is in a function subprogram.
C1583 (R1544) If RESULT appears, <i>result-name</i> shall not be the same as the <i>function-name</i> in the FUNCTION statement and
    shall not be the same as the <i>entry-name</i> in any ENTRY statement in the subprogram.
Optionally, a subprogram may have one or more ENTRY statements.
If the ENTRY statement is in a function subprogram, an additional function is defined by that subprogram. The name of the
function is <i>entry-name</i> and the name of its result is <i>result-name</i> or is <i>entry-name</i> if no <i>result-name</i> is provided. The dummy
arguments of the function are those specified in the ENTRY statement. If the characteristics of the result of the function named in
the ENTRY statement are the same as the characteristics of the result of the function named in the FUNCTION statement, their
result names identify the same entity, although their names need not be the same. Otherwise, they are storage associated and shall
all be nonpointer, nonallocatable scalar variables that are default integer, default real, double precision real, default complex, or
default logical.
If the ENTRY statement is in a subroutine subprogram, an additional subroutine is defined by that subprogram. The name of the
subroutine is <i>entry-name</i>. The dummy arguments of the subroutine are those specified in the ENTRY statement.
The order, number, types, kind type parameters, and names of the dummy arguments in an ENTRY statement may differ from the
order, number, types, kind type parameters, and names of the dummy arguments in the FUNCTION or SUBROUTINE statement
in the containing subprogram.
Because an ENTRY statement defines an additional function or an additional subroutine, it is referenced in the same manner as any
other function or subroutine (15.5).
In a subprogram, a dummy argument specified in an ENTRY statement shall not appear in an executable statement preceding that
ENTRY statement, unless it also appears in a FUNCTION, SUBROUTINE, or ENTRY statement that precedes the executable
statement. A function result specified by a <i>result-name</i> in an ENTRY statement shall not appear in any executable statement that
precedes the first RESULT clause with that name.
In a subprogram, a dummy argument specified in an ENTRY statement shall not appear in the expression of a statement function
that precedes the first <i>dummy-arg</i> with that name in the subprogram. A function result specified by a <i>result-name</i> in an ENTRY
statement shall not appear in the expression of a statement function that precedes the first RESULT clause with that name.
If a dummy argument appears in an executable statement, the execution of the executable statement is permitted during the
execution of a reference to the function or subroutine only if the dummy argument appears in the dummy argument list of the
referenced procedure.
If a dummy argument is used in a specification expression to specify an array bound or character length of an object, the appearance
of the object in a statement that is executed during a procedure reference is permitted only if the dummy argument appears in the
dummy argument list of the referenced procedure and it is present (15.5.2.13).
The NON_RECURSIVE and RECURSIVE keywords are not used in an ENTRY statement. Instead, the presence or absence of
NON_RECURSIVE in the initial SUBROUTINE or FUNCTION statement controls whether the procedure defined by an ENTRY
statement is permitted to reference itself or another procedure defined by the subprogram.
The keywords PURE and IMPURE are not used in an ENTRY statement. Instead, the procedure defined by an ENTRY statement
is pure if and only if the subprogram is a pure subprogram.
ThekeywordELEMENTALisnotusedinanENTRYstatement. Instead, theproceduredefinedbyanENTRYstatementiselemental
if and only if ELEMENTAL is specified in the SUBROUTINE or FUNCTION statement.
<b>15.6.2.7</b> <b>RETURN</b> <b>statement</b>
R1545 <i>return-stmt</i> <b>is</b> RETURN [ <i>scalar-int-expr</i> ]
C1584 (R1545) The <i>return-stmt</i> shall be in the inclusive scope of a function or subroutine subprogram.
C1585 (R1545) The <i>scalar-int-expr</i> is allowed only in the inclusive scope of a subroutine subprogram.
Execution of the RETURN statement completes execution of the instance of the subprogram in which it appears.
If the expression appears and has a value <i>n</i> between 1 and the number of asterisks in the dummy argument list, the CALL statement
that invoked the subroutine branches (11.2) to the branch target statement identified by the <i>n</i>
                                                <i>th</i>
                                           alternate return specifier in the
actual argument list of the referenced procedure. If the expression is omitted or has a value outside the required range, there is no
transfer of control to an alternate return.
Execution of an <i>end-function-stmt</i>, <i>end-mp-subprogram-stmt</i>, or <i>end-subroutine-stmt</i> is equivalent to execution
of a RETURN statement with no expression.
<b>15.6.2.8</b> <b>CONTAINS</b> <b>statement</b>
R1546 <i>contains-stmt</i> <b>is</b> CONTAINS
The CONTAINS statement separates the body of a main program, module, submodule, or subprogram from any
internal or module subprograms it might contain, or it introduces the type-bound procedure part of a derived-type
definition (7.5.5). The CONTAINS statement is not executable.
<b>15.6.3</b> <b>Definition</b> <b>and</b> <b>invocation</b> <b>of</b> <b>procedures</b> <b>by</b> <b>means</b> <b>other</b> <b>than</b> <b>Fortran</b>
A procedure may be defined by means other than Fortran. The interface of a procedure defined by means other
than Fortran may be specified by an interface body or procedure declaration statement. A reference to such a
procedure is made as though it were defined by an external subprogram.
A procedure defined by means other than Fortran that is invoked by a Fortran procedure and does not cause
termination of execution shall return to its caller.
<b>NOTE</b> <b>1</b>
Examples of code that might cause a transfer of control that bypasses the normal return mechanism of a
Fortran procedure are setjmp and longjmp in C and exception handling in other languages. No such behavior
is permitted by this document.
If the interface of a procedure has a <i>proc-language-binding-spec</i>, the procedure is interoperable (18.10).
Interoperation with C functions is described in 18.10.
<b>NOTE</b> <b>2</b>
For explanatory information on definition of procedures by means other than Fortran, see C.11.2.
<b>15.6.4</b> <b>Statement</b> <b>function</b>
A statement function is a function defined by a single statement.
R1547 <i>stmt-function-stmt</i> <b>is</b> <i>function-name</i> ( [ <i>dummy-arg-name-list</i> ] ) = <i>scalar-expr</i>
C1586 (R1547) Each <i>primary</i> in <i>scalar-expr</i> shall be a constant (literal or named), a reference to a variable, a reference to a
    function, or an expression in parentheses. Each operation shall be intrinsic. If <i>scalar-expr</i> contains a reference to a
    function, the reference shall not require an explicit interface, the function shall not require an explicit interface unless it is
    an intrinsic function, the function shall not be a transformational intrinsic, and the result shall be scalar. If an argument to
    a function is an array, it shall be an array name. If a reference to a statement function appears in <i>scalar-expr</i>, its definition
    shall have been provided earlier in the scoping unit and shall not be the name of the statement function being defined.
C1587 (R1547) Named constants in <i>scalar-expr</i> shall have been declared earlier in the scoping unit or made accessible by use
    or host association. If array elements appear in <i>scalar-expr</i>, the array shall have been declared as an array earlier in the
    scoping unit or made accessible by use or host association.
C1588 (R1547) If a <i>dummy-arg-name</i>, variable, function reference, or dummy function reference is typed by the implicit typing
    rules, its appearance in any subsequent type declaration statement shall confirm this implied type and the values of any
    implied type parameters.
C1589 (R1547) The <i>function-name</i> and each <i>dummy-arg-name</i> shall be specified, explicitly or implicitly, to be scalar.
C1590 (R1547) A given <i>dummy-arg-name</i> shall not appear more than once in a given <i>dummy-arg-name-list</i>.
C1591 A statement function shall not be of a parameterized derived type.
The definition of a statement function with the same name as an accessible entity from the host shall be preceded by the declaration
of its type in a type declaration statement.
The dummy arguments have a scope of the statement function statement. Each dummy argument has the same type and type
parameters as the entity of the same name in the scoping unit containing the statement function statement.
A statement function shall not be supplied as an actual argument.
Execution of a statement function consists of evaluating the expression using the values of the actual arguments for the values of the
corresponding dummy arguments and, if necessary, converting the result to the declared type and type parameters of the function.
A function reference in the scalar expression shall not cause a dummy argument of the statement function to become redefined or
undefined.
<b>15.7</b> <b>Pure</b> <b>procedures</b>
A pure procedure is
 a simple procedure,
 a pure intrinsic procedure (16.1),
 a module procedure in an intrinsic module, if it is specified to be pure,
 defined by a pure subprogram,
 a dummy procedure that has been specified to be PURE,
 a procedure pointer that has been specified to be PURE,
 a type-bound procedure that is bound to a pure procedure, or
 a statement function that references only pure functions and does not contain the <i>designator</i> of a variable with the VOLATILE
  attribute.
A pure subprogram is a subprogram that has the <i>prefix-spec</i> PURE or the <i>prefix-spec</i> SIMPLE, or that has the
<i>prefix-spec</i> ELEMENTAL and does not have the <i>prefix-spec</i> IMPURE. The following additional constraints apply
to pure subprograms.
C1592 The <i>specification-part</i> of a pure function subprogram shall specify that all its nonpointer dummy data
   objects have the INTENT (IN) or the VALUE attribute.
C1593 The function result of a pure function shall not be such that finalization of a reference to the function
   would reference an impure procedure.
C1594 The function result of a pure function shall not be both polymorphic and allocatable, or have a poly-
   morphic allocatable ultimate component.
C1595 The <i>specification-part</i> of a pure subroutine subprogram shall specify the intents of all its nonpointer
   dummy data objects that do not have the VALUE attribute.
C1596 An INTENT (OUT) dummy argument of a pure procedure shall not be such that finalization of the
   actual argument would reference an impure procedure.
C1597 An INTENT (OUT) dummy argument of a pure procedure shall not be polymorphic or have a poly-
   morphic allocatable ultimate component.
C1598 A local variable of a pure subprogram, or of a BLOCK construct within a pure subprogram, shall not
   have the SAVE or VOLATILE attribute.
<b>NOTE</b> <b>1</b>
Variable initialization in a <i>type-declaration-stmt</i> or a <i>data-stmt</i> implies the SAVE attribute; therefore, such
initialization is also disallowed.
C1599 A named local entity or construct entity of a pure subprogram shall not be of a type that has default
   initialization of a data pointer component to a target at any level of component selection.
C15100 The <i>specification-part</i> of a pure subprogram shall specify that all its dummy procedures are pure.
C15101 If a procedure that is neither an intrinsic procedure nor a statement function is used in a context that
   requires it to be pure, then its interface shall be explicit in the scope of that use. The interface shall
   specify that the procedure is pure.
C15102 All internal subprograms in a pure subprogram shall be pure.
C15103 A <i>designator</i> of a variable with the VOLATILE attribute shall not appear in a pure subprogram.
C15104 In a pure subprogram any designator with a base object that is in common or accessed by use or host
   association, is a pointer dummy argument of a pure function, is a dummy argument with the INTENT
   (IN) attribute, is a coindexed object, or an object that is storage associated with any such variable, shall
   not be used
   (1) in a variable definition context (19.6.7),
   (2) in a pointer association context (19.6.8),
   (3) as the <i>data-target</i> in a <i>pointer-assignment-stmt</i>,
   (4) as the <i>expr</i> corresponding to a component in a <i>structure-constructor</i> if the component has the
      POINTER attribute or has a pointer component at any level of component selection,
   (5) as the <i>expr</i> of an intrinsic assignment statement in which the variable is of a derived type if the
      derived type has a pointer component at any level of component selection,
   (6) as the <i>source-expr</i> in a SOURCE= specifier if the designator is of a derived type that has a pointer
      component at any level of component selection,
   (7) as an actual argument corresponding to a dummy argument with the POINTER attribute, or
   (8) as the actual argument to the function C_LOC from the intrinsic module ISO_C_BINDING.
<b>NOTE</b> <b>2</b>
Item 5 requires that processors be able to determine if entities with the PRIVATE attribute or with private
components have a pointer component.
C15105 Anyprocedurereferencedinapuresubprogram, includingonereferencedviaadefinedoperation, defined
   assignment, defined input/output, or finalization, shall be pure.
C15106 A statement that might result in the deallocation of a polymorphic entity is not permitted in a pure
   procedure.
<b>NOTE</b> <b>3</b>
This includes intrinsic assignment to a variable that has a potential subobject component that is polymorphic
and allocatable.
C15107 A pure subprogram shall not contain a <i>print-stmt</i>, <i>open-stmt</i>, <i>close-stmt</i>, <i>backspace-stmt</i>, <i>endfile-stmt</i>,
   <i>rewind-stmt</i>, <i>flush-stmt</i>, <i>wait-stmt</i>, or <i>inquire-stmt</i>.
C15108 A pure subprogram shall not contain a <i>read-stmt</i> or <i>write-stmt</i> whose <i>io-unit</i> is a <i>file-unit-number</i> or *.
C15109 A pure subprogram shall not contain an image control statement (11.7.1).
C15110 A reference to the function C_FUNLOC from the intrinsic module ISO_C_BINDING shall not appear
   in a pure subprogram if its argument is impure.
<b>NOTE</b> <b>4</b>
The above constraints are designed to guarantee that a pure procedure is free from side effects (modifications
of data visible outside the procedure), which means that it is safe to reference it in constructs such as DO
CONCURRENT and FORALL, where there is no explicit order of evaluation.
The constraints on pure subprograms appear to be complicated, but it is not necessary for a programmer to
be intimately familiar with them. From the programmer's point of view, these constraints can be summarized
as follows: a pure subprogram cannot contain any operation that could conceivably result in an assignment
or pointer assignment to a common variable, a variable accessed by use or host association, or an INTENT (IN)
dummyargument; norcanapuresubprogramcontainanyoperationthatcouldconceivablyperformanyexternal
file input/output or execute an image control statement (including a STOP statement). Note the use of the
word conceivably; it is not sufficient for a pure subprogram merely to be side-effect free in practice. For example,
a function that contains an assignment to a global variable but in a block that is not executed in any invocation
of the function is nevertheless not a pure function. The exclusion of functions of this nature is required if strict
compile-time checking is to be used.
It is expected that most library procedures will conform to the constraints required of pure procedures, and so
can be declared pure and referenced in DO CONCURRENT constructs, FORALL statements and constructs, and
within user-defined pure procedures.
<b>NOTE</b> <b>5</b>
Pure subroutines are included to allow subroutine calls from pure procedures in a safe way, and to allow <i>forall-</i>
<i>assignment-stmt</i>s to be defined assignments. The constraints for pure subroutines are based on the same principles
as for pure functions, except that side effects to INTENT (OUT), INTENT (INOUT), and pointer dummy
arguments are permitted.
<b>15.8</b> <b>Simple</b> <b>procedures</b>
A simple procedure is
 an intrinsic procedure (16.1), if it is specified to be simple,
 a module procedure, if it is specified to be simple,
 a procedure defined by a simple subprogram,
 a dummy procedure that has been specified to be simple,
 a procedure pointer that has been specified to be simple,
 a type-bound procedure that is bound to a simple procedure,
 a deferred type-bound procedure whose interface specifies it to be simple,
 a statement function defined in a simple subprogram.
A simple procedure is also a pure procedure and is subject to the constraints for pure procedures (15.7). A simple
procedure can also be an elemental procedure.
A simple subprogram is a subprogram that has the <i>prefix-spec</i> SIMPLE. The following additional constraints
apply to simple subprograms.
C15111 The <i>specification-part</i> of a simple subprogram shall specify that all of its dummy procedures are simple.
C15112 If a procedure that is not an intrinsic procedure, a module procedure of an intrinsic module, or a statement
    function is used in a context that requires it to be simple, then its interface shall be explicit in the scope
   of that use. The interface shall specify that the procedure is simple.
C15113 All internal subprograms in a simple subprogram shall be simple.
C15114 Any procedure referenced in a simple subprogram shall be simple.
C15115 A simple subprogram shall not contain a designator of a variable that is accessed by use or host associ-
   ation, unless the designator is part of a specification inquiry (10.1.11) that is a constant expression.
C15116 A simple subprogram shall not contain a reference to a variable in a common block.
C15117 A simple subprogram shall not contain an ENTRY statement.
<b>15.9</b> <b>Elemental</b> <b>procedures</b>
<b>15.9.1</b> <b>Elemental</b> <b>procedure</b> <b>declaration</b> <b>and</b> <b>interface</b>
An elemental procedure is
 an elemental intrinsic procedure (16.1),
 a module procedure in an intrinsic module, if it is specified to be elemental,
 a procedure that is defined by an elemental subprogram, or
 a type-bound procedure that is bound to an elemental procedure.
An elemental procedure has only scalar dummy arguments, but may have array actual arguments.
A dummy procedure or procedure pointer shall not be specified to be ELEMENTAL.
An elemental subprogram has the <i>prefix-spec</i> ELEMENTAL. An elemental subprogram is a pure subprogram
unless it has the <i>prefix-spec</i> IMPURE. The following additional constraints apply to elemental subprograms.
C15118 All dummy arguments of an elemental procedure shall be scalar noncoarray dummy data objects and
   shall not have the POINTER or ALLOCATABLE attribute.
C15119 Theresultofanelementalfunctionshallbescalar, andshallnothavethePOINTERorALLOCATABLE
   attribute.
C15120 The <i>specification-part</i> of an elemental subprogram shall specify the intents of all of its dummy arguments
   that do not have the VALUE attribute.
C15121 In the <i>specification-expr</i> that specifies a type parameter value of the result of an elemental function, an
   object designator with a dummy argument of the function as the base object shall appear only as the
   subject of a specification inquiry (10.1.11), and that specification inquiry shall not depend on a property
   that is deferred.
In a reference to an elemental procedure, if any argument is an array, each actual argument that corresponds to
an INTENT (OUT) or INTENT (INOUT) dummy argument shall be an array. All actual arguments shall be
conformable. An array actual argument is considered to be associated with the scalar dummy arguments of the
procedure throughout the entire execution of the elemental reference; thus, the restrictions on actions specified
in 15.5.2.14 apply to the entirety of the actual array argument.
<b>15.9.2</b> <b>Elemental</b> <b>function</b> <b>actual</b> <b>arguments</b> <b>and</b> <b>results</b>
If a generic name or a specific name is used to reference an elemental function, the shape of the result is the
same as the shape of the actual argument with the greatest rank. If there are no actual arguments or the actual
arguments are all scalar, the result is scalar. In the array case, the values of the elements, if any, of the result are
the same as would have been obtained if the scalar function had been applied separately, in array element order,
to corresponding elements of each array actual argument.
<b>NOTE</b>
An example of an elemental reference to the intrinsic function MAX: if X and Y are arrays with bounds
(1:M, 1:N), then
   MAX (X, 0.0, Y)
is an array expression of shape [M, N] whose elements in order have the values of
   [ ((MAX (X(I, J), 0.0, Y(I, J)), I = 1, M), J = 1, N) ]
<b>15.9.3</b> <b>Elemental</b> <b>subroutine</b> <b>actual</b> <b>arguments</b>
In a reference to an elemental subroutine, if the actual arguments corresponding to INTENT (OUT) and INTENT
(INOUT) dummy arguments are arrays, the values of the elements, if any, of the results are the same as would
be obtained if the subroutine had been applied separately, in array element order, to corresponding elements of
each array actual argument.
<b>16</b> <b>Intrinsic</b> <b>procedures</b> <b>and</b> <b>modules</b>
<b>16.1</b> <b>Classes</b> <b>of</b> <b>intrinsic</b> <b>procedures</b>
Intrinsic procedures are divided into eight classes: inquiry functions, elemental functions, transformational func-
tions, elemental subroutines, simple subroutines, atomic subroutines, collective subroutines, and (impure) sub-
routines.
An intrinsic inquiry function is one whose result depends on the properties of one or more of its arguments instead
of their values; in fact, these argument values may be undefined. Unless the description of an intrinsic inquiry
function states otherwise, these arguments are permitted to be unallocated allocatable variables or pointers that
are undefined or disassociated. An elemental intrinsic function is one that is specified for scalar arguments,
but may be applied to array arguments as described in 15.9. All other intrinsic functions are transformational
functions; they almost all have one or more array arguments or an array result. All standard intrinsic functions
are simple.
An atomic subroutine is an intrinsic subroutine that performs an atomic action. The semantics of atomic actions
are described in 16.5.
A collective subroutine is an intrinsic subroutine that performs a cooperative calculation on a team of images
without requiring synchronization. The semantics of collective subroutines are described in 16.6.
The subroutine MOVE_ALLOC with noncoarray argument FROM, the subroutine SPLIT, the subroutine
TOKENIZE, and the elemental subroutine MVBITS, are simple. No other standard intrinsic subroutine is
pure or simple.
Generic names of standard intrinsic procedures are listed in 16.7. In most cases, generic functions accept argu-
ments of more than one type and the type of the result is the same as the type of the arguments. Specific names of
standard intrinsic functions with corresponding generic names are listed in 16.8.
If an intrinsic procedure is used as an actual argument to a procedure, its specific name shall be used and it shall be referenced in
the called procedure only with scalar arguments. If an intrinsic procedure does not have a specific name, it shall not be used as an
actual argument (15.5.2.10).
Elemental intrinsic procedures behave as described in 15.9.
<b>16.2</b> <b>Arguments</b> <b>to</b> <b>intrinsic</b> <b>procedures</b>
<b>16.2.1</b> <b>General</b> <b>rules</b>
All intrinsic procedures can be invoked with either positional arguments or argument keywords (15.5). The
descriptions in 16.7 through 16.9 give the argument keyword names and positional sequence for standard intrinsic
procedures.
Many of the intrinsic procedures have optional arguments. These arguments are identified by the notation
"optional" in the argument descriptions. In addition, the names of the optional arguments are enclosed in square
brackets in description headings and in lists of procedures. The valid forms of reference for procedures with
optional arguments are described in 15.5.2.
<b>NOTE</b> <b>1</b>
The text CMPLX (X [, Y, KIND]) indicates that Y and KIND are both optional arguments. Valid ref-
erence forms include CMPLX(<i>x</i>), CMPLX(<i>x</i>, <i>y</i>), CMPLX(<i>x</i>, KIND=<i>kind</i>), CMPLX(<i>x</i>, <i>y</i>, <i>kind</i>), and CM-
PLX(KIND=<i>kind</i>, X=<i>x</i>, Y=<i>y</i>).
<b>NOTE</b> <b>2</b>
Some intrinsic procedures impose additional requirements on their optional arguments. For example, SELEC-
TED_REAL_KIND requires that at least one of its optional arguments be present, and RANDOM_SEED
requires that at most one of its optional arguments be present.
The dummy arguments of the specific intrinsic procedures in 16.8 have INTENT (IN). The dummy arguments of the intrinsic
procedures in 16.9 have INTENT (IN) if the intent is not stated explicitly.
The actual argument corresponding to an intrinsic function dummy argument named KIND shall be a scalar
integer constant expression and its value shall specify a representation method for the function result that exists
on the processor.
Intrinsic subroutines that assign values to arguments of type character do so in accordance with the rules of
intrinsic assignment (10.2.1.3).
In a reference to the intrinsic subroutine MVBITS, the actual arguments corresponding to the TO and FROM
dummy arguments may be the same variable and may be associated scalar variables or associated array variables
all of whose corresponding elements are associated. Apart from this, the actual arguments in a reference to an
intrinsic subroutine shall be such that the execution of the intrinsic subroutine would satisfy the restrictions of
15.5.2.14.
An argument to an intrinsic procedure other than ASSOCIATED, NULL, or PRESENT shall be a data object.
<b>16.2.2</b> <b>The</b> <b>shape</b> <b>of</b> <b>array</b> <b>arguments</b>
Unless otherwise specified, the intrinsic inquiry functions accept array arguments for which the shape need not
be defined. The shape of array arguments to transformational and elemental intrinsic functions shall be defined.
<b>16.2.3</b> <b>Mask</b> <b>arguments</b>
Some array intrinsic functions have an optional MASK argument of type logical that is used by the function to
select the elements of one or more arguments to be operated on by the function. Any element not selected by the
mask need not be defined at the time the function is invoked.
The MASK affects only the value of the function, and does not affect the evaluation, prior to invoking the
function, of arguments that are array expressions.
<b>16.2.4</b> <b>DIM</b> <b>arguments</b> <b>and</b> <b>reduction</b> <b>functions</b>
Some array intrinsic functions are "reduction" functions; that is, they reduce the rank of an array by collapsing
one dimension (or all dimensions, usually producing a scalar result). These functions have a DIM argument that
can specify the dimension to be reduced.
The process of reducing a dimension usually combines the selected elements with a simple operation such as
addition or an intrinsic function such as MAX, but more sophisticated reductions are also provided, e.g. by
COUNT and MAXLOC.
<b>16.3</b> <b>Bit</b> <b>model</b>
<b>16.3.1</b> <b>General</b>
The bit manipulation procedures are described in terms of a model for the representation and behavior of bits
on a processor.
For the purposes of these procedures, a bit is defined to be a binary digit <i>w</i> located at position<i>k</i> of a nonnegative
integer scalar object based on a model nonnegative integer defined by
                 <i>j</i> =
                        <i>z</i>-1
              X
                        <i>k</i>=0
                    <i>w</i>
                          <i>k</i>
            x 2
                             <i>k</i>
and for which <i>w</i>
       <i>k</i>
       has the value 0 or 1. This defines a sequence of bits <i>w</i>
                                <i>z</i>-1
                           <i>...w</i>
                                        0
                                   , with<i>w</i>
                                         <i>z</i>-1
                                        the leftmost bit and
<i>w</i>
0
 the rightmost bit. The positions of bits in the sequence are numbered from right to left, with the position of
the rightmost bit being zero. The length of a sequence of bits is <i>z</i>. An example of a model number compatible
with the examples used in 16.4 would have <i>z</i> = 32, thereby defining a 32-bit integer.
The interpretation of a negative integer as a sequence of bits is processor dependent.
The inquiry function BIT_SIZE provides the value of the parameter <i>z</i> of the model.
Effectively, this model defines an integer object to consist of <i>z</i> bits in sequence numbered from right to left from
0 to <i>z</i>- 1. This model is valid only in the context of the use of such an object as the argument or result of an
intrinsic procedure that interprets that object as a sequence of bits. In all other contexts, the model defined for
an integer in 16.4 applies. In particular, whereas the models are identical for <i>r</i> = 2 and <i>w</i>
                                          <i>z</i>-1
                                                                           = 0, they do not
correspond for <i>r</i>?= 2 or <i>w</i>
           <i>z</i>-1
                       = 1 and the interpretation of bits in such objects is processor dependent.
<b>16.3.2</b> <b>Bit</b> <b>sequence</b> <b>comparisons</b>
When bit sequences of unequal length are compared, the shorter sequence is considered to be extended to the
length of the longer sequence by padding with zero bits on the left.
Bit sequences are compared from left to right, one bit at a time, until unequal bits are found or all bits have been
compared and found to be equal. If unequal bits are found, the sequence with zero in the unequal position is
considered to be less than the sequence with one in the unequal position. Otherwise the sequences are considered
to be equal.
<b>16.3.3</b> <b>Bit</b> <b>sequences</b> <b>as</b> <b>arguments</b> <b>to</b> <b>INT</b> <b>and</b> <b>REAL</b>
When a <i>boz-literal-constant</i> is the argument A of the intrinsic function INT or REAL,
 if the length of the sequence of bits specified by A is less than the size in bits of a scalar variable of the
  same type and kind type parameter as the result, the <i>boz-literal-constant</i> is treated as if it were extended
  to a length equal to the size in bits of the result by padding on the left with zero bits, and
 if the length of the sequence of bits specified by A is greater than the size in bits of a scalar variable of the
  same type and kind type parameter as the result, the <i>boz-literal-constant</i> is treated as if it were truncated
  from the left to a length equal to the size in bits of the result.
C1601 If a <i>boz-literal-constant</i> is truncated as an argument to the intrinsic function REAL, the discarded bits
   shall all be zero.
<b>NOTE</b>
The result values of the intrinsic functions CMPLX and DBLE are defined by references to the intrinsic function
REAL with the same arguments. Therefore, the padding and truncation of <i>boz-literal-constant</i> arguments to
those intrinsic functions is the same as for the intrinsic function REAL.
<b>16.4</b> <b>Numeric</b> <b>models</b>
The numeric manipulation and inquiry functions are described in terms of a model for the representation and
behavior of numbers on a processor. The model has parameters that are determined so as to make the model
best fit the machine on which the program is executed.
The model set for integer <i>i</i> is defined by
                 <i>i</i> =<i>s</i>x
                         <i>q</i>-1
               X
                         <i>k</i>=0
                     <i>w</i>
                           <i>k</i>
             x<i>r</i>
                             <i>k</i>
where <i>r</i> is an integer exceeding one, <i>q</i> is a positive integer, each <i>w</i>
                              <i>k</i>
                             is a nonnegative integer less than <i>r</i>, and <i>s</i> is
+1 or-1. The integer parameters <i>r</i> and <i>q</i> determine the set of model integers.
The model set for real <i>x</i> is defined by
               <i>x</i> =
            ?
            ?
            ?
            ?
            ?
                                      0 or
                  <i>s</i>x<i>b</i>
                        <i>e</i>
            x
                           <i>p</i>
               X
                          <i>k</i>=1
                      <i>f</i>
                            <i>k</i>
              x<i>b</i>
                  -<i>k</i>
where <i>b</i> and <i>p</i> are integers exceeding one; each <i>f</i>
                       <i>k</i>
                       is a nonnegative integer less than <i>b</i>, with <i>f</i>
                                                 1
                                           nonzero; <i>s</i> is
+1 or-1; and <i>e</i> is an integer that lies between some integer maximum <i>e</i>
                                   max
                                  and some integer minimum <i>e</i>
                                                    min
inclusively. For <i>x</i> = 0, its exponent <i>e</i> and digits <i>f</i>
                      <i>k</i>
                      are defined to be zero. The integer parameters <i>b</i>, <i>p</i>, <i>e</i>
                                                 min
                                              , and
<i>e</i>
max
  determine the set of model floating-point numbers.
The parameters of the integer and real models are available for each representation method of the integer and
real types. The parameters characterize the set of available numbers in the definition of the model. Intrinsic
functions provide the values of some parameters and other values related to the models.
There is also an extended model set for each kind of real <i>x</i>; this extended model is the same as the ordinary
model except that there are no limits on the range of the exponent <i>e</i>.
<b>NOTE</b>
Some of the function descriptions use the models
                 <i>i</i> =<i>s</i>x
                           30
              X
                         <i>k</i>=0
                     <i>w</i>
                           <i>k</i>
             x 2
                             <i>k</i>
and
          <i>x</i> = 0 or <i>s</i>x 2
                   <i>e</i>
         x
             
                                     1
                                     2
                                       +
                          24
              X
                       <i>k</i>=2
                    <i>f</i>
                          <i>k</i>
            x 2
                -<i>k</i>
                 !
                        <i>,</i> -126<i>e</i> 127
<b>16.5</b> <b>Atomic</b> <b>subroutines</b>
An atomic subroutine is an intrinsic subroutine that performs an action on its ATOM argument, and if it has an
OLD argument, determination of the value to be assigned to that argument, atomically. Definition or evaluation
of any argument other than ATOM is not performed atomically.
For any two executions in unordered segments of atomic subroutines whose ATOM argument is the same object,
the effect is as if one of the executions is performed completely before the other execution begins. Which execution
is performed first is processor dependent. The sequence of atomic actions within ordered segments is specified in
5.3.5. If successive atomic subroutine invocations on image <i>P</i> redefine a variable atomically in segments <i>P</i>
                                                 <i>i</i>
                                               and
<i>P</i>
<i>j</i>
 , atomic references to that variable from image <i>Q</i> in a segment <i>Q</i>
                               <i>k</i>
                              that is unordered relative to <i>P</i>
                                             <i>i</i>
                                           and <i>P</i>
                                                 <i>j</i>
                                               may
observe the changes in the value of that variable in any order.
Atomic operations shall make asynchronous progress. If a variable X on image <i>P</i> is defined by an atomic
subroutine on image <i>Q</i>, image <i>R</i> repeatedly references X [<i>P</i>] by an atomic subroutine in an unordered segment,
and no other image defines X [<i>P</i>] in an unordered segment, image <i>R</i> shall eventually receive the value assigned
by image <i>Q</i>, even if none of the images <i>P</i>, <i>Q</i>, or <i>R</i> execute an image control statement until after the definition
of X [<i>P</i>] by image <i>Q</i> and the reception of that value by image <i>R</i>.
If the STAT argument is present in an invocation of an atomic subroutine and no error condition occurs, it is
assigned the value zero.
If the STAT argument is present in an invocation of an atomic subroutine and an error condition occurs, any
other argument that is not INTENT (IN) becomes undefined. If the ATOM argument is on a failed image, an
error condition occurs and the value STAT_FAILED_IMAGE from the intrinsic module ISO_FORTRAN_-
ENV is assigned to the STAT argument. If any other error condition occurs, the STAT argument is assigned a
processor-dependent positive value that is different from the value of STAT_FAILED_IMAGE.
If the STAT argument is not present in an invocation of an atomic subroutine and an error condition occurs,
error termination is initiated.
<b>NOTE</b>
Thepropertiesofatomicsubroutinesareintendedtosupportcustomsynchronizationmechanisms. Theprogram
will need to handle all possible orderings of sequences of atomic subroutine executions that can arise as a
consequence of the above rules; note that the orderings can appear to be different on different images even in
the same program execution.
<b>16.6</b> <b>Collective</b> <b>subroutines</b>
Successful execution of a collective subroutine performs a calculation on all the images of the current team and
assigns a computed value on one or all of them. If it is invoked by one image, it shall be invoked by the same
statement on all active images of its current team in segments that are not ordered with respect to each other;
corresponding references participate in the same collective computation.
Before execution of the first CHANGE TEAM statement on an image, in between executions of CHANGE
TEAM and/or END TEAM statements, and after the last execution of an END TEAM statement, the sequence
of invocations of collective subroutines shall be the same on all active images of a team. A collective subroutine
shall not be referenced when an image control statement is not permitted to be executed (for example, in a
procedure invoked from a CRITICAL construct).
C1602 A reference to a collective subroutine shall not appear in a context where an image control statement is
   not permitted to appear.
If the A argument in a reference to a collective subroutine is a coarray, the corresponding ultimate arguments on
all active images of the current team shall be corresponding coarrays as described in 5.4.7.
If the STAT argument is present in a reference to a collective subroutine on one image:
 it shall be present on all the corresponding references;
 if no error condition occurs on that image, it is assigned the value zero;
 if an error condition occurs on that image, the A argument becomes undefined;
 if an error condition occurs other than that an image in the current team has stopped or failed, the STAT
  argument is assigned a processor-dependent positive value that is different from the value of STAT_-
  STOPPED_IMAGE or STAT_FAILED_IMAGE from the intrinsic module ISO_FORTRAN_ENV.
A reference to a collective subroutine on an image may be successful even if an error condition occurs during the
corresponding reference on another image. If error conditions occur on more than one image, the error conditions
may be different.
If the current team contains an image that is known to have stopped, an error condition occurs, and if the
STAT argument is present it is assigned the value STAT_STOPPED_IMAGE from the intrinsic module ISO_-
FORTRAN_ENV. Otherwise, if the current team contained an image that is known to have failed, an error
condition occurs, and if the STAT argument is present it is assigned the value STAT_FAILED_IMAGE from
the intrinsic module ISO_FORTRAN_ENV.
If the STAT argument is not present in a reference to a collective subroutine and an error condition occurs, error
termination is initiated.
If the ERRMSG argument is present in a reference to a collective subroutine and an error condition occurs, it is
assigned an explanatory message, as if by intrinsic assignment. If no error condition occurs, the definition status
and value of ERRMSG are unchanged.
<b>NOTE</b> <b>1</b>
The argument A becomes undefined if an error condition occurs during execution of a collective subroutine
because it is intended to allow the processor to use A for intermediate values during calculation.
<b>NOTE</b> <b>2</b>
Although the calculations performed by a collective subroutine have some internal synchronizations, a reference
to a collective subroutine is not an image control statement.
<b>16.7</b> <b>Standard</b> <b>generic</b> <b>intrinsic</b> <b>procedures</b>
For all of the standard intrinsic procedures, the arguments shown are the names that shall be used for argument
keywords if the keyword form is used for actual arguments.
<b>NOTE</b> <b>1</b>
For example, a reference to CMPLX can be written in the form CMPLX (A, B, M) or in the form CM-
PLX (Y = B, KIND = M, X = A).
<b>NOTE</b> <b>2</b>
Many of the argument keywords have names that are indicative of their usage. For example:
  KIND Describes the kind type parameter of the result
  STRING, STRING_A An arbitrary character string
  BACK Controls the direction of string scan
                    (forward or backward)
  MASK A mask to be applied to the arguments
  DIM A selected dimension of an array argument
In the Class column of Table 16.1,
 A indicates that the procedure is an atomic subroutine,
 C indicates that the procedure is a collective subroutine,
 E indicates that the procedure is an elemental function,
ES indicates that the procedure is a simple elemental subroutine,
 I indicates that the procedure is an inquiry function,
PS indicates that the procedure is a simple subroutine when the FROM argument is not a coarray,
 S indicates that the procedure is an impure subroutine,
SS indicates that the procedure is a simple subroutine, and
 T indicates that the procedure in a transformational function.
        <b>Table</b> <b>16.1</b> <b>-</b> <b>Standard</b> <b>generic</b> <b>intrinsic</b> <b>procedure</b> <b>summary</b>
Procedure (arguments) Class Description
ABS (A) E Absolute value.
ACHAR (I [, KIND]) E Character from ASCII code value.
ACOS (X) E Arccosine (inverse cosine) function.
ACOSD (X) E Arc cosine function in degrees.
       <b>Table</b> <b>16.1:</b> <b>Standard</b> <b>generic</b> <b>intrinsic</b> <b>procedure</b> <b>summary</b> (cont.)
Procedure (arguments) Class Description
ACOSH (X) E Inverse hyperbolic cosine function.
ACOSPI (X) E Circular arc cosine function.
ADJUSTL (STRING) E Left-justified string value.
ADJUSTR (STRING) E Right-justified string value.
AIMAG (Z) E Imaginary part of a complex number.
AINT (A [, KIND]) E Truncation toward 0 to a whole number.
ALL (MASK) or ALL (MASK, DIM) T Array reduced by .AND. operator.
ALLOCATED (ARRAY) or ALLOCATED (SCALAR) I Allocation status of allocatable variable.
ANINT (A [, KIND]) E Nearest whole number.
ANY (MASK) or ANY (MASK, DIM) T Array reduced by .OR. operator.
ASIN (X) E Arcsine (inverse sine) function.
ASIND (X) E Arc sine function in degrees.
ASINH (X) E Inverse hyperbolic sine function.
ASINPI (X) E Circular arc sine function.
ASSOCIATED (POINTER [, TARGET]) I Pointer association status inquiry.
ATAN (X) or ATAN (Y, X) E Arctangent (inverse tangent) function.
ATAN2 (Y, X) E Arctangent (inverse tangent) function.
ATAN2D (Y, X) E Arc tangent function in degrees.
ATAN2PI (Y, X) E Circular arc tangent function.
ATAND (X) or ATAND (Y, X) E Arc tangent function in degrees.
ATANH (X) E Inverse hyperbolic tangent function.
ATANPI (X) or ATANPI (Y, X) E Circular arc tangent function.
ATOMIC_ADD (ATOM, VALUE [, STAT]) A Atomic addition.
ATOMIC_AND (ATOM, VALUE [, STAT]) A Atomic bitwise AND.
ATOMIC_CAS (ATOM, OLD, COMPARE, NEW[, STAT]) A Atomic compare and swap.
ATOMIC_DEFINE (ATOM, VALUE [, STAT]) A Define a variable atomically.
ATOMIC_FETCH_ADD (ATOM, VALUE, OLD [, STAT]) A Atomic fetch and add.
ATOMIC_FETCH_AND (ATOM, VALUE, OLD [, STAT]) A Atomic fetch and bitwise AND.
ATOMIC_FETCH_OR (ATOM, VALUE, OLD [, STAT]) A Atomic fetch and bitwise OR.
ATOMIC_FETCH_XOR (ATOM, VALUE, OLD [, STAT]) A Atomic fetch and bitwise exclusive OR.
ATOMIC_OR (ATOM, VALUE [, STAT]) A Atomic bitwise OR.
ATOMIC_REF (VALUE, ATOM [, STAT]) A Reference a variable atomically.
ATOMIC_XOR (ATOM, VALUE [, STAT]) A Atomic bitwise exclusive OR.
BESSEL_J0 (X) E Bessel function of the 1
                                          <i>st</i>
                                         kind, order 0.
BESSEL_J1 (X) E Bessel function of the 1
                                          <i>st</i>
                                         kind, order 1.
BESSEL_JN (N, X) E Bessel function of the 1
                                          <i>st</i>
                                         kind, order N.
BESSEL_JN (N1, N2, X) T Bessel functions of the 1
                                           <i>st</i>
                                         kind.
BESSEL_Y0 (X) E Bessel function of the 2
                                          <i>nd</i>
                                         kind, order 0.
BESSEL_Y1 (X) E Bessel function of the 2
                                          <i>nd</i>
                                         kind, order 1.
BESSEL_YN (N, X) E Bessel function of the 2
                                          <i>nd</i>
                                         kind, order N.
BESSEL_YN (N1, N2, X) T Bessel functions of the 2
                                           <i>nd</i>
                                         kind.
BGE (I, J) E Bitwise greater than or equal to.
BGT (I, J) E Bitwise greater than.
BIT_SIZE (I) I Number of bits in integer model 16.3.
BLE (I, J) E Bitwise less than or equal to.
BLT (I, J) E Bitwise less than.
BTEST (I, POS) E Test single bit in an integer.
CEILING (A [, KIND]) E Least integer greater than or equal to A.
CHAR (I [, KIND]) E Character from code value.
CMPLX (X [, KIND]) or CMPLX (X [, Y, KIND]) E Conversion to complex type.
CO_BROADCAST (A, SOURCE_IMAGE [, STAT, C Broadcast value to images.
 ERRMSG])
CO_MAX (A [, RESULT_IMAGE, STAT, ERRMSG]) C Compute maximum value across images.
       <b>Table</b> <b>16.1:</b> <b>Standard</b> <b>generic</b> <b>intrinsic</b> <b>procedure</b> <b>summary</b> (cont.)
Procedure (arguments) Class Description
CO_MIN (A [, RESULT_IMAGE, STAT, ERRMSG]) C Compute minimum value across images.
CO_REDUCE (A, OPERATION [, RESULT_IMAGE, C Generalized reduction across images.
 STAT, ERRMSG])
CO_SUM (A [, RESULT_IMAGE, STAT, ERRMSG]) C Compute sum across images.
COMMAND_ARGUMENT_COUNT ( ) T Number of command arguments.
CONJG (Z) E Conjugate of a complex number.
COS (X) E Cosine function.
COSD (X) E Degree cosine function.
COSH (X) E Hyperbolic cosine function.
COSHAPE (COARRAY [, KIND]) I Sizes of codimensions of a coarray.
COSPI (X) E Circular cosine function.
COUNT (MASK [, DIM, KIND]) T Array reduced by counting true values.
CPU_TIME (TIME) S Processor time used.
CSHIFT (ARRAY, SHIFT [, DIM]) T Circular shift of an array.
DATE_AND_TIME ([DATE, TIME, ZONE, VALUES]) S Date and time.
DBLE (A) E Conversion to double precision real.
DIGITS (X) I Significant digits in numeric model.
DIM (X, Y) E Maximum of X- Y and zero.
DOT_PRODUCT (VECTOR_A, VECTOR_B) T Dot product of two vectors.
DPROD (X, Y) E Double precision real product.
DSHIFTL (I, J, SHIFT) E Combined left shift.
DSHIFTR (I, J, SHIFT) E Combined right shift.
EOSHIFT (ARRAY, SHIFT [, BOUNDARY, DIM]) T End-off shift of the elements of an array.
EPSILON (X) I Model number that is small compared to 1.
ERF (X) E Error function.
ERFC (X) E Complementary error function.
ERFC_SCALED (X) E Scaled complementary error function.
EVENT_QUERY (EVENT, COUNT [, STAT]) S Query event count.
EXECUTE_COMMAND_LINE (COMMAND [, WAIT, S Execute a command line.
 EXITSTAT, CMDSTAT, CMDMSG])
EXP (X) E Exponential function.
EXPONENT (X) E Exponent of floating-point number.
EXTENDS_TYPE_OF (A, MOLD) I Dynamic type extension inquiry.
FAILED_IMAGES ([TEAM, KIND]) T Indices of failed images.
FINDLOC (ARRAY, VALUE [, MASK, KIND, BACK]) or T Location(s) of a specified value.
FINDLOC (ARRAY, VALUE, DIM [, MASK, KIND, BACK])
FLOOR (A [, KIND]) E Greatest integer less than or equal to A.
FRACTION (X) E Fractional part of number.
GAMMA (X) E Gamma function.
GET_COMMAND ([COMMAND, LENGTH, STATUS, S Get program invocation command.
 ERRMSG])
GET_COMMAND_ARGUMENT (NUMBER [, VALUE, S Get program invocation argument.
 LENGTH, STATUS, ERRMSG])
GET_ENVIRONMENT_VARIABLE (NAME [, VALUE, S Get environment variable.
 LENGTH, STATUS, TRIM_NAME, ERRMSG])
GET_TEAM ([LEVEL]) T Team.
HUGE (X) I Largest model value or last enumeration
                              value.
HYPOT (X, Y) E Euclidean distance function.
IACHAR (C [, KIND]) E ASCII code value for character.
IALL (ARRAY, DIM [, MASK]) or IALL (ARRAY [, MASK]) T Array reduced by IAND function.
IAND (I, J) E Bitwise AND.
IANY(ARRAY,DIM[,MASK])orIANY(ARRAY[,MASK]) T Array reduced by IOR function.
       <b>Table</b> <b>16.1:</b> <b>Standard</b> <b>generic</b> <b>intrinsic</b> <b>procedure</b> <b>summary</b> (cont.)
Procedure (arguments) Class Description
IBCLR (I, POS) E I with bit POS replaced by zero.
IBITS (I, POS, LEN) E Specified sequence of bits.
IBSET (I, POS) E I with bit POS replaced by one.
ICHAR (C [, KIND]) E Code value for character.
IEOR (I, J) E Bitwise exclusive OR.
IMAGE_INDEX (COARRAY, SUB, TEAM_NUMBER) or T Image index from cosubscripts.
IMAGE_INDEX (COARRAY, SUB, TEAM) or
IMAGE_INDEX (COARRAY, SUB)
IMAGE_STATUS (IMAGE [, TEAM]) E Image execution state.
INDEX (STRING, SUBSTRING [, BACK, KIND]) E Character string search.
INT (A [, KIND]) E Conversion to integer type.
IOR (I, J) E Bitwise inclusive OR.
IPARITY (ARRAY, DIM [, MASK]) or T Array reduced by IEOR function.
IPARITY (ARRAY [, MASK])
ISHFT (I, SHIFT) E Logical shift.
ISHFTC (I, SHIFT [, SIZE]) E Circular shift of the rightmost bits.
IS_CONTIGUOUS (ARRAY) I Array contiguity test (8.5.7).
IS_IOSTAT_END (I) E IOSTAT value test for end of file.
IS_IOSTAT_EOR (I) E IOSTAT value test for end of record.
KIND (X) I Value of the kind type parameter of X.
LBOUND (ARRAY [, DIM, KIND]) I Lower bound(s).
LCOBOUND (COARRAY [, DIM, KIND]) I Lower cobound(s) of a coarray.
LEADZ (I) E Number of leading zero bits.
LEN (STRING [, KIND]) I Length of a character entity.
LEN_TRIM (STRING [, KIND]) E Length without trailing blanks.
LGE (STRING_A, STRING_B) E ASCII greater than or equal.
LGT (STRING_A, STRING_B) E ASCII greater than.
LLE (STRING_A, STRING_B) E ASCII less than or equal.
LLT (STRING_A, STRING_B) E ASCII less than.
LOG (X) E Natural logarithm.
LOG_GAMMA (X) E Logarithm of the absolute value of the
                              gamma function.
LOG10 (X) E Common logarithm.
LOGICAL (L [, KIND]) E Conversion between kinds of logical.
MASKL (I [, KIND]) E Left justified mask.
MASKR (I [, KIND]) E Right justified mask.
MATMUL (MATRIX_A, MATRIX_B) T Matrix multiplication.
MAX (A1, A2 [, A3, ...]) E Maximum value.
MAXEXPONENT (X) I Maximum exponent of a real model.
MAXLOC (ARRAY, DIM [, MASK, KIND, BACK]) or T Location(s) of maximum value.
MAXLOC (ARRAY [, MASK, KIND, BACK])
MAXVAL (ARRAY, DIM [, MASK]) or T Maximum value(s) of array.
MAXVAL (ARRAY [, MASK])
MERGE (TSOURCE, FSOURCE, MASK) E Expression value selection.
MERGE_BITS (I, J, MASK) E Merge of bits under mask.
MIN (A1, A2 [, A3, ...]) E Minimum value.
MINEXPONENT (X) I Minimum exponent of a real model.
MINLOC (ARRAY, DIM [, MASK, KIND, BACK]) or T Location(s) of minimum value.
MINLOC (ARRAY [, MASK, KIND, BACK])
MINVAL (ARRAY, DIM [, MASK]) or T Minimum value(s) of array.
MINVAL (ARRAY [, MASK])
MOD (A, P) E Remainder function.
MODULO (A, P) E Modulo function.
       <b>Table</b> <b>16.1:</b> <b>Standard</b> <b>generic</b> <b>intrinsic</b> <b>procedure</b> <b>summary</b> (cont.)
Procedure (arguments) Class Description
MOVE_ALLOC (FROM, TO [, STAT, ERRMSG]) PS Move an allocation.
MVBITS (FROM, FROMPOS, LEN, TO, TOPOS) ES Copy a sequence of bits.
NEAREST (X, S) E Adjacent machine number.
NEW_LINE (A) I Newline character.
NEXT (A [, STAT]) E Next enumeration value.
NINT (A [, KIND]) E Nearest integer.
NORM2 (X) or NORM2 (X, DIM) T <i>L</i>
                                   2
                               norm of an array.
NOT (I) E Bitwise complement.
NULL ([MOLD]) T Disassociated pointer or unallocated
                              allocatable entity.
NUM_IMAGES ( ) or NUM_IMAGES (TEAM) or T Number of images.
NUM_IMAGES (TEAM_NUMBER)
OUT_OF_RANGE (X, MOLD [, ROUND]) E Whether a value cannot be converted
                              safely.
PACK (ARRAY, MASK [, VECTOR]) T Array packed into a vector.
PARITY (MASK) or PARITY (MASK, DIM) T Array reduced by .NEQV. operator.
POPCNT (I) E Number of one bits.
POPPAR (I) E Parity expressed as 0 or 1.
PRECISION (X) I Decimal precision of a real model.
PRESENT (A) I Presence of optional argument.
PREVIOUS (A [, STAT]) E Previous enumeration value.
PRODUCT (ARRAY, DIM [, MASK]) or T Array reduced by multiplication.
PRODUCT (ARRAY [, MASK])
RADIX (X) I Base of a numeric model.
RANDOM_INIT (REPEATABLE, IMAGE_DISTINCT) S Initialize pseudorandom number generator.
RANDOM_NUMBER (HARVEST) S Generate pseudorandom number(s).
RANDOM_SEED ([SIZE, PUT, GET]) S Pseudorandom number generator control.
RANGE (X) I Decimal exponent range of a numeric
                              model (16.4).
RANK (A) I Rank of a data object.
REAL (A [, KIND]) E Conversion to real type.
REDUCE (ARRAY, OPERATION [, MASK, IDENTITY, T General reduction of array
 ORDERED]) or REDUCE (ARRAY, OPERATION, DIM
 [, MASK, IDENTITY, ORDERED])
REPEAT (STRING, NCOPIES) T Repetitive string concatenation.
RESHAPE (SOURCE, SHAPE [, PAD, ORDER]) T Arbitrary shape array construction.
RRSPACING (X) E Reciprocal of relative spacing of model
                              numbers.
SAME_TYPE_AS (A, B) I Dynamic type equality test.
SCALE (X, I) E Real number scaled by radix power.
SCAN (STRING, SET [, BACK, KIND]) E Character set membership search.
SELECTED_CHAR_KIND (NAME) T Character kind selection.
SELECTED_INT_KIND (R) T Integer kind selection.
SELECTED_LOGICAL_KIND (BITS) T Logical kind selection.
SELECTED_REAL_KIND ([P, R, RADIX]) T Real kind selection.
SET_EXPONENT (X, I) E Real value with specified exponent.
SHAPE (SOURCE [, KIND]) I Shape of an array or a scalar.
SHIFTA (I, SHIFT) E Right shift with fill.
SHIFTL (I, SHIFT) E Left shift.
SHIFTR (I, SHIFT) E Right shift.
SIGN (A, B) E Magnitude of A with the sign of B.
SIN (X) E Sine function.
SIND (X) E Degree sine function.
       <b>Table</b> <b>16.1:</b> <b>Standard</b> <b>generic</b> <b>intrinsic</b> <b>procedure</b> <b>summary</b> (cont.)
Procedure (arguments) Class Description
SINH (X) E Hyperbolic sine function.
SINPI (X) E Circular sine function.
SIZE (ARRAY [, DIM, KIND]) I Size of an array or one extent.
SPACING (X) E Spacing of model numbers.
SPLIT (STRING, SET, POS [, BACK]) SS Parse a string into tokens, one at a time.
SPREAD (SOURCE, DIM, NCOPIES) T Value replicated in a new dimension.
SQRT (X) E Square root.
STOPPED_IMAGES ([TEAM, KIND]) T Indices of stopped images.
STORAGE_SIZE (A [, KIND]) I Storage size in bits.
SUM (ARRAY, DIM [, MASK]) or SUM (ARRAY [, MASK]) T Array reduced by addition.
SYSTEM_CLOCK ([COUNT, COUNT_RATE, S Query system clock.
 COUNT_MAX])
TAN (X) E Tangent function.
TAND (X) E Degree tangent function.
TANH (X) E Hyperbolic tangent function.
TANPI (X) E Circular tangent function.
TEAM_NUMBER ([TEAM]) T Team number.
THIS_IMAGE ([TEAM]) T Index of the invoking image.
THIS_IMAGE (COARRAY [, TEAM]) or T Cosubscript(s) for this image.
THIS_IMAGE (COARRAY, DIM [, TEAM])
TINY (X) I Smallest positive model number.
TOKENIZE (STRING, SET, TOKENS [, SEPARATOR]) or SS Parse a string into tokens.
TOKENIZE (STRING, SET, FIRST, LAST)
TRAILZ (I) E Number of trailing zero bits.
TRANSFER (SOURCE, MOLD [, SIZE]) T Transfer physical representation.
TRANSPOSE (MATRIX) T Transpose of an array of rank two.
TRIM (STRING) T String without trailing blanks.
UBOUND (ARRAY [, DIM, KIND]) I Upper bound(s).
UCOBOUND (COARRAY [, DIM, KIND]) I Upper cobound(s) of a coarray.
UNPACK (VECTOR, MASK, FIELD) T Vector unpacked into an array.
VERIFY (STRING, SET [, BACK, KIND]) E Character set non-membership search.
The effect of calling EXECUTE_COMMAND_LINE on any image other than image 1 in the initial team is
processor dependent.
The use of all other standard intrinsic procedures in unordered segments is subject only to their argument use
following the rules in 11.7.2.
<b>16.8</b> <b>Specific</b> <b>names</b> <b>for</b> <b>standard</b> <b>intrinsic</b> <b>functions</b>
Except for AMAX0, AMIN0, MAX1, and MIN1, the result type of the specific function is the same that the result type of the
corresponding generic function reference would be if it were invoked with the same arguments as the specific function.
A function listed in Table 16.3 is not permitted to be used as an actual argument (15.5.1, C1534), as a target in a procedure
pointer assignment statement (10.2.2.2, C1033), as an initial target in a procedure declaration statement (15.4.3.6, C1519), or to
specify an interface (15.4.3.6, C1515).
         <b>Table</b> <b>16.2</b> <b>-</b> <b>Unrestricted</b> <b>specific</b> <b>intrinsic</b> <b>functions</b>
                Specific name Generic name Argument type and kind
                ABS ABS default real
                ACOS ACOS default real
                AIMAG AIMAG default complex
                AINT AINT default real
                ALOG LOG default real
           <b>Unrestricted</b> <b>specific</b> <b>intrinsic</b> <b>functions</b> (cont.)
                Specific name Generic name Argument type and kind
                ALOG10 LOG10 default real
                AMOD MOD default real
                ANINT ANINT default real
                ASIN ASIN default real
                ATAN ATAN (X) default real
                ATAN2 ATAN2 default real
                CABS ABS default complex
                CCOS COS default complex
                CEXP EXP default complex
                CLOG LOG default complex
                CONJG CONJG default complex
                COS COS default real
                COSH COSH default real
                CSIN SIN default complex
                CSQRT SQRT default complex
                DABS ABS double precision real
                DACOS ACOS double precision real
                DASIN ASIN double precision real
                DATAN ATAN double precision real
                DATAN2 ATAN2 double precision real
                DCOS COS double precision real
                DCOSH COSH double precision real
                DDIM DIM double precision real
                DEXP EXP double precision real
                DIM DIM default real
                DINT AINT double precision real
                DLOG LOG double precision real
                DLOG10 LOG10 double precision real
                DMOD MOD double precision real
                DNINT ANINT double precision real
                DPROD DPROD default real
                DSIGN SIGN double precision real
                DSIN SIN double precision real
                DSINH SINH double precision real
                DSQRT SQRT double precision real
                DTAN TAN double precision real
                DTANH TANH double precision real
                EXP EXP default real
                IABS ABS default integer
                IDIM DIM default integer
                IDNINT NINT double precision real
                INDEX INDEX default character
                ISIGN SIGN default integer
                LEN LEN default character
                MOD MOD default integer
                NINT NINT default real
                SIGN SIGN default real
                SIN SIN default real
                SINH SINH default real
                SQRT SQRT default real
                TAN TAN default real
                TANH TANH default real
          <b>Table</b> <b>16.3</b> <b>-</b> <b>Restricted</b> <b>specific</b> <b>intrinsic</b> <b>functions</b>
              Specific name Generic name Argument type and kind
              AMAX0 (...) REAL (MAX (...)) default integer
              AMAX1 MAX default real
              AMIN0 (...) REAL (MIN (...)) default integer
              AMIN1 MIN default real
              CHAR CHAR default integer
              DMAX1 MAX double precision real
              DMIN1 MIN double precision real
              FLOAT REAL default integer
              ICHAR ICHAR default character
           <b>Restricted</b> <b>specific</b> <b>intrinsic</b> <b>functions</b> (cont.)
              Specific name Generic name Argument type and kind
              IDINT INT double precision real
              IFIX INT default real
              INT INT default real
              LGE LGE default character
              LGT LGT default character
              LLE LLE default character
              LLT LLT default character
              MAX0 MAX default integer
              MAX1 (...) INT (MAX (...)) default real
              MIN0 MIN default integer
              MIN1 (...) INT (MIN (...)) default real
              REAL REAL default integer
              SNGL REAL double precision real
<b>16.9</b> <b>Specifications</b> <b>of</b> <b>the</b> <b>standard</b> <b>intrinsic</b> <b>procedures</b>
<b>16.9.1</b> <b>General</b>
Detailed specifications of the standard generic intrinsic procedures are provided in 16.9 in alphabetical order.
The types and type parameters of standard intrinsic procedure arguments and function results are determined
by these specifications. The "Argument(s)" paragraphs specify requirements on the actual arguments of the
procedures. The result characteristics are sometimes specified in terms of the characteristics of the arguments. A
program shall not invoke an intrinsic procedure under circumstances where a value to be assigned to a subroutine
argumentorreturnedasafunctionresultisnotrepresentablebyobjectsofthespecifiedtypeandtypeparameters.
When an allocatable deferred-length character scalar corresponding to an INTENT (INOUT) or INTENT (OUT)
argument is assigned a value, the value is assigned as if by intrinsic assignment.
If an IEEE infinity is assigned or returned by an intrinsic procedure, the intrinsic module IEEE_ARITHMETIC
is accessible, and the actual arguments were finite numbers, the flag IEEE_OVERFLOW or IEEE_DIVIDE_-
BY_ZERO shall signal. If an IEEE NaN is assigned or returned, the actual arguments were finite numbers, the
intrinsic module IEEE_ARITHMETIC is accessible, and the exception IEEE_INVALID is supported, the flag
IEEE_INVALID shall signal. If no IEEE infinity or NaN is assigned or returned, these flags shall have the same
status as when the intrinsic procedure was invoked.
The result values of some functions are described using pseudo-subscripts (<i>s</i>
                                       1
                                  to <i>s</i>
                                      <i>n</i>
                                     ) of the argument array(s).
These should be interpreted as if the lower bounds of the arrays were all equal to one.
<b>16.9.2</b> <b>ABS</b> <b>(A)</b>
<b>Description.</b> Absolute value.
<b>Class.</b> Elemental function.
<b>Argument.</b> A shall be of type integer, real, or complex.
<b>Result</b> <b>Characteristics.</b> The same as A except that if A is complex, the result is real.
<b>Result</b> <b>Value.</b> If A is of type integer or real, the value of the result is|A|; if A is complex with value (<i>x,y</i>),
the result is equal to a processor-dependent approximation to
                 p
                        <i>x</i>
                                  2
                                                      +<i>y</i>
                                    2
                                computed without undue overflow or
underflow.
<b>Example.</b> ABS ((3.0, 4.0)) has the value 5.0 (approximately).
<b>16.9.3</b> <b>ACHAR</b> <b>(I</b> <b>[,</b> <b>KIND])</b>
<b>Description.</b> Character from ASCII code value.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
I shall be of type integer.
KIND (optional) shall be a scalar integer constant expression.
<b>Result</b> <b>Characteristics.</b> Character of length one. If KIND is present, the kind type parameter is that specified
by the value of KIND; otherwise, the kind type parameter is that of default character.
<b>Result</b> <b>Value.</b> If I has a value in the range 0 I 127, the result is the character in position I of the ASCII
collating sequence, provided the processor is capable of representing that character in the character kind of the
result; otherwise, the result is processor dependent. ACHAR (IACHAR (C)) shall have the value C for any
character C capable of representation as a default character.
<b>Example.</b> ACHAR (88) has the value 'X'.
<b>16.9.4</b> <b>ACOS</b> <b>(X)</b>
<b>Description.</b> Arccosine (inverse cosine) function.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real with a value that satisfies the inequality|X| 1, or of type complex.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has a value equal to a processor-dependent approximation to arccos(X). If it is real
it is expressed in radians and lies in the range 0 ACOS (X) . If it is complex the real part is expressed in
radians and lies in the range 0 REAL (ACOS (X)) .
<b>Example.</b> ACOS (0.54030231) has the value 1.0 (approximately).
<b>16.9.5</b> <b>ACOSD</b> <b>(X)</b>
<b>Description.</b> Arc cosine function in degrees.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real with a value that satisfies the inequality|X| 1.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has a value equal to a processor-dependent approximation to the arc cosine of X. It
is expressed in degrees and lies in the range 0 ACOSD (X) 180.
<b>Example.</b> ACOSD (-1<i>.</i>0) has the value 180.0 (approximately).
<b>16.9.6</b> <b>ACOSH</b> <b>(X)</b>
<b>Description.</b> Inverse hyperbolic cosine function.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real or complex.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has a value equal to a processor-dependent approximation to the inverse hyperbolic
cosine function of X. If the result is complex the real part is nonnegative, and the imaginary part is expressed in
radians and lies in the range- AIMAG (ACOSH (X)) 
<b>Example.</b> ACOSH (1.5430806) has the value 1.0 (approximately).
<b>16.9.7</b> <b>ACOSPI</b> <b>(X)</b>
<b>Description.</b> Circular arc cosine function.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real with a value that satisfies the inequality|X| 1.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has a value equal to a processor-dependent approximation to the arc cosine of X. It
is expressed in half-revolutions and lies in the range 0 ACOSPI (X) 1.
<b>Example.</b> ACOSPI (-1<i>.</i>0) has the value 1.0 (approximately).
<b>16.9.8</b> <b>ADJUSTL</b> <b>(STRING)</b>
<b>Description.</b> Left-justified string value.
<b>Class.</b> Elemental function.
<b>Argument.</b> STRING shall be of type character.
<b>Result</b> <b>Characteristics.</b> Character of the same length and kind type parameter as STRING.
<b>Result</b> <b>Value.</b> The value of the result is the same as STRING except that any leading blanks have been deleted
and the same number of trailing blanks have been inserted.
<b>Example.</b> ADJUSTL (' WORD') has the value 'WORD '.
<b>16.9.9</b> <b>ADJUSTR</b> <b>(STRING)</b>
<b>Description.</b> Right-justified string value.
<b>Class.</b> Elemental function.
<b>Argument.</b> STRING shall be of type character.
<b>Result</b> <b>Characteristics.</b> Character of the same length and kind type parameter as STRING.
<b>Result</b> <b>Value.</b> The value of the result is the same as STRING except that any trailing blanks have been deleted
and the same number of leading blanks have been inserted.
<b>Example.</b> ADJUSTR ('WORD ') has the value ' WORD'.
<b>16.9.10</b> <b>AIMAG</b> <b>(Z)</b>
<b>Description.</b> Imaginary part of a complex number.
<b>Class.</b> Elemental function.
<b>Argument.</b> Z shall be of type complex.
<b>Result</b> <b>Characteristics.</b> Real with the same kind type parameter as Z.
<b>Result</b> <b>Value.</b> If Z has the value (<i>x,y</i>), the result has the value <i>y</i>.
<b>Example.</b> AIMAG ((2.0, 3.0)) has the value 3.0.
<b>16.9.11</b> <b>AINT</b> <b>(A</b> <b>[,</b> <b>KIND])</b>
<b>Description.</b> Truncation toward 0 to a whole number.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
A shall be of type real.
KIND (optional) shall be a scalar integer constant expression.
<b>Result</b> <b>Characteristics.</b> The result is of type real. If KIND is present, the kind type parameter is that specified
by the value of KIND; otherwise, the kind type parameter is that of A.
<b>Result</b> <b>Value.</b> If|A| <i><</i> 1, AINT (A) has the value 0; if|A| 1, AINT (A) has a value equal to the integer
whose magnitude is the largest integer that does not exceed the magnitude of A and whose sign is the same as
the sign of A.
<b>Examples.</b> AINT (2.783) has the value 2.0. AINT (-2.783) has the value-2.0.
<b>16.9.12</b> <b>ALL</b> <b>(MASK)</b> <b>or</b> <b>ALL</b> <b>(MASK,</b> <b>DIM)</b>
<b>Description.</b> Array reduced by .AND. operator.
<b>Class.</b> Transformational function.
<b>Arguments.</b>
MASK shall be a logical array.
DIM shall be an integer scalar with value in the range 1 DIM<i>n</i>, where <i>n</i> is the rank of MASK.
<b>Result</b> <b>Characteristics.</b> The result is of type logical with the same kind type parameter as MASK. It is scalar
if DIM does not appear or <i>n</i> = 1; otherwise, the result has rank <i>n</i>- 1 and shape [<i>d</i>
                                          1
                                     , <i>d</i>
                                            2
                                       , ..., <i>d</i>
                                              DIM-1
                                            , <i>d</i>
                                                  DIM+1
                                                ,
..., <i>d</i>
  <i>n</i>
   ] where [<i>d</i>
        1
       , <i>d</i>
          2
         , ..., <i>d</i>
             <i>n</i>
            ] is the shape of MASK.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> The result of ALL (MASK) has the value true if all elements of MASK are true or if MASK has
     size zero, and the result has value false if any element of MASK is false.
<i>Case</i> <i>(ii):</i> If MASK has rank one, ALL (MASK, DIM) is equal to ALL (MASK). Otherwise, the value of
     element (<i>s</i>
            1
          , <i>s</i>
             2
            , ..., <i>s</i>
                DIM-1
                  , <i>s</i>
                     DIM+1
                     , ..., <i>s</i>
                          <i>n</i>
                         ) of ALL (MASK, DIM) is equal to ALL (MASK (<i>s</i>
                                                       1
                                                ,
    <i>s</i>
       2
      , ..., <i>s</i>
          DIM-1
            , :, <i>s</i>
               DIM+1
                 , ..., <i>s</i>
                     <i>n</i>
                    )).
<b>Examples.</b>
<i>Case</i> <i>(i):</i> The value of ALL ([.TRUE., .FALSE., .TRUE.]) is false.
<i>Case</i> <i>(ii):</i> If B is the array
        ?
                          1 3 5
                          2 4 6
           ?
                   and C is the array
                 ?
                                                    0 3 5
                                                    7 4 8
                     ?
                                  then ALL (B /= C, DIM = 1) is
     [true, false, false] and ALL (B /= C, DIM = 2) is [false, false].
<b>16.9.13</b> <b>ALLOCATED</b> <b>(ARRAY)</b> <b>or</b> <b>ALLOCATED</b> <b>(SCALAR)</b>
<b>Description.</b> Allocation status of allocatable variable.
<b>Class.</b> Inquiry function.
<b>Arguments.</b>
ARRAY shall be an allocatable array.
SCALAR shall be an allocatable scalar.
<b>Result</b> <b>Characteristics.</b> Default logical scalar.
<b>Result</b> <b>Value.</b> The result has the value true if the argument (ARRAY or SCALAR) is allocated and has the
value false if the argument is unallocated.
<b>16.9.14</b> <b>ANINT</b> <b>(A</b> <b>[,</b> <b>KIND])</b>
<b>Description.</b> Nearest whole number.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
A shall be of type real.
KIND (optional) shall be a scalar integer constant expression.
<b>Result</b> <b>Characteristics.</b> The result is of type real. If KIND is present, the kind type parameter is that specified
by the value of KIND; otherwise, the kind type parameter is that of A.
<b>Result</b> <b>Value.</b> The result is the integer nearest A, or if there are two integers equally near A, the result is
whichever such integer has the greater magnitude.
<b>Examples.</b> ANINT (2.783) has the value 3.0. ANINT (-2.783) has the value-3.0.
<b>16.9.15</b> <b>ANY</b> <b>(MASK)</b> <b>or</b> <b>ANY</b> <b>(MASK,</b> <b>DIM)</b>
<b>Description.</b> Array reduced by .OR. operator.
<b>Class.</b> Transformational function.
<b>Arguments.</b>
MASK shall be a logical array.
DIM shall be an integer scalar with a value in the range 1 DIM<i>n</i>, where <i>n</i> is the rank of MASK.
<b>Result</b> <b>Characteristics.</b> The result is of type logical with the same kind type parameter as MASK. It is scalar
if DIM does not appear or <i>n</i> = 1; otherwise, the result has rank <i>n</i>- 1 and shape [<i>d</i>
                                          1
                                     , <i>d</i>
                                            2
                                       , ..., <i>d</i>
                                              DIM-1
                                            , <i>d</i>
                                                  DIM+1
                                                ,
..., <i>d</i>
  <i>n</i>
   ] where [<i>d</i>
        1
       , <i>d</i>
          2
         , ..., <i>d</i>
             <i>n</i>
            ] is the shape of MASK.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> The result of ANY (MASK) has the value true if any element of MASK is true and has the value
     false if no elements are true or if MASK has size zero.
<i>Case</i> <i>(ii):</i> If MASK has rank one, ANY (MASK, DIM) is equal to ANY (MASK). Otherwise, the value of
     element (<i>s</i>
            1
          , <i>s</i>
             2
            , ..., <i>s</i>
                DIM-1
                  , <i>s</i>
                    DIM+1
                     , ..., <i>s</i>
                          <i>n</i>
                         ) of ANY (MASK, DIM) is equal to ANY (MASK (<i>s</i>
                                                       1
                                                ,
    <i>s</i>
       2
      , ..., <i>s</i>
          DIM-1
            , :, <i>s</i>
               DIM+1
                 , ..., <i>s</i>
                     <i>n</i>
                    )).
<b>Examples.</b>
<i>Case</i> <i>(i):</i> The value of ANY ([.TRUE., .FALSE., .TRUE.]) is true.
<i>Case</i> <i>(ii):</i> If B is the array
        ?
                          1 3 5
                          2 4 6
           ?
                   and C is the array
                 ?
                                                    0 3 5
                                                    7 4 8
                    ?
                                  then ANY (B /= C, DIM = 1) is
     [true, false, true] and ANY (B /= C, DIM = 2) is [true, true].
<b>16.9.16</b> <b>ASIN</b> <b>(X)</b>
<b>Description.</b> Arcsine (inverse sine) function.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real with a value that satisfies the inequality|X| 1, or of type complex.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has a value equal to a processor-dependent approximation to arcsin(X). If it is real it
is expressed in radians and lies in the range-<i>/</i>2 ASIN (X) <i>/</i>2. If it is complex the real part is expressed
in radians and lies in the range-<i>/</i>2 REAL (ASIN (X)) <i>/</i>2.
<b>Example.</b> ASIN (0.84147098) has the value 1.0 (approximately).
<b>16.9.17</b> <b>ASIND</b> <b>(X)</b>
<b>Description.</b> Arc sine function in degrees.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real with a value that satisfies the inequality|X| 1.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has a value equal to a processor-dependent approximation to the arc sine of X. It is
expressed in degrees and lies in the range-90 ASIND (X) 90.
<b>Example.</b> ASIND (1<i>.</i>0) has the value 90<i>.</i>0 (approximately).
<b>16.9.18</b> <b>ASINH</b> <b>(X)</b>
<b>Description.</b> Inverse hyperbolic sine function.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real or complex.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has a value equal to a processor-dependent approximation to the inverse hyperbolic
sine function of X. If the result is complex the imaginary part is expressed in radians and lies in the range
-<i>/</i>2 AIMAG (ASINH (X)) <i>/</i>2.
<b>Example.</b> ASINH (1.1752012) has the value 1.0 (approximately).
<b>16.9.19</b> <b>ASINPI</b> <b>(X)</b>
<b>Description.</b> Circular arc sine function.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real with a value that satisfies the inequality|X| 1.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has a value equal to a processor-dependent approximation to the arc sine of X. It is
expressed in half-revolutions and lies in the range-
                          1
                          2
            ASINPI (X)
                                    1
                                    2
                                .
<b>Example.</b> ASINPI (1<i>.</i>0) has the value 0<i>.</i>5 (approximately).
<b>16.9.20</b> <b>ASSOCIATED</b> <b>(POINTER</b> <b>[,</b> <b>TARGET])</b>
<b>Description.</b> Pointer association status inquiry.
<b>Class.</b> Inquiry function.
<b>Arguments.</b>
POINTER shall be a pointer. It may be of any type or may be a procedure pointer. Its pointer association
     status shall not be undefined.
TARGET (optional) shall be a pointer or an entity that could be a target. If TARGET is a pointer then its
     pointer association status shall not be undefined.
     If POINTER is a procedure pointer, TARGET shall be a procedure (or procedure pointer) that
     would be allowable as the target of a pointer assignment (10.2.2) for a procedure pointer with the
     same characteristics as POINTER.
     Otherwise, TARGET shall be a noncoindexed variable that is not an array section with a vector
     subscript, or a reference to a function that returns a data pointer. If POINTER is not unlimited
     polymorphic, TARGET shall be type compatible with it, and the corresponding kind type para-
     meters shall be equal. If POINTER is not assumed-rank, TARGET shall have the same rank as
     POINTER.
<b>Result</b> <b>Characteristics.</b> Default logical scalar.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> If TARGET is absent, the result is true if and only if POINTER is associated with a target.
<i>Case</i> <i>(ii):</i> If TARGET is present and is a procedure other than a dummy procedure or procedure pointer, the
     result is true if and only if POINTER is associated with TARGET and, if TARGET is an internal
     procedure, they have the same host instance.
<i>Case</i> <i>(iii):</i> If TARGET is present and is a dummy procedure that is not a procedure pointer, the result is true
     if and only if POINTER is associated with the procedure that is the ultimate argument of TARGET
     and, if the procedure is an internal procedure, they have the same host instance.
<i>Case</i> <i>(iv):</i> If TARGET is present and is a procedure pointer, the result is true if and only if POINTER and
     TARGET are associated with the same procedure and, if the procedure is an internal procedure,
     they have the same host instance.
<i>Case</i> <i>(v):</i> If TARGET is present and is a scalar target, the result is true if and only if TARGET is not a zero-
     sized storage sequence and POINTER is associated with a target that occupies the same storage
     units as TARGET.
<i>Case</i> <i>(vi):</i> If TARGET is present and is an array target, the result is true if and only if POINTER is associated
     withatargetthathasthesameshapeasTARGET,isneitherofsizezeronoranarraywhoseelements
     are zero-sized storage sequences, and occupies the same storage units as TARGET in array element
     order.
<i>Case</i> <i>(vii):</i> If TARGET is present and is a scalar pointer, the result is true if and only if POINTER and
     TARGET are associated, the targets are not zero-sized storage sequences, and they occupy the
     same storage units.
<i>Case</i> <i>(viii):</i> If TARGET is present and is an array pointer, the result is true if and only if POINTER and
     TARGET are both associated, have the same shape, are neither of size zero nor arrays whose
     elements are zero-sized storage sequences, and occupy the same storage units in array element
     order.
<b>NOTE</b>
The references to TARGET in the above cases are referring to properties that might be possessed by the actual
argument, so the case of TARGET being a disassociated pointer will be covered by case <i>(iv)</i>, <i>(vii)</i>, or <i>(viii)</i>.
<b>Examples.</b> ASSOCIATED (CURRENT, HEAD) is true if CURRENT is associated with the target HEAD.
After the execution of
 A_PART =<i>></i> A (:N)
ASSOCIATED (A_PART, A) is true if N is equal to UBOUND (A, DIM = 1). After the execution of
 NULLIFY (CUR); NULLIFY (TOP)
ASSOCIATED (CUR, TOP) is false.
<b>16.9.21</b> <b>ATAN</b> <b>(X)</b> <b>or</b> <b>ATAN</b> <b>(Y,</b> <b>X)</b>
<b>Description.</b> Arctangent (inverse tangent) function.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
Y shall be of type real.
X If Y appears, X shall be of type real with the same kind type parameter as Y. If Y has the value
     zero, X shall not have the value zero. If Y does not appear, X shall be of type real or complex.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> If Y appears, the result is the same as the result of ATAN2 (Y,X). If Y does not appear, the
result has a value equal to a processor-dependent approximation to arctan(X) whose real part is expressed in
radians and lies in the range-<i>/</i>2 ATAN (X) <i>/</i>2.
<b>Example.</b> ATAN (1.5574077) has the value 1.0 (approximately).
<b>16.9.22</b> <b>ATAN2</b> <b>(Y,</b> <b>X)</b>
<b>Description.</b> Arctangent (inverse tangent) function.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
Y shall be of type real.
X shall be of the same type and kind type parameter as Y. If Y has the value zero, X shall not have
     the value zero.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has a value equal to a processor-dependent approximation to the principal value of the
argument of the complex number (X, Y), expressed in radians. It lies in the range- ATAN2 (Y,X)  and is
equal to a processor-dependent approximation to a value of arctan(Y/X) if X?= 0. If Y<i>></i> 0, the result is positive.
If Y = 0 and X <i>></i> 0, the result is Y. If Y = 0 and X <i><</i> 0, then the result is approximately  if Y is positive real
zero or the processor does not distinguish between positive and negative real zero, and approximately- if Y is
negative real zero. If Y <i><</i> 0, the result is negative. If X = 0, the absolute value of the result is approximately
<i>/</i>2.
<b>Examples.</b> ATAN2 (1.5574077, 1.0) has the value 1.0 (approximately). If Y has the value
                         ?
                                                                           1 1
                    -1 -1
                            ?
                                              and X
has the value
   ?
   -1 1
   -1 1
      ?
          , the value of ATAN2 (Y, X) is approximately
                   ?
                                                           3<i>/</i>4 <i>/</i>4
                -3<i>/</i>4 -<i>/</i>4
                        ?
                                       .
<b>16.9.23</b> <b>ATAN2D</b> <b>(Y,</b> <b>X)</b>
<b>Description.</b> Arc tangent function in degrees.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
Y shall be of type real.
X shall be of the same type and kind type parameter as Y. If Y has the value zero, X shall not have
     the value zero.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result is expressed in degrees and lies in the range-180 ATAN2D (Y, X) 180. It has
a value equal to a processor-dependent approximation to ATAN2 (Y, X)x180<i>/</i>.
<b>Examples.</b> ATAN2D (1.0, 1.0) has the value 45.0 (approximately). If Y has the value
                        ?
                                                                        1 1
                   -1 -1
                           ?
                                            and X has
the value
  ?
  -1 1
  -1 1
     ?
         , the value of ATAN2D (Y, X) is approximately
                   ?
                                                         135<i>.</i>0 45<i>.</i>0
               -135<i>.</i>0 -45<i>.</i>0
                        ?
                                       .
<b>16.9.24</b> <b>ATAN2PI</b> <b>(Y,</b> <b>X)</b>
<b>Description.</b> Circular arc tangent function.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
Y shall be of type real.
X shall be of the same type and kind type parameter as Y. If Y has the value zero, X shall not have
     the value zero.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result is expressed in half-revolutions and lies in the range-1 ATAN2PI (Y, X) 1. It
has a value equal to a processor-dependent approximation to ATAN2 (Y, X).
<b>Examples.</b> ATAN2PI (1.0, 1.0) has the value 0.25 (approximately). If Y has the value
                        ?
                                                                        1 1
                   -1 -1
                           ?
                                            and X has
the value
  ?
  -1 1
  -1 1
     ?
         , the value of ATAN2PI (Y, X) is approximately
                   ?
                                                         0<i>.</i>75 0<i>.</i>25
               -0<i>.</i>75 -0<i>.</i>25
                        ?
                                      .
<b>16.9.25</b> <b>ATAND</b> <b>(X)</b> <b>or</b> <b>ATAND</b> <b>(Y,</b> <b>X)</b>
<b>Description.</b> Arc tangent function in degrees.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
Y shall be of type real.
X If Y appears, X shall be of type real with the same kind type parameter as Y. If Y has the value
     zero, X shall not have the value zero. If Y does not appear, X shall be of type real.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> If Y appears, the result is the same as the result of ATAN2D (Y, X). If Y does not appear,
the result has a value equal to a processor-dependent approximation to the arc tangent of X; it is expressed in
degrees and lies in the range-90 ATAND (X) 90.
<b>Example.</b> ATAND (1.0) has the value 45.0 (approximately).
<b>16.9.26</b> <b>ATANH</b> <b>(X)</b>
<b>Description.</b> Inverse hyperbolic tangent function.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real or complex.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has a value equal to a processor-dependent approximation to the inverse hyperbolic
tangent function of X. If the result is complex the imaginary part is expressed in radians and lies in the range
-<i>/</i>2 AIMAG (ATANH (X)) <i>/</i>2.
<b>Example.</b> ATANH (0.76159416) has the value 1.0 (approximately).
<b>16.9.27</b> <b>ATANPI</b> <b>(X)</b> <b>or</b> <b>ATANPI</b> <b>(Y,</b> <b>X)</b>
<b>Description.</b> Circular arc tangent function.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
Y shall be of type real.
X If Y appears, X shall be of type real with the same kind type parameter as Y. If Y has the value
     zero, X shall not have the value zero. If Y does not appear, X shall be of type real.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> If Y appears, the result is the same as the result of ATAN2PI (Y, X). If Y does not appear,
the result has a value equal to a processor-dependent approximation to the arc tangent of X; it is expressed in
half-revolutions and lies in the range-0<i>.</i>5 ATANPI (X) 0<i>.</i>5.
<b>Example.</b> ATANPI (1.0) has the value 0.25 (approximately).
<b>16.9.28</b> <b>ATOMIC_ADD</b> <b>(ATOM,</b> <b>VALUE</b> <b>[,</b> <b>STAT])</b>
<b>Description.</b> Atomic addition.
<b>Class.</b> Atomic subroutine.
<b>Arguments.</b>
ATOM shall be a scalar coarray or coindexed object. It shall be of type integer with kind ATOMIC_INT_-
     KIND from the intrinsic module ISO_FORTRAN_ENV. It is an INTENT (INOUT) argument. If
     an error condition occurs, ATOM becomes undefined; otherwise, it becomes defined with the value
     of ATOM + VALUE.
VALUE shall be an integer scalar. It is an INTENT (IN) argument. The values of VALUE and ATOM +
     VALUE shall be representable in kind ATOMIC_INT_KIND.
STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
     INTENT (OUT) argument. It is assigned a value as specified in 16.5. If an error condition occurs
     and STAT is not present, error termination is initiated.
<b>Example.</b> CALL ATOMIC_ADD (I [3], 42) will cause I on image 3 to become defined with the value 46 if the
value of I [3] is 4 when the atomic operation is executed.
<b>16.9.29</b> <b>ATOMIC_AND</b> <b>(ATOM,</b> <b>VALUE</b> <b>[,</b> <b>STAT])</b>
<b>Description.</b> Atomic bitwise AND.
<b>Class.</b> Atomic subroutine.
<b>Arguments.</b>
ATOM shall be a scalar coarray or coindexed object. It shall be of type integer with kind ATOMIC_INT_-
     KIND from the intrinsic module ISO_FORTRAN_ENV. It is an INTENT (INOUT) argument. If
     an error condition occurs, ATOM becomes undefined; otherwise, it becomes defined with the value
     of IAND (ATOM, INT (VALUE, ATOMIC_INT_KIND)).
VALUE shall be an integer scalar. It is an INTENT (IN) argument. The value of VALUE shall be repres-
     entable in kind ATOMIC_INT_KIND.
STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
     INTENT (OUT) argument. It is assigned a value as specified in 16.5. If an error condition occurs
     and STAT is not present, error termination is initiated.
<b>Example.</b> CALL ATOMIC_AND (I [3], 6) will cause I on image 3 to become defined with the value 4 if the
value of I [3] is 5 when the atomic operation is executed.
<b>16.9.30</b> <b>ATOMIC_CAS</b> <b>(ATOM,</b> <b>OLD,</b> <b>COMPARE,</b> <b>NEW</b> <b>[,</b> <b>STAT])</b>
<b>Description.</b> Atomic compare and swap.
<b>Class.</b> Atomic subroutine.
<b>Arguments.</b>
ATOM shall be a scalar coarray or coindexed object. It shall be of type integer with kind ATOMIC_INT_-
     KIND from the intrinsic module ISO_FORTRAN_ENV, or of type logical with kind ATOMIC_-
     LOGICAL_KIND from the intrinsic module ISO_FORTRAN_ENV. It is an INTENT (INOUT)
     argument. If an error condition occurs, ATOM becomes undefined; otherwise, if ATOM is of type
     integerandequaltoCOMPARE,oroftypelogicalandequivalenttoCOMPARE,itbecomesdefined
     with the value of NEW.
OLD shall be scalar and of the same type and kind as ATOM. It is an INTENT (OUT) argument. If
     an error condition occurs, it becomes undefined; otherwise, it becomes defined with the value that
     ATOM had at the start of the atomic operation.
COMPARE shall be scalar and of the same type and kind as ATOM. It is an INTENT (IN) argument.
NEW shall be scalar and of the same type and kind as ATOM. It is an INTENT (IN) argument.
STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
     INTENT (OUT) argument. It is assigned a value as specified in 16.5. If an error condition occurs
     and STAT is not present, error termination is initiated.
<b>Example.</b> If the value of I on image 3 is equal to 13 at the beginning of the atomic operation performed by
CALL ATOMIC_CAS (I [3], OLD, 0, 1), the value of I on image 3 will be unchanged, and OLD will become
defined with the value 13. If the value of I on image 3 is equal to 0 at the beginning of the atomic operation
performed by CALL ATOMIC_CAS (I [3], OLD, 0, 1), I on image 3 will become defined with the value 1, and
OLD will become defined with the value 0.
<b>16.9.31</b> <b>ATOMIC_DEFINE</b> <b>(ATOM,</b> <b>VALUE</b> <b>[,</b> <b>STAT])</b>
<b>Description.</b> Define a variable atomically.
<b>Class.</b> Atomic subroutine.
<b>Arguments.</b>
ATOM shall be a scalar coarray or coindexed object. It shall be of type integer with kind ATOMIC_INT_-
     KIND from the intrinsic module ISO_FORTRAN_ENV, or of type logical with kind ATOMIC_-
     LOGICAL_KIND from the intrinsic module ISO_FORTRAN_ENV. It is an INTENT (OUT)
     argument. On successful execution, it becomes defined with the value of VALUE. If an error
     condition occurs, it becomes undefined.
VALUE shall be scalar and of the same type as ATOM. It is an INTENT (IN) argument.
STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
     INTENT (OUT) argument. It is assigned a value as specified in 16.5. If an error condition occurs
     and STAT is not present, error termination is initiated.
<b>Example.</b> CALL ATOMIC_DEFINE (I [3], 4) causes I on image 3 to become defined with the value 4.
<b>16.9.32</b> <b>ATOMIC_FETCH_ADD</b> <b>(ATOM,</b> <b>VALUE,</b> <b>OLD</b> <b>[,</b> <b>STAT])</b>
<b>Description.</b> Atomic fetch and add.
<b>Class.</b> Atomic subroutine.
<b>Arguments.</b>
ATOM shall be a scalar coarray or coindexed object. It shall be of type integer with kind ATOMIC_INT_-
     KIND from the intrinsic module ISO_FORTRAN_ENV. It is an INTENT (INOUT) argument. If
     an error condition occurs, ATOM becomes undefined; otherwise, it becomes defined with the value
     of ATOM + VALUE.
VALUE shall be an integer scalar. It is an INTENT (IN) argument. The values of VALUE and ATOM +
     VALUE shall be representable in kind ATOMIC_INT_KIND.
OLD shall be scalar and of the same type and kind as ATOM. It is an INTENT (OUT) argument. If
     an error condition occurs, it becomes undefined; otherwise, it becomes defined with the value that
     ATOM had at the start of the atomic operation.
STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
     INTENT (OUT) argument. It is assigned a value as specified in 16.5. If an error condition occurs
     and STAT is not present, error termination is initiated.
<b>Example.</b> CALL ATOMIC_FETCH_ADD (I [3], 7, J) will cause I on image 3 to become defined with the value
12, and J to become defined with the value 5, if the value of I [3] is 5 when the atomic operation is executed.
<b>16.9.33</b> <b>ATOMIC_FETCH_AND</b> <b>(ATOM,</b> <b>VALUE,</b> <b>OLD</b> <b>[,</b> <b>STAT])</b>
<b>Description.</b> Atomic fetch and bitwise AND.
<b>Class.</b> Atomic subroutine.
<b>Arguments.</b>
ATOM shall be a scalar coarray or coindexed object. It shall be of type integer with kind ATOMIC_INT_-
     KIND from the intrinsic module ISO_FORTRAN_ENV. It is an INTENT (INOUT) argument. If
     an error condition occurs, ATOM becomes undefined; otherwise, it becomes defined with the value
     of IAND (ATOM, INT (VALUE, ATOMIC_INT_KIND)).
VALUE shall be an integer scalar. It is an INTENT (IN) argument. The value of VALUE shall be repres-
     entable in kind ATOMIC_INT_KIND.
OLD shall be scalar and of the same type and kind as ATOM. It is an INTENT (OUT) argument. If
     an error condition occurs, it becomes undefined; otherwise, it becomes defined with the value that
     ATOM had at the start of the atomic operation.
STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
     INTENT (OUT) argument. It is assigned a value as specified in 16.5. If an error condition occurs
     and STAT is not present, error termination is initiated.
<b>Example.</b> CALL ATOMIC_FETCH_AND (I [3], 6, J) will cause I on image 3 to become defined with the value
4, and J to become defined with the value 5, if the value of I [3] is 5 when the atomic operation is executed.
<b>16.9.34</b> <b>ATOMIC_FETCH_OR</b> <b>(ATOM,</b> <b>VALUE,</b> <b>OLD</b> <b>[,</b> <b>STAT])</b>
<b>Description.</b> Atomic fetch and bitwise OR.
<b>Class.</b> Atomic subroutine.
<b>Arguments.</b>
ATOM shall be a scalar coarray or coindexed object. It shall be of type integer with kind ATOMIC_INT_-
     KIND from the intrinsic module ISO_FORTRAN_ENV. It is an INTENT (INOUT) argument. If
     an error condition occurs, ATOM becomes undefined; otherwise, it becomes defined with the value
     of IOR (ATOM, INT (VALUE, ATOMIC_INT_KIND)).
VALUE shall be an integer scalar. It is an INTENT (IN) argument. The value of VALUE shall be repres-
     entable in kind ATOMIC_INT_KIND.
OLD shall be scalar and of the same type and kind as ATOM. It is an INTENT (OUT) argument. If
     an error condition occurs, it becomes undefined; otherwise, it becomes defined with the value that
     ATOM had at the start of the atomic operation.
STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
     INTENT (OUT) argument. It is assigned a value as specified in 16.5. If an error condition occurs
     and STAT is not present, error termination is initiated.
<b>Example.</b> CALL ATOMIC_FETCH_OR (I [3], 1, J) will cause I on image 3 to become defined with the value
3, and J to become defined with the value 2, if the value of I [3] is 2 when the atomic operation is executed.
<b>16.9.35</b> <b>ATOMIC_FETCH_XOR</b> <b>(ATOM,</b> <b>VALUE,</b> <b>OLD</b> <b>[,</b> <b>STAT])</b>
<b>Description.</b> Atomic fetch and bitwise exclusive OR.
<b>Class.</b> Atomic subroutine.
<b>Arguments.</b>
ATOM shall be a scalar coarray or coindexed object. It shall be of type integer with kind ATOMIC_INT_-
     KIND from the intrinsic module ISO_FORTRAN_ENV. It is an INTENT (INOUT) argument. If
     an error condition occurs, ATOM becomes undefined; otherwise, it becomes defined with the value
     of IEOR (ATOM, INT (VALUE, ATOMIC_INT_KIND)).
VALUE shall be an integer scalar. It is an INTENT (IN) argument. The value of VALUE shall be repres-
     entable in kind ATOMIC_INT_KIND.
OLD shall be scalar and of the same type and kind as ATOM. It is an INTENT (OUT) argument. If
     an error condition occurs, it becomes undefined; otherwise, it becomes defined with the value that
     ATOM had at the start of the atomic operation.
STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
     INTENT (OUT) argument. It is assigned a value as specified in 16.5. If an error condition occurs
     and STAT is not present, error termination is initiated.
<b>Example.</b> CALL ATOMIC_FETCH_XOR (I [3], 1, J) will cause I on image 3 to become defined with the value
2, and J to become defined with the value 3, if the value of I [3] is 3 when the atomic operation is executed.
<b>16.9.36</b> <b>ATOMIC_OR</b> <b>(ATOM,</b> <b>VALUE</b> <b>[,</b> <b>STAT])</b>
<b>Description.</b> Atomic bitwise OR.
<b>Class.</b> Atomic subroutine.
<b>Arguments.</b>
ATOM shall be a scalar coarray or coindexed object. It shall be of type integer with kind ATOMIC_INT_-
     KIND from the intrinsic module ISO_FORTRAN_ENV. It is an INTENT (INOUT) argument. If
     an error condition occurs, ATOM becomes undefined; otherwise, it becomes defined with the value
     of IOR (ATOM, INT (VALUE, ATOMIC_INT_KIND)).
VALUE shall be an integer scalar. It is an INTENT (IN) argument. The value of VALUE shall be repres-
     entable in kind ATOMIC_INT_KIND.
STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
     INTENT (OUT) argument. It is assigned a value as specified in 16.5. If an error condition occurs
     and STAT is not present, error termination is initiated.
<b>Example.</b> CALL ATOMIC_OR (I [3], 1) will cause I on image 3 to become defined with the value 3 if the value
of I [3] is 2 when the atomic operation is executed.
<b>16.9.37</b> <b>ATOMIC_REF</b> <b>(VALUE,</b> <b>ATOM</b> <b>[,</b> <b>STAT])</b>
<b>Description.</b> Reference a variable atomically.
<b>Class.</b> Atomic subroutine.
<b>Arguments.</b>
VALUE shall be scalar and of the same type as ATOM. It is an INTENT (OUT) argument. On successful
     execution, it becomes defined with the value of ATOM. If an error condition occurs, it becomes
     undefined.
ATOM shall be a scalar coarray or coindexed object. It shall be of type integer with kind ATOMIC_INT_-
     KINDfromtheintrinsicmoduleISO_FORTRAN_ENV,oroftypelogicalwithkindATOMIC_LO-
     GICAL_KIND from the intrinsic module ISO_FORTRAN_ENV. It is an INTENT (IN) argument.
STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
     INTENT (OUT) argument. It is assigned a value as specified in 16.5. If an error condition occurs
     and STAT is not present, error termination is initiated.
<b>Example.</b> CALL ATOMIC_REF (VAL, I [3]) causes VAL to become defined with the value of I on image 3.
<b>16.9.38</b> <b>ATOMIC_XOR</b> <b>(ATOM,</b> <b>VALUE</b> <b>[,</b> <b>STAT])</b>
<b>Description.</b> Atomic bitwise exclusive OR.
<b>Class.</b> Atomic subroutine.
<b>Arguments.</b>
ATOM shall be a scalar coarray or coindexed object. It shall be of type integer with kind ATOMIC_INT_-
     KIND from the intrinsic module ISO_FORTRAN_ENV. It is an INTENT (INOUT) argument. If
     an error condition occurs, ATOM becomes undefined; otherwise, it becomes defined with the value
     of IEOR (ATOM, INT (VALUE, ATOMIC_INT_KIND)).
VALUE shall be an integer scalar. It is an INTENT (IN) argument. The value of VALUE shall be repres-
     entable in kind ATOMIC_INT_KIND.
STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
     INTENT (OUT) argument. It is assigned a value as specified in 16.5. If an error condition occurs
     and STAT is not present, error termination is initiated.
<b>Example.</b> CALL ATOMIC_XOR (I [3], 1) will cause I on image 3 to become defined with the value 2 if the
value of I [3] is 3 when the atomic operation is executed.
<b>16.9.39</b> <b>BESSEL_J0</b> <b>(X)</b>
<b>Description.</b> Bessel function of the 1
                 <i>st</i>
                 kind, order 0.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has a value equal to a processor-dependent approximation to the Bessel function of
the first kind and order zero of X.
<b>Example.</b> BESSEL_J0 (1.0) has the value 0.765 (approximately).
<b>16.9.40</b> <b>BESSEL_J1</b> <b>(X)</b>
<b>Description.</b> Bessel function of the 1
                 <i>st</i>
                 kind, order 1.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has a value equal to a processor-dependent approximation to the Bessel function of
the first kind and order one of X.
<b>Example.</b> BESSEL_J1 (1.0) has the value 0.440 (approximately).
<b>16.9.41</b> <b>BESSEL_JN</b> <b>(N,</b> <b>X)</b> <b>or</b> <b>BESSEL_JN</b> <b>(N1,</b> <b>N2,</b> <b>X)</b>
<b>Description.</b> Bessel functions of the 1
                  <i>st</i>
                  kind.
<b>Class.</b>
<i>Case</i> <i>(i):</i> BESSEL_JN (N,X) is an elemental function.
<i>Case</i> <i>(ii):</i> BESSEL_JN (N1,N2,X) is a transformational function.
<b>Arguments.</b>
N shall be of type integer and nonnegative.
N1 shall be an integer scalar with a nonnegative value.
N2 shall be an integer scalar with a nonnegative value.
X shall be of type real; if the function is transformational, X shall be scalar.
<b>Result</b> <b>Characteristics.</b> Same type and kind as X. The result of BESSEL_JN (N1, N2, X) is a rank-one array
with extent MAX (N2-N1+1, 0).
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> The result value of BESSEL_JN (N, X) is a processor-dependent approximation to the Bessel
     function of the first kind and order N of X.
<i>Case</i> <i>(ii):</i> Element <i>i</i> of the result value of BESSEL_JN (N1, N2, X) is a processor-dependent approximation
     to the Bessel function of the first kind and order N1+<i>i</i>- 1 of X.
<b>Example.</b> BESSEL_JN (2, 1.0) has the value 0.115 (approximately).
<b>16.9.42</b> <b>BESSEL_Y0</b> <b>(X)</b>
<b>Description.</b> Bessel function of the 2
                 <i>nd</i>
                  kind, order 0.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real. Its value shall be greater than zero.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has a value equal to a processor-dependent approximation to the Bessel function of
the second kind and order zero of X.
<b>Example.</b> BESSEL_Y0 (1.0) has the value 0.088 (approximately).
<b>16.9.43</b> <b>BESSEL_Y1</b> <b>(X)</b>
<b>Description.</b> Bessel function of the 2
                 <i>nd</i>
                  kind, order 1.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real. Its value shall be greater than zero.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has a value equal to a processor-dependent approximation to the Bessel function of
the second kind and order one of X.
<b>Example.</b> BESSEL_Y1 (1.0) has the value-0.781 (approximately).
<b>16.9.44</b> <b>BESSEL_YN</b> <b>(N,</b> <b>X)</b> <b>or</b> <b>BESSEL_YN</b> <b>(N1,</b> <b>N2,</b> <b>X)</b>
<b>Description.</b> Bessel functions of the 2
                  <i>nd</i>
                  kind.
<b>Class.</b>
<i>Case</i> <i>(i):</i> BESSEL_YN (N, X) is an elemental function.
<i>Case</i> <i>(ii):</i> BESSEL_YN (N1, N2, X) is a transformational function.
<b>Arguments.</b>
N shall be of type integer and nonnegative.
N1 shall be an integer scalar with a nonnegative value.
N2 shall be an integer scalar with a nonnegative value.
X shall be of type real; if the function is transformational, X shall be scalar. Its value shall be greater
     than zero.
<b>Result</b> <b>Characteristics.</b> Same type and kind as X. The result of BESSEL_YN (N1, N2, X) is a rank-one array
with extent MAX (N2-N1+1, 0).
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> The result value of BESSEL_YN (N, X) is a processor-dependent approximation to the Bessel
     function of the second kind and order N of X.
<i>Case</i> <i>(ii):</i> Element <i>i</i> of the result value of BESSEL_YN (N1, N2, X) is a processor-dependent approximation
     to the Bessel function of the second kind and order N1+<i>i</i>- 1 of X.
<b>Example.</b> BESSEL_YN (2, 1.0) has the value-1.651 (approximately).
<b>16.9.45</b> <b>BGE</b> <b>(I,</b> <b>J)</b>
<b>Description.</b> Bitwise greater than or equal to.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
I shall be of type integer or a <i>boz-literal-constant</i>.
J shall be of type integer or a <i>boz-literal-constant</i>.
<b>Result</b> <b>Characteristics.</b> Default logical.
<b>Result</b> <b>Value.</b> The result is true if the sequence of bits represented by I is greater than or equal to the sequence
of bits represented by J, according to the method of bit sequence comparison in 16.3.2; otherwise the result is
false.
The interpretation of a <i>boz-literal-constant</i> as a sequence of bits is described in 7.7. The interpretation of an
integer value as a sequence of bits is described in 16.3.
<b>Example.</b> If BIT_SIZE (J) has the value 8, BGE (Z'FF', J) has the value true for any value of J. BGE (0,-1)
has the value false.
<b>16.9.46</b> <b>BGT</b> <b>(I,</b> <b>J)</b>
<b>Description.</b> Bitwise greater than.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
I shall be of type integer or a <i>boz-literal-constant</i>.
J shall be of type integer or a <i>boz-literal-constant</i>.
<b>Result</b> <b>Characteristics.</b> Default logical.
<b>Result</b> <b>Value.</b> The result is true if the sequence of bits represented by I is greater than the sequence of bits
represented by J, according to the method of bit sequence comparison in 16.3.2; otherwise the result is false.
The interpretation of a <i>boz-literal-constant</i> as a sequence of bits is described in 7.7. The interpretation of an
integer value as a sequence of bits is described in 16.3.
<b>Example.</b> BGT (Z'FF', Z'FC') has the value true. BGT (0,-1) has the value false.
<b>16.9.47</b> <b>BIT_SIZE</b> <b>(I)</b>
<b>Description.</b> Number of bits in integer model 16.3.
<b>Class.</b> Inquiry function.
<b>Argument.</b> I shall be of type integer. It may be a scalar or an array.
<b>Result</b> <b>Characteristics.</b> Scalar integer with the same kind type parameter as I.
<b>Result</b> <b>Value.</b> The result has the value of the number of bits <i>z</i> of the model integer defined for bit manipulation
contexts in 16.3.
<b>Example.</b> BIT_SIZE (1) has the value 32 if <i>z</i> of the model is 32.
<b>16.9.48</b> <b>BLE</b> <b>(I,</b> <b>J)</b>
<b>Description.</b> Bitwise less than or equal to.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
I shall be of type integer or a <i>boz-literal-constant</i>.
J shall be of type integer or a <i>boz-literal-constant</i>.
<b>Result</b> <b>Characteristics.</b> Default logical.
<b>Result</b> <b>Value.</b> The result is true if the sequence of bits represented by I is less than or equal to the sequence of
bits represented by J, according to the method of bit sequence comparison in 16.3.2; otherwise the result is false.
The interpretation of a <i>boz-literal-constant</i> as a sequence of bits is described in 7.7. The interpretation of an
integer value as a sequence of bits is described in 16.3.
<b>Example.</b> BLE (0, J) has the value true for any value of J. BLE (-1, 0) has the value false.
<b>16.9.49</b> <b>BLT</b> <b>(I,</b> <b>J)</b>
<b>Description.</b> Bitwise less than.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
I shall be of type integer or a <i>boz-literal-constant</i>.
J shall be of type integer or a <i>boz-literal-constant</i>.
<b>Result</b> <b>Characteristics.</b> Default logical.
<b>Result</b> <b>Value.</b> The result is true if the sequence of bits represented by I is less than the sequence of bits
represented by J, according to the method of bit sequence comparison in 16.3.2; otherwise the result is false.
The interpretation of a <i>boz-literal-constant</i> as a sequence of bits is described in 7.7. The interpretation of an
integer value as a sequence of bits is described in 16.3.
<b>Example.</b> BLT (0,-1) has the value true. BLT (Z'FF', Z'FC') has the value false.
<b>16.9.50</b> <b>BTEST</b> <b>(I,</b> <b>POS)</b>
<b>Description.</b> Test single bit in an integer.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
I shall be of type integer.
POS shall be of type integer. It shall be nonnegative and be less than BIT_SIZE (I).
<b>Result</b> <b>Characteristics.</b> Default logical.
<b>Result</b> <b>Value.</b> The result has the value true if bit POS of I has the value 1 and has the value false if bit POS
of I has the value 0. The model for the interpretation of an integer value as a sequence of bits is in 16.3.
<b>Examples.</b> BTEST (8, 3) has the value true. If A has the value
                   ?
                                                         1 2
                                                         3 4
                     ?
                                  , the value of BTEST (A, 2) is
?
 false false
 false true
    ?
       and the value of BTEST (2, A) is
              ?
                       true false
                       false false
                  ?
                             .
<b>16.9.51</b> <b>CEILING</b> <b>(A</b> <b>[,</b> <b>KIND])</b>
<b>Description.</b> Least integer greater than or equal to A.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
A shall be of type real.
KIND (optional) shall be a scalar integer constant expression.
<b>Result</b> <b>Characteristics.</b> Integer. If KIND is present, the kind type parameter is that specified by the value of
KIND; otherwise, the kind type parameter is that of default integer type.
<b>Result</b> <b>Value.</b> The result has a value equal to the least integer greater than or equal to A.
<b>Examples.</b> CEILING (3.7) has the value 4. CEILING (-3.7) has the value-3.
<b>16.9.52</b> <b>CHAR</b> <b>(I</b> <b>[,</b> <b>KIND])</b>
<b>Description.</b> Character from code value.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
I shall be of type integer with a value in the range 0 I<i>n</i>- 1, where <i>n</i> is the number of characters
     in the collating sequence associated with the specified kind type parameter.
KIND (optional) shall be a scalar integer constant expression.
<b>Result</b> <b>Characteristics.</b> Character of length one. If KIND is present, the kind type parameter is that specified
by the value of KIND; otherwise, the kind type parameter is that of default character.
<b>Result</b> <b>Value.</b> The result is the character in position I of the collating sequence associated with the spe-
cified kind type parameter. ICHAR (CHAR (I, KIND (C))) shall have the value I for 0  I  <i>n</i>- 1 and
CHAR (ICHAR (C), KIND (C)) shall have the value C for any character C capable of representation in the
processor.
<b>Example.</b> CHAR (88) has the value 'X' on a processor using the ASCII collating sequence for default characters.
<b>16.9.53</b> <b>CMPLX</b> <b>(X</b> <b>[,</b> <b>KIND])</b> <b>or</b> <b>CMPLX</b> <b>(X</b> <b>[,</b> <b>Y,</b> <b>KIND])</b>
<b>Description.</b> Conversion to complex type.
<b>Class.</b> Elemental function.
<b>Arguments</b> <b>for</b> <b>CMPLX(X</b> <b>[,</b> <b>KIND]).</b>
X shall be of type complex.
KIND (optional) shall be a scalar integer constant expression.
<b>Arguments</b> <b>for</b> <b>CMPLX(X</b> <b>[,</b> <b>Y,</b> <b>KIND]).</b>
X shall be of type integer or real, or a <i>boz-literal-constant</i>.
Y (optional) shall be of type integer or real, or a <i>boz-literal-constant</i>.
KIND (optional) shall be a scalar integer constant expression.
<b>Result</b> <b>Characteristics.</b> The result is of type complex. If KIND is present, the kind type parameter is that
specified by the value of KIND; otherwise, the kind type parameter is that of default real kind.
<b>Result</b> <b>Value.</b> If Y is absent and X is not complex, it is as if Y were present with the value zero. If KIND is
absent, it is as if KIND were present with the value KIND (0.0). If X is complex, the result is the same as that
of CMPLX (REAL (X), AIMAG (X), KIND). The result of CMPLX (X, Y, KIND) has the complex value whose
real part is REAL (X, KIND) and whose imaginary part is REAL (Y, KIND).
<b>Example.</b> CMPLX (-3) has the value (-3.0, 0.0).
<b>16.9.54</b> <b>CO_BROADCAST</b> <b>(A,</b> <b>SOURCE_IMAGE</b> <b>[,</b> <b>STAT,</b> <b>ERRMSG])</b>
<b>Description.</b> Broadcast value to images.
<b>Class.</b> Collective subroutine.
<b>Arguments.</b>
A shall have the same shape, type, and type parameter values, in corresponding references. It shall not
     be polymorphic or a coindexed object. It is an INTENT (INOUT) argument. If no error condition
     occurs, A becomes defined, as if by intrinsic assignment, on all images in the current team with the
     value of A on image SOURCE_IMAGE, including (re)allocation of any allocatable potential subob-
     ject component, and setting the dynamic type of any polymorphic allocatable potential subobject
     component.
SOURCE_IMAGE shall be an integer scalar. It is an INTENT (IN) argument. Its value shall be that of an
     image index of an image in the current team. The value shall be the same in all corresponding
     references.
STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
     INTENT (OUT) argument.
ERRMSG (optional) shall be a noncoindexed default character scalar. It is an INTENT (INOUT) argument.
The semantics of STAT and ERRMSG are described in 16.6.
<b>Example.</b> If A is the array [1, 5, 3] on image one, after execution of
   CALL CO_BROADCAST (A, 1)
the value of A on all images of the current team is [1, 5, 3].
<b>16.9.55</b> <b>CO_MAX</b> <b>(A</b> <b>[,</b> <b>RESULT_IMAGE,</b> <b>STAT,</b> <b>ERRMSG])</b>
<b>Description.</b> Compute maximum value across images.
<b>Class.</b> Collective subroutine.
<b>Arguments.</b>
A shall be of type integer, real, or character. It shall have the same shape, type, and type parameter
     values, in corresponding references. It shall not be a coindexed object. It is an INTENT (INOUT)
     argument. Ifitisscalar, thecomputedvalueisequaltothemaximumvalueofAinallcorresponding
     references. If it is an array each element of the computed value is equal to the maximum value of
     all corresponding elements of A in all corresponding references.
     The computed value is assigned to A if no error condition occurs, and either RESULT_IMAGE is
     absent, or the executing image is the one identified by RESULT_IMAGE. Otherwise, A becomes
     undefined.
RESULT_IMAGE (optional) shall be an integer scalar. It is an INTENT (IN) argument. Its presence, and value
     if present, shall be the same in all corresponding references. If it is present, its value shall be that
     of an image index in the current team.
STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
     INTENT (OUT) argument.
ERRMSG (optional) shall be a noncoindexed default character scalar. It is an INTENT (INOUT) argument.
The semantics of STAT and ERRMSG are described in 16.6.
<b>Example.</b> If the number of images in the current team is two and A is the array [1, 5, 3] on one image and [4,
1, 6] on the other image, the value of A after executing the statement CALL CO_MAX (A) is [4, 5, 6] on both
images.
<b>16.9.56</b> <b>CO_MIN</b> <b>(A</b> <b>[,</b> <b>RESULT_IMAGE,</b> <b>STAT,</b> <b>ERRMSG])</b>
<b>Description.</b> Compute minimum value across images.
<b>Class.</b> Collective subroutine.
<b>Arguments.</b>
A shall be of type integer, real, or character. It shall have the same shape, type, and type parameter
     values, in corresponding references. It shall not be a coindexed object. It is an INTENT (INOUT)
     argument. If it is scalar, the computed value is equal to the minimum value of A in all corresponding
     references. If it is an array each element of the computed value is equal to the minimum value of
     all corresponding elements of A in all corresponding references.
     The computed value is assigned to A if no error condition occurs, and either RESULT_IMAGE is
     absent, or the executing image is the one identified by RESULT_IMAGE. Otherwise, A becomes
     undefined.
RESULT_IMAGE (optional) shall be an integer scalar. It is an INTENT (IN) argument. Its presence, and value
     if present, shall be the same in all corresponding references. If it is present, its value shall be that
     of an image index in the current team.
STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
     INTENT (OUT) argument.
ERRMSG (optional) shall be a noncoindexed default character scalar. It is an INTENT (INOUT) argument.
The semantics of STAT and ERRMSG are described in 16.6.
<b>Example.</b> If the number of images in the current team is two and A is the array [1, 5, 3] on one image and [4,
1, 6] on the other image, the value of A after executing the statement CALL CO_MIN (A) is [1, 1, 3] on both
images.
<b>16.9.57</b> <b>CO_REDUCE</b> <b>(A,</b> <b>OPERATION</b> <b>[,</b> <b>RESULT_IMAGE,</b> <b>STAT,</b> <b>ERRMSG])</b>
<b>Description.</b> Generalized reduction across images.
<b>Class.</b> Collective subroutine.
<b>Arguments.</b>
A shall not be polymorphic. It shall not be of a type with an ultimate component that is allocatable
     or a pointer. It shall have the same shape, type, and type parameter values, in corresponding
     references. It shall not be a coindexed object. It is an INTENT (INOUT) argument. If A is scalar,
     the computed value is the result of the reduction operation of applying OPERATION to the values
     of A in all corresponding references. If A is an array, each element of the computed value is equal
     to the result of the reduction operation of applying OPERATION to corresponding elements of A
     in all corresponding references.
     The computed value is assigned to A if no error condition occurs, and either RESULT_IMAGE is
     absent, or the executing image is the one identified by RESULT_IMAGE. Otherwise, A becomes
     undefined.
OPERATION shallbeapurefunctionwithexactlytwoarguments; theresultandeachargumentshallbeascalar,
     nonallocatable, noncoarray, nonpointer, nonpolymorphic data object with the same type and type
     parameters as A. The arguments shall not be optional. If one argument has the ASYNCHRONOUS,
     TARGET, or VALUE attribute, the other shall have that attribute. OPERATION shall implement
     a mathematically associative operation. OPERATION shall be the same function on all images in
     corresponding references.
     The computed value of a reduction operation over a set of values is the result of an iterative process.
     Each iteration involves the evaluation of OPERATION (<i>x</i>, <i>y</i>) for <i>x</i> and <i>y</i> in the set, the removal of
    <i>x</i> and <i>y</i> from the set, and the addition of the value of OPERATION (<i>x</i>, <i>y</i>) to the set. The process
     terminates when the set has only one element; this is the computed value.
RESULT_IMAGE (optional) shall be an integer scalar. It is an INTENT (IN) argument. Its presence, and value
     if present, shall be the same in all corresponding references. If it is present, its value shall be that
     of an image index in the current team.
STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
     INTENT (OUT) argument.
ERRMSG (optional) shall be a noncoindexed default character scalar. It is an INTENT (INOUT) argument.
The semantics of STAT and ERRMSG are described in 16.6.
<b>Example.</b> The subroutine below demonstrates how to use CO_REDUCE to create a collective counterpart to
the intrinsic function ALL:
   SUBROUTINE co_all(boolean)
    LOGICAL, INTENT(INOUT) :: boolean
    CALL CO_REDUCE(boolean,both)
   CONTAINS
    PURE FUNCTION both(lhs,rhs) RESULT(lhs_and_rhs)
     LOGICAL, INTENT(IN) :: lhs,rhs
     LOGICAL :: lhs_and_rhs
     lhs_and_rhs = lhs .AND. rhs
    END FUNCTION both
   END SUBROUTINE co_all
<b>NOTE</b>
If the OPERATION function is not mathematically commutative, the result of calling CO_REDUCE can
depend on the order of evaluations.
<b>16.9.58</b> <b>CO_SUM</b> <b>(A</b> <b>[,</b> <b>RESULT_IMAGE,</b> <b>STAT,</b> <b>ERRMSG])</b>
<b>Description.</b> Compute sum across images.
<b>Class.</b> Collective subroutine.
<b>Arguments.</b>
A shall be of numeric type. It shall have the same shape, type, and type parameter values, in cor-
     responding references. It shall not be a coindexed object. It is an INTENT (INOUT) argument.
     If it is scalar, the computed value is equal to a processor-dependent approximation to the sum of
     the values of A in corresponding references. If it is an array, each element of the computed value
     is equal to a processor-dependent approximation to the sum of all corresponding elements of A in
     corresponding references.
     The computed value is assigned to A if no error condition occurs, and either RESULT_IMAGE is
     absent, or the executing image is the one identified by RESULT_IMAGE. Otherwise, A becomes
     undefined.
RESULT_IMAGE (optional) shall be an integer scalar. It is an INTENT (IN) argument. Its presence, and value
     if present, shall be the same in all corresponding references. If it is present, its value shall be that
     of an image index in the current team.
STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
     INTENT (OUT) argument.
ERRMSG (optional) shall be a noncoindexed default character scalar. It is an INTENT (INOUT) argument.
The semantics of STAT and ERRMSG are described in 16.6.
<b>Example.</b> If the number of images in the current team is two and A is the array [1, 5, 3] on one image and [4,
1, 6] on the other image, the value of A after executing the statement CALL CO_SUM(A) is [5, 6, 9] on both
images.
<b>16.9.59</b> <b>COMMAND_ARGUMENT_COUNT</b> <b>(</b> <b>)</b>
<b>Description.</b> Number of command arguments.
<b>Class.</b> Transformational function.
<b>Argument.</b> None.
<b>Result</b> <b>Characteristics.</b> Default integer scalar.
<b>Result</b> <b>Value.</b> The result value is equal to the number of command arguments available. If there are no
command arguments available or if the processor does not support command arguments, then the result has the
value zero. If the processor has a concept of a command name, the command name does not count as one of the
command arguments.
<b>Example.</b> See 16.9.93.
<b>16.9.60</b> <b>CONJG</b> <b>(Z)</b>
<b>Description.</b> Conjugate of a complex number.
<b>Class.</b> Elemental function.
<b>Argument.</b> Z shall be of type complex.
<b>Result</b> <b>Characteristics.</b> Same as Z.
<b>Result</b> <b>Value.</b> If Z has the value (<i>x,y</i>), the result has the value (<i>x,</i>-<i>y</i>).
<b>Example.</b> CONJG ((2.0, 3.0)) has the value (2.0,-3.0).
<b>16.9.61</b> <b>COS</b> <b>(X)</b>
<b>Description.</b> Cosine function.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real or complex.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has a value equal to a processor-dependent approximation to cos(X). If X is of type
real, it is regarded as a value in radians. If X is of type complex, its real part is regarded as a value in radians.
<b>Example.</b> COS (1.0) has the value 0.54030231 (approximately).
<b>16.9.62</b> <b>COSD</b> <b>(X)</b>
<b>Description.</b> Degree cosine function.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has a value equal to a processor-dependent approximation to the cosine of X, which
is regarded as a value in degrees.
<b>Example.</b> COSD (180.0) has the value-1<i>.</i>0 (approximately).
<b>16.9.63</b> <b>COSH</b> <b>(X)</b>
<b>Description.</b> Hyperbolic cosine function.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real or complex.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has a value equal to a processor-dependent approximation to cosh(X). If X is of type
complex its imaginary part is regarded as a value in radians.
<b>Example.</b> COSH (1.0) has the value 1.5430806 (approximately).
<b>16.9.64</b> <b>COSHAPE</b> <b>(COARRAY</b> <b>[,</b> <b>KIND])</b>
<b>Description.</b> Sizes of codimensions of a coarray.
<b>Class.</b> Inquiry function.
<b>Arguments.</b>
COARRAY shall be a coarray of any type. It shall not be an unallocated allocatable coarray. If its <i>designator</i>
     has more than one <i>part-ref</i>, the rightmost <i>part-ref</i> shall have nonzero corank.
KIND (optional) shall be a scalar integer constant expression.
<b>Result</b> <b>Characteristics.</b> Integer. If KIND is present, the kind type parameter is that specified by the value
of KIND; otherwise the kind type parameter is that of default integer type. The result is an array of rank one
whose size is equal to the corank of COARRAY.
<b>Result</b> <b>Value.</b> The result has a value whose<i>i</i>
                     <i>th</i>
                     element is equal to the size of the<i>i</i>
                                      <i>th</i>
                                     codimension of COARRAY,
as given by UCOBOUND (COARRAY, <i>i</i>)- LCOBOUND (COARRAY, <i>i</i>) +1.
<b>Example.</b>
The following code allocates the coarray D with the same size in each codimension as that of the coarray C, with
the lower cobound 1.
 REAL, ALLOCATABLE :: C[:,:], D[:,:]
 INTEGER, ALLOCATABLE :: COSHAPE_C(:)
 ...
 COSHAPE_C = COSHAPE(C)
 ALLOCATE ( D[COSHAPE_C(1),*] )
<b>16.9.65</b> <b>COSPI</b> <b>(X)</b>
<b>Description.</b> Circular cosine function.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has a value equal to a processor-dependent approximation to the cosine of X, which
is regarded as a value in half-revolutions; thus COSPI (X) is approximately equal to COS (Xx).
<b>Example.</b> COSPI (1.0) has the value-1<i>.</i>0 (approximately).
<b>16.9.66</b> <b>COUNT</b> <b>(MASK</b> <b>[,</b> <b>DIM,</b> <b>KIND])</b>
<b>Description.</b> Array reduced by counting true values.
<b>Class.</b> Transformational function.
<b>Arguments.</b>
MASK shall be a logical array.
DIM (optional) shall be an integer scalar with a value in the range 1 DIM<i>n</i>, where <i>n</i> is the rank of MASK.
     The corresponding actual argument shall not be an optional dummy argument, a disassociated
     pointer, or an unallocated allocatable.
KIND (optional) shall be a scalar integer constant expression.
<b>Result</b> <b>Characteristics.</b> Integer. If KIND is present, the kind type parameter is that specified by the value of
KIND; otherwise the kind type parameter is that of default integer type. The result is scalar if DIM is absent or
<i>n</i> = 1; otherwise, the result has rank <i>n</i>- 1 and shape [<i>d</i>
                           1
                        ,<i>d</i>
                             2
                          , ...,<i>d</i>
                               DIM-1
                               ,<i>d</i>
                                   DIM+1
                                   , ...,<i>d</i>
                                        <i>n</i>
                                       ] where [<i>d</i>
                                                 1
                                           ,<i>d</i>
                                                   2
                                             , ...,<i>d</i>
                                                   <i>n</i>
                                                ]
is the shape of MASK.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> If DIM is absent or MASK has rank one, the result has a value equal to the number of true elements
     of MASK or has the value zero if MASK has size zero.
<i>Case</i> <i>(ii):</i> If DIM is present and MASK has rank <i>n></i> 1, the value of element (<i>s</i>
                                         1
                                    ,<i>s</i>
                                          2
                                     , ..., <i>s</i>
                                            DIM-1
                                           ,<i>s</i>
                                                DIM+1
                                              , ...,
    <i>s</i>
      <i>n</i>
      ) of the result is equal to the number of true elements of MASK (<i>s</i>
                                          1
                                    , <i>s</i>
                                           2
                                      , ..., <i>s</i>
                                             DIM-1
                                            , :, <i>s</i>
                                                  DIM+1
                                                ,
     ..., <i>s</i>
        <i>n</i>
        ).
<b>Examples.</b>
<i>Case</i> <i>(i):</i> The value of COUNT ([.TRUE., .FALSE., .TRUE.]) is 2.
<i>Case</i> <i>(ii):</i> If B is the array
        ?
                          1 3 5
                          2 4 6
           ?
                   and C is the array
                  ?
                                                     0 3 5
                                                     7 4 8
                     ?
                                  , COUNT (B /= C, DIM = 1) is
     [2, 0, 1] and COUNT (B /= C, DIM = 2) is [1, 2].
<b>16.9.67</b> <b>CPU_TIME</b> <b>(TIME)</b>
<b>Description.</b> Processor time used.
<b>Class.</b> Subroutine.
<b>Argument.</b> TIME shall be a real scalar. It is an INTENT (OUT) argument. If the processor cannot provide
a meaningful value for the time, it is assigned a processor-dependent negative value; otherwise, it is assigned a
processor-dependent approximation to the processor time in seconds. Whether the value assigned is an approx-
imation to the amount of time used by the invoking image, or the amount of time used by the whole program, is
processor dependent.
<b>Example.</b>
    REAL T1, T2
    ...
    CALL CPU_TIME(T1)
    ... <i>Code</i> <i>to</i> <i>be</i> <i>timed.</i>
    CALL CPU_TIME(T2)
    WRITE (*,*) 'Time taken by code was ', T2-T1, ' seconds'
writes the processor time taken by a piece of code.
<b>NOTE</b>
A processor for which a single result is inadequate (for example, a parallel processor) might choose to provide
an additional version for which time is an array.
The exact definition of time is left imprecise because of the variability in what different processors are able to
provide. The primary purpose is to compare different algorithms on the same processor or discover which parts
of a calculation are the most expensive.
The start time is left imprecise because the purpose is to time sections of code, as in the example.
Most computer systems have multiple concepts of time. One common concept is that of time expended by the
processor for a given program. This might or might not include system overhead, and has no obvious connection
to elapsed "wall clock" time.
<b>16.9.68</b> <b>CSHIFT</b> <b>(ARRAY,</b> <b>SHIFT</b> <b>[,</b> <b>DIM])</b>
<b>Description.</b> Circular shift of an array.
<b>Class.</b> Transformational function.
<b>Arguments.</b>
ARRAY may be of any type. It shall be an array.
SHIFT shall be of type integer and shall be scalar if ARRAY has rank one; otherwise, it shall be scalar or
     of rank <i>n</i>- 1 and of shape [<i>d</i>
                     1
                  , <i>d</i>
                       2
                    , ..., <i>d</i>
                         DIM-1
                          , <i>d</i>
                             DIM+1
                              , ..., <i>d</i>
                                  <i>n</i>
                                 ] where [<i>d</i>
                                           1
                                      , <i>d</i>
                                             2
                                       , ..., <i>d</i>
                                             <i>n</i>
                                           ] is the shape
     of ARRAY.
DIM (optional) shall be an integer scalar with a value in the range 1 DIM<i>n</i>, where<i>n</i> is the rank of ARRAY.
     If DIM is absent, it is as if it were present with the value 1.
<b>Result</b> <b>Characteristics.</b> The result is of the type and type parameters of ARRAY, and has the shape of
ARRAY.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> IfARRAYhasrankone, element<i>i</i>oftheresultisARRAY(LBOUND(ARRAY,1)+MODULO(<i>i</i>+
     SHIFT- 1, SIZE (ARRAY))).
<i>Case</i> <i>(ii):</i> If ARRAY has rank greater than one, section (<i>s</i>
                               1
                           , <i>s</i>
                                 2
                             , ..., <i>s</i>
                                   DIM-1
                                  , :, <i>s</i>
                                        DIM+1
                                       , ..., <i>s</i>
                                             <i>n</i>
                                           ) of the result
     has a value equal to CSHIFT (ARRAY (<i>s</i>
                            1
                        , <i>s</i>
                             2
                          , ..., <i>s</i>
                                DIM-1
                                , :, <i>s</i>
                                     DIM+1
                                    , ..., <i>s</i>
                                         <i>n</i>
                                        ), <i>sh</i>, 1), where <i>sh</i> is
     SHIFT or SHIFT (<i>s</i>
                 1
               , <i>s</i>
                  2
                , ..., <i>s</i>
                     DIM-1
                      , <i>s</i>
                         DIM+1
                          , ..., <i>s</i>
                              <i>n</i>
                             ).
<b>Examples.</b>
<i>Case</i> <i>(i):</i> If V is the array [1, 2, 3, 4, 5, 6], the effect of shifting V circularly to the left by two positions is
     achieved by CSHIFT (V, SHIFT = 2) which has the value [3, 4, 5, 6, 1, 2]; CSHIFT (V, SHIFT =
  -2) achieves a circular shift to the right by two positions and has the value [5, 6, 1, 2, 3, 4].
<i>Case</i> <i>(ii):</i> The rows of an array of rank two may all be shifted by the same amount or by different amounts.
     If M is the array
        ?
        ?
                          1 2 3
                          4 5 6
                          7 8 9
           ?
           ?
                   , the value of
     CSHIFT (M, SHIFT =-1, DIM = 2) is
               ?
               ?
                                             3 1 2
                                             6 4 5
                                             9 7 8
                  ?
                  ?
                             , and the value of
     CSHIFT (M, SHIFT = [-1, 1, 0], DIM = 2) is
                ?
                ?
                                                  3 1 2
                                                  5 6 4
                                                  7 8 9
                    ?
                    ?
                                .
<b>16.9.69</b> <b>DATE_AND_TIME</b> <b>([DATE,</b> <b>TIME,</b> <b>ZONE,</b> <b>VALUES])</b>
<b>Description.</b> Date and time.
<b>Class.</b> Subroutine.
<b>Arguments.</b>
DATE (optional) shall be a default character scalar. It is an INTENT (OUT) argument. It is assigned a value
     of the form <i>YYYYMMDD</i>, where <i>YYYY</i> is the year in the Gregorian calendar, <i>MM</i> is the month
     within the year, and <i>DD</i> is the day within the month. The characters of this value shall all be
     decimal digits. If there is no date available, DATE is assigned all blanks.
TIME (optional) shall be a default character scalar. It is an INTENT (OUT) argument. It is assigned a value
     of the form <i>hhmmss.sss</i>, where <i>hh</i> is the hour of the day, <i>mm</i> is the minutes of the hour, and <i>ss.sss</i>
     is the seconds and milliseconds of the minute. Except for the decimal point, the characters of this
     value shall all be decimal digits. If there is no clock available, TIME is assigned all blanks.
ZONE (optional) shall be a default character scalar. It is an INTENT (OUT) argument. It is assigned a value of
     the form +<i>hhmm</i> or -<i>hhmm</i>, where <i>hh</i> and <i>mm</i> are the time difference with respect to Coordinated
     Universal Time (UTC) in hours and minutes, respectively. The characters of this value following
     the sign character shall all be decimal digits. If this information is not available, ZONE is assigned
     all blanks.
VALUES (optional) shall be a rank-one array of type integer with a decimal exponent range of at least four. It
     is an INTENT (OUT) argument. Its size shall be at least 8. The values assigned to VALUES are
     as follows:
 VALUES (1) the year, including the century (for example, 2008), or-HUGE (VALUES) if there is no date
     available;
 VALUES (2) the month of the year, or-HUGE (VALUES) if there is no date available;
 VALUES (3) the day of the month, or-HUGE (VALUES) if there is no date available;
 VALUES (4) the time difference from Coordinated Universal Time (UTC) in minutes, or-HUGE (VALUES)
     if this information is not available;
 VALUES (5) the hour of the day, in the range of 0 to 23, or-HUGE (VALUES) if there is no clock;
 VALUES (6) the minutes of the hour, in the range 0 to 59, or-HUGE (VALUES) if there is no clock;
 VALUES (7) the seconds of the minute, in the range 0 to 60, or-HUGE (VALUES) if there is no clock;
 VALUES (8) the milliseconds of the second, in the range 0 to 999, or-HUGE (VALUES) if there is no clock.
The date, clock, and time zone information might be available on some images and not others. If the date, clock,
or time zone information is available on more than one image, it is processor dependent whether or not those
images share the same information.
<b>Example.</b> If run in Geneva, Switzerland on April 12, 2008 at 15:27:35.5 with a system configured for the
local time zone, this example would have assigned the value 20080412 to BIG_BEN (1), the value 152735.500 to
BIG_BEN(2), thevalue+0100toBIG_BEN(3), andthevalue[2008, 4, 12, 60, 15, 27, 35, 500]toDATE_TIME.
   INTEGER DATE_TIME (8)
   CHARACTER (LEN = 10) BIG_BEN (3)
   CALL DATE_AND_TIME (BIG_BEN (1), BIG_BEN (2), BIG_BEN (3), DATE_TIME)
<b>NOTE</b>
These forms are compatible with the representations defined in ISO 8601:2004. UTC is established by the
International Bureau of Weights and Measures (BIPM, i.e. Bureau International des Poids et Mesures) and the
International Earth Rotation Service (IERS).
<b>16.9.70</b> <b>DBLE</b> <b>(A)</b>
<b>Description.</b> Conversion to double precision real.
<b>Class.</b> Elemental function.
<b>Argument.</b> A shall be of type integer, real, complex, or a <i>boz-literal-constant</i>.
<b>Result</b> <b>Characteristics.</b> Double precision real.
<b>Result</b> <b>Value.</b> The result has the value REAL (A, KIND (0.0D0)).
<b>Example.</b> DBLE (-3) has the value-3.0D0.
<b>16.9.71</b> <b>DIGITS</b> <b>(X)</b>
<b>Description.</b> Significant digits in numeric model.
<b>Class.</b> Inquiry function.
<b>Argument.</b> X shall be of type integer or real. It may be a scalar or an array.
<b>Result</b> <b>Characteristics.</b> Default integer scalar.
<b>Result</b> <b>Value.</b> The result has the value <i>q</i> if X is of type integer and <i>p</i> if X is of type real, where <i>q</i> and <i>p</i> are as
defined in 16.4 for the model representing numbers of the same type and kind type parameter as X.
<b>Example.</b> DIGITS (X) has the value 24 for real X whose model is as in 16.4, NOTE.
<b>16.9.72</b> <b>DIM</b> <b>(X,</b> <b>Y)</b>
<b>Description.</b> Maximum of X- Y and zero.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
X shall be of type integer or real.
Y shall be of the same type and kind type parameter as X.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The value of the result is the maximum of X- Y and zero.
<b>Example.</b> DIM (-3.0, 2.0) has the value 0.0.
<b>16.9.73</b> <b>DOT_PRODUCT</b> <b>(VECTOR_A,</b> <b>VECTOR_B)</b>
<b>Description.</b> Dot product of two vectors.
<b>Class.</b> Transformational function.
<b>Arguments.</b>
VECTOR_A shall be of numeric type (integer, real, or complex) or of logical type. It shall be a rank-one array.
VECTOR_B shall be of numeric type if VECTOR_A is of numeric type or of type logical if VECTOR_A is of
     type logical. It shall be a rank-one array. It shall be of the same size as VECTOR_A.
<b>Result</b> <b>Characteristics.</b> If the arguments are of numeric type, the type and kind type parameter of the result
are those of the expression VECTOR_A * VECTOR_B determined by the types and kinds of the arguments
accordingto10.1.9.3. Iftheargumentsareoftypelogical, theresultisoftypelogicalwiththekindtypeparameter
of the expression VECTOR_A .AND. VECTOR_B according to 10.1.9.3. The result is scalar.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> If VECTOR_A is of type integer or real, the result has the value SUM (VECTOR_A*VECTOR_-
     B). If the vectors have size zero, the result has the value zero.
<i>Case</i> <i>(ii):</i> If VECTOR_A is of type complex, the result has the value SUM (CONJG (VECTOR_A)*VECT-
     OR_B). If the vectors have size zero, the result has the value zero.
<i>Case</i> <i>(iii):</i> IfVECTOR_Aisoftypelogical, theresulthasthevalueANY(VECTOR_A.AND.VECTOR_B).
     If the vectors have size zero, the result has the value false.
<b>Example.</b> DOT_PRODUCT ([1, 2, 3], [2, 3, 4]) has the value 20.
<b>16.9.74</b> <b>DPROD</b> <b>(X,</b> <b>Y)</b>
<b>Description.</b> Double precision real product.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
X shall be default real.
Y shall be default real.
<b>Result</b> <b>Characteristics.</b> Double precision real.
<b>Result</b> <b>Value.</b> The result has a value equal to a processor-dependent approximation to the product of X and
Y. DPROD (X, Y) should have the same value as DBLE (X) * DBLE (Y).
<b>Example.</b> DPROD (-3.0, 2.0) has the value-6.0D0.
<b>16.9.75</b> <b>DSHIFTL</b> <b>(I,</b> <b>J,</b> <b>SHIFT)</b>
<b>Description.</b> Combined left shift.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
I shall be of type integer or a <i>boz-literal-constant</i>.
J shall be of type integer or a <i>boz-literal-constant</i>. If both I and J are of type integer, they shall have
     the same kind type parameter. I and J shall not both be <i>boz-literal-constant</i>s.
SHIFT shall be of type integer. It shall be nonnegative and less than or equal to BIT_SIZE (I) if I is of
     type integer; otherwise, it shall be less than or equal to BIT_SIZE (J).
<b>Result</b> <b>Characteristics.</b> Same as I if I is of type integer; otherwise, same as J.
<b>Result</b> <b>Value.</b> If either I or J is a <i>boz-literal-constant</i>, it is first converted as if by the intrinsic function INT to
type integer with the kind type parameter of the other. The rightmost SHIFT bits of the result value are the same
as the leftmost bits of J, and the remaining bits of the result value are the same as the rightmost bits of I. This
is equal to IOR (SHIFTL (I, SHIFT), SHIFTR (J, BIT_SIZE (J)-SHIFT)). The model for the interpretation of
an integer value as a sequence of bits is in 16.3.
<b>Examples.</b> DSHIFTL (1, 2**30, 2) has the value 5 if default integer has 32 bits. DSHIFTL (I, I, SHIFT) has
the same result value as ISHFTC (I, SHIFT).
<b>16.9.76</b> <b>DSHIFTR</b> <b>(I,</b> <b>J,</b> <b>SHIFT)</b>
<b>Description.</b> Combined right shift.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
I shall be of type integer or a <i>boz-literal-constant</i>.
J shall be of type integer or a <i>boz-literal-constant</i>. If both I and J are of type integer, they shall have
     the same kind type parameter. I and J shall not both be <i>boz-literal-constant</i>s.
SHIFT shall be of type integer. It shall be nonnegative and less than or equal to BIT_SIZE (I) if I is of
     type integer; otherwise, it shall be less than or equal to BIT_SIZE (J).
<b>Result</b> <b>Characteristics.</b> Same as I if I is of type integer; otherwise, same as J.
<b>Result</b> <b>Value.</b> If either I or J is a <i>boz-literal-constant</i>, it is first converted as if by the intrinsic function INT to
type integer with the kind type parameter of the other. The leftmost SHIFT bits of the result value are the same
as the rightmost bits of I, and the remaining bits of the result value are the same as the leftmost bits of J. This
is equal to IOR (SHIFTL (I, BIT_SIZE (I)-SHIFT), SHIFTR (J, SHIFT)). The model for the interpretation of
an integer value as a sequence of bits is in 16.3.
<b>Examples.</b> DSHIFTR (1, 16, 3) has the value 2
                        29
                                        + 2 if default integer has 32 bits. DSHIFTR (I, I, SHIFT) has
the same result value as ISHFTC (I,-SHIFT).
<b>16.9.77</b> <b>EOSHIFT</b> <b>(ARRAY,</b> <b>SHIFT</b> <b>[,</b> <b>BOUNDARY,</b> <b>DIM])</b>
<b>Description.</b> End-off shift of the elements of an array.
<b>Class.</b> Transformational function.
<b>Arguments.</b>
ARRAY shall be an array be of any type.
SHIFT shall be of type integer and shall be scalar if ARRAY has rank one; otherwise, it shall be scalar or
     of rank <i>n</i>- 1 and of shape [<i>d</i>
                     1
                  , <i>d</i>
                       2
                    , ..., <i>d</i>
                         DIM-1
                          , <i>d</i>
                             DIM+1
                              , ..., <i>d</i>
                                  <i>n</i>
                                 ] where [<i>d</i>
                                           1
                                      , <i>d</i>
                                             2
                                       , ..., <i>d</i>
                                             <i>n</i>
                                           ] is the shape
     of ARRAY.
BOUNDARY (optional) shall be of the same type and type parameters as ARRAY and shall be scalar if ARRAY
     has rank one; otherwise, it shall be either scalar or of rank <i>n</i>- 1 and of shape [<i>d</i>
                                               1
                                         , <i>d</i>
                                                 2
                                           , ..., <i>d</i>
                                                  DIM-1
                                                ,
    <i>d</i>
       DIM+1
         , ..., <i>d</i>
             <i>n</i>
            ]. BOUNDARY is permitted to be absent only for the types in Table 16.4, and in
     this case it is as if it were present with the scalar value shown, converted if necessary to the kind
     type parameter value of ARRAY.
        <b>Table</b> <b>16.4</b> <b>-</b> <b>Default</b> <b>BOUNDARY</b> <b>values</b> <b>for</b> <b>EOSHIFT</b>
              Type of ARRAY Value of BOUNDARY
                Integer 0
                 Real 0.0
          <b>Default</b> <b>BOUNDARY</b> <b>values</b> <b>for</b> <b>EOSHIFT</b> (cont.)
              Type of ARRAY Value of BOUNDARY
                Complex (0.0, 0.0)
                Logical .FALSE.
              Character (<i>len</i>) <i>len</i> blanks
DIM (optional) shall be an integer scalar with a value in the range 1 DIM<i>n</i>, where<i>n</i> is the rank of ARRAY.
     If DIM is absent, it is as if it were present with the value 1.
<b>Result</b> <b>Characteristics.</b> The result has the type, type parameters, and shape of ARRAY.
<b>Result</b> <b>Value.</b> Element (<i>s</i>
              1
            , <i>s</i>
                2
              , ..., <i>s</i>
                  <i>n</i>
                  ) of the result has the value ARRAY (<i>s</i>
                                         1
                                    , <i>s</i>
                                           2
                                     , ..., <i>s</i>
                                            DIM-1
                                           , <i>s</i>
                                                 DIM
                                                                                    +<i>sh</i>,
<i>s</i>
DIM+1
   , ..., <i>s</i>
      <i>n</i>
      ) where <i>sh</i> is SHIFT or SHIFT (<i>s</i>
                         1
                      , <i>s</i>
                           2
                        , ..., <i>s</i>
                              DIM-1
                              , <i>s</i>
                                  DIM+1
                                  , ..., <i>s</i>
                                       <i>n</i>
                                      ) provided the inequality
LBOUND (ARRAY, DIM) <i>s</i>
               DIM
                            +<i>sh</i> UBOUND (ARRAY, DIM) holds and is otherwise BOUNDARY or
BOUNDARY (<i>s</i>
        1
       , <i>s</i>
         2
         , ..., <i>s</i>
             DIM-1
              , <i>s</i>
                 DIM+1
                  , ..., <i>s</i>
                      <i>n</i>
                      ).
<b>Examples.</b>
<i>Case</i> <i>(i):</i> If V is the array [1, 2, 3, 4, 5, 6], the effect of shifting V end-off to the left by 3 positions is achieved
     by EOSHIFT (V, SHIFT = 3), which has the value [4, 5, 6, 0, 0, 0]; EOSHIFT (V, SHIFT =-2,
     BOUNDARY = 99) achieves an end-off shift to the right by 2 positions with the boundary value of
     99 and has the value [99, 99, 1, 2, 3, 4].
<i>Case</i> <i>(ii):</i> The rows of an array of rank two may all be shifted by the same amount or by different amounts
     and the boundary elements can be the same or different. If M is the array
                        ?
                        ?
                                       A B C
                                       D E F
                                       G H I
                           ?
                           ?
                                            , then the
     value of EOSHIFT (M, SHIFT =-1, BOUNDARY = '*', DIM = 2) is
                       ?
                       ?
                                     * A B
                                     * D E
                  * G H
                          ?
                          ?
                                          , and the value
     of EOSHIFT (M, SHIFT = [-1, 1, 0], BOUNDARY = ['*', '/', '?'], DIM = 2) is
                          ?
                          ?
                                          * A B
                                          E F <i>/</i>
                                          G H I
                              ?
                              ?
                                                .
<b>16.9.78</b> <b>EPSILON</b> <b>(X)</b>
<b>Description.</b> Model number that is small compared to 1.
<b>Class.</b> Inquiry function.
<b>Argument.</b> X shall be of type real. It may be a scalar or an array.
<b>Result</b> <b>Characteristics.</b> Scalar of the same type and kind type parameter as X.
<b>Result</b> <b>Value.</b> The result has the value <i>b</i>
                      1-<i>p</i>
                    where <i>b</i> and <i>p</i> are as defined in 16.4 for the model representing
numbers of the same type and kind type parameter as X.
<b>Example.</b> EPSILON (X) has the value 2
           -23
                    for real X whose model is as in 16.4, NOTE.
<b>16.9.79</b> <b>ERF</b> <b>(X)</b>
<b>Description.</b> Error function.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has a value equal to a processor-dependent approximation to the error function of X,
2


R
  <i>X</i>
  0
     exp(-<i>t</i>
       2
           )d<i>t</i>.
<b>Example.</b> ERF (1.0) has the value 0.843 (approximately).
<b>16.9.80</b> <b>ERFC</b> <b>(X)</b>
<b>Description.</b> Complementary error function.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has a value equal to a processor-dependent approximation to the complementary error
function of X, 1-ERF (X); this is equivalent to
                         2
             
                           
              R
              
                        <i>X</i>
                                            exp(-<i>t</i>
                                2
                                                   )d<i>t</i>.
<b>Example.</b> ERFC (1.0) has the value 0.157 (approximately).
<b>16.9.81</b> <b>ERFC_SCALED</b> <b>(X)</b>
<b>Description.</b> Scaled complementary error function.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has a value equal to a processor-dependent approximation to the exponentially-scaled
complementary error function of X, exp(<i>X</i>
                     2
                                  )
                       2
            
                        
             R
             
                      <i>X</i>
                                        exp(-<i>t</i>
                             2
                                               )d<i>t</i>.
<b>Example.</b> ERFC_SCALED (20.0) has the value 0.02817434874 (approximately).
<b>NOTE</b>
The complementary error function is asymptotic to exp(-<i>X</i>
                              2
                                                )<i>/</i>(<i>X</i>
              
                             ). As such it underflows for <i>X</i> <i>></i> 9 when
using ISO/IEC/IEEE 60559:2020 single precision arithmetic. The exponentially-scaled complementary error
function is asymptotic to 1<i>/</i>(<i>X</i>
      
              ). As such it does not underflow until <i>X</i> <i>></i> HUGE (X)<i>/</i>
                   
                                       .
<b>16.9.82</b> <b>EVENT_QUERY</b> <b>(EVENT,</b> <b>COUNT</b> <b>[,</b> <b>STAT])</b>
<b>Description.</b> Query event count.
<b>Class.</b> Subroutine.
<b>Arguments.</b>
EVENT shall be an event variable (16.10.2.10). It shall not be coindexed. It is an INTENT (IN) argument.
     The EVENT argument is accessed atomically with respect to the execution of EVENT POST
     statements in unordered segments, in exact analogy to atomic subroutines.
COUNT shall be an integer scalar with a decimal exponent range no smaller than that of default integer. It
     is an INTENT (OUT) argument. If no error condition occurs, COUNT is assigned the value of the
     count of EVENT; otherwise, it is assigned the value-1.
STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
     INTENT (OUT) argument. If the STAT argument is present, it is assigned a processor-dependent
     positive value if an error condition occurs; otherwise it is assigned the value zero. If the STAT
     argument is not present and an error condition occurs, error termination is initiated.
<b>Example.</b> If EVENT is an event variable for which there have been no successful posts or waits in preceding
segments, and for which there are no posts or waits in an unordered segment, after execution of
   CALL EVENT_QUERY (EVENT, COUNT)
the integer variable COUNT will have the value zero. If there have been ten successful posts to EVENT and two
successful waits without an UNTIL_COUNT= specifier in preceding segments, and for which there are no posts
or waits in an unordered segment, after execution of
   CALL EVENT_QUERY (EVENT, COUNT)
the variable COUNT will have the value eight.
<b>NOTE</b>
Execution of EVENT_QUERY does not imply any synchronization.
<b>16.9.83</b> <b>EXECUTE_COMMAND_LINE</b> <b>(COMMAND</b> <b>[,</b> <b>WAIT,</b> <b>EXITSTAT,</b>
    <b>CMDSTAT,</b> <b>CMDMSG</b> <b>])</b>
<b>Description.</b> Execute a command line.
<b>Class.</b> Subroutine.
<b>Arguments.</b>
COMMAND shall be a default character scalar. It is an INTENT (IN) argument. Its value is the command line
     to be executed. The interpretation is processor dependent.
WAIT (optional) shall be a logical scalar. It is an INTENT (IN) argument. If WAIT is present with the value
     false, and the processor supports asynchronous execution of the command, the command is executed
     asynchronously; otherwise it is executed synchronously.
EXITSTAT (optional) shall be a scalar of type integer with a decimal exponent range of at least nine. It is an
     INTENT (INOUT) argument. If the command is executed synchronously, it is assigned the value
     of the processor-dependent exit status. Otherwise, the value of EXITSTAT is unchanged.
CMDSTAT (optional) shall be a scalar of type integer with a decimal exponent range of at least four. It is an
     INTENT (OUT) argument. It is assigned the value-1 if the processor does not support command
     line execution, a processor-dependent positive value if an error condition occurs, or the value-2
     if no error condition occurs but WAIT is present with the value false and the processor does not
     support asynchronous execution. Otherwise it is assigned the value 0.
CMDMSG (optional) shall be a default character scalar. It is an INTENT (INOUT) argument. If an error condi-
     tion occurs, it is assigned a processor-dependent explanatory message. Otherwise, it is unchanged.
If the processor supports command line execution, it shall support synchronous and may support asynchronous
execution of the command line.
When the command is executed synchronously, EXECUTE_COMMAND_LINE returns after the command line
has completed execution. Otherwise, EXECUTE_COMMAND_LINE returns without waiting.
If a condition occurs that would assign a nonzero value to CMDSTAT but the CMDSTAT variable is not present,
error termination is initiated.
<b>16.9.84</b> <b>EXP</b> <b>(X)</b>
<b>Description.</b> Exponential function.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real or complex.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has a value equal to a processor-dependent approximation to <i>e</i>
                                            X
                                         . If X is of type
complex, its imaginary part is regarded as a value in radians.
<b>Example.</b> EXP (1.0) has the value 2.7182818 (approximately).
<b>16.9.85</b> <b>EXPONENT</b> <b>(X)</b>
<b>Description.</b> Exponent of floating-point number.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real.
<b>Result</b> <b>Characteristics.</b> Default integer.
<b>Result</b> <b>Value.</b> The result has a value equal to the exponent <i>e</i> of the representation for the value of X in the
extended real model for the kind of X (16.4), provided X is nonzero and <i>e</i> is within the range for default integers.
If X has the value zero, the result has the value zero. If X is an IEEE infinity or NaN, the result has the value
HUGE (0).
<b>Examples.</b> EXPONENT (1.0) has the value 1 and EXPONENT (4.1) has the value 3 for reals whose model is
as in 16.4, NOTE.
<b>16.9.86</b> <b>EXTENDS_TYPE_OF</b> <b>(A,</b> <b>MOLD)</b>
<b>Description.</b> Dynamic type extension inquiry.
<b>Class.</b> Inquiry function.
<b>Arguments.</b>
A shall be an object of extensible declared type or unlimited polymorphic. If it is a polymorphic
     pointer, it shall not have an undefined association status.
MOLD shall be an object of extensible declared type or unlimited polymorphic. If it is a polymorphic
     pointer, it shall not have an undefined association status.
<b>Result</b> <b>Characteristics.</b> Default logical scalar.
<b>Result</b> <b>Value.</b> If MOLD is unlimited polymorphic and is either a disassociated pointer or unallocated allocatable
variable, the result is true; otherwise if A is unlimited polymorphic and is either a disassociated pointer or
unallocated allocatable variable, the result is false; otherwise if the dynamic type of A or MOLD is extensible, the
result is true if and only if the dynamic type of A is an extension type of the dynamic type of MOLD; otherwise
the result is processor dependent.
<b>NOTE</b> <b>1</b>
The dynamic type of a disassociated pointer or unallocated allocatable variable is its declared type.
<b>NOTE</b> <b>2</b>
The test performed by EXTENDS_TYPE_OF is not the same as the test performed by the type guard CLASS
IS. The test performed by EXTENDS_TYPE_OF does not consider kind type parameters.
<b>Example.</b> Given the declarations and assignments
   TYPE T1
     REAL C
   END TYPE
   TYPE, EXTENDS(T1) :: T2
   END TYPE
   CLASS(T1), POINTER :: P, Q
   ALLOCATE (P)
   ALLOCATE (T2 :: Q)
the result of EXTENDS_TYPE_OF (P, Q) will be false, and the result of EXTENDS_TYPE_OF (Q, P) will
be true.
<b>16.9.87</b> <b>FAILED_IMAGES</b> <b>([TEAM,</b> <b>KIND])</b>
<b>Description.</b> Indices of failed images.
<b>Class.</b> Transformational function.
<b>Arguments.</b>
TEAM (optional) shall be a scalar of type TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV. Its
     value shall be that of the current or an ancestor team. If TEAM is absent, the team specified is the
     current team.
KIND (optional) shall be a scalar integer constant expression.
<b>Result</b> <b>Characteristics.</b> Integer. If KIND is present, the kind type parameter is that specified by the value
of KIND; otherwise, the kind type parameter is that of default integer type. The result is an array of rank one
whose size is equal to the number of images in the specified team that are known by the invoking image to have
failed.
<b>Result</b> <b>Value.</b> The elements of the result are the values of the image indices of the known failed images in the
specified team, in numerically increasing order. If the executing image has previously executed an image control
statement whose STAT= specifier assigned the value STAT_FAILED_IMAGE from the intrinsic module ISO_-
FORTRAN_ENV, or referenced a collective subroutine whose STAT argument was set to STAT_FAILED_-
IMAGE, at least one image in the set of images participating in that image control statement or collective
subroutine reference shall be known to have failed.
<b>Examples.</b> If image 3 is the only image in the current team that is known by the invoking image to have failed,
FAILED_IMAGES() will have the value [3]. If there are no images in the current team that are known by the
invoking image to have failed, the value of FAILED_IMAGES() will be a zero-sized array.
<b>16.9.88</b> <b>FINDLOC</b> <b>(ARRAY,</b> <b>VALUE,</b> <b>DIM</b> <b>[,</b> <b>MASK,</b> <b>KIND,</b> <b>BACK])</b> <b>or</b>
    <b>FINDLOC</b> <b>(ARRAY,</b> <b>VALUE</b> <b>[,</b> <b>MASK,</b> <b>KIND,</b> <b>BACK])</b>
<b>Description.</b> Location(s) of a specified value.
<b>Class.</b> Transformational function.
<b>Arguments.</b>
ARRAY shall be an array of intrinsic type.
VALUE shall be scalar and in type conformance with ARRAY, as specified in Table 10.2 for the operator
     == or the operator .EQV..
DIM shall be an integer scalar with a value in the range 1 DIM<i>n</i>, where <i>n</i> is the rank of ARRAY.
MASK (optional) shall be of type logical and shall be conformable with ARRAY.
KIND (optional) shall be a scalar integer constant expression.
BACK (optional) shall be a logical scalar.
<b>Result</b> <b>Characteristics.</b> Integer. If KIND is present, the kind type parameter is that specified by the value of
KIND; otherwise the kind type parameter is that of default integer type. If DIM does not appear, the result is
an array of rank one and of size equal to the rank of ARRAY; otherwise, the result is of rank <i>n</i>- 1 and shape
[<i>d</i>
1
 , <i>d</i>
  2
  , ..., <i>d</i>
      DIM-1
        , <i>d</i>
          DIM+1
            , ..., <i>d</i>
                <i>n</i>
                ], where [<i>d</i>
                       1
                     , <i>d</i>
                         2
                      , ..., <i>d</i>
                           <i>n</i>
                          ] is the shape of ARRAY.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> The result of FINDLOC (ARRAY, VALUE) is a rank-one array whose element values are the values
     of the subscripts of an element of ARRAY whose value matches VALUE. If there is such a value,
     the <i>i</i>
        <i>th</i>
         element value is in the range 1 to <i>e</i>
                         <i>i</i>
                        , where <i>e</i>
                              <i>i</i>
                             is the extent of the <i>i</i>
                                        <i>th</i>
                                       dimension of ARRAY.
     If no elements match VALUE or ARRAY has size zero, all elements of the result are zero.
<i>Case</i> <i>(ii):</i> The result of FINDLOC (ARRAY, VALUE, MASK = MASK) is a rank-one array whose element
     values are the values of the subscripts of an element of ARRAY, corresponding to a true element
     of MASK, whose value matches VALUE. If there is such a value, the <i>i</i>
                                       <i>th</i>
                                      element value is in the
     range 1 to <i>e</i>
           <i>i</i>
           , where <i>e</i>
                <i>i</i>
               is the extent of the <i>i</i>
                          <i>th</i>
                         dimension of ARRAY. If no elements match VALUE,
     ARRAY has size zero, or every element of MASK has the value false, all elements of the result are
     zero.
<i>Case</i> <i>(iii):</i> If ARRAY has rank one, the result of
     FINDLOC (ARRAY, VALUE, DIM=DIM [, MASK = MASK]) is a scalar whose value is equal to
     that of the first element of FINDLOC (ARRAY, VALUE [, MASK = MASK]). Otherwise, the value
     of element (<i>s</i>
             1
            , <i>s</i>
               2
             , ..., <i>s</i>
                  DIM-1
                   , <i>s</i>
                      DIM+1
                       , ..., <i>s</i>
                           <i>n</i>
                           ) of the result is equal to FINDLOC (ARRAY (<i>s</i>
                                                       1
                                                ,
    <i>s</i>
       2
      , ..., <i>s</i>
          DIM-1
            , :, <i>s</i>
                DIM+1
                 , ..., <i>s</i>
                     <i>n</i>
                     ), VALUE, DIM=1 [, MASK = MASK (<i>s</i>
                                              1
                                        , <i>s</i>
                                               2
                                         , ..., <i>s</i>
                                                 DIM-1
                                               , :,
    <i>s</i>
       DIM+1
         , ..., <i>s</i>
            <i>n</i>
            )]).
If both ARRAY and VALUE are of type logical, the comparison is performed with the .EQV. operator; otherwise,
thecomparisonisperformedwiththe==operator. If thevalueof the comparisonis true, that element ofARRAY
matches VALUE.
If DIM is not present, more than one element matches VALUE, and BACK is absent or present with the value
false, the value returned indicates the first such element, taken in array element order. If DIM is not present and
BACK is present with the value true, the value returned indicates the last such element, taken in array element
order.
<b>Examples.</b>
<i>Case</i> <i>(i):</i> The value of FINDLOC ([2, 6, 4, 6], VALUE=6) is [2], and the value of FINDLOC ([2, 6, 4, 6],
     VALUE=6, BACK=.TRUE.) is [4].
<i>Case</i> <i>(ii):</i> If A has the value
        ?
        ?
                           0 -5 7 7
                           3 4 -1 2
                           1 5 6 7
              ?
              ?
                      , and M has the value
                    ?
                    ?
                            <i>T</i> <i>T</i> <i>F</i> <i>T</i>
                            <i>T</i> <i>T</i> <i>F</i> <i>T</i>
                            <i>T</i> <i>T</i> <i>F</i> <i>T</i>
                         ?
                         ?
                                         , FINDLOC (A, 7,
     MASK = M) has the value [1, 4] and FINDLOC (A, 7, MASK = M, BACK = .TRUE.) has the
     value [3, 4]. This is independent of the declared lower bounds for A.
<i>Case</i> <i>(iii):</i> The value of FINDLOC ([2, 6, 4], VALUE=6, DIM=1) is 2. If B has the value
   ?
            1 2 -9
            2 2 6
       ?
            , FINDLOC (B, VALUE=2, DIM=1) has the value [2, 1, 0] and FINDLOC (B,
     VALUE=2, DIM=2) has the value [2, 1]. This is independent of the declared lower bounds for B.
<b>16.9.89</b> <b>FLOOR</b> <b>(A</b> <b>[,</b> <b>KIND])</b>
<b>Description.</b> Greatest integer less than or equal to A.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
A shall be of type real.
KIND (optional) shall be a scalar integer constant expression.
<b>Result</b> <b>Characteristics.</b> Integer. If KIND is present, the kind type parameter is that specified by the value of
KIND; otherwise, the kind type parameter is that of default integer type.
<b>Result</b> <b>Value.</b> The result has a value equal to the greatest integer less than or equal to A.
<b>Examples.</b> FLOOR (3.7) has the value 3. FLOOR (-3.7) has the value-4.
<b>16.9.90</b> <b>FRACTION</b> <b>(X)</b>
<b>Description.</b> Fractional part of number.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has the value Xx<i>b</i>
            -<i>e</i>
                     , where <i>b</i> and <i>e</i> are as defined in 16.4 for the representation of
X in the extended real model for the kind of X. If X has the value zero, the result is zero. If X is an IEEE NaN,
the result is that NaN. If X is an IEEE infinity, the result is an IEEE NaN.
<b>Example.</b> FRACTION (3.0) has the value 0.75 for reals whose model is as in 16.4, NOTE.
<b>16.9.91</b> <b>GAMMA</b> <b>(X)</b>
<b>Description.</b> Gamma function.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real. Its value shall not be a negative integer or zero.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has a value equal to a processor-dependent approximation to the gamma function of
X,
    (<i>X</i>) =
   ?
   ?
   ?
   ?
   ?
    R
     
         0
       <i>t</i>
          <i>X</i>-1
                    exp(-<i>t</i>)d<i>t</i> <i>X</i> <i>></i> 0
    R
     
         0
       <i>t</i>
          <i>X</i>-1
       ?
                     exp(-<i>t</i>)-
          P
                  <i>n</i>
                  <i>k</i>=0
                      (-<i>t</i>)
                           <i>k</i>
                     <i>k</i>!
             ?
                      d<i>t</i> -<i>n</i>- 1<i><X</i> <i><</i>-<i>n,</i> <i>n</i> an integer  0
<b>Example.</b> GAMMA (1.0) has the value 1.000 (approximately).
<b>16.9.92</b> <b>GET_COMMAND</b> <b>([COMMAND,</b> <b>LENGTH,</b> <b>STATUS,</b> <b>ERRMSG])</b>
<b>Description.</b> Get program invocation command.
<b>Class.</b> Subroutine.
<b>Arguments.</b>
COMMAND (optional) shall be a default character scalar. It is an INTENT (OUT) argument. It is assigned
     the entire command by which the program was invoked. If the command cannot be determined,
     COMMAND is assigned all blanks.
LENGTH (optional) shall be a scalar of type integer with a decimal exponent range of at least four. It is an
     INTENT (OUT) argument. It is assigned the significant length of the command by which the
     program was invoked. The significant length may include trailing blanks if the processor allows
     commands with significant trailing blanks. This length does not consider any possible truncation or
     padding in assigning the command to the COMMAND argument; in fact the COMMAND argument
     need not even be present. If the command length cannot be determined, a length of 0 is assigned.
STATUS (optional) shall be a scalar of type integer with a decimal exponent range of at least four. It is an
     INTENT (OUT) argument. It is assigned the value-1 if the COMMAND argument is present and
     has a length less than the significant length of the command. It is assigned a processor-dependent
     positive value if the command retrieval fails. Otherwise it is assigned the value 0.
ERRMSG (optional) shall be a default character scalar. It is an INTENT (INOUT) argument. It is assigned a
     processor-dependentexplanatorymessageifthecommandretrievalfails. Otherwise, itisunchanged.
<b>Example.</b> If the program below is invoked with the command "example" on a processor that supports command
retrieval, it will display "Hello example".
   PROGRAM hello
    CHARACTER(:), ALLOCATABLE :: cmd
    CALL GET_COMMAND(cmd)
    PRINT *, 'Hello ', cmd
   END PROGRAM
<b>16.9.93</b> <b>GET_COMMAND_ARGUMENT</b> <b>(NUMBER</b> <b>[,</b> <b>VALUE,</b> <b>LENGTH,</b>
    <b>STATUS,</b> <b>ERRMSG])</b>
<b>Description.</b> Get program invocation argument.
<b>Class.</b> Subroutine.
<b>Arguments.</b>
NUMBER shallbeanintegerscalar. ItisanINTENT(IN)argumentthatspecifiesthenumberofthecommand
     argument that the other arguments give information about.
     Command argument 0 always exists, and is the command name by which the program was invoked
     if the processor has such a concept; otherwise, the value of command argument 0 is processor
     dependent. The remaining command arguments are numbered consecutively from 1 to the argument
     count in an order determined by the processor.
VALUE (optional) shall be a default character scalar. It is an INTENT (OUT) argument. If the command
     argument specified by NUMBER exists, its value is assigned to VALUE; otherwise, VALUE is
     assigned all blanks.
LENGTH (optional) shall be a scalar of type integer with a decimal exponent range of at least four. It is an
     INTENT (OUT) argument. If the command argument specified by NUMBER exists, its significant
     length is assigned to LENGTH; otherwise, LENGTH is assigned the value zero. It is processor
     dependent whether the significant length includes trailing blanks. This length does not consider any
     possible truncation or padding in assigning the command argument value to the VALUE argument;
     in fact the VALUE argument need not even be present.
STATUS (optional) shall be a scalar of type integer with a decimal exponent range of at least four. It is an
     INTENT (OUT) argument. If NUMBER is less than zero or greater than the argument count that
     would be returned by the intrinsic function COMMAND_ARGUMENT_COUNT, or command
     retrieval fails, STATUS is assigned a processor-dependent positive value. Otherwise, if VALUE is
     present and has a length less than the significant length of the specified command argument, it is
     assigned the value-1. Otherwise it is assigned the value 0.
ERRMSG (optional) shall be a default character scalar. It is an INTENT (INOUT) argument. It is assigned
     a processor-dependent explanatory message if the optional argument STATUS is, or would be if
     present, assigned a positive value. Otherwise, it is unchanged.
<b>Example.</b> On a processor that supports command arguments, the following program displays the arguments of
the command by which it was invoked.
   PROGRAM show_arguments
    INTEGER :: i
    CHARACTER :: command*32, arg*128
    CALL get_command_argument(0, command)
    WRITE (*,*) "Command name is: ", command
    DO i = 1, command_argument_count()
     CALL get_command_argument(i, arg)
     WRITE (*,*) "Argument ", i, " is ", arg
    END DO
   END PROGRAM show_arguments
<b>16.9.94</b> <b>GET_ENVIRONMENT_VARIABLE</b> <b>(NAME</b> <b>[,</b> <b>VALUE,</b> <b>LENGTH,</b>
    <b>STATUS,</b> <b>TRIM_NAME,</b> <b>ERRMSG])</b>
<b>Description.</b> Get environment variable.
<b>Class.</b> Subroutine.
<b>Arguments.</b>
NAME shall be a default character scalar. It is an INTENT (IN) argument. The interpretation of case is
     processor dependent.
VALUE (optional) shall be a default character scalar. It is an INTENT (OUT) argument. It is assigned the value
     of the environment variable specified by NAME. VALUE is assigned all blanks if the environment
     variable does not exist or does not have a value, or if the processor does not support environment
     variables.
LENGTH (optional) shall be a scalar of type integer with a decimal exponent range of at least four. It is an
     INTENT (OUT) argument. If the specified environment variable exists and has a value, LENGTH
     is assigned the value of its length. Otherwise LENGTH is assigned the value zero.
STATUS (optional) shall be a scalar of type integer with a decimal exponent range of at least four. It is an
     INTENT (OUT) argument. If the environment variable exists and either has no value, its value is
     successfully assigned to VALUE, or the VALUE argument is not present, STATUS is assigned the
     value zero. STATUS is assigned the value-1 if the VALUE argument is present and has a length
     less than the significant length of the environment variable. It is assigned the value 1 if the specified
     environment variable does not exist, or 2 if the processor does not support environment variables.
     Processor-dependent values greater than 2 may be assigned for other error conditions.
TRIM_NAME (optional) shall be a logical scalar. It is an INTENT (IN) argument. If TRIM_NAME is present
     with the value false then trailing blanks in NAME are considered significant if the processor sup-
     ports trailing blanks in environment variable names. Otherwise trailing blanks in NAME are not
     considered part of the environment variable's name.
ERRMSG (optional) shall be a default character scalar. It is an INTENT (INOUT) argument. It is assigned
     a processor-dependent explanatory message if the optional argument STATUS is, or would be if
     present, assigned a positive value. Otherwise, it is unchanged.
It is processor dependent whether an environment variable that exists on an image also exists on another image,
and if it does exist on both images, whether the values are the same or different.
<b>Example.</b> If the value of the environment variable DATAFILE is datafile.dat, executing the statement sequence
below will assign the value 'datafile.dat' to FILENAME.
   CHARACTER(:),ALLOCATABLE :: FILENAME
   CALL GET_ENVIRONMENT_VARIABLE("DATAFILE", FILENAME)
<b>16.9.95</b> <b>GET_TEAM</b> <b>([LEVEL])</b>
<b>Description.</b> Team.
<b>Class.</b> Transformational function.
<b>Argument.</b> LEVEL (optional) shall be a scalar integer whose value is equal to one of the named constants
INITIAL_TEAM, PARENT_TEAM, or CURRENT_TEAM from the intrinsic module ISO_FORTRAN_ENV.
<b>Result</b> <b>Characteristics.</b> Scalar of type TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV.
<b>Result</b> <b>Value.</b> The result is a TEAM_TYPE value that identifies the current team if LEVEL is not present,
present with the value CURRENT_TEAM, or if the current team is the initial team. Otherwise, the result
identifies the parent team if LEVEL is present with the value PARENT_TEAM, and identifies the initial team
if LEVEL is present with the value INITIAL_TEAM.
<b>Examples.</b>
   PROGRAM EXAMPLE1
     USE,INTRINSIC :: ISO_FORTRAN_ENV, ONLY: TEAM_TYPE
     TYPE(TEAM_TYPE) :: WORLD_TEAM, TEAM2
     ! Define a team variable representing the initial team
     WORLD_TEAM = GET_TEAM()
   END PROGRAM
   SUBROUTINE EXAMPLE2 (A)
     USE,INTRINSIC :: ISO_FORTRAN_ENV, ONLY: TEAM_TYPE
     REAL A[*]
     TYPE(TEAM_TYPE) :: NEW_TEAM, PARENT_TEAM
     ... ! Form NEW_TEAM
     PARENT_TEAM = GET_TEAM ()
     CHANGE TEAM (NEW_TEAM)
      ! Reference image 1 in parent's team
      A [1,TEAM=PARENT_TEAM] = 4.2
      ! Reference image 1 in current team
      A [1] = 9.0
     END TEAM
   END SUBROUTINE EXAMPLE2
<b>NOTE</b>
Because the result of GET_TEAM is of type TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV,
a program unit that assigns the result of a reference to GET_TEAM to a local variable will also need access
to the definition of TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV.
<b>16.9.96</b> <b>HUGE</b> <b>(X)</b>
<b>Description.</b> Largest model value or last enumeration value.
<b>Class.</b> Inquiry function.
<b>Argument.</b> X shall be of type integer or real, or of enumeration type. It may be a scalar or an array.
<b>Result</b> <b>Characteristics.</b> Scalar of the same type and kind type parameter as X.
<b>Result</b> <b>Value.</b> The result has the value <i>r</i>
                    <i>q</i>
         - 1 if X is of type integer and (1-<i>b</i>
                      -<i>p</i>
                                                                   )<i>b</i>
                                        <i>e</i>max
                                        if X is of type real,
where <i>r</i>, <i>q</i>, <i>b</i>, <i>p</i>, and <i>e</i>
          max
           are as defined in 16.4 for the model representing numbers of the same type and kind
type parameter as X. If X is of enumeration type, the result has the value of the last enumerator in the type
definition.
<b>Example.</b> HUGE (X) has the value (1- 2
           -24
                                    )x 2
                          127
                        for real X whose model is as in 16.4, NOTE.
<b>16.9.97</b> <b>HYPOT</b> <b>(X,</b> <b>Y)</b>
<b>Description.</b> Euclidean distance function.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
X shall be of type real.
Y shall be of type real with the same kind type parameter as X.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has a value equal to a processor-dependent approximation to the Euclidean distance,
p
 X
  2
    +Y
    2
    , without undue overflow or underflow.
<b>Example.</b> HYPOT (3.0, 4.0) has the value 5.0 (approximately).
<b>16.9.98</b> <b>IACHAR</b> <b>(C</b> <b>[,</b> <b>KIND])</b>
<b>Description.</b> ASCII code value for character.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
C shall be of type character and of length one.
KIND (optional) shall be a scalar integer constant expression.
<b>Result</b> <b>Characteristics.</b> Integer. If KIND is present, the kind type parameter is that specified by the value of
KIND; otherwise, the kind type parameter is that of default integer type.
<b>Result</b> <b>Value.</b> If C is in the collating sequence defined by the codes specified in ISO/IEC 646:1991 (International
Reference Version), the result is the position of C in that sequence; it is nonnegative and less than or equal to
127. The value of the result is processor dependent if C is not in the ASCII collating sequence. The results
are consistent with the LGE, LGT, LLE, and LLT comparison functions. For example, if LLE (C, D) is true,
IACHAR (C) <= IACHAR (D) is true where C and D are any two characters representable by the processor.
<b>Example.</b> IACHAR ('X') has the value 88.
<b>16.9.99</b> <b>IALL</b> <b>(ARRAY,</b> <b>DIM</b> <b>[,</b> <b>MASK])</b> <b>or</b> <b>IALL</b> <b>(ARRAY</b> <b>[,</b> <b>MASK])</b>
<b>Description.</b> Array reduced by IAND function.
<b>Class.</b> Transformational function.
<b>Arguments.</b>
ARRAY shall be an array of type integer.
DIM shall be an integer scalar with a value in the range 1 DIM<i>n</i>, where <i>n</i> is the rank of ARRAY.
MASK (optional) shall be of type logical and shall be conformable with ARRAY.
<b>Result</b> <b>Characteristics.</b> The result is of the same type and kind type parameter as ARRAY. It is scalar if
DIM does not appear or if ARRAY has rank one; otherwise, the result is an array of rank <i>n</i>- 1 and shape [<i>d</i>
                                                       1
                                                ,
<i>d</i>
2
 , ..., <i>d</i>
    DIM-1
      , <i>d</i>
        DIM+1
          , ..., <i>d</i>
              <i>n</i>
              ] where [<i>d</i>
                     1
                  , <i>d</i>
                       2
                    , ..., <i>d</i>
                        <i>n</i>
                        ] is the shape of ARRAY.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> If ARRAY has size zero the result value is equal to NOT (INT (0, KIND (ARRAY))). Otherwise,
     the result of IALL (ARRAY) has a value equal to the bitwise AND of all the elements of ARRAY.
<i>Case</i> <i>(ii):</i> The result of IALL (ARRAY, MASK=MASK) has a value equal to
     IALL (PACK (ARRAY, MASK)).
<i>Case</i> <i>(iii):</i> TheresultofIALL(ARRAY,DIM=DIM[,MASK=MASK])hasavalueequaltothatofIALL(AR-
     RAY [ , MASK=MASK]) if ARRAY has rank one. Otherwise, the value of element (<i>s</i>
                                                   1
                                             , <i>s</i>
                                                     2
                                              , ...,
    <i>s</i>
       DIM-1
         , <i>s</i>
           DIM+1
            , ..., <i>s</i>
                <i>n</i>
                ) of the result is equal to IALL (ARRAY (<i>s</i>
                                         1
                                    , <i>s</i>
                                           2
                                      , ..., <i>s</i>
                                             DIM-1
                                            , :, <i>s</i>
                                                  DIM+1
                                                ,
     ..., <i>s</i>
        <i>n</i>
        ) [, MASK = MASK (<i>s</i>
                      1
                   , <i>s</i>
                       2
                     , ..., <i>s</i>
                          DIM-1
                          , :, <i>s</i>
                               DIM+1
                               , ..., <i>s</i>
                                    <i>n</i>
                                   )]).
<b>Examples.</b> IALL ([14, 13, 11]) has the value 8. IALL ([14, 13, 11], MASK=[.true., .false., .true.]) has the value
10.
<b>16.9.100</b> <b>IAND</b> <b>(I,</b> <b>J)</b>
<b>Description.</b> Bitwise AND.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
I shall be of type integer or a <i>boz-literal-constant</i>.
J shall be of type integer or a <i>boz-literal-constant</i>. If both I and J are of type integer, they shall have
     the same kind type parameter. I and J shall not both be <i>boz-literal-constant</i>s.
<b>Result</b> <b>Characteristics.</b> Same as I if I is of type integer; otherwise, same as J.
<b>Result</b> <b>Value.</b> If either I or J is a <i>boz-literal-constant</i>, it is first converted as if by the intrinsic function INT to
type integer with the kind type parameter of the other. The result has the value obtained by combining I and J
bit-by-bit according to the following table:
                    I J IAND (I, J)
                    1 1 1
                    1 0 0
                    0 1 0
                    0 0 0
The model for the interpretation of an integer value as a sequence of bits is in 16.3.
<b>Example.</b> IAND (1, 3) has the value 1.
<b>16.9.101</b> <b>IANY</b> <b>(ARRAY,</b> <b>DIM</b> <b>[,</b> <b>MASK])</b> <b>or</b> <b>IANY</b> <b>(ARRAY</b> <b>[,</b> <b>MASK])</b>
<b>Description.</b> Reduce array with bitwise OR operation.
<b>Class.</b> Transformational function.
<b>Arguments.</b>
ARRAY shall be of type integer. It shall be an array.
DIM shall be an integer scalar with a value in the range 1<i>DIM</i><i>n</i>, where <i>n</i> is the rank of ARRAY.
MASK (optional) shall be of type logical and shall be conformable with ARRAY.
<b>Result</b> <b>Characteristics.</b> The result is of the same type and kind type parameter as ARRAY. It is scalar if
DIM does not appear or if ARRAY has rank one; otherwise, the result is an array of rank <i>n</i>- 1 and shape [<i>d</i>
                                                       1
                                                ,
<i>d</i>
2
 , ..., <i>d</i>
    DIM-1
      , <i>d</i>
        DIM+1
          , ..., <i>d</i>
              <i>n</i>
              ] where [<i>d</i>
                     1
                  , <i>d</i>
                       2
                    , ..., <i>d</i>
                        <i>n</i>
                        ] is the shape of ARRAY.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> The result of IANY (ARRAY) is the bitwise OR of all the elements of ARRAY. If ARRAY has size
     zero the result value is equal to zero.
<i>Case</i> <i>(ii):</i> The result of IANY (ARRAY, MASK=MASK) has a value equal to
     IANY (PACK (ARRAY, MASK)).
<i>Case</i> <i>(iii):</i> TheresultofIANY(ARRAY,DIM=DIM[,MASK=MASK])hasavalueequaltothatofIANY(AR-
     RAY [, MASK=MASK]) if ARRAY has rank one. Otherwise, the value of element (<i>s</i>
                                                   1
                                             , <i>s</i>
                                                     2
                                              , ...,
    <i>s</i>
       DIM-1
         , <i>s</i>
           DIM+1
            , ..., <i>s</i>
                <i>n</i>
                ) of the result is equal to IANY (ARRAY (<i>s</i>
                                         1
                                    , <i>s</i>
                                           2
                                      , ..., <i>s</i>
                                             DIM-1
                                            , :, <i>s</i>
                                                  DIM+1
                                                ,
     ..., <i>s</i>
        <i>n</i>
        ) [, MASK = MASK (<i>s</i>
                      1
                   , <i>s</i>
                       2
                     , ..., <i>s</i>
                          DIM-1
                          , :, <i>s</i>
                               DIM+1
                               , ..., <i>s</i>
                                    <i>n</i>
                                   )]).
<b>Examples.</b> IANY ([14, 13, 8]) has the value 15. IANY ([14, 13, 8], MASK=[.true., .false., .true.]) has the value
14.
<b>16.9.102</b> <b>IBCLR</b> <b>(I,</b> <b>POS)</b>
<b>Description.</b> I with bit POS replaced by zero.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
I shall be of type integer.
POS shall be of type integer. It shall be nonnegative and less than BIT_SIZE (I).
<b>Result</b> <b>Characteristics.</b> Same as I.
<b>Result</b> <b>Value.</b> The result has the value of the sequence of bits of I, except that bit POS is zero. The model for
the interpretation of an integer value as a sequence of bits is in 16.3.
<b>Examples.</b> IBCLR (14, 1) has the value 12. If V has the value [1, 2, 3, 4], the value of IBCLR (POS = V, I = 31)
is [29, 27, 23, 15].
<b>16.9.103</b> <b>IBITS</b> <b>(I,</b> <b>POS,</b> <b>LEN)</b>
<b>Description.</b> Specified sequence of bits.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
I shall be of type integer.
POS shall be of type integer. It shall be nonnegative and POS + LEN shall be less than or equal to
     BIT_SIZE (I).
LEN shall be of type integer and nonnegative.
<b>Result</b> <b>Characteristics.</b> Same as I.
<b>Result</b> <b>Value.</b> The result has the value of the sequence of LEN bits in I beginning at bit POS, right-adjusted
and with all other bits zero. The model for the interpretation of an integer value as a sequence of bits is in 16.3.
<b>Example.</b> IBITS (14, 1, 3) has the value 7.
<b>16.9.104</b> <b>IBSET</b> <b>(I,</b> <b>POS)</b>
<b>Description.</b> I with bit POS replaced by one.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
I shall be of type integer.
POS shall be of type integer. It shall be nonnegative and less than BIT_SIZE (I).
<b>Result</b> <b>Characteristics.</b> Same as I.
<b>Result</b> <b>Value.</b> The result has the value of the sequence of bits of I, except that bit POS is one. The model for
the interpretation of an integer value as a sequence of bits is in 16.3.
<b>Examples.</b> IBSET (12, 1) has the value 14. If V has the value [1, 2, 3, 4], the value of IBSET (POS=V, I=0)
is [2, 4, 8, 16].
<b>16.9.105</b> <b>ICHAR</b> <b>(C</b> <b>[,</b> <b>KIND])</b>
<b>Description.</b> Code value for character.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
C shall be of type character and of length one. Its value shall be that of a character capable of
     representation in the processor.
KIND (optional) shall be a scalar integer constant expression.
<b>Result</b> <b>Characteristics.</b> Integer. If KIND is present, the kind type parameter is that specified by the value of
KIND; otherwise, the kind type parameter is that of default integer type.
<b>Result</b> <b>Value.</b> The result is the position of C in the processor collating sequence associated with the kind type
parameter of C; it is nonnegative and less than <i>n</i>, where <i>n</i> is the number of characters in the collating sequence.
The kind type parameter of the result shall specify an integer kind that is capable of representing <i>n</i>. For any char-
acters C and D capable of representation in the processor, C <= D is true if and only if ICHAR (C) <= ICHAR (D)
is true and C == D is true if and only if ICHAR (C) == ICHAR (D) is true.
<b>Example.</b> ICHAR('X')hasthevalue88onaprocessorusingtheASCIIcollatingsequencefordefaultcharacters.
<b>16.9.106</b> <b>IEOR</b> <b>(I,</b> <b>J)</b>
<b>Description.</b> Bitwise exclusive OR.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
I shall be of type integer or a <i>boz-literal-constant</i>.
J shall be of type integer or a <i>boz-literal-constant</i>. If both I and J are of type integer, they shall have
     the same kind type parameter. I and J shall not both be <i>boz-literal-constant</i>s.
<b>Result</b> <b>Characteristics.</b> Same as I if I is of type integer; otherwise, same as J.
<b>Result</b> <b>Value.</b> If either I or J is a <i>boz-literal-constant</i>, it is first converted as if by the intrinsic function INT to
type integer with the kind type parameter of the other. The result has the value obtained by combining I and J
bit-by-bit according to the following table:
                    I J IEOR (I, J)
                    1 1 0
                    1 0 1
                    0 1 1
                    0 0 0
The model for the interpretation of an integer value as a sequence of bits is in 16.3.
<b>Example.</b> IEOR (1, 3) has the value 2.
<b>16.9.107</b> <b>IMAGE_INDEX</b> <b>(COARRAY,</b> <b>SUB)</b> <b>or</b> <b>(COARRAY,</b> <b>SUB,</b> <b>TEAM)</b> <b>or</b>
    <b>(COARRAY,</b> <b>SUB,</b> <b>TEAM_NUMBER)</b>
<b>Description.</b> Image index from cosubscripts.
<b>Class.</b> Transformational function.
<b>Arguments.</b>
COARRAY shall be a coarray of any type. If its <i>designator</i> has more than one <i>part-ref</i>, the rightmost <i>part-ref</i>
     shall have nonzero corank. If TEAM_NUMBER appears and the current team is not the initial
     team, it shall be established in the parent of the current team. If TEAM_NUMBER appears and
     the current team is the initial team, it shall be established in the initial team and the value of
     TEAM_NUMBER shall be the team number for the initial team. If TEAM appears, it shall be
     established in that team. If neither TEAM nor TEAM_NUMBER appears, it shall be established
     in the current team.
SUB shall be a rank-one integer array of size equal to the corank of COARRAY.
TEAM shall be a scalar of type TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV, with a
     value that identifies the current or an ancestor team.
TEAM_NUMBER shall be an integer scalar. It shall identify the initial team or a sibling team of the current
     team.
<b>Result</b> <b>Characteristics.</b> Default integer scalar.
<b>Result</b> <b>Value.</b> If the value of SUB is a valid sequence of cosubscripts for COARRAY in the team specified by
TEAM or TEAM_NUMBER, or the current team if neither TEAM nor TEAM_NUMBER appears, the result
is the index of the corresponding image in that team. Otherwise, the result is zero.
<b>Examples.</b> If A and B are declared as A [0:*] and B (10, 20) [10, 0:9, 0:*] respectively, IMAGE_INDEX (A, [0])
has the value 1 and IMAGE_INDEX (B, [3, 1, 2]) has the value 213 (on any image, provided the number of
images is at least 213).
<b>16.9.108</b> <b>IMAGE_STATUS</b> <b>(IMAGE</b> <b>[,</b> <b>TEAM])</b>
<b>Description.</b> Image execution state.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
IMAGE shall be of type integer. Its value shall be positive and less than or equal to the number of images
     in the specified team.
TEAM (optional) shall be a scalar of type TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV. Its
     value shall represent the current or an ancestor team. If TEAM is absent, the team specified is the
     current team.
<b>Result</b> <b>Characteristics.</b> Default integer.
<b>Result</b> <b>Value.</b> The result value is STAT_FAILED_IMAGE from the intrinsic module ISO_FORTRAN_ENV
if the specified image has failed, STAT_STOPPED_IMAGE from the intrinsic module ISO_FORTRAN_ENV
if that image has initiated normal termination, and zero otherwise.
<b>Example.</b> If image 3 of the current team has failed, IMAGE_STATUS (3) has the value STAT_FAILED_-
IMAGE.
<b>16.9.109</b> <b>INDEX</b> <b>(STRING,</b> <b>SUBSTRING</b> <b>[,</b> <b>BACK,</b> <b>KIND])</b>
<b>Description.</b> Character string search.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
STRING shall be of type character.
SUBSTRING shall be of type character with the same kind type parameter as STRING.
BACK (optional) shall be of type logical.
KIND (optional) shall be a scalar integer constant expression.
<b>Result</b> <b>Characteristics.</b> Integer. If KIND is present, the kind type parameter is that specified by the value of
KIND; otherwise the kind type parameter is that of default integer type.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> If STRING % LEN <i><</i> SUBSTRING % LEN, the result has the value zero.
<i>Case</i> <i>(ii):</i> Otherwise, if there is an integer I in the range 1 I STRING % LEN- SUBSTRING % LEN
          + 1, such that STRING(I : I + SUBSTRING % LEN- 1) is equal to SUBSTRING, the result has
     the value of the smallest such I if BACK is absent or present with the value false, and the greatest
     such I if BACK is present with the value true.
<i>Case</i> <i>(iii):</i> Otherwise, the result has the value zero.
<b>Examples.</b> INDEX ('FORTRAN', 'R') has the value 3.
INDEX ('FORTRAN', 'R', BACK = .TRUE.) has the value 5.
<b>16.9.110</b> <b>INT</b> <b>(A</b> <b>[,</b> <b>KIND])</b>
<b>Description.</b> Conversion to integer type.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
A shall be of type integer, real, or complex, or of enum or enumeration type, or a <i>boz-literal-constant</i>.
KIND (optional) shall be a scalar integer constant expression.
<b>Result</b> <b>Characteristics.</b> Integer. If KIND is present, the kind type parameter is that specified by the value of
KIND; otherwise, the kind type parameter is that of default integer type.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> If A is of type integer, INT (A) = A.
<i>Case</i> <i>(ii):</i> If A is of type real, there are two cases: if|A| <i><</i> 1, INT (A) has the value 0; if|A| 1, INT (A)
     is the integer whose magnitude is the largest integer that does not exceed the magnitude of A and
     whose sign is the same as the sign of A.
<i>Case</i> <i>(iii):</i> If A is of type complex, INT (A) = INT (REAL (A, KIND (A))).
<i>Case</i> <i>(iv):</i> If A is of enum type, INT (A) has the value of the corresponding integer value.
<i>Case</i> <i>(v):</i> If A is of enumeration type, INT (A) has the value of the ordinal position of A.
<i>Case</i> <i>(vi):</i> If A is a <i>boz-literal-constant</i>, the value of the result is the value whose bit sequence according to the
     model in 16.3 is the same as that of A as modified by padding or truncation according to 16.3.3.
     The interpretation of a bit sequence whose most significant bit is 1 is processor dependent.
<b>Example.</b> INT (-3.7) has the value-3.
<b>16.9.111</b> <b>IOR</b> <b>(I,</b> <b>J)</b>
<b>Description.</b> Bitwise inclusive OR.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
I shall be of type integer or a <i>boz-literal-constant</i>.
J shall be of type integer or a <i>boz-literal-constant</i>. If both I and J are of type integer, they shall have
     the same kind type parameter. I and J shall not both be <i>boz-literal-constant</i>s.
<b>Result</b> <b>Characteristics.</b> Same as I if I is of type integer; otherwise, same as J.
<b>Result</b> <b>Value.</b> If either I or J is a <i>boz-literal-constant</i>, it is first converted as if by the intrinsic function INT to
type integer with the kind type parameter of the other. The result has the value obtained by combining I and J
bit-by-bit according to the following table:
                    I J IOR (I, J)
                    1 1 1
                    1 0 1
                    0 1 1
                    0 0 0
The model for the interpretation of an integer value as a sequence of bits is in 16.3.
<b>Example.</b> IOR (5, 3) has the value 7.
<b>16.9.112</b> <b>IPARITY</b> <b>(ARRAY,</b> <b>DIM</b> <b>[,</b> <b>MASK])</b> <b>or</b> <b>IPARITY</b> <b>(ARRAY</b> <b>[,</b> <b>MASK])</b>
<b>Description.</b> Array reduced by IEOR function.
<b>Class.</b> Transformational function.
<b>Arguments.</b>
ARRAY shall be of type integer. It shall be an array.
DIM shall be an integer scalar with a value in the range 1 DIM<i>n</i>, where <i>n</i> is the rank of ARRAY.
MASK (optional) shall be of type logical and shall be conformable with ARRAY.
<b>Result</b> <b>Characteristics.</b> The result is of the same type and kind type parameter as ARRAY. It is scalar if
DIM does not appear; otherwise, the result has rank <i>n</i>- 1 and shape [<i>d</i>
                                   1
                               ,<i>d</i>
                                     2
                                , ..., <i>d</i>
                                       DIM-1
                                      ,<i>d</i>
                                           DIM+1
                                          , ..., <i>d</i>
                                                <i>n</i>
                                             ] where
[<i>d</i>
1
 , <i>d</i>
  2
  , ..., <i>d</i>
      <i>n</i>
      ] is the shape of ARRAY.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> The result of IPARITY (ARRAY) has a value equal to the bitwise exclusive OR of all the elements
     of ARRAY. If ARRAY has size zero the result has the value zero.
<i>Case</i> <i>(ii):</i> The result of IPARITY (ARRAY, MASK=MASK) has a value equal to that of IPARITY (PACK
     (ARRAY, MASK)).
<i>Case</i> <i>(iii):</i> The result of IPARITY (ARRAY, DIM=DIM [, MASK=MASK]) has a value equal to that of
     IPARITY (ARRAY [, MASK=MASK]) if ARRAY has rank one. Otherwise, the value of element
     (<i>s</i>
       1
       , <i>s</i>
         2
        , ..., <i>s</i>
             DIM-1
              , <i>s</i>
                 DIM+1
                  , ..., <i>s</i>
                       <i>n</i>
                      ) of the result is equal to IPARITY (ARRAY (<i>s</i>
                                                   1
                                             , <i>s</i>
                                                     2
                                              , ...,
    <i>s</i>
       DIM-1
         , :, <i>s</i>
            DIM+1
             , ..., <i>s</i>
                 <i>n</i>
                 ) [, MASK = MASK (<i>s</i>
                               1
                            , <i>s</i>
                                 2
                             , ..., <i>s</i>
                                   DIM-1
                                   , :, <i>s</i>
                                        DIM+1
                                       , ..., <i>s</i>
                                             <i>n</i>
                                           )]).
<b>Examples.</b> IPARITY ([14, 13, 8]) has the value 11. IPARITY ([14, 13, 8], MASK=[.true., .false., .true.]) has
the value 6.
<b>16.9.113</b> <b>ISHFT</b> <b>(I,</b> <b>SHIFT)</b>
<b>Description.</b> Logical shift.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
I shall be of type integer.
SHIFT shall be of type integer. The absolute value of SHIFT shall be less than or equal to BIT_SIZE (I).
<b>Result</b> <b>Characteristics.</b> Same as I.
<b>Result</b> <b>Value.</b> The result has the value obtained by shifting the bits of I by SHIFT positions. If SHIFT is
positive, the shift is to the left; if SHIFT is negative, the shift is to the right; if SHIFT is zero, no shift is
performed. Bits shifted out from the left or from the right, as appropriate, are lost. Zeros are shifted in from the
opposite end. The model for the interpretation of an integer value as a sequence of bits is in 16.3.
<b>Example.</b> ISHFT (3, 1) has the value 6.
<b>16.9.114</b> <b>ISHFTC</b> <b>(I,</b> <b>SHIFT</b> <b>[,</b> <b>SIZE])</b>
<b>Description.</b> Circular shift of the rightmost bits.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
I shall be of type integer.
SHIFT shall be of type integer. The absolute value of SHIFT shall be less than or equal to SIZE.
SIZE (optional) shall be of type integer. The value of SIZE shall be positive and shall not exceed BIT_SIZE (I).
     If SIZE is absent, it is as if it were present with the value of BIT_SIZE (I).
<b>Result</b> <b>Characteristics.</b> Same as I.
<b>Result</b> <b>Value.</b> The result has the value obtained by shifting the SIZE rightmost bits of I circularly by SHIFT
positions. If SHIFT is positive, the shift is to the left; if SHIFT is negative, the shift is to the right; and if SHIFT
is zero, no shift is performed. No bits are lost. The unshifted bits are unaltered. The model for the interpretation
of an integer value as a sequence of bits is in 16.3.
<b>Example.</b> ISHFTC (3, 2, 3) has the value 5.
<b>16.9.115</b> <b>IS_CONTIGUOUS</b> <b>(ARRAY)</b>
<b>Description.</b> Array contiguity test (8.5.7).
<b>Class.</b> Inquiry function.
<b>Argument.</b> ARRAY may be of any type. It shall be assumed-rank or an array. If it is a pointer it shall be
associated.
<b>Result</b> <b>Characteristics.</b> Default logical scalar.
<b>Result</b> <b>Value.</b> The result has the value true if ARRAY has rank zero or is contiguous, and false otherwise.
<b>Example.</b> After the pointer assignment AP =<i>></i> TARGET (1:10:2), IS_CONTIGUOUS (AP) has the value
false.
<b>16.9.116</b> <b>IS_IOSTAT_END</b> <b>(I)</b>
<b>Description.</b> IOSTAT value test for end of file.
<b>Class.</b> Elemental function.
<b>Argument.</b> I shall be of type integer.
<b>Result</b> <b>Characteristics.</b> Default logical.
<b>Result</b> <b>Value.</b> The result has the value true if and only if I is a value for the <i>stat-variable</i> in an IOSTAT=
specifier (12.11.5) that would indicate an end-of-file condition.
<b>16.9.117</b> <b>IS_IOSTAT_EOR</b> <b>(I)</b>
<b>Description.</b> IOSTAT value test for end of record.
<b>Class.</b> Elemental function.
<b>Argument.</b> I shall be of type integer.
<b>Result</b> <b>Characteristics.</b> Default logical.
<b>Result</b> <b>Value.</b> The result has the value true if and only if I is a value for the <i>stat-variable</i> in an IOSTAT=
specifier (12.11.5) that would indicate an end-of-record condition.
<b>16.9.118</b> <b>KIND</b> <b>(X)</b>
<b>Description.</b> Value of the kind type parameter of X.
<b>Class.</b> Inquiry function.
<b>Argument.</b> X may be of any intrinsic type. It may be a scalar or an array.
<b>Result</b> <b>Characteristics.</b> Default integer scalar.
<b>Result</b> <b>Value.</b> The result has a value equal to the kind type parameter value of X.
<b>Example.</b> KIND (0.0) has the kind type parameter value of default real.
<b>16.9.119</b> <b>LBOUND</b> <b>(ARRAY</b> <b>[,</b> <b>DIM,</b> <b>KIND])</b>
<b>Description.</b> Lower bound(s).
<b>Class.</b> Inquiry function.
<b>Arguments.</b>
ARRAY shall be assumed-rank or an array. It shall not be an unallocated allocatable variable or a pointer
     that is not associated.
DIM (optional) shall be an integer scalar with a value in the range 1 DIM<i>n</i>, where<i>n</i> is the rank of ARRAY.
     The corresponding actual argument shall not be an optional dummy argument, a disassociated
     pointer, or an unallocated allocatable.
KIND (optional) shall be a scalar integer constant expression.
<b>Result</b> <b>Characteristics.</b> Integer. If KIND is present, the kind type parameter is that specified by the value of
KIND; otherwise the kind type parameter is that of default integer type. The result is scalar if DIM is present;
otherwise, the result is an array of rank one and size <i>n</i>, where <i>n</i> is the rank of ARRAY.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> If DIM is present, ARRAY is a whole array, and either ARRAY is an assumed-size array of rank
     DIM or dimension DIM of ARRAY has nonzero extent, the result has a value equal to the lower
     bound for subscript DIM of ARRAY. Otherwise, if DIM is present, the result value is 1.
<i>Case</i> <i>(ii):</i> LBOUND (ARRAY) has a value whose<i>i</i>
                        <i>th</i>
                        element is equal to LBOUND (ARRAY,<i>i</i>), for<i>i</i> = 1<i>,</i> 2<i>,</i>
    <i>...,</i> <i>n</i>, where <i>n</i> is the rank of ARRAY. LBOUND (ARRAY, KIND=KIND) has a value whose <i>i</i>
                                                   <i>th</i>
     element is equal to LBOUND (ARRAY, <i>i</i>, KIND), for <i>i</i> = 1<i>,</i> 2<i>,</i> <i>...,</i> <i>n</i>, where <i>n</i> is the rank of
     ARRAY.
<b>NOTE</b>
If ARRAY is assumed-rank and has rank zero, DIM cannot be present since it cannot satisfy the requirement
1 DIM 0.
<b>Examples.</b> If A is declared by the statement
   REAL A (2:3, 7:10)
then LBOUND (A) is [2, 7] and LBOUND (A, DIM=2) is 7.
<b>16.9.120</b> <b>LCOBOUND</b> <b>(COARRAY</b> <b>[,</b> <b>DIM,</b> <b>KIND])</b>
<b>Description.</b> Lower cobound(s) of a coarray.
<b>Class.</b> Inquiry function.
<b>Arguments.</b>
COARRAY shall be a coarray and may be of any type. It may be a scalar or an array. If it is allocatable it
     shall be allocated. If its <i>designator</i> has more than one <i>part-ref</i>, the rightmost <i>part-ref</i> shall have
     nonzero corank.
DIM (optional) shall be an integer scalar with a value in the range 1  DIM  <i>n</i>, where <i>n</i> is the corank
     of COARRAY. The corresponding actual argument shall not be an optional dummy argument, a
     disassociated pointer, or an unallocated allocatable.
KIND (optional) shall be a scalar integer constant expression.
<b>Result</b> <b>Characteristics.</b> Integer. If KIND is present, the kind type parameter is that specified by the value of
KIND; otherwise, the kind type parameter is that of default integer type. The result is scalar if DIM is present;
otherwise, the result is an array of rank one and size <i>n</i>, where <i>n</i> is the corank of COARRAY.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> If DIM is present, the result has a value equal to the lower cobound for codimension DIM of
     COARRAY.
<i>Case</i> <i>(ii):</i> If DIM is absent, the result has a value whose <i>i</i>
                            <i>th</i>
                            element is equal to the lower cobound for codi-
     mension <i>i</i> of COARRAY, for <i>i</i> = 1, 2,..., <i>n</i>, where <i>n</i> is the corank of COARRAY.
<b>Examples.</b> If A is allocated by the statement ALLOCATE (A [2:3, 7:*]) then LCOBOUND (A) is [2, 7] and
LCOBOUND (A, DIM=2) is 7.
<b>16.9.121</b> <b>LEADZ</b> <b>(I)</b>
<b>Description.</b> Number of leading zero bits.
<b>Class.</b> Elemental function.
<b>Argument.</b> I shall be of type integer.
<b>Result</b> <b>Characteristics.</b> Default integer.
<b>Result</b> <b>Value.</b> If all of the bits of I are zero, the result has the value BIT_SIZE (I). Otherwise, the result has
the value BIT_SIZE (I)-1-<i>k</i>, where<i>k</i> is the position of the leftmost 1 bit in I. The model for the interpretation
of an integer value as a sequence of bits is in 16.3.
<b>Examples.</b> LEADZ (1) has the value 31 if BIT_SIZE (1) has the value 32.
<b>16.9.122</b> <b>LEN</b> <b>(STRING</b> <b>[,</b> <b>KIND])</b>
<b>Description.</b> Length of a character entity.
<b>Class.</b> Inquiry function.
<b>Arguments.</b>
STRING shall be of type character. If it is an unallocated allocatable variable or a pointer that is not
     associated, its length type parameter shall not be deferred.
KIND (optional) shall be a scalar integer constant expression.
<b>Result</b> <b>Characteristics.</b> Integer scalar. If KIND is present, the kind type parameter is that specified by the
value of KIND; otherwise the kind type parameter is that of default integer type.
<b>Result</b> <b>Value.</b> The result has a value equal to the number of characters in STRING if it is scalar or in an
element of STRING if it is an array.
<b>Example.</b> If C is declared by the statement
 CHARACTER (11) C (100)
LEN (C) has the value 11.
<b>16.9.123</b> <b>LEN_TRIM</b> <b>(STRING</b> <b>[,</b> <b>KIND])</b>
<b>Description.</b> Length without trailing blanks.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
STRING shall be of type character.
KIND (optional) shall be a scalar integer constant expression.
<b>Result</b> <b>Characteristics.</b> Integer. If KIND is present, the kind type parameter is that specified by the value of
KIND; otherwise the kind type parameter is that of default integer type.
<b>Result</b> <b>Value.</b> The result has a value equal to the number of characters remaining after any trailing blanks in
STRING are removed. If the argument contains no nonblank characters, the result is zero.
<b>Examples.</b> LEN_TRIM (' A B ') has the value 4 and LEN_TRIM (' ') has the value 0.
<b>16.9.124</b> <b>LGE</b> <b>(STRING_A,</b> <b>STRING_B)</b>
<b>Description.</b> ASCII greater than or equal.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
STRING_A shall be default character or ASCII character.
STRING_B shall be of type character with the same kind type parameter as STRING_A.
<b>Result</b> <b>Characteristics.</b> Default logical.
<b>Result</b> <b>Value.</b> If the strings are of unequal length, the comparison is made as if the shorter string were extended
on the right with blanks to the length of the longer string. If either string contains a character not in the ASCII
character set, the result is processor dependent. The result is true if the strings are equal or if STRING_A follows
STRING_B in the ASCII collating sequence; otherwise, the result is false.
<b>NOTE</b>
The result is true if both STRING_A and STRING_B are of zero length.
<b>Example.</b> LGE ('ONE', 'TWO') has the value false.
<b>16.9.125</b> <b>LGT</b> <b>(STRING_A,</b> <b>STRING_B)</b>
<b>Description.</b> ASCII greater than.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
STRING_A shall be default character or ASCII character.
STRING_B shall be of type character with the same kind type parameter as STRING_A.
<b>Result</b> <b>Characteristics.</b> Default logical.
<b>Result</b> <b>Value.</b> If the strings are of unequal length, the comparison is made as if the shorter string were extended
on the right with blanks to the length of the longer string. If either string contains a character not in the ASCII
character set, the result is processor dependent. The result is true if STRING_A follows STRING_B in the
ASCII collating sequence; otherwise, the result is false.
<b>NOTE</b>
The result is false if both STRING_A and STRING_B are of zero length.
<b>Example.</b> LGT ('ONE', 'TWO') has the value false.
<b>16.9.126</b> <b>LLE</b> <b>(STRING_A,</b> <b>STRING_B)</b>
<b>Description.</b> ASCII less than or equal.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
STRING_A shall be default character or ASCII character.
STRING_B shall be of type character with the same kind type parameter as STRING_A.
<b>Result</b> <b>Characteristics.</b> Default logical.
<b>Result</b> <b>Value.</b> If the strings are of unequal length, the comparison is made as if the shorter string were extended
on the right with blanks to the length of the longer string. If either string contains a character not in the ASCII
character set, the result is processor dependent. The result is true if the strings are equal or if STRING_A
precedes STRING_B in the ASCII collating sequence; otherwise, the result is false.
<b>NOTE</b>
The result is true if both STRING_A and STRING_B are of zero length.
<b>Example.</b> LLE ('ONE', 'TWO') has the value true.
<b>16.9.127</b> <b>LLT</b> <b>(STRING_A,</b> <b>STRING_B)</b>
<b>Description.</b> ASCII less than.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
STRING_A shall be default character or ASCII character.
STRING_B shall be of type character with the same kind type parameter as STRING_A.
<b>Result</b> <b>Characteristics.</b> Default logical.
<b>Result</b> <b>Value.</b> If the strings are of unequal length, the comparison is made as if the shorter string were extended
on the right with blanks to the length of the longer string. If either string contains a character not in the ASCII
character set, the result is processor dependent. The result is true if STRING_A precedes STRING_B in the
ASCII collating sequence; otherwise, the result is false.
<b>NOTE</b>
The result is false if both STRING_A and STRING_B are of zero length.
<b>Example.</b> LLT ('ONE', 'TWO') has the value true.
<b>16.9.128</b> <b>LOG</b> <b>(X)</b>
<b>Description.</b> Natural logarithm.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real or complex. If X is real, its value shall be greater than zero. If X is complex,
its value shall not be zero.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has a value equal to a processor-dependent approximation to log
                                          <i>e</i>
                                        X. A result of type
complex is the principal value with imaginary part <i>?</i> in the range-<i>?</i> . If the real part of X is less than
zero and the imaginary part of X is zero, then the imaginary part of the result is approximately  if the imaginary
part of X is positive real zero or the processor does not distinguish between positive and negative real zero, and
approximately- if the imaginary part of X is negative real zero.
<b>Example.</b> LOG (10.0) has the value 2.3025851 (approximately).
<b>16.9.129</b> <b>LOG_GAMMA</b> <b>(X)</b>
<b>Description.</b> Logarithm of the absolute value of the gamma function.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real. Its value shall not be a negative integer or zero.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has a value equal to a processor-dependent approximation to the natural logarithm
of the absolute value of the gamma function of X.
<b>Example.</b> LOG_GAMMA (3.0) has the value 0.693 (approximately).
<b>16.9.130</b> <b>LOG10</b> <b>(X)</b>
<b>Description.</b> Common logarithm.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real. The value of X shall be greater than zero.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has a value equal to a processor-dependent approximation to log
                                              10
                                         X.
<b>Example.</b> LOG10 (10.0) has the value 1.0 (approximately).
<b>16.9.131</b> <b>LOGICAL</b> <b>(L</b> <b>[,</b> <b>KIND])</b>
<b>Description.</b> Conversion between kinds of logical.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
L shall be of type logical.
KIND (optional) shall be a scalar integer constant expression.
<b>Result</b> <b>Characteristics.</b> Logical. If KIND is present, the kind type parameter is that specified by the value of
KIND; otherwise, the kind type parameter is that of default logical.
<b>Result</b> <b>Value.</b> The value is that of L.
<b>Example.</b> LOGICAL (L .OR. .NOT. L) has the value true and is default logical, regardless of the kind type
parameter of the logical variable L.
<b>16.9.132</b> <b>MASKL</b> <b>(I</b> <b>[,</b> <b>KIND])</b>
<b>Description.</b> Left justified mask.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
I shall be of type integer. It shall be nonnegative and less than or equal to the number of bits <i>z</i> of
     the model integer defined for bit manipulation contexts in 16.3 for the kind of the result.
KIND (optional) shall be a scalar integer constant expression.
<b>Result</b> <b>Characteristics.</b> Integer. If KIND is present, the kind type parameter is that specified by the value of
KIND; otherwise, the kind type parameter is that of default integer type.
<b>Result</b> <b>Value.</b> The result value has its leftmost I bits set to 1 and the remaining bits set to 0. The model for
the interpretation of an integer value as a sequence of bits is in 16.3.
<b>Example.</b> MASKL (3) has the value SHIFTL (7, BIT_SIZE (0)- 3).
<b>16.9.133</b> <b>MASKR</b> <b>(I</b> <b>[,</b> <b>KIND])</b>
<b>Description.</b> Right justified mask.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
I shall be of type integer. It shall be nonnegative and less than or equal to the number of bits <i>z</i> of
     the model integer defined for bit manipulation contexts in 16.3 for the kind of the result.
KIND (optional) shall be a scalar integer constant expression.
<b>Result</b> <b>Characteristics.</b> Integer. If KIND is present, the kind type parameter is that specified by the value of
KIND; otherwise, the kind type parameter is that of default integer type.
<b>Result</b> <b>Value.</b> The result value has its rightmost I bits set to 1 and the remaining bits set to 0. The model for
the interpretation of an integer value as a sequence of bits is in 16.3.
<b>Example.</b> MASKR (3) has the value 7.
<b>16.9.134</b> <b>MATMUL</b> <b>(MATRIX_A,</b> <b>MATRIX_B)</b>
<b>Description.</b> Matrix multiplication.
<b>Class.</b> Transformational function.
<b>Arguments.</b>
MATRIX_A shall be a rank-one or rank-two array of numeric type or logical type.
MATRIX_B shall be of numeric type if MATRIX_A is of numeric type and of logical type if MATRIX_A is of
     logical type. It shall be an array of rank one or two. MATRIX_A and MATRIX_B shall not both
     have rank one. The size of the first (or only) dimension of MATRIX_B shall equal the size of the
     last (or only) dimension of MATRIX_A.
<b>Result</b> <b>Characteristics.</b> If the arguments are of numeric type, the type and kind type parameter of the result
are determined by the types of the arguments as specified in 10.1.9.3 for the * operator. If the arguments are of
type logical, the result is of type logical with the kind type parameter of the arguments as specified in 10.1.9.3
for the .AND. operator. The shape of the result depends on the shapes of the arguments as follows:
<i>Case</i> <i>(i):</i> If MATRIX_A has shape [<i>n,m</i>] and MATRIX_B has shape [<i>m,k</i>], the result has shape [<i>n,k</i>].
<i>Case</i> <i>(ii):</i> If MATRIX_A has shape [<i>m</i>] and MATRIX_B has shape [<i>m,k</i>], the result has shape [<i>k</i>].
<i>Case</i> <i>(iii):</i> If MATRIX_A has shape [<i>n,m</i>] and MATRIX_B has shape [<i>m</i>], the result has shape [<i>n</i>].
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> Element (<i>i,j</i>) of the result has the value SUM (MATRIX_A (<i>i</i>, :) * MATRIX_B (:, <i>j</i>)) if the
     arguments are of numeric type and has the value ANY (MATRIX_A (<i>i</i>, :) .AND. MATRIX_B (:,
    <i>j</i>)) if the arguments are of logical type.
<i>Case</i> <i>(ii):</i> Element (<i>j</i>) of the result has the value SUM (MATRIX_A (:) * MATRIX_B (:,<i>j</i>)) if the arguments
     are of numeric type and has the value ANY (MATRIX_A (:) .AND. MATRIX_B (:, <i>j</i>)) if the
     arguments are of logical type.
<i>Case</i> <i>(iii):</i> Element (<i>i</i>) of the result has the value SUM (MATRIX_A (<i>i</i>, :) * MATRIX_B (:)) if the arguments
     are of numeric type and has the value ANY (MATRIX_A (<i>i</i>, :) .AND. MATRIX_B (:)) if the
     arguments are of logical type.
<b>Examples.</b> Let A and B be the matrices
            ?
                                    1 2 3
                                    2 3 4
               ?
                         and
                 ?
                 ?
                                                   1 2
                                                   2 3
                                                   3 4
                   ?
                   ?
                               ; let X and Y be the vectors [1, 2] and
[1, 2, 3].
<i>Case</i> <i>(i):</i> The result of MATMUL (A, B) is the matrix-matrix product AB with the value
                          ?
                                                                            14 20
                                                                            20 29
                            ?
                                              .
<i>Case</i> <i>(ii):</i> The result of MATMUL (X, A) is the vector-matrix product XA with the value [5, 8, 11].
<i>Case</i> <i>(iii):</i> The result of MATMUL (A, Y) is the matrix-vector product AY with the value [14, 20].
<b>16.9.135</b> <b>MAX</b> <b>(A1,</b> <b>A2</b> <b>[,</b> <b>A3,</b> <b>...])</b>
<b>Description.</b> Maximum value.
<b>Class.</b> Elemental function.
<b>Arguments.</b> The arguments shall all have the same type which shall be integer, real, or character and they shall
all have the same kind type parameter.
<b>Result</b> <b>Characteristics.</b> The type and kind type parameter of the result are the same as those of the arguments.
For arguments of character type, the length of the result is the length of the longest argument.
<b>Result</b> <b>Value.</b> The value of the result is that of the largest argument. For arguments of character type, the
result is the value that would be selected by application of intrinsic relational operators; that is, the collating
sequence for characters with the kind type parameter of the arguments is applied. If the selected argument is
shorter than the longest argument, the result is extended with blanks on the right to the length of the longest
argument.
<b>Examples.</b> MAX (-9.0, 7.0, 2.0) has the value 7.0, MAX ('Z', 'BB') has the value 'Z ', and MAX (['A', 'Z'],
['BB', 'Y ']) has the value ['BB', 'Z '].
<b>16.9.136</b> <b>MAXEXPONENT</b> <b>(X)</b>
<b>Description.</b> Maximum exponent of a real model.
<b>Class.</b> Inquiry function.
<b>Argument.</b> X shall be of type real. It may be a scalar or an array.
<b>Result</b> <b>Characteristics.</b> Default integer scalar.
<b>Result</b> <b>Value.</b> The result has the value <i>e</i>
                    max
                   , as defined in 16.4 for the model representing numbers of the same
type and kind type parameter as X.
<b>Example.</b> MAXEXPONENT (X) has the value 127 for real X whose model is as in 16.4, NOTE.
<b>16.9.137</b> <b>MAXLOC</b> <b>(ARRAY,</b> <b>DIM</b> <b>[,</b> <b>MASK,</b> <b>KIND,</b> <b>BACK])</b> <b>or</b>
    <b>MAXLOC</b> <b>(ARRAY</b> <b>[,</b> <b>MASK,</b> <b>KIND,</b> <b>BACK])</b>
<b>Description.</b> Location(s) of maximum value.
<b>Class.</b> Transformational function.
<b>Arguments.</b>
ARRAY shall be an array of type integer, real, or character.
DIM shall be an integer scalar with a value in the range 1 DIM<i>n</i>, where <i>n</i> is the rank of ARRAY.
MASK (optional) shall be of type logical and shall be conformable with ARRAY.
KIND (optional) shall be a scalar integer constant expression.
BACK (optional) shall be a logical scalar.
<b>Result</b> <b>Characteristics.</b> Integer. If KIND is present, the kind type parameter is that specified by the value of
KIND; otherwise the kind type parameter is that of default integer type. If DIM does not appear, the result is
an array of rank one and of size equal to the rank of ARRAY; otherwise, the result is of rank <i>n</i>- 1 and shape
[<i>d</i>
1
 , <i>d</i>
  2
  , ..., <i>d</i>
      DIM-1
        , <i>d</i>
          DIM+1
            , ..., <i>d</i>
                <i>n</i>
                ], where [<i>d</i>
                       1
                     , <i>d</i>
                         2
                      , ..., <i>d</i>
                           <i>n</i>
                          ] is the shape of ARRAY.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> If DIM does not appear and MASK is absent, the result is a rank-one array whose element values
     are the values of the subscripts of an element of ARRAY whose value equals the maximum value of
     all of the elements of ARRAY. The <i>i</i>
                       <i>th</i>
                       subscript returned lies in the range 1 to <i>e</i>
                                            <i>i</i>
                                          , where <i>e</i>
                                                <i>i</i>
                                              is the
     extent of the <i>i</i>
            <i>th</i>
             dimension of ARRAY. If ARRAY has size zero, all elements of the result are zero.
<i>Case</i> <i>(ii):</i> If DIM does not appear and MASK is present, the result is a rank-one array whose element values
     are the values of the subscripts of an element of ARRAY, corresponding to a true element of MASK,
     whose value equals the maximum value of all such elements of ARRAY. The <i>i</i>
                                          <i>th</i>
                                         subscript returned
     lies in the range 1 to <i>e</i>
                <i>i</i>
                , where <i>e</i>
                     <i>i</i>
                    is the extent of the <i>i</i>
                               <i>th</i>
                              dimension of ARRAY. If ARRAY has size
     zero or every element of MASK has the value false, all elements of the result are zero.
<i>Case</i> <i>(iii):</i> If ARRAY has rank one and DIM is specified, the result has a value equal to that of the first element
     of MAXLOC (ARRAY [, MASK = MASK, KIND = KIND, BACK = BACK]). Otherwise, if DIM
     is specified, the value of element (<i>s</i>
                         1
                      , <i>s</i>
                          2
                       , ..., <i>s</i>
                             DIM-1
                             , <i>s</i>
                                 DIM+1
                                 , ..., <i>s</i>
                                      <i>n</i>
                                     ) of the result is equal to
        MAXLOC (ARRAY (<i>s</i>
                     1
                   , <i>s</i>
                       2
                    , ..., <i>s</i>
                         DIM-1
                          , :, <i>s</i>
                              DIM+1
                               , ..., <i>s</i>
                                    <i>n</i>
                                  ),
             DIM = 1
             [, MASK = MASK (<i>s</i>
                          1
                       , <i>s</i>
                            2
                         , ..., <i>s</i>
                               DIM-1
                               , :, <i>s</i>
                                    DIM+1
                                   , ..., <i>s</i>
                                         <i>n</i>
                                       ),
              KIND = KIND,
              BACK = BACK] ).
If only one element has the maximum value, that element's subscripts are returned. Otherwise, if more than
one element has the maximum value and BACK is absent or present with the value false, the element whose
subscripts are returned is the first such element, taken in array element order. If BACK is present with the value
true, the element whose subscripts are returned is the last such element, taken in array element order.
If ARRAY has type character, the result is the value that would be selected by application of intrinsic relational
operators; that is, the collating sequence for characters with the kind type parameter of the arguments is applied.
<b>Examples.</b>
<i>Case</i> <i>(i):</i> The value of MAXLOC ([2, 6, 4, 6]) is [2] and the value of MAXLOC ([2, 6, 4, 6], BACK=.TRUE.)
     is [4].
<i>Case</i> <i>(ii):</i> If A has the value
        ?
        ?
                           0 -5 8 -3
                           3 4 -1 2
                           1 5 6 -4
              ?
              ?
                       , MAXLOC (A, MASK = A <i><</i> 6) has the value [3, 2]. This
     is independent of the declared lower bounds for A.
<i>Case</i> <i>(iii):</i> The value of MAXLOC ([5,-9, 3], DIM = 1) is 1. If B has the value
                       ?
                                                                     1 3 -9
                                                                     2 2 6
                           ?
                                           , MAXLOC
     (B, DIM = 1) is [2, 1, 2] and MAXLOC (B, DIM = 2) is [2, 3]. This is independent of the declared
     lower bounds for B.
<b>16.9.138</b> <b>MAXVAL</b> <b>(ARRAY,</b> <b>DIM</b> <b>[,</b> <b>MASK])</b> <b>or</b> <b>MAXVAL</b> <b>(ARRAY</b> <b>[,</b> <b>MASK])</b>
<b>Description.</b> Maximum value(s) of array.
<b>Class.</b> Transformational function.
<b>Arguments.</b>
ARRAY shall be an array of type integer, real, or character.
DIM shall be an integer scalar with a value in the range 1 DIM<i>n</i>, where <i>n</i> is the rank of ARRAY.
MASK (optional) shall be of type logical and shall be conformable with ARRAY.
<b>Result</b> <b>Characteristics.</b> The result is of the same type and type parameters as ARRAY. It is scalar if DIM
does not appear; otherwise, the result has rank <i>n</i>- 1 and shape [<i>d</i>
                                  1
                              , <i>d</i>
                                    2
                                , ..., <i>d</i>
                                      DIM-1
                                      , <i>d</i>
                                           DIM+1
                                          , ..., <i>d</i>
                                                <i>n</i>
                                             ] where
[<i>d</i>
1
 , <i>d</i>
  2
  , ..., <i>d</i>
      <i>n</i>
      ] is the shape of ARRAY.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> The result of MAXVAL (ARRAY) has a value equal to the maximum value of all the elements of
     ARRAY if the size of ARRAY is not zero. If ARRAY has size zero and type integer or real, the
     result has the value of the negative number of the largest magnitude supported by the processor
     for numbers of the type and kind type parameter of ARRAY. If ARRAY has size zero and type
     character, the result has the value of a string of characters of length LEN (ARRAY), with each
     character equal to CHAR (0, KIND (ARRAY)).
<i>Case</i> <i>(ii):</i> The result of MAXVAL (ARRAY, MASK = MASK) has a value equal to that of MAXVAL (PACK
     (ARRAY, MASK)).
<i>Case</i> <i>(iii):</i> The result of MAXVAL (ARRAY, DIM = DIM [,MASK = MASK]) has a value equal to that of
     MAXVAL (ARRAY [,MASK = MASK]) if ARRAY has rank one. Otherwise, the value of element
     (<i>s</i>
       1
       , <i>s</i>
         2
        , ..., <i>s</i>
            DIM-1
              , <i>s</i>
                DIM+1
                  , ..., <i>s</i>
                      <i>n</i>
                     ) of the result is equal to
        MAXVAL (ARRAY (<i>s</i>
                     1
                   , <i>s</i>
                       2
                    , ..., <i>s</i>
                         DIM-1
                          , :, <i>s</i>
                              DIM+1
                               , ..., <i>s</i>
                                    <i>n</i>
                                  )
        [, MASK = MASK (<i>s</i>
                    1
                  , <i>s</i>
                      2
                    , ..., <i>s</i>
                         DIM-1
                         , :, <i>s</i>
                              DIM+1
                              , ..., <i>s</i>
                                   <i>n</i>
                                  ) ] ).
If ARRAY is of type character, the result is the value that would be selected by application of intrinsic relational
operators; that is, the collating sequence for characters with the kind type parameter of the arguments is applied.
<b>Examples.</b>
<i>Case</i> <i>(i):</i> The value of MAXVAL ([1, 2, 3]) is 3.
<i>Case</i> <i>(ii):</i> MAXVAL (C, MASK = C<0.0) is the maximum of the negative elements of C.
<i>Case</i> <i>(iii):</i> If B is the array
        ?
                          1 3 5
                          2 7 6
           ?
                   , MAXVAL (B, DIM=1) is [2, 7, 6] and MAXVAL (B, DIM=2) is
     [5, 7].
<b>16.9.139</b> <b>MERGE</b> <b>(TSOURCE,</b> <b>FSOURCE,</b> <b>MASK)</b>
<b>Description.</b> Expression value selection.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
TSOURCE may be of any type.
FSOURCE shall be of the same type and type parameters as TSOURCE.
MASK shall be of type logical.
<b>Result</b> <b>Characteristics.</b> Same type and type parameters as TSOURCE. Because TSOURCE and FSOURCE
are required to have the same type and type parameters (for both the declared and dynamic types), the result is
polymorphic if and only if both TSOURCE and FSOURCE are polymorphic.
<b>Result</b> <b>Value.</b> The result is TSOURCE if MASK is true and FSOURCE otherwise.
<b>Examples.</b> If TSOURCE is the array
           ?
                                  1 6 5
                                  2 4 6
              ?
                       , FSOURCE is the array
                      ?
                                                                 0 3 2
                                                                 7 4 8
                         ?
                                         and MASK is the
array
 ?
   T . T
   . . T
     ?
        , where "T" represents true and "." represents false, then MERGE (TSOURCE, FSOURCE,
MASK) is
  ?
          1 3 5
          7 4 6
      ?
          . The value of MERGE (1.0, 0.0, K <i>></i> 0) is 1.0 for K = 5 and 0.0 for K =-2.
<b>16.9.140</b> <b>MERGE_BITS</b> <b>(I,</b> <b>J,</b> <b>MASK)</b>
<b>Description.</b> Merge of bits under mask.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
I shall be of type integer or a <i>boz-literal-constant</i>.
J shall be of type integer or a <i>boz-literal-constant</i>. If both I and J are of type integer they shall have
     the same kind type parameter. I and J shall not both be <i>boz-literal-constant</i>s.
MASK shall be of type integer or a <i>boz-literal-constant</i>. If MASK is of type integer, it shall have the same
     kind type parameter as each other argument of type integer.
<b>Result</b> <b>Characteristics.</b> Same as I if I is of type integer; otherwise, same as J.
<b>Result</b> <b>Value.</b> If any argument is a <i>boz-literal-constant</i>, it is first converted as if by the intrinsic function
INT to the type and kind type parameter of the result. The result has the value of IOR (IAND (I, MASK),
IAND (J, NOT (MASK))).
<b>Example.</b> MERGE_BITS (13, 18, 22) has the value 4.
<b>16.9.141</b> <b>MIN</b> <b>(A1,</b> <b>A2</b> <b>[,</b> <b>A3,</b> <b>...])</b>
<b>Description.</b> Minimum value.
<b>Class.</b> Elemental function.
<b>Arguments.</b> The arguments shall all be of the same type which shall be integer, real, or character and they
shall all have the same kind type parameter.
<b>Result</b> <b>Characteristics.</b> The type and kind type parameter of the result are the same as those of the arguments.
For arguments of character type, the length of the result is the length of the longest argument.
<b>Result</b> <b>Value.</b> The value of the result is that of the smallest argument. For arguments of character type, the
result is the value that would be selected by application of intrinsic relational operators; that is, the collating
sequence for characters with the kind type parameter of the arguments is applied. If the selected argument is
shorter than the longest argument, the result is extended with blanks on the right to the length of the longest
argument.
<b>Examples.</b> MIN (-9.0, 7.0, 2.0) has the value-9.0, MIN ('A', 'YY') has the value 'A ', and
MIN (['Z', 'A'], ['YY', 'B ']) has the value ['YY', 'A '].
<b>16.9.142</b> <b>MINEXPONENT</b> <b>(X)</b>
<b>Description.</b> Minimum exponent of a real model.
<b>Class.</b> Inquiry function.
<b>Argument.</b> X shall be of type real. It may be a scalar or an array.
<b>Result</b> <b>Characteristics.</b> Default integer scalar.
<b>Result</b> <b>Value.</b> The result has the value <i>e</i>
                    min
                   , as defined in 16.4 for the model representing numbers of the same
type and kind type parameter as X.
<b>Example.</b> MINEXPONENT (X) has the value-126 for real X whose model is as in 16.4, NOTE.
<b>16.9.143</b> <b>MINLOC</b> <b>(ARRAY,</b> <b>DIM</b> <b>[,</b> <b>MASK,</b> <b>KIND,</b> <b>BACK])</b> <b>or</b>
    <b>MINLOC</b> <b>(ARRAY</b> <b>[,</b> <b>MASK,</b> <b>KIND,</b> <b>BACK])</b>
<b>Description.</b> Location(s) of minimum value.
<b>Class.</b> Transformational function.
<b>Arguments.</b>
ARRAY shall be an array of type integer, real, or character.
DIM shall be an integer scalar with a value in the range 1 DIM<i>n</i>, where <i>n</i> is the rank of ARRAY.
MASK (optional) shall be of type logical and shall be conformable with ARRAY.
KIND (optional) shall be a scalar integer constant expression.
BACK (optional) shall be a logical scalar.
<b>Result</b> <b>Characteristics.</b> Integer. If KIND is present, the kind type parameter is that specified by the value of
KIND; otherwise the kind type parameter is that of default integer type. If DIM does not appear, the result is
an array of rank one and of size equal to the rank of ARRAY; otherwise, the result is of rank <i>n</i>- 1 and shape
[<i>d</i>
1
 , <i>d</i>
  2
  , ..., <i>d</i>
      DIM-1
        , <i>d</i>
          DIM+1
            , ..., <i>d</i>
                <i>n</i>
                ], where [<i>d</i>
                       1
                     , <i>d</i>
                         2
                      , ..., <i>d</i>
                           <i>n</i>
                          ] is the shape of ARRAY.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> If DIM does not appear and MASK is absent the result is a rank-one array whose element values
     are the values of the subscripts of an element of ARRAY whose value equals the minimum value
     of all the elements of ARRAY. The <i>i</i>
                       <i>th</i>
                       subscript returned lies in the range 1 to <i>e</i>
                                            <i>i</i>
                                          , where <i>e</i>
                                                <i>i</i>
                                              is the
     extent of the <i>i</i>
            <i>th</i>
             dimension of ARRAY. If ARRAY has size zero, all elements of the result are zero.
<i>Case</i> <i>(ii):</i> If DIM does not appear and MASK is present, the result is a rank-one array whose element values
     are the values of the subscripts of an element of ARRAY, corresponding to a true element of MASK,
     whose value equals the minimum value of all such elements of ARRAY. The <i>i</i>
                                          <i>th</i>
                                         subscript returned
     lies in the range 1 to <i>e</i>
                <i>i</i>
                , where <i>e</i>
                     <i>i</i>
                    is the extent of the <i>i</i>
                               <i>th</i>
                              dimension of ARRAY. If ARRAY has size
     zero or every element of MASK has the value false, all elements of the result are zero.
<i>Case</i> <i>(iii):</i> If ARRAY has rank one and DIM is specified, the result has a value equal to that of the first element
     of MINLOC (ARRAY [, MASK = MASK, KIND = KIND, BACK = BACK]). Otherwise, if DIM
     is specified, the value of element (<i>s</i>
                         1
                      , <i>s</i>
                           2
                       , ..., <i>s</i>
                             DIM-1
                             , <i>s</i>
                                 DIM+1
                                 , ..., <i>s</i>
                                       <i>n</i>
                                     ) of the result is equal to
        MINLOC (ARRAY (<i>s</i>
                     1
                  , <i>s</i>
                      2
                    , ..., <i>s</i>
                         DIM-1
                         , :, <i>s</i>
                              DIM+1
                              , ..., <i>s</i>
                                   <i>n</i>
                                  ),
             DIM = 1
             [, MASK = MASK (<i>s</i>
                          1
                       , <i>s</i>
                            2
                        , ..., <i>s</i>
                              DIM-1
                              , :, <i>s</i>
                                   DIM+1
                                   , ..., <i>s</i>
                                        <i>n</i>
                                      ),
             KIND = KIND,
             BACK = BACK] ).
If only one element has the minimum value, that element's subscripts are returned. Otherwise, if more than one
element has the minimum value and BACK is absent or present with the value false, the element whose subscripts
are returned is the first such element, taken in array element order. If BACK is present with the value true, the
element whose subscripts are returned is the last such element, taken in array element order.
If ARRAY is of type character, the result is the value that would be selected by application of intrinsic relational
operators; that is, the collating sequence for characters with the kind type parameter of the arguments is applied.
<b>Examples.</b>
<i>Case</i> <i>(i):</i> The value of MINLOC ([4, 3, 6, 3]) is [2] and the value of MINLOC ([4, 3, 6, 3], BACK = .TRUE.)
     is [4].
<i>Case</i> <i>(ii):</i> If A has the value
         ?
         ?
                            0 -5 8 -3
                            3 4 -1 2
                            1 5 6 -4
              ?
              ?
                        , MINLOC (A, MASK = A <i>></i>-4) has the value [1, 4].
     This is independent of the declared lower bounds for A.
<i>Case</i> <i>(iii):</i> The value of MINLOC ([5, -9, 3], DIM = 1) is 2. If B has the value
                        ?
                                                                         1 3 -9
                                                                         2 2 6
                            ?
                                             , MIN-
     LOC (B, DIM = 1) is [1, 2, 1] and MINLOC (B, DIM = 2) is [3, 1]. This is independent of
     the declared lower bounds for B.
<b>16.9.144</b> <b>MINVAL</b> <b>(ARRAY,</b> <b>DIM</b> <b>[,</b> <b>MASK])</b> <b>or</b> <b>MINVAL</b> <b>(ARRAY</b> <b>[,</b> <b>MASK])</b>
<b>Description.</b> Minimum value(s) of array.
<b>Class.</b> Transformational function.
<b>Arguments.</b>
ARRAY shall be an array of type integer, real, or character.
DIM shall be an integer scalar with a value in the range 1 DIM<i>n</i>, where <i>n</i> is the rank of ARRAY.
MASK (optional) shall be of type logical and shall be conformable with ARRAY.
<b>Result</b> <b>Characteristics.</b> The result is of the same type and type parameters as ARRAY. It is scalar if DIM
does not appear; otherwise, the result has rank <i>n</i>- 1 and shape [<i>d</i>
                                  1
                              , <i>d</i>
                                    2
                                , ..., <i>d</i>
                                      DIM-1
                                      , <i>d</i>
                                           DIM+1
                                          , ..., <i>d</i>
                                                <i>n</i>
                                             ] where
[<i>d</i>
1
 , <i>d</i>
  2
  , ..., <i>d</i>
      <i>n</i>
      ] is the shape of ARRAY.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> The result of MINVAL (ARRAY) has a value equal to the minimum value of all the elements of
     ARRAY if the size of ARRAY is not zero. If ARRAY has size zero and type integer or real, the
     result has the value of the positive number of the largest magnitude supported by the processor
     for numbers of the type and kind type parameter of ARRAY. If ARRAY has size zero and type
     character, the result has the value of a string of characters of length LEN (ARRAY), with each
     character equal to CHAR (<i>n</i>- 1, KIND (ARRAY)), where <i>n</i> is the number of characters in the
     collating sequence for characters with the kind type parameter of ARRAY.
<i>Case</i> <i>(ii):</i> The result of MINVAL (ARRAY, MASK = MASK) has a value equal to that of MINVAL (PACK
     (ARRAY, MASK)).
<i>Case</i> <i>(iii):</i> The result of MINVAL (ARRAY, DIM = DIM [, MASK = MASK]) has a value equal to that of
     MINVAL (ARRAY [, MASK = MASK]) if ARRAY has rank one. Otherwise, the value of element
     (<i>s</i>
       1
       , <i>s</i>
         2
        , ..., <i>s</i>
            DIM-1
              , <i>s</i>
                DIM+1
                  , ..., <i>s</i>
                      <i>n</i>
                     ) of the result is equal to
        MINVAL (ARRAY (<i>s</i>
                     1
                  , <i>s</i>
                      2
                    , ..., <i>s</i>
                         DIM-1
                         , :, <i>s</i>
                              DIM+1
                              , ..., <i>s</i>
                                   <i>n</i>
                                  )
        [, MASK= MASK (<i>s</i>
                    1
                  , <i>s</i>
                      2
                   , ..., <i>s</i>
                        DIM-1
                         , :, <i>s</i>
                              DIM+1
                              , ..., <i>s</i>
                                   <i>n</i>
                                 ) ] ).
If ARRAY is of type character, the result is the value that would be selected by application of intrinsic relational
operators; that is, the collating sequence for characters with the kind type parameter of the arguments is applied.
<b>Examples.</b>
<i>Case</i> <i>(i):</i> The value of MINVAL ([1, 2, 3]) is 1.
<i>Case</i> <i>(ii):</i> MINVAL (C, MASK = C>0.0) is the minimum of the positive elements of C.
<i>Case</i> <i>(iii):</i> If B is the array
        ?
                          1 3 5
                          2 4 6
           ?
                   , MINVAL (B, DIM = 1) is [1, 3, 5] and MINVAL (B, DIM = 2) is
     [1, 2].
<b>16.9.145</b> <b>MOD</b> <b>(A,</b> <b>P)</b>
<b>Description.</b> Remainder function.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
A shall be of type integer or real.
P shall be of the same type and kind type parameter as A. P shall not be zero.
<b>Result</b> <b>Characteristics.</b> Same as A.
<b>Result</b> <b>Value.</b> The value of the result is A- INT (A/P) * P.
<b>Examples.</b> MOD (3.0, 2.0) has the value 1.0 (approximately). MOD (8, 5) has the value 3. MOD (-8, 5) has
the value-3. MOD (8,-5) has the value 3. MOD (-8,-5) has the value-3.
<b>16.9.146</b> <b>MODULO</b> <b>(A,</b> <b>P)</b>
<b>Description.</b> Modulo function.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
A shall be of type integer or real.
P shall be of the same type and kind type parameter as A. P shall not be zero.
<b>Result</b> <b>Characteristics.</b> Same as A.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> A is of type integer. MODULO (A, P) has the value R such that A = Qx P + R, where Q is an
     integer, the inequalities 0 R<i><</i> P hold if P <i>></i> 0, and P<i><</i> R 0 hold if P <i><</i> 0.
<i>Case</i> <i>(ii):</i> A is of type real. The value of the result is A- FLOOR (A / P) * P.
<b>Examples.</b> MODULO (8, 5) has the value 3. MODULO (-8, 5) has the value 2. MODULO (8,-5) has the
value-2. MODULO (-8,-5) has the value-3.
<b>16.9.147</b> <b>MOVE_ALLOC</b> <b>(FROM,</b> <b>TO</b> <b>[,</b> <b>STAT,</b> <b>ERRMSG])</b>
<b>Description.</b> Move an allocation.
<b>Class.</b> Subroutine, simple if and only if FROM is not a coarray.
<b>Arguments.</b>
FROM may be of any type, rank, and corank. It shall be allocatable and shall not be a coindexed object.
     It is an INTENT (INOUT) argument.
TO shall be type compatible (7.3.3) with FROM and have the same rank and corank. It shall be
     allocatable and shall not be a coindexed object. It shall be polymorphic if FROM is polymorphic.
     It is an INTENT (OUT) argument. Each nondeferred parameter of the declared type of TO shall
     have the same value as the corresponding parameter of the declared type of FROM.
STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an
     INTENT (OUT) argument.
ERRMSG (optional) shall be a noncoindexed default character scalar. It is an INTENT (INOUT) argument.
If execution of MOVE_ALLOC is successful, or if STAT_FAILED_IMAGE is assigned to STAT,
 On invocation of MOVE_ALLOC, if the allocation status of TO is allocated, it is deallocated. Then,
  if FROM has an allocation status of allocated on entry to MOVE_ALLOC, TO becomes allocated with
  dynamic type, type parameters, bounds, cobounds, and value identical to those that FROM had on entry
  to MOVE_ALLOC. Note that if FROM and TO are the same variable, it shall be unallocated when
  MOVE_ALLOC is invoked.
 If TO has the TARGET attribute, any pointer associated with FROM on entry to MOVE_ALLOC becomes
  correspondingly associated with TO. If TO does not have the TARGET attribute, the pointer association
  status of any pointer associated with FROM on entry becomes undefined.
 The allocation status of FROM becomes unallocated.
When a reference to MOVE_ALLOC is executed for which the FROM argument is a coarray, there is an implicit
synchronization of all active images of the current team. On those images, execution of the segment (11.7.2)
following the CALL statement is delayed until all other active images of the current team have executed the same
statement the same number of times. When such a reference is executed, if any image of the current team has
stopped or failed, an error condition occurs.
If STAT is present and execution is successful, it is assigned the value zero.
If an error condition occurs,
 if STAT is absent, error termination is initiated;
 otherwise, if FROM is a coarray and the current team contains a stopped image, STAT is assigned the value
  STAT_STOPPED_IMAGE from the intrinsic module ISO_FORTRAN_ENV;
 otherwise, if FROM is a coarray and the current team contains a failed image, and no other error condition
  occurs, STAT is assigned the value STAT_FAILED_IMAGE from the intrinsic module ISO_FORTRAN_-
  ENV;
 otherwise, STAT is assigned a processor-dependent positive value that differs from that of STAT_STOP-
  PED_IMAGE or STAT_FAILED_IMAGE.
If the ERRMSG argument is present and an error condition occurs, it is assigned an explanatory message. If no
error condition occurs, the definition status and value of ERRMSG are unchanged.
<b>Example.</b> The example below demonstrates reallocation of GRID to twice its previous size, with its previous
contents evenly distributed over the new elements so that intermediate points can be inserted.
   REAL,ALLOCATABLE :: GRID(:),TEMPGRID(:)
   ...
   ALLOCATE(GRID(-N:N)) ! initial allocation of GRID
   ...
   ALLOCATE(TEMPGRID(-2*N:2*N)) ! allocate bigger grid
   TEMPGRID(::2)=GRID ! distribute values to new locations
   CALL MOVE_ALLOC(TO=GRID,FROM=TEMPGRID)
The old grid is deallocated because TO is INTENT (OUT), and GRID then takes over the new grid allocation.
<b>NOTE</b>
It is expected that the implementation of allocatable objects will typically involve descriptors to locate the
allocated storage; MOVE_ALLOC could then be implemented by transferring the contents of the descriptor
for FROM to the descriptor for TO and clearing the descriptor for FROM.
<b>16.9.148</b> <b>MVBITS</b> <b>(FROM,</b> <b>FROMPOS,</b> <b>LEN,</b> <b>TO,</b> <b>TOPOS)</b>
<b>Description.</b> Copy a sequence of bits.
<b>Class.</b> Simple elemental subroutine.
<b>Arguments.</b>
FROM shall be of type integer. It is an INTENT (IN) argument.
FROMPOS shall be of type integer and nonnegative. It is an INTENT (IN) argument. FROMPOS + LEN
     shall be less than or equal to BIT_SIZE (FROM). The model for the interpretation of an integer
     value as a sequence of bits is in 16.3.
LEN shall be of type integer and nonnegative. It is an INTENT (IN) argument.
TO shall be a variable of the same type and kind type parameter value as FROM and may be associated
     with FROM (15.9.3). It is an INTENT (INOUT) argument. TO is defined by copying the sequence
     of bits of length LEN, starting at position FROMPOS of FROM to position TOPOS of TO. No
     other bits of TO are altered. On return, the LEN bits of TO starting at TOPOS are equal to
     the value that the LEN bits of FROM starting at FROMPOS had on entry. The model for the
     interpretation of an integer value as a sequence of bits is in 16.3.
TOPOS shall be of type integer and nonnegative. It is an INTENT (IN) argument. TOPOS + LEN shall
     be less than or equal to BIT_SIZE (TO).
<b>Example.</b> If TO has the initial value 6, its value after the statement CALL MVBITS (7, 2, 2, TO, 0) is 5.
<b>16.9.149</b> <b>NEAREST</b> <b>(X,</b> <b>S)</b>
<b>Description.</b> Adjacent machine number.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
X shall be of type real.
S shall be of type real and not equal to zero.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has a value equal to the machine-representable number distinct from X and nearest
to it in the direction of the with the same sign as S.
<b>Example.</b> NEAREST (3.0, 2.0) has the value 3 + 2
              -22
                         on a machine whose representation for default real is
that of the model in 16.4, NOTE.
<b>NOTE</b>
Unlike other floating-point manipulation functions, NEAREST operates on machine-representable numbers
rather than model numbers. On many systems there are machine-representable numbers that lie between
adjacent model numbers.
<b>16.9.150</b> <b>NEW_LINE</b> <b>(A)</b>
<b>Description.</b> Newline character.
<b>Class.</b> Inquiry function.
<b>Argument.</b> A shall be of type character. It may be a scalar or an array.
<b>Result</b> <b>Characteristics.</b> Character scalar of length one with the same kind type parameter as A.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> If A is default character and the character in position 10 of the ASCII collating sequence is repres-
     entable in the default character set, then the result is ACHAR (10).
<i>Case</i> <i>(ii):</i> If A is ASCII character or ISO 10646 character, then the result is CHAR (10, KIND (A)).
<i>Case</i> <i>(iii):</i> Otherwise, the result is a processor-dependent character that represents a newline in output to files
     connected for formatted stream output if there is such a character.
<i>Case</i> <i>(iv):</i> Otherwise, the result is the blank character.
<b>Example.</b> If there is a suitable newline character, and unit 10 is connected for formatted stream output, the
statement
   WRITE (10, '(A)') 'New'//NEW_LINE('a')//'Line'
will write a record containing "New" and then a record containing "Line".
<b>16.9.151</b> <b>NEXT</b> <b>(A</b> <b>[,</b> <b>STAT])</b>
<b>Description.</b> Next enumeration value.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
A shall be of enumeration type.
STAT (optional) shallbeanintegerscalarwithadecimalexponentrangeofatleastfour. ItisanINTENT(OUT)
     argument. If A is equal to the last enumerator of its type, it is assigned a processor-dependent
     positive value; otherwise, it is assigned the value zero. If STAT would have been assigned a nonzero
     value but is not present, error termination is initiated.
<b>Result</b> <b>Characteristics.</b> Same as A.
<b>Result</b> <b>Value.</b> If A is equal to the last enumerator of its type, the value of the result is that of A. Otherwise,
the value of the result is the next enumerator following the value of A.
<b>Example.</b> If the enumerators of an enumeration type are EN1, EN2, EN3, and EN4, NEXT (EN1) is equal to
EN2, and NEXT (EN4, ISTAT) is equal to EN4 and a positive value is assigned to ISTAT.
<b>16.9.152</b> <b>NINT</b> <b>(A</b> <b>[,</b> <b>KIND])</b>
<b>Description.</b> Nearest integer.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
A shall be of type real.
KIND (optional) shall be a scalar integer constant expression.
<b>Result</b> <b>Characteristics.</b> Integer. If KIND is present, the kind type parameter is that specified by the value of
KIND; otherwise, the kind type parameter is that of default integer type.
<b>Result</b> <b>Value.</b> The result is the integer nearest A, or if there are two integers equally near A, the result is
whichever such integer has the greater magnitude.
<b>Example.</b> NINT (2.783) has the value 3.
<b>16.9.153</b> <b>NORM2</b> <b>(X)</b> <b>or</b> <b>NORM2</b> <b>(X,</b> <b>DIM)</b>
<b>Description.</b> <i>L</i>
        2
        norm of an array.
<b>Class.</b> Transformational function.
<b>Arguments.</b>
X shall be a real array.
DIM shall be an integer scalar with a value in the range 1 DIM<i>n</i>, where <i>n</i> is the rank of X.
<b>Result</b> <b>Characteristics.</b> The result is of the same type and type parameters as X. It is scalar if DIM does not
appear; otherwise the result has rank <i>n</i>- 1 and shape [<i>d</i>
                            1
                         , <i>d</i>
                              2
                          , ..., <i>d</i>
                                DIM-1
                                , <i>d</i>
                                    DIM+1
                                    , ..., <i>d</i>
                                         <i>n</i>
                                       ], where <i>n</i> is the rank
of X and [<i>d</i>
     1
     , <i>d</i>
       2
       , ..., <i>d</i>
          <i>n</i>
          ] is the shape of X.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> The result of NORM2 (X) has a value equal to a processor-dependent approximation to the gener-
     alized <i>L</i>
          2
          norm of X, which is the square root of the sum of the squares of the elements of X. If X
     has size zero, the result has the value zero.
<i>Case</i> <i>(ii):</i> The result of NORM2 (X, DIM=DIM) has a value equal to that of NORM2 (X) if X has rank
     one. Otherwise, the value of element (<i>s</i>
                          1
                       , <i>s</i>
                            2
                         , ..., <i>s</i>
                              DIM-1
                              , <i>s</i>
                                  DIM+1
                                  , ... <i>s</i>
                                       <i>n</i>
                                      ) of the result is equal to
     NORM2 (X(<i>s</i>
             1
            , <i>s</i>
               2
             , ..., <i>s</i>
                  DIM-1
                   , :, <i>s</i>
                       DIM+1
                        , ... <i>s</i>
                            <i>n</i>
                           )).
It is recommended that the processor compute the result without undue overflow or underflow.
<b>Example.</b> The value of NORM2 ([3.0, 4.0]) is 5.0 (approximately). If X has the value
                        ?
                                                                         1<i>.</i>0 2<i>.</i>0
                                                                         3<i>.</i>0 4<i>.</i>0
                            ?
                                             then the
value of NORM2 (X, DIM=1) is [3.162, 4.472] (approximately) and the value of NORM2 (X, DIM=2) is [2.236,
5.0] (approximately).
<b>16.9.154</b> <b>NOT</b> <b>(I)</b>
<b>Description.</b> Bitwise complement.
<b>Class.</b> Elemental function.
<b>Argument.</b> I shall be of type integer.
<b>Result</b> <b>Characteristics.</b> Same as I.
<b>Result</b> <b>Value.</b> The result has the value obtained by complementing I bit-by-bit according to the following table:
                     I NOT (I)
                     1 0
                     0 1
The model for the interpretation of an integer value as a sequence of bits is in 16.3.
<b>Example.</b> If I is represented by the string of bits 01010101, NOT (I) has the binary value 10101010.
<b>16.9.155</b> <b>NULL</b> <b>([MOLD])</b>
<b>Description.</b> Disassociated pointer or unallocated allocatable entity.
<b>Class.</b> Transformational function.
<b>Argument.</b> MOLD shall be a pointer or allocatable. It may be of any type or may be a procedure pointer.
If MOLD is a pointer its pointer association status may be undefined, disassociated, or associated. If MOLD is
allocatable its allocation status may be allocated or unallocated. It need not be defined with a value.
<b>Result</b> <b>Characteristics.</b> If MOLD is present, the characteristics are the same as MOLD. If MOLD has deferred
type parameters, those type parameters of the result are deferred.
If MOLD is absent, the characteristics of the result are determined by the entity with which the reference is
associated. See Table 16.5. MOLD shall not be absent in any other context. If any type parameters of the
contextual entity are deferred, those type parameters of the result are deferred. If any type parameters of the
contextual entity are assumed, MOLD shall be present.
If the context of the reference to NULL is an actual argument in a generic procedure reference, MOLD shall be
present if the type, type parameters, or rank are required to resolve the generic reference. If the context of the
reference to NULL is an actual argument corresponding to an assumed-rank dummy argument, MOLD shall be
present.
         <b>Table</b> <b>16.5</b> <b>-</b> <b>Characteristics</b> <b>of</b> <b>the</b> <b>result</b> <b>of</b> <b>NULL</b> <b>(</b> <b>)</b>
    Appearance of NULL ( ) Type, type parameters, and rank of result:
    right side of a pointer assignment pointer on the left side
    initialization for an object in a declaration the object
    default initialization for a component the component
    in a structure constructor the corresponding component
    as an actual argument the corresponding dummy argument
    in a DATA statement the corresponding pointer object
<b>Result.</b> The result is a disassociated pointer or an unallocated allocatable entity.
<b>Examples.</b>
<i>Case</i> <i>(i):</i> REAL, POINTER, DIMENSION (:) :: VEC =<i>></i> NULL ( ) defines the initial association status of
     VEC to be disassociated.
<i>Case</i> <i>(ii):</i> The MOLD argument is required in the following:
     INTERFACE GEN
       SUBROUTINE S1 (J, PI)
         INTEGER J
         INTEGER, POINTER :: PI
       END SUBROUTINE S1
       SUBROUTINE S2 (K, PR)
         INTEGER K
         REAL, POINTER :: PR
       END SUBROUTINE S2
     END INTERFACE
     REAL, POINTER :: REAL_PTR
     CALL GEN (7, NULL (REAL_PTR) ) ! Invokes S2
<b>16.9.156</b> <b>NUM_IMAGES</b> <b>(</b> <b>)</b> <b>or</b> <b>NUM_IMAGES</b> <b>(TEAM)</b> <b>or</b>
    <b>NUM_IMAGES</b> <b>(TEAM_NUMBER)</b>
<b>Description.</b> Number of images.
<b>Class.</b> Transformational function.
<b>Arguments.</b>
TEAM shall be a scalar of type TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV, with a
     value that identifies the current or an ancestor team.
TEAM_NUMBER shall be an integer scalar. It shall identify the initial team or a sibling team of the current
     team.
<b>Result</b> <b>Characteristics.</b> Default integer scalar.
<b>Result</b> <b>Value.</b> The number of images in the specified team, or in the current team if no team is specified.
<b>Example.</b> The following code uses image 1 to read data and broadcast it to other images.
   REAL :: P[*]
   IF (THIS_IMAGE()==1) THEN
     READ (6,*) P
     DO I = 2, NUM_IMAGES()
      P[I] = P
     END DO
   END IF
   SYNC ALL
<b>16.9.157</b> <b>OUT_OF_RANGE</b> <b>(X,</b> <b>MOLD</b> <b>[,</b> <b>ROUND])</b>
<b>Description.</b> Whether a value cannot be converted safely.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
X shall be of type integer or real.
MOLD shall be an integer or real scalar. If it is a variable, it need not be defined.
ROUND (optional) shall be a logical scalar. ROUND shall be present only if X is of type real and MOLD is of
     type integer.
<b>Result</b> <b>Characteristics.</b> Default logical.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> If MOLD is of type integer, and ROUND is absent or present with the value false, the result is true
     if and only if the value of X is an IEEE infinity or NaN, or if the integer with largest magnitude
     that lies between zero and X inclusive is not representable by objects with the type and kind of
     MOLD.
<i>Case</i> <i>(ii):</i> If MOLD is of type integer, and ROUND is present with the value true, the result is true if and only
     if the value of X is an IEEE infinity or NaN, or if the integer nearest X, or the integer of greater
     magnitude if two integers are equally near to X, is not representable by objects with the type and
     kind of MOLD.
<i>Case</i> <i>(iii):</i> Otherwise, the result is true if and only if the value of X is an IEEE infinity or NaN that is not
     supported by objects of the type and kind of MOLD, or if X is a finite number and the result of
     rounding the value of X (according to the IEEE rounding mode if appropriate) to the extended
     model for the kind of MOLD has magnitude larger than that of the largest finite number with the
     same sign as X that is representable by objects with the type and kind of MOLD.
<b>Examples.</b> If INT8 is the kind value for an 8-bit binary integer type, OUT_OF_RANGE (-128.5, 0_INT8)
will have the value false and OUT_OF_RANGE (-128.5, 0_INT8, .TRUE.) will have the value true.
<b>NOTE</b>
MOLD is required to be a scalar because the only information taken from it is its type and kind. Allowing
an array MOLD would require that it be conformable with X. ROUND is scalar because allowing an array
rounding mode would have severe performance difficulties on many processors.
<b>16.9.158</b> <b>PACK</b> <b>(ARRAY,</b> <b>MASK</b> <b>[,</b> <b>VECTOR])</b>
<b>Description.</b> Array packed into a vector.
<b>Class.</b> Transformational function.
<b>Arguments.</b>
ARRAY shall be an array of any type.
MASK shall be of type logical and shall be conformable with ARRAY.
VECTOR (optional) shall be of the same type and type parameters as ARRAY and shall have rank one. VEC-
     TOR shall have at least as many elements as there are true elements in MASK. If MASK is scalar
     with the value true, VECTOR shall have at least as many elements as there are in ARRAY.
<b>Result</b> <b>Characteristics.</b> The result is an array of rank one with the same type and type parameters as
ARRAY. If VECTOR is present, the result size is that of VECTOR; otherwise, the result size is the number <i>t</i>
of true elements in MASK unless MASK is scalar with the value true, in which case the result size is the size of
ARRAY.
<b>Result</b> <b>Value.</b> Element <i>i</i> of the result is the element of ARRAY that corresponds to the <i>i</i>
                                           <i>th</i>
                                          true element of
MASK, taking elements in array element order, for <i>i</i> = 1, 2, ..., <i>t</i>. If VECTOR is present and has size <i>n</i> <i>></i> <i>t</i>,
element <i>i</i> of the result has the value VECTOR (<i>i</i>), for <i>i</i> = <i>t</i> + 1, ..., <i>n</i>.
<b>Examples.</b> The nonzero elements of an array M with the value
                  ?
                  ?
                                                      0 0 0
                                                      9 0 0
                                                      0 0 7
                     ?
                     ?
                                   can be "gathered" by the func-
tion PACK. The result of PACK (M, MASK = M/=0) is [9, 7] and the result of PACK (M, M /= 0, VEC-
TOR = [2, 4, 6, 8, 10, 12]) is [9, 7, 6, 8, 10, 12].
<b>16.9.159</b> <b>PARITY</b> <b>(MASK)</b> <b>or</b> <b>PARITY</b> <b>(MASK,</b> <b>DIM)</b>
<b>Description.</b> Array reduced by .NEQV. operation.
<b>Class.</b> Transformational function.
<b>Arguments.</b>
MASK shall be a logical array.
DIM shall be an integer scalar with a value in the range 1 DIM<i>n</i>, where <i>n</i> is the rank of MASK.
<b>Result</b> <b>Characteristics.</b> The result is of type logical with the same kind type parameter as MASK. It is scalar
if DIM does not appear; otherwise, the result has rank <i>n</i>- 1 and shape [<i>d</i>
                                      1
                                 , <i>d</i>
                                        2
                                   , ..., <i>d</i>
                                          DIM-1
                                         , <i>d</i>
                                              DIM+1
                                             , ..., <i>d</i>
                                                   <i>n</i>
                                                ]
where [<i>d</i>
    1
    , <i>d</i>
      2
     , ..., <i>d</i>
         <i>n</i>
         ] is the shape of MASK.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> The result of PARITY (MASK) has the value true if an odd number of the elements of MASK are
     true, and false otherwise.
<i>Case</i> <i>(ii):</i> If MASK has rank one, PARITY (MASK, DIM) is equal to PARITY (MASK). Otherwise, the
     value of element (<i>s</i>
                1
               , <i>s</i>
                  2
                , ..., <i>s</i>
                      DIM-1
                      , <i>s</i>
                          DIM+1
                          , ..., <i>s</i>
                               <i>n</i>
                              ) of PARITY (MASK, DIM) is equal to
     PARITY (MASK (<i>s</i>
                 1
               , <i>s</i>
                  2
                , ..., <i>s</i>
                     DIM-1
                      , :, <i>s</i>
                          DIM+1
                           , ..., <i>s</i>
                               <i>n</i>
                              )).
<b>Examples.</b>
<i>Case</i> <i>(i):</i> The value of PARITY ([T, T, T, F]) is true if T has the value true and F has the value false.
<i>Case</i> <i>(ii):</i> If B is the array
        ?
            <i>T</i> <i>T</i> <i>F</i>
            <i>T</i> <i>T</i> <i>T</i>
            ?
                    , where T has the value true and F has the value false, then
     PARITY (B, DIM=1) has the value [F, F, T] and PARITY (B, DIM=2) has the value [F, T].
<b>16.9.160</b> <b>POPCNT</b> <b>(I)</b>
<b>Description.</b> Number of one bits.
<b>Class.</b> Elemental function.
<b>Argument.</b> I shall be of type integer.
<b>Result</b> <b>Characteristics.</b> Default integer.
<b>Result</b> <b>Value.</b> The result value is equal to the number of one bits in the sequence of bits of I. The model for
the interpretation of an integer value as a sequence of bits is in 16.3.
<b>Examples.</b> POPCNT ([1, 2, 3, 4, 5, 6]) has the value [1, 1, 2, 1, 2, 2].
<b>16.9.161</b> <b>POPPAR</b> <b>(I)</b>
<b>Description.</b> Parity expressed as 0 or 1.
<b>Class.</b> Elemental function.
<b>Argument.</b> I shall be of type integer.
<b>Result</b> <b>Characteristics.</b> Default integer.
<b>Result</b> <b>Value.</b> POPPAR (I) has the value 1 if POPCNT (I) is odd, and 0 if POPCNT (I) is even.
<b>Examples.</b> POPPAR ([1, 2, 3, 4, 5, 6]) has the value [1, 1, 0, 1, 0, 0].
<b>16.9.162</b> <b>PRECISION</b> <b>(X)</b>
<b>Description.</b> Decimal precision of a real model.
<b>Class.</b> Inquiry function.
<b>Argument.</b> X shall be of type real or complex. It may be a scalar or an array.
<b>Result</b> <b>Characteristics.</b> Default integer scalar.
<b>Result</b> <b>Value.</b> The result has the value INT ((<i>p</i>- 1) * LOG10 (<i>b</i>)) + <i>k</i>, where <i>b</i> and <i>p</i> are as defined in 16.4
for the model representing real numbers with the same value for the kind type parameter as X, and where <i>k</i> is 1
if <i>b</i> is an integral power of 10 and 0 otherwise.
<b>Example.</b> PRECISION (X) has the value INT (23 * LOG10 (2.)) = INT (6.92...) = 6 for real X whose model
is as in 16.4, NOTE.
<b>16.9.163</b> <b>PRESENT</b> <b>(A)</b>
<b>Description.</b> Presence of optional argument.
<b>Class.</b> Inquiry function.
<b>Argument.</b> A shall be the name of an optional dummy argument that is accessible in the subprogram in which
the PRESENT function reference appears. There are no other requirements on A.
<b>Result</b> <b>Characteristics.</b> Default logical scalar.
<b>Result</b> <b>Value.</b> The result has the value true if A is present (15.5.2.13) and otherwise has the value false.
<b>16.9.164</b> <b>PREVIOUS</b> <b>(A</b> <b>[,</b> <b>STAT])</b>
<b>Description.</b> Previous enumeration value.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
A shall be of enumeration type.
STAT (optional) shallbeanintegerscalarwithadecimalexponentrangeofatleastfour. ItisanINTENT(OUT)
     argument. If A is equal to the first enumerator of its type, it is assigned a processor-dependent
     positive value; otherwise, it is assigned the value zero. If STAT would have been assigned a nonzero
     value but is not present, error termination is initiated.
<b>Result</b> <b>Characteristics.</b> Same as A.
<b>Result</b> <b>Value.</b> If A is equal to the first enumerator of its type, the value of the result is that of A. Otherwise,
the value of the result is the enumerator preceding the value of A.
<b>Example.</b> If the enumerators of an enumeration type are EN1, EN2, EN3, and EN4, PREVIOUS (EN3) is equal
to EN2, and PREVIOUS (EN1, ISTAT) is equal to EN1 and a positive value is assigned to ISTAT.
<b>16.9.165</b> <b>PRODUCT</b> <b>(ARRAY,</b> <b>DIM</b> <b>[,</b> <b>MASK])</b> <b>or</b>
    <b>PRODUCT</b> <b>(ARRAY</b> <b>[,</b> <b>MASK])</b>
<b>Description.</b> Array reduced by multiplication.
<b>Class.</b> Transformational function.
<b>Arguments.</b>
ARRAY shall be an array of numeric type.
DIM shall be an integer scalar with a value in the range 1 DIM<i>n</i>, where <i>n</i> is the rank of ARRAY.
MASK (optional) shall be of type logical and shall be conformable with ARRAY.
<b>Result</b> <b>Characteristics.</b> The result is of the same type and kind type parameter as ARRAY. It is scalar if
DIM does not appear; otherwise, the result has rank <i>n</i>- 1 and shape [<i>d</i>
                                   1
                               ,<i>d</i>
                                     2
                                , ..., <i>d</i>
                                       DIM-1
                                      ,<i>d</i>
                                           DIM+1
                                          , ..., <i>d</i>
                                                <i>n</i>
                                             ] where
[<i>d</i>
1
 , <i>d</i>
  2
  , ..., <i>d</i>
      <i>n</i>
      ] is the shape of ARRAY.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> The result of PRODUCT (ARRAY) has a value equal to a processor-dependent approximation to
     the product of all the elements of ARRAY or has the value one if ARRAY has size zero.
<i>Case</i> <i>(ii):</i> The result of PRODUCT (ARRAY, MASK = MASK) has a value equal to a processor-dependent
     approximation to the product of the elements of ARRAY corresponding to the true elements of
     MASK or has the value one if there are no true elements.
<i>Case</i> <i>(iii):</i> If ARRAY has rank one, PRODUCT (ARRAY, DIM = DIM [, MASK = MASK]) has a value equal
     to that of PRODUCT (ARRAY [, MASK = MASK ]). Otherwise, the value of element (<i>s</i>
                                                   1
                                             , <i>s</i>
                                                     2
                                              , ...,
    <i>s</i>
       DIM-1
         , <i>s</i>
           DIM+1
            , ..., <i>s</i>
                <i>n</i>
                ) of PRODUCT (ARRAY, DIM = DIM [, MASK = MASK]) is equal to
        PRODUCT (ARRAY (<i>s</i>
                      1
                   , <i>s</i>
                       2
                     , ..., <i>s</i>
                          DIM-1
                          , :, <i>s</i>
                               DIM+1
                               , ..., <i>s</i>
                                    <i>n</i>
                                  ) [, MASK = MASK (<i>s</i>
                                                   1
                                             , <i>s</i>
                                                     2
                                              , ...,
       <i>s</i>
         DIM-1
           , :, <i>s</i>
               DIM+1
                , ..., <i>s</i>
                    <i>n</i>
                    ) ] ).
<b>Examples.</b>
<i>Case</i> <i>(i):</i> The value of PRODUCT ([1, 2, 3]) is 6.
<i>Case</i> <i>(ii):</i> PRODUCT (C, MASK = C > 0.0) forms the product of the positive elements of C.
<i>Case</i> <i>(iii):</i> If B is the array
        ?
                         1 3 5
                         2 4 6
           ?
                  , PRODUCT (B, DIM = 1) is [2, 12, 30] and PRODUCT (B, DIM = 2)
     is [15, 48].
<b>16.9.166</b> <b>RADIX</b> <b>(X)</b>
<b>Description.</b> Base of a numeric model.
<b>Class.</b> Inquiry function.
<b>Argument.</b> X shall be of type integer or real. It may be a scalar or an array.
<b>Result</b> <b>Characteristics.</b> Default integer scalar.
<b>Result</b> <b>Value.</b> The result has the value <i>r</i> if X is of type integer and the value <i>b</i> if X is of type real, where <i>r</i> and
<i>b</i> are as defined in 16.4 for the model representing numbers of the same type and kind type parameter as X.
<b>Example.</b> RADIX (X) has the value 2 for real X whose model is as in 16.4, NOTE.
<b>16.9.167</b> <b>RANDOM_INIT</b> <b>(REPEATABLE,</b> <b>IMAGE_DISTINCT)</b>
<b>Description.</b> Initialize pseudorandom number generator.
<b>Class.</b> Subroutine.
<b>Arguments.</b>
REPEATABLE shall be a logical scalar. It is an INTENT (IN) argument.
IMAGE_DISTINCT shall be a logical scalar. It is an INTENT (IN) argument.
The effect of calling RANDOM_INIT depends on the values of the REPEATABLE and IMAGE_DISTINCT
arguments:
<i>Case</i> <i>(i):</i> CALL RANDOM_INIT (REPEATABLE=true, IMAGE_DISTINCT=true) is equivalent to invok-
     ing RANDOM_SEED with a processor-dependent value for PUT that is different on every invoking
     image. In each execution of the program with the same execution environment, if the invoking
     image index value in the initial team is the same, the value for PUT shall be the same.
<i>Case</i> <i>(ii):</i> CALL RANDOM_INIT(REPEATABLE=true, IMAGE_DISTINCT=false) is equivalent to invok-
     ing RANDOM_SEED with a processor-dependent value for PUT that is the same on every invoking
     image. In each execution of the program with the same execution environment, the value for PUT
     shall be the same.
<i>Case</i> <i>(iii):</i> CALL RANDOM_INIT(REPEATABLE=false, IMAGE_DISTINCT=true) is equivalent to invok-
     ing RANDOM_SEED with a processor-dependent value for PUT that is different on every invoking
     image. Different values for PUT shall be used for subsequent invocations, and for each execution of
     the program.
<i>Case</i> <i>(iv):</i> CALL RANDOM_INIT(REPEATABLE=false, IMAGE_DISTINCT=false) is equivalent to invok-
     ing RANDOM_SEED with a processor-dependent value for PUT that is the same on every invoking
     image. Different values for PUT shall be used for subsequent invocations, and for each execution of
     the program.
In each of these cases, a different processor-dependent value for PUT shall result in a different sequence of
pseudorandom numbers.
<b>Example.</b> The following statement initializes the pseudorandom number generator of the invoking image so that
the pseudorandom number sequence will differ from that of other images that execute a similar statement, and
will be different on subsequent execution of the program.
   CALL RANDOM_INIT (REPEATABLE=.FALSE., IMAGE_DISTINCT=.TRUE.)
<b>16.9.168</b> <b>RANDOM_NUMBER</b> <b>(HARVEST)</b>
<b>Description.</b> Generate pseudorandom number(s).
<b>Class.</b> Subroutine.
<b>Argument.</b> HARVEST shall be of type real. It is an INTENT (OUT) argument. It may be a scalar or an array.
It is assigned pseudorandom numbers from the uniform distribution in the interval 0<i>x<</i> 1.
<b>Example.</b>
   REAL X, Y (10, 10)
   ! Initialize X with a pseudorandom number
   CALL RANDOM_NUMBER (HARVEST = X)
   CALL RANDOM_NUMBER (Y)
   ! X and Y contain uniformly distributed random numbers
<b>16.9.169</b> <b>RANDOM_SEED</b> <b>([SIZE,</b> <b>PUT,</b> <b>GET])</b>
<b>Description.</b> Pseudorandom number generator control.
<b>Class.</b> Subroutine.
<b>Arguments.</b> There shall either be exactly one or no arguments present.
SIZE (optional) shall be a default integer scalar. It is an INTENT (OUT) argument. It is assigned the number
    <i>N</i> of integers that the processor uses to hold the value of the seed.
PUT (optional) shall be a default integer array of rank one and size <i>N</i>. It is an INTENT (IN) argument. It
     is used in a processor-dependent manner to compute the seed value accessed by the pseudorandom
     number generator.
GET (optional) shall be a default integer array of rank one and size <i>N</i>. It is an INTENT (OUT) argument.
     It is assigned the value of the seed.
If no argument is present, the processor assigns a processor-dependent value to the seed.
The pseudorandom number generator used by RANDOM_NUMBER maintains a seed on each image that is
updatedduringtheexecutionofRANDOM_NUMBERandthatcanberetrievedorchangedbyRANDOM_INIT
or RANDOM_SEED
          1
         . Computation of the seed from the argument PUT is performed in a processor-dependent
manner. The value assigned to GET need not be the same as the value of PUT in an immediately preceding
reference to RANDOM_SEED. For example, following execution of the statements
   CALL RANDOM_SEED (PUT=SEED1)
   CALL RANDOM_SEED (GET=SEED2)
SEED2 need not equal SEED1. When the values differ, the use of either value as the PUT argument in a
subsequentcalltoRANDOM_SEEDshallresultinthesamesequenceofpseudorandomnumbersbeinggenerated.
For example, after execution of the statements
   CALL RANDOM_SEED (PUT=SEED1)
   CALL RANDOM_SEED (GET=SEED2)
   CALL RANDOM_NUMBER (X1)
   CALL RANDOM_SEED (PUT=SEED2)
   CALL RANDOM_NUMBER (X2)
X2 equals X1.
<b>Examples.</b>
   CALL RANDOM_SEED ! Processor-dependent initialization
   CALL RANDOM_SEED (SIZE = K) ! Puts size of seed in K
   CALL RANDOM_SEED (PUT = SEED (1 : K)) ! Define seed
   CALL RANDOM_SEED (GET = OLD (1 : K)) ! Read current seed
 1
 These three procedures only affect the value of the seed on the invoking image.
<b>16.9.170</b> <b>RANGE</b> <b>(X)</b>
<b>Description.</b> Decimal exponent range of a numeric model (16.4).
<b>Class.</b> Inquiry function.
<b>Argument.</b> X shall be of type integer, real, or complex. It may be a scalar or an array.
<b>Result</b> <b>Characteristics.</b> Default integer scalar.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> If X is of type integer, the result has the value INT (LOG10 (HUGE (X))).
<i>Case</i> <i>(ii):</i> IfXisoftypereal, theresulthasthevalueINT(MIN(LOG10(HUGE(X)),-LOG10(TINY(X)))).
<i>Case</i> <i>(iii):</i> If X is of type complex, the result has the value RANGE (REAL (X)).
<b>Examples.</b> RANGE (X) has the value 38 for real X whose model is as in 16.4, NOTE, because in this case
HUGE (X) = (1- 2
     -24
                  )x 2
              127
              and TINY (X) = 2
              -127
                        .
<b>16.9.171</b> <b>RANK</b> <b>(A)</b>
<b>Description.</b> Rank of a data object.
<b>Class.</b> Inquiry function.
<b>Argument.</b> A shall be a data object of any type.
<b>Result</b> <b>Characteristics.</b> Default integer scalar.
<b>Result</b> <b>Value.</b> The value of the result is the rank of A.
<b>Example.</b> If X is an assumed-rank dummy argument and its associated effective argument is an array of rank
3, RANK(X) has the value 3.
<b>16.9.172</b> <b>REAL</b> <b>(A</b> <b>[,</b> <b>KIND])</b>
<b>Description.</b> Conversion to real type.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
A shall be of type integer, real, or complex, or a <i>boz-literal-constant</i>.
KIND (optional) shall be a scalar integer constant expression.
<b>Result</b> <b>Characteristics.</b> Real.
<i>Case</i> <i>(i):</i> If A is of type integer or real and KIND is present, the kind type parameter is that specified by the
     value of KIND. If A is of type integer or real and KIND is not present, the kind type parameter is
     that of default real kind.
<i>Case</i> <i>(ii):</i> If A is of type complex and KIND is present, the kind type parameter is that specified by the value
     of KIND. If A is of type complex and KIND is not present, the kind type parameter is the kind
     type parameter of A.
<i>Case</i> <i>(iii):</i> If A is a <i>boz-literal-constant</i> and KIND is present, the kind type parameter is that specified by the
     value of KIND. If A is a <i>boz-literal-constant</i> and KIND is not present, the kind type parameter is
     that of default real kind.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> If A is of type integer or real, the result is equal to a processor-dependent approximation to A.
<i>Case</i> <i>(ii):</i> If A is of type complex, the result is equal to a processor-dependent approximation to the real part
     of A.
<i>Case</i> <i>(iii):</i> If A is a <i>boz-literal-constant</i>, the value of the result is the value whose internal representation as a
     bit sequence is the same as that of A as modified by padding or truncation according to 16.3.3. The
     interpretation of the bit sequence is processor dependent.
<b>Examples.</b> REAL (-3) has the value-3.0. REAL (Z) has the same kind type parameter and the same value
as the real part of the complex variable Z.
<b>16.9.173</b> <b>REDUCE</b> <b>(ARRAY,</b> <b>OPERATION</b> <b>[,</b> <b>MASK,</b> <b>IDENTITY,</b> <b>ORDERED])</b> <b>or</b>
    <b>REDUCE</b> <b>(ARRAY,</b> <b>OPERATION,</b> <b>DIM</b> <b>[,</b> <b>MASK,</b> <b>IDENTITY,</b>
    <b>ORDERED])</b>
<b>Description.</b> General reduction of array.
<b>Class.</b> Transformational function.
<b>Arguments.</b>
ARRAY shall be an array of any type.
OPERATION shall be a pure function with exactly two arguments; each argument shall be a scalar, nonalloc-
     atable, noncoarray, nonpointer, nonpolymorphic, nonoptional dummy data object with the same
     declared type and type parameters as ARRAY. If one argument has the ASYNCHRONOUS, TAR-
     GET, or VALUE attribute, the other shall have that attribute. Its result shall be a nonpolymorphic
     scalar and have the same declared type and type parameters as ARRAY. OPERATION should
     implement a mathematically associative operation. It need not be commutative.
DIM shall be an integer scalar with a value in the range 1 DIM<i>n</i>, where <i>n</i> is the rank of ARRAY.
MASK (optional) shall be of type logical and shall be conformable with ARRAY.
IDENTITY (optional) shall be scalar with the same declared type and type parameters as ARRAY.
ORDERED (optional) shall be a logical scalar.
<b>Result</b> <b>Characteristics.</b> The result is of the same declared type and type parameters as ARRAY. It is scalar
if DIM does not appear; otherwise, the result has rank <i>n</i>- 1 and shape [<i>d</i>
                                      1
                                 , <i>d</i>
                                        2
                                   , ..., <i>d</i>
                                          DIM-1
                                         , <i>d</i>
                                              DIM+1
                                             , ..., <i>d</i>
                                                   <i>n</i>
                                                ]
where [<i>d</i>
    1
    , <i>d</i>
      2
     , ..., <i>d</i>
         <i>n</i>
         ] is the shape of ARRAY.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> The result of REDUCE (ARRAY, OPERATION [, IDENTITY = IDENTITY, ORDERED =
     ORDERED]) over the sequence of values in ARRAY is the result of an iterative process. The
     initial order of the sequence is array element order. While the sequence has more than one element,
     each iteration involves the execution of<i>r</i> = OPERATION(<i>x</i>,<i>y</i>) for adjacent<i>x</i> and<i>y</i> in the sequence,
     with <i>x</i> immediately preceding <i>y</i>, and the subsequent replacement of <i>x</i> and <i>y</i> with <i>r</i>; if ORDERED
     is present with the value true, <i>x</i> and <i>y</i> shall be the first two elements of the sequence. The process
     continues until the sequence has only one element which is the value of the reduction. If the initial
     sequence is empty, the result has the value IDENTITY if IDENTITY is present, and otherwise,
     error termination is initiated.
<i>Case</i> <i>(ii):</i> The result of REDUCE (ARRAY, OPERATION, MASK = MASK [, IDENTITY = IDENTITY,
     ORDERED = ORDERED]) is as for Case (i) except that the initial sequence is only those elements
     of ARRAY for which the corresponding elements of MASK are true.
<i>Case</i> <i>(iii):</i> If ARRAY has rank one, REDUCE (ARRAY, OPERATION, DIM = DIM [, MASK = MASK,
     IDENTITY = IDENTITY, ORDERED = ORDERED]) has a value equal to that of REDUCE (AR-
     RAY, OPERATION [, MASK = MASK, IDENTITY = IDENTITY, ORDERED = ORDERED]).
     Otherwise, thevalueofelement(<i>s</i>
                       1
                    ,<i>s</i>
                         2
                      , ...,<i>s</i>
                           DIM-1
                            ,<i>s</i>
                               DIM+1
                               , ...,<i>s</i>
                                    <i>n</i>
                                   )ofREDUCE(ARRAY,OPER-
     ATION, DIM = DIM [, MASK = MASK, IDENTITY = IDENTITY, ORDERED = ORDERED])
     is equal to
        REDUCE (ARRAY (<i>s</i>
                     1
                  , <i>s</i>
                       2
                    , ..., <i>s</i>
                         DIM-1
                          , :, <i>s</i>
                              DIM+1
                              , ..., <i>s</i>
                                   <i>n</i>
                                  ),
             OPERATION = OPERATION,
             DIM=1
             [, MASK = MASK (<i>s</i>
                          1
                       , <i>s</i>
                            2
                         , ..., <i>s</i>
                              DIM-1
                              , :, <i>s</i>
                                   DIM+1
                                   , ..., <i>s</i>
                                        <i>n</i>
                                       ),
             IDENTITY = IDENTITY,
             ORDERED = ORDERED] ).
<b>Examples.</b> The following examples all use the function MY_MULT, which returns the product of its two integer
arguments.
<i>Case</i> <i>(i):</i> The value of REDUCE ([1, 2, 3], MY_MULT) is 6.
<i>Case</i> <i>(ii):</i> REDUCE (C, MY_MULT, MASK= C > 0, IDENTITY=1) forms the product of the positive
     elements of C.
<i>Case</i> <i>(iii):</i> If B is the array
        ?
                         1 3 5
                         2 4 6
           ?
                  , REDUCE (B, MY_MULT, DIM = 1) is [2, 12, 30] and REDUCE (B,
     MY_MULT, DIM = 2) is [15, 48].
<b>NOTE</b>
If OPERATION is not computationally associative, REDUCE without ORDERED=.TRUE. with the same
argument values might not always produce the same result, as the processor can apply the associative law to
the evaluation.
<b>16.9.174</b> <b>REPEAT</b> <b>(STRING,</b> <b>NCOPIES)</b>
<b>Description.</b> Repetitive string concatenation.
<b>Class.</b> Transformational function.
<b>Arguments.</b>
STRING shall be a character scalar.
NCOPIES shall be an integer scalar. Its value shall not be negative.
<b>Result</b> <b>Characteristics.</b> Character scalar of length NCOPIES times that of STRING, with the same kind type
parameter as STRING.
<b>Result</b> <b>Value.</b> The value of the result is the concatenation of NCOPIES copies of STRING.
<b>Examples.</b> REPEAT ('H', 2) has the value HH. REPEAT ('XYZ', 0) has the value of a zero-length string.
<b>16.9.175</b> <b>RESHAPE</b> <b>(SOURCE,</b> <b>SHAPE</b> <b>[,</b> <b>PAD,</b> <b>ORDER])</b>
<b>Description.</b> Arbitrary shape array construction.
<b>Class.</b> Transformational function.
<b>Arguments.</b>
SOURCE shall be an array of any type. If PAD is absent or of size zero, the size of SOURCE shall be greater
     than or equal to PRODUCT (SHAPE). The size of the result is the product of the values of the
     elements of SHAPE.
SHAPE shall be a rank-one integer array. SIZE (<i>x</i>), where <i>x</i> is the actual argument corresponding to
     SHAPE, shall be a constant expression whose value is positive and less than 16. It shall not have
     an element whose value is negative.
PAD (optional) shall be an array of the same type and type parameters as SOURCE.
ORDER (optional) shall be of type integer, shall have the same shape as SHAPE, and its value shall be a
     permutation of (1, 2, ..., <i>n</i>), where <i>n</i> is the size of SHAPE. If absent, it is as if it were present with
     value (1, 2, ..., <i>n</i>).
<b>Result</b> <b>Characteristics.</b> The result is an array of shape SHAPE (that is, SHAPE (RESHAPE (SOURCE,
SHAPE, PAD, ORDER)) is equal to SHAPE) with the same type and type parameters as SOURCE.
<b>Result</b> <b>Value.</b> The elements of the result, taken in permuted subscript order ORDER (1), ..., ORDER (<i>n</i>), are
those of SOURCE in normal array element order followed if necessary by those of PAD in array element order,
followed if necessary by additional copies of PAD in array element order.
<b>Examples.</b> RESHAPE ([1, 2, 3, 4, 5, 6], [2, 3]) has the value
                 ?
                                                   1 3 5
                                                   2 4 6
                    ?
                                .
RESHAPE ([1, 2, 3, 4, 5, 6], [2, 4], [0, 0], [2, 1]) has the value
                 ?
                                                   1 2 3 4
                                                   5 6 0 0
                     ?
                                  .
<b>16.9.176</b> <b>RRSPACING</b> <b>(X)</b>
<b>Description.</b> Reciprocal of relative spacing of model numbers.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has the value|Yx<i>b</i>
            -<i>e</i>
          |x<i>b</i>
                        <i>p</i>
                                           = ABS (FRACTION (Y)) * RADIX (X) / EPSILON (X),
where <i>b</i>, <i>e</i>, and <i>p</i> are as defined in 16.4 for Y, the value nearest to X in the model for real values whose kind type
parameter is that of X; if there are two such values, the value of greater absolute value is taken. If X is an IEEE
infinity, the result is an IEEE NaN. If X is an IEEE NaN, the result is that NaN.
<b>Example.</b> RRSPACING (-3.0) has the value 0<i>.</i>75x 2
                           24
                         for reals whose model is as in 16.4, NOTE.
<b>16.9.177</b> <b>SAME_TYPE_AS</b> <b>(A,</b> <b>B)</b>
<b>Description.</b> Dynamic type equality test.
<b>Class.</b> Inquiry function.
<b>Arguments.</b>
A shall be an object of extensible declared type or unlimited polymorphic. If it is a polymorphic
     pointer, it shall not have an undefined association status.
B shall be an object of extensible declared type or unlimited polymorphic. If it is a polymorphic
     pointer, it shall not have an undefined association status.
<b>Result</b> <b>Characteristics.</b> Default logical scalar.
<b>Result</b> <b>Value.</b> If the dynamic type of A or B is extensible, the result is true if and only if the dynamic type of
A is the same as the dynamic type of B. If neither A nor B has extensible dynamic type, the result is processor
dependent.
<b>NOTE</b> <b>1</b>
Thedynamictypeofadisassociatedpointerorunallocatedallocatablevariableisitsdeclaredtype. Anunlimited
polymorphic entity has no declared type.
<b>NOTE</b> <b>2</b>
The test performed by SAME_TYPE_AS is not the same as the test performed by the type guard TYPE IS.
The test performed by SAME_TYPE_AS does not consider kind type parameters.
<b>Example.</b> Given the declarations and assignments
   TYPE T1
     REAL C
   END TYPE
   TYPE, EXTENDS(T1) :: T2
   END TYPE
   CLASS(T1), POINTER :: P, Q, R
   ALLOCATE(P, Q)
   ALLOCATE(T2 :: R)
the value of SAME_TYPE_AS (P, Q) will be true, and the value of SAME_TYPE_AS (P, R) will be false.
<b>16.9.178</b> <b>SCALE</b> <b>(X,</b> <b>I)</b>
<b>Description.</b> Real number scaled by radix power.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
X shall be of type real.
I shall be of type integer.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has the value Xx<i>b</i>
                      I
                    , where <i>b</i> is defined in 16.4 for model numbers representing values
of X, provided this result is representable; if not, the result is processor dependent.
<b>Example.</b> SCALE (3.0, 2) has the value 12.0 for reals whose model is as in 16.4, NOTE.
<b>16.9.179</b> <b>SCAN</b> <b>(STRING,</b> <b>SET</b> <b>[,</b> <b>BACK,</b> <b>KIND])</b>
<b>Description.</b> Character set membership search.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
STRING shall be of type character.
SET shall be of type character with the same kind type parameter as STRING.
BACK (optional) shall be of type logical.
KIND (optional) shall be a scalar integer constant expression.
<b>Result</b> <b>Characteristics.</b> Integer. If KIND is present, the kind type parameter is that specified by the value of
KIND; otherwise the kind type parameter is that of default integer type.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> If BACK is absent or is present with the value false and if STRING contains at least one character
     that is in SET, the value of the result is the position of the leftmost character of STRING that is
     in SET.
<i>Case</i> <i>(ii):</i> If BACK is present with the value true and if STRING contains at least one character that is in
     SET, the value of the result is the position of the rightmost character of STRING that is in SET.
<i>Case</i> <i>(iii):</i> The value of the result is zero if no character of STRING is in SET or if the length of STRING or
     SET is zero.
<b>Examples.</b>
<i>Case</i> <i>(i):</i> SCAN ('FORTRAN', 'TR') has the value 3.
<i>Case</i> <i>(ii):</i> SCAN ('FORTRAN', 'TR', BACK = .TRUE.) has the value 5.
<i>Case</i> <i>(iii):</i> SCAN ('FORTRAN', 'BCD') has the value 0.
<b>16.9.180</b> <b>SELECTED_CHAR_KIND</b> <b>(NAME)</b>
<b>Description.</b> Character kind selection.
<b>Class.</b> Transformational function.
<b>Argument.</b> NAME shall be default character scalar.
<b>Result</b> <b>Characteristics.</b> Default integer scalar.
<b>Result</b> <b>Value.</b> If NAME has the value DEFAULT, then the result has a value equal to that of the kind type
parameter of default character. If NAME has the value ASCII, then the result has a value equal to that of the
kind type parameter of ASCII character if the processor supports such a kind; otherwise the result has the value
-1. If NAME has the value ISO_10646, then the result has a value equal to that of the kind type parameter of
the ISO 10646 character kind (corresponding to UCS-4 as specified in ISO/IEC 10646) if the processor supports
such a kind; otherwise the result has the value-1. If NAME is a processor-defined name of some other character
kind supported by the processor, then the result has a value equal to that kind type parameter value. If NAME is
not the name of a supported character type, then the result has the value-1. The NAME is interpreted without
respect to case or trailing blanks.
<b>Examples.</b> SELECTED_CHAR_KIND ('ASCII') has the value 1 on a processor that uses 1 as the kind type
parameter for the ASCII character set. The following subroutine produces a Japanese date stamp.
    SUBROUTINE create_date_string(string)
     INTRINSIC date_and_time,selected_char_kind
     INTEGER,PARAMETER :: ucs4 = selected_char_kind("ISO_10646")
     CHARACTER(1,UCS4),PARAMETER :: nen=CHAR(INT(Z'5e74'),UCS4), & !year
      gatsu=CHAR(INT(Z'6708'),UCS4), & !month
      nichi=CHAR(INT(Z'65e5'),UCS4) !day
     CHARACTER(len= *, kind= ucs4) string
     INTEGER values(8)
     CALL date_and_time(values=values)
     WRITE(string,1) values(1),nen,values(2),gatsu,values(3),nichi
    1 FORMAT(I0,A,I0,A,I0,A)
    END SUBROUTINE
<b>16.9.181</b> <b>SELECTED_INT_KIND</b> <b>(R)</b>
<b>Description.</b> Integer kind selection.
<b>Class.</b> Transformational function.
<b>Argument.</b> R shall be an integer scalar.
<b>Result</b> <b>Characteristics.</b> Default integer scalar.
<b>Result</b> <b>Value.</b> The result has a value equal to the value of the kind type parameter of an integer type that
represents all values <i>n</i> in the range-10
                   R
                <i><</i> <i>n</i> <i><</i> 10
                         R
                        , or if no such kind type parameter is available on the
processor, the result is-1. If more than one kind type parameter meets the criterion, the value returned is the
one with the smallest decimal exponent range, unless there are several such values, in which case the smallest of
these kind values is returned.
<b>Example.</b> Assume a processor supports two integer kinds, 32 with representation method <i>r</i> = 2 and <i>q</i> = 31,
and 64 with representation method <i>r</i> = 2 and <i>q</i> = 63. On this processor SELECTED_INT_KIND (9) has the
value 32 and SELECTED_INT_KIND (10) has the value 64.
<b>16.9.182</b> <b>SELECTED_LOGICAL_KIND</b> <b>(BITS)</b>
<b>Description.</b> Logical kind selection.
<b>Class.</b> Transformational function.
<b>Argument.</b> BITS shall be an integer scalar.
<b>Result</b> <b>Characteristics.</b> Default integer scalar.
<b>Result</b> <b>Value.</b> The result has a value equal to the value of the kind type parameter of a logical type whose
storage size in bits is at least BITS, or if no such kind type parameter is available on the processor, the result is
-1. If more than one kind type parameter meets the criterion, the value returned is the one with the smallest
storage size, unless there are several such values, in which case the smallest of these kind values is returned.
<b>Example.</b> Assume a processor supports four logical kinds with kind type parameter values 8, 16, 32, and 64 for
representations with those storage sizes. On this processor, SELECTED_LOGICAL_KIND (1) has the value 8,
SELECTED_LOGICAL_KIND (12) has the value 16, and SELECTED_LOGICAL_KIND (128) has the value
-1.
<b>16.9.183</b> <b>SELECTED_REAL_KIND</b> <b>([P,</b> <b>R,</b> <b>RADIX])</b>
<b>Description.</b> Real kind selection.
<b>Class.</b> Transformational function.
<b>Arguments.</b> At least one argument shall be present.
P (optional) shall be an integer scalar.
R (optional) shall be an integer scalar.
RADIX (optional) shall be an integer scalar.
<b>Result</b> <b>Characteristics.</b> Default integer scalar.
<b>Result</b> <b>Value.</b> If P or R is absent, the result value is the same as if it were present with the value zero. If
RADIX is absent, there is no requirement on the radix of the selected kind.
The result has a value equal to a value of the kind type parameter of a real type with decimal precision, as
returned by the function PRECISION, of at least P digits, a decimal exponent range, as returned by the function
RANGE, of at least R, and a radix, as returned by the function RADIX, of RADIX, if such a kind type parameter
is available on the processor.
Otherwise, the result is-1 if the processor supports a real type with radix RADIX and exponent range of at least
R but not with precision of at least P,-2 if the processor supports a real type with radix RADIX and precision of
at least P but not with exponent range of at least R,-3 if the processor supports a real type with radix RADIX
but with neither precision of at least P nor exponent range of at least R,-4 if the processor supports a real type
with radix RADIX and either precision of at least P or exponent range of at least R but not both together, and
-5 if the processor supports no real type with radix RADIX.
If more than one kind type parameter value meets the criteria, the value returned is the one with the smallest
decimal precision, unless there are several such values, in which case the smallest of these kind values is returned.
<b>Example.</b> SELECTED_REAL_KIND (6, 70) has the value KIND (0.0) on a machine that supports a default
real approximation method with <i>b</i> = 16, <i>p</i> = 6, <i>e</i>
                        min
                        =-64, and <i>e</i>
                                max
                                = 63 and does not have a less precise
approximation method.
<b>16.9.184</b> <b>SET_EXPONENT</b> <b>(X,</b> <b>I)</b>
<b>Description.</b> Real value with specified exponent.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
X shall be of type real.
I shall be of type integer.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> If X has the value zero, the result has the same value as X. If X is an IEEE infinity, the result is
an IEEE NaN. If X is an IEEE NaN, the result is the same NaN. Otherwise, the result has the value Xx<i>b</i>
                                                   I-<i>e</i>
                                                ,
where <i>b</i> and <i>e</i> are as defined in 16.4 for the representation for the value of X in the extended real model for the
kind of X.
<b>Example.</b> SET_EXPONENT (3.0, 1) has the value 1.5 for reals whose model is as in 16.4, NOTE.
<b>16.9.185</b> <b>SHAPE</b> <b>(SOURCE</b> <b>[,</b> <b>KIND])</b>
<b>Description.</b> Shape of an array or a scalar.
<b>Class.</b> Inquiry function.
<b>Arguments.</b>
SOURCE may be of any type. It shall not be an unallocated allocatable variable or a pointer that is not
     associated. It shall not be an assumed-size array.
KIND (optional) shall be a scalar integer constant expression.
<b>Result</b> <b>Characteristics.</b> Integer. If KIND is present, the kind type parameter is that specified by the value
of KIND; otherwise the kind type parameter is that of default integer type. The result is an array of rank one
whose size is equal to the rank of SOURCE.
<b>Result</b> <b>Value.</b> The result has a value whose <i>i</i>
                      <i>th</i>
                      element is equal to the extent of dimension <i>i</i> of SOURCE,
except that if SOURCE is assumed-rank, and associated with an assumed-size array, the last element is equal to
-1.
<b>Examples.</b> The value of SHAPE (A (2:5,-1:1) ) is [4, 3]. The value of SHAPE (3) is the rank-one array of size
zero.
<b>16.9.186</b> <b>SHIFTA</b> <b>(I,</b> <b>SHIFT)</b>
<b>Description.</b> Right shift with fill.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
I shall be of type integer.
SHIFT shall be of type integer. It shall be nonnegative and less than or equal to BIT_SIZE (I).
<b>Result</b> <b>Characteristics.</b> Same as I.
<b>Result</b> <b>Value.</b> The result has the value obtained by shifting the bits of I to the right SHIFT bits and replicating
the leftmost bit of I in the left SHIFT bits.
If SHIFT is zero the result is I. Bits shifted out from the right are lost. The model for the interpretation of an
integer value as a sequence of bits is in 16.3.
<b>Example.</b> SHIFTA (IBSET (0, BIT_SIZE (0)- 1), 2) is equal to SHIFTL (7, BIT_SIZE (0)- 3).
<b>16.9.187</b> <b>SHIFTL</b> <b>(I,</b> <b>SHIFT)</b>
<b>Description.</b> Left shift.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
I shall be of type integer.
SHIFT shall be of type integer. It shall be nonnegative and less than or equal to BIT_SIZE (I).
<b>Result</b> <b>Characteristics.</b> Same as I.
<b>Result</b> <b>Value.</b> The value of the result is ISHFT (I, SHIFT).
<b>Examples.</b> SHIFTL (3, 1) has the value 6.
<b>16.9.188</b> <b>SHIFTR</b> <b>(I,</b> <b>SHIFT)</b>
<b>Description.</b> Right shift.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
I shall be of type integer.
SHIFT shall be of type integer. It shall be nonnegative and less than or equal to BIT_SIZE (I).
<b>Result</b> <b>Characteristics.</b> Same as I.
<b>Result</b> <b>Value.</b> The value of the result is ISHFT (I,-SHIFT).
<b>Examples.</b> SHIFTR (3, 1) has the value 1.
<b>16.9.189</b> <b>SIGN</b> <b>(A,</b> <b>B)</b>
<b>Description.</b> Magnitude of A with the sign of B.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
A shall be of type integer or real.
B shall be of the same type as A.
<b>Result</b> <b>Characteristics.</b> Same as A.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> If B <i>></i> 0, the value of the result is|A|.
<i>Case</i> <i>(ii):</i> If B <i><</i> 0, the value of the result is -|A|.
<i>Case</i> <i>(iii):</i> If B is of type integer and B=0, the value of the result is|A|.
<i>Case</i> <i>(iv):</i> If B is of type real and is zero, then:
     if the processor does not distinguish between positive and negative real zero, or if B is positive
        real zero, the value of the result is|A|;
     if the processor distinguishes between positive and negative real zero, and B is negative real
        zero, the value of the result is -|A|.
<b>Example.</b> SIGN (-3.0, 2.0) has the value 3.0.
<b>16.9.190</b> <b>SIN</b> <b>(X)</b>
<b>Description.</b> Sine function.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real or complex.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has a value equal to a processor-dependent approximation to sin(X). If X is of type
real, it is regarded as a value in radians. If X is of type complex, its real part is regarded as a value in radians.
<b>Example.</b> SIN (1.0) has the value 0.84147098 (approximately).
<b>16.9.191</b> <b>SIND</b> <b>(X)</b>
<b>Description.</b> Degree sine function.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has a value equal to a processor-dependent approximation to the sine of X, which is
regarded as a value in degrees.
<b>Example.</b> SIND (180.0) has the value 0.0 (approximately).
<b>16.9.192</b> <b>SINH</b> <b>(X)</b>
<b>Description.</b> Hyperbolic sine function.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real or complex.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has a value equal to a processor-dependent approximation to sinh(X). If X is of type
complex its imaginary part is regarded as a value in radians.
<b>Example.</b> SINH (1.0) has the value 1.1752012 (approximately).
<b>16.9.193</b> <b>SINPI</b> <b>(X)</b>
<b>Description.</b> Circular sine function.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has a value equal to a processor-dependent approximation to the sine of X, which is
regarded as a value in half-revolutions; thus, SINPI (X) is approximately equal to SIN (Xx).
<b>Example.</b> SINPI (1.0) has the value 0.0 (approximately).
<b>16.9.194</b> <b>SIZE</b> <b>(ARRAY</b> <b>[,</b> <b>DIM,</b> <b>KIND])</b>
<b>Description.</b> Size of an array or one extent.
<b>Class.</b> Inquiry function.
<b>Arguments.</b>
ARRAY shall be assumed-rank or an array. It shall not be an unallocated allocatable variable or a pointer
     that is not associated. If ARRAY is an assumed-size array, DIM shall be present with a value less
     than the rank of ARRAY.
DIM (optional) shall be an integer scalar with a value in the range 1 DIM<i>n</i>, where<i>n</i> is the rank of ARRAY.
KIND (optional) shall be a scalar integer constant expression.
<b>Result</b> <b>Characteristics.</b> Integer scalar. If KIND is present, the kind type parameter is that specified by the
value of KIND; otherwise the kind type parameter is that of default integer type.
<b>Result</b> <b>Value.</b> If DIM is present, the result has a value equal to the extent of dimension DIM of ARRAY, except
that if ARRAY is assumed-rank and associated with an assumed-size array and DIM is present with a value equal
to the rank of ARRAY, the value is-1.
If DIM is absent and ARRAY is assumed-rank, the result has a value equal to PRODUCT(SHAPE(ARRAY,
KIND)). Otherwise, the result has a value equal to the total number of elements of ARRAY.
<b>Examples.</b> The value of SIZE (A (2:5,-1:1), DIM=2) is 3. The value of SIZE (A (2:5,-1:1)) is 12.
<b>NOTE</b>
If ARRAY is assumed-rank and has rank zero, DIM cannot be present since it cannot satisfy the requirement
1 DIM 0.
<b>16.9.195</b> <b>SPACING</b> <b>(X)</b>
<b>Description.</b> Spacing of model numbers.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> If X does not have the value zero and is not an IEEE infinity or NaN, the result has the value
<i>b</i>
<i>e</i>-<i>p</i>
 , where <i>b</i>, <i>e</i>, and <i>p</i> are as defined in 16.4 for the value nearest to X in the model for real values whose kind
type parameter is that of X, provided this result is representable; otherwise, the result is the same as that of
TINY (X). If there are two extended model values equally near to X, the value of greater absolute value is taken.
If X has the value zero, the result is the same as that of TINY (X). If X is an IEEE infinity, the result is an IEEE
NaN. If X is an IEEE NaN, the result is that NaN.
<b>Example.</b> SPACING (3.0) has the value 2
           -22
                    for reals whose model is as in 16.4, NOTE.
<b>16.9.196</b> <b>SPLIT</b> <b>(STRING,</b> <b>SET,</b> <b>POS</b> <b>[,</b> <b>BACK])</b>
<b>Description.</b> Parse a string into tokens, one at a time.
<b>Class.</b> Simple subroutine.
<b>Arguments.</b>
STRING shall be a scalar of type character. It is an INTENT (IN) argument.
SET shall be a scalar of type character with the same kind type parameter as STRING. It is an INTENT
     (IN) argument. Each character in SET is a token delimiter. A sequence of zero or more characters
     in STRING delimited by any token delimiter, or the beginning or end of STRING, comprise a token.
     Thus, two consecutive token delimiters in STRING, or a token delimiter in the first or last character
     of STRING, indicate a token with zero length.
POS shall be an integer scalar. It is an INTENT (INOUT) argument. If BACK is present with the value
     true, the value of POS shall be in the range 0<i><</i> POS LEN (STRING) + 1; otherwise it shall be
     in the range 0 POS LEN (STRING).
     If BACK is absent or is present with the value false, POS is assigned the position of the leftmost
     token delimiter in STRING whose position is greater than POS, or if there is no such character, it
     is assigned a value one greater than the length of STRING. This identifies a token with starting
     position one greater than the value of POS on invocation, and ending position one less than the
     value of POS on return.
     IfBACKispresentwiththevaluetrue, POSisassignedthepositionoftherightmosttokendelimiter
     in STRING whose position is less than POS, or if there is no such character, it is assigned the value
     zero. This identifies a token with ending position one less than the value of POS on invocation, and
     starting position one greater than the value of POS on return.
     If SPLIT is invoked with a value for POS in the range 1 POS LEN (STRING), and the value
     of STRING (POS:POS) is not equal to any character in SET, the token identified by SPLIT will
     not comprise a complete token as described in the description of the SET argument, but rather a
     partial token.
BACK (optional) shall be a logical scalar. It is an INTENT (IN) argument.
<b>Example.</b>
Execution of
   CHARACTER (LEN=:), ALLOCATABLE :: INPUT
   CHARACTER (LEN=2) :: SET = ', '
   INTEGER P
   INPUT = "one,last example"
   P = 0
   DO
     IF (P > LEN (INPUT)) EXIT
     ISTART = P + 1
     CALL SPLIT (INPUT, SET, P)
     IEND = P - 1
     PRINT '(T7,A)', INPUT (ISTART:IEND)
   END DO
will print
   one
   last
   example
<b>16.9.197</b> <b>SPREAD</b> <b>(SOURCE,</b> <b>DIM,</b> <b>NCOPIES)</b>
<b>Description.</b> Value replicated in a new dimension.
<b>Class.</b> Transformational function.
<b>Arguments.</b>
SOURCE shall be a scalar or array of any type. The rank of SOURCE shall be less than 15.
DIM shall be an integer scalar with value in the range 1 DIM<i>n</i>+1, where<i>n</i> is the rank of SOURCE.
NCOPIES shall be an integer scalar.
<b>Result</b> <b>Characteristics.</b> The result is an array of the same type and type parameters as SOURCE and of rank
<i>n</i> + 1, where <i>n</i> is the rank of SOURCE.
<i>Case</i> <i>(i):</i> If SOURCE is scalar, the shape of the result is (MAX (NCOPIES, 0)).
<i>Case</i> <i>(ii):</i> If SOURCE is an array with shape [<i>d</i>
                         1
                      , <i>d</i>
                           2
                        , ..., <i>d</i>
                             <i>n</i>
                            ], the shape of the result is [<i>d</i>
                                               1
                                         , <i>d</i>
                                                 2
                                           , ..., <i>d</i>
                                                  DIM-1
                                                ,
     MAX (NCOPIES, 0), <i>d</i>
                 DIM
                 , ..., <i>d</i>
                      <i>n</i>
                     ].
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> If SOURCE is scalar, each element of the result has a value equal to SOURCE.
<i>Case</i> <i>(ii):</i> If SOURCE is an array, the element of the result with subscripts (<i>r</i>
                                         1
                                    , <i>r</i>
                                           2
                                     , ..., <i>r</i>
                                           <i>n</i>+1
                                          ) has the value
     SOURCE (<i>r</i>
             1
           , <i>r</i>
              2
             , ..., <i>r</i>
                 DIM-1
                  , <i>r</i>
                     DIM+1
                      , ..., <i>r</i>
                           <i>n</i>+1
                           ).
<b>Examples.</b> If A is the array [2, 3, 4], SPREAD (A, DIM=1, NCOPIES=NC) is the array
                         ?
                         ?
                                                                           2 3 4
                                                                           2 3 4
                                                                           2 3 4
                            ?
                            ?
                                              if NC
has the value 3 and is a zero-sized array if NC has the value 0.
<b>16.9.198</b> <b>SQRT</b> <b>(X)</b>
<b>Description.</b> Square root.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real or complex. If X is real, its value shall be greater than or equal to zero.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has a value equal to a processor-dependent approximation to the square root of X. A
result of type complex is the principal value with the real part greater than or equal to zero. When the real part
of the result is zero, the imaginary part has the same sign as the imaginary part of X.
<b>Example.</b> SQRT (4.0) has the value 2.0 (approximately).
<b>16.9.199</b> <b>STOPPED_IMAGES</b> <b>([TEAM,</b> <b>KIND])</b>
<b>Description.</b> Indices of stopped images.
<b>Class.</b> Transformational function.
<b>Arguments.</b>
TEAM (optional) shall be a scalar of type TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV,
     whose value identifies the current or an ancestor team. If TEAM is absent the team specified is the
     current team.
KIND (optional) shall be a scalar integer constant expression.
<b>Result</b> <b>Characteristics.</b> Integer. If KIND is present, the kind type parameter is that specified by the value
of KIND; otherwise, the kind type parameter is that of default integer type. The result is an array of rank one
whose size is equal to the number of images in the specified team that have initiated normal termination.
<b>Result</b> <b>Value.</b> The elements of the result are the values of the indices of the images that are known to have
initiated normal termination in the specified team, in numerically increasing order. If the executing image has
previously executed an image control statement whose STAT= specifier assigned the value STAT_STOPPED_-
IMAGE from the intrinsic module ISO_FORTRAN_ENV or invoked a collective subroutine whose STAT argu-
ment was assigned STAT_STOPPED_IMAGE, at least one of the images participating in that image control
statement or collective invocation shall be known to have initiated normal termination.
<b>Examples.</b> If image 3 is the only image in the current team that is known to have initiated normal termination,
STOPPED_IMAGES() will have the value [3]. If there are no images in the current team that have initiated
normal termination, the value of STOPPED_IMAGES() will be a zero-sized array.
<b>16.9.200</b> <b>STORAGE_SIZE</b> <b>(A</b> <b>[,</b> <b>KIND])</b>
<b>Description.</b> Storage size in bits.
<b>Class.</b> Inquiry function.
<b>Arguments.</b>
A shall be a data object of any type. If it is polymorphic it shall not be an undefined pointer. If
     it is unlimited polymorphic or has any deferred type parameters, it shall not be an unallocated
     allocatable variable or a disassociated or undefined pointer.
KIND (optional) shall be a scalar integer constant expression.
<b>Result</b> <b>Characteristics.</b> Integer scalar. If KIND is present, the kind type parameter is that specified by the
value of KIND; otherwise, the kind type parameter is that of default integer type.
<b>Result</b> <b>Value.</b> The result value is the size expressed in bits for an element of an array that has the dynamic
type and type parameters of A. If the type and type parameters are such that storage association (19.5.3) applies,
the result is consistent with the named constants defined in the intrinsic module ISO_FORTRAN_ENV.
<b>NOTE</b> <b>1</b>
An array element might take more bits to store than an isolated scalar, since any hardware-imposed alignment
requirements for array elements might not apply to a simple scalar variable.
<b>NOTE</b> <b>2</b>
This is intended to be the size in memory that an object takes when it is stored; this might differ from the
size it takes during expression handling (which might be the native register size) or when stored in a file. If an
object is never stored in memory but only in a register, this function nonetheless returns the size it would take
if it were stored in memory.
<b>Example.</b> STORAGE_SIZE (1.0) has the same value as the named constant NUMERIC_STORAGE_SIZE in
the intrinsic module ISO_FORTRAN_ENV.
<b>16.9.201</b> <b>SUM</b> <b>(ARRAY,</b> <b>DIM</b> <b>[,</b> <b>MASK])</b> <b>or</b> <b>SUM</b> <b>(ARRAY</b> <b>[,</b> <b>MASK])</b>
<b>Description.</b> Array reduced by addition.
<b>Class.</b> Transformational function.
<b>Arguments.</b>
ARRAY shall be an array of numeric type.
DIM shall be an integer scalar with a value in the range 1 DIM<i>n</i>, where <i>n</i> is the rank of ARRAY.
MASK (optional) shall be of type logical and shall be conformable with ARRAY.
<b>Result</b> <b>Characteristics.</b> The result is of the same type and kind type parameter as ARRAY. It is scalar if
DIM does not appear; otherwise, the result has rank <i>n</i>- 1 and shape [<i>d</i>
                                   1
                               ,<i>d</i>
                                     2
                                , ..., <i>d</i>
                                       DIM-1
                                      ,<i>d</i>
                                           DIM+1
                                          , ..., <i>d</i>
                                                <i>n</i>
                                             ] where
[<i>d</i>
1
 , <i>d</i>
  2
  , ..., <i>d</i>
      <i>n</i>
      ] is the shape of ARRAY.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> The result of SUM (ARRAY) has a value equal to a processor-dependent approximation to the sum
     of all the elements of ARRAY or has the value zero if ARRAY has size zero.
<i>Case</i> <i>(ii):</i> The result of SUM (ARRAY, MASK = MASK) has a value equal to a processor-dependent approx-
     imation to the sum of the elements of ARRAY corresponding to the true elements of MASK or has
     the value zero if there are no true elements.
<i>Case</i> <i>(iii):</i> If ARRAY has rank one, SUM (ARRAY, DIM = DIM [, MASK = MASK]) has a value equal to that
     of SUM (ARRAY [,MASK = MASK ]). Otherwise, the value of element (<i>s</i>
                                           1
                                      ,<i>s</i>
                                             2
                                       , ...,<i>s</i>
                                              DIM-1
                                             ,<i>s</i>
                                                  DIM+1
                                                ,
     ..., <i>s</i>
        <i>n</i>
        ) of SUM (ARRAY, DIM = DIM [ , MASK = MASK]) is equal to
        SUM (ARRAY (<i>s</i>
                  1
                ,<i>s</i>
                    2
                  , ...,<i>s</i>
                       DIM-1
                       , :,<i>s</i>
                           DIM+1
                            , ...,<i>s</i>
                                 <i>n</i>
                               ) [, MASK= MASK (<i>s</i>
                                               1
                                         ,<i>s</i>
                                                 2
                                           , ...,<i>s</i>
                                                  DIM-1
                                                ,
        :, <i>s</i>
          DIM+1
            , ..., <i>s</i>
                <i>n</i>
                ) ] ).
<b>Examples.</b>
<i>Case</i> <i>(i):</i> The value of SUM ([1, 2, 3]) is 6.
<i>Case</i> <i>(ii):</i> SUM (C, MASK= C > 0.0) forms the sum of the positive elements of C.
<i>Case</i> <i>(iii):</i> If B is the array
        ?
                         1 3 5
                         2 4 6
           ?
                  , SUM (B, DIM = 1) is [3<i>,</i> 7<i>,</i> 11] and SUM (B, DIM = 2) is [9<i>,</i> 12].
<b>16.9.202</b> <b>SYSTEM_CLOCK</b> <b>([COUNT,</b> <b>COUNT_RATE,</b> <b>COUNT_MAX])</b>
<b>Description.</b> Query system clock.
<b>Class.</b> Subroutine.
<b>Arguments.</b>
COUNT (optional) shall be an integer scalar with a decimal exponent range no smaller than that of default
     integer. It is an INTENT (OUT) argument. It is assigned a processor-dependent value based on
     the value of a processor clock, or-HUGE (COUNT) if there is no clock for the invoking image. The
     processor-dependent value is incremented by one for each clock count until the value COUNT_-
     MAX is reached and is reset to zero at the next count. It lies in the range 0 to COUNT_MAX if
     there is a clock.
COUNT_RATE (optional) shall be an integer or real scalar. If it is of type integer, it shall have a decimal
     exponent range no smaller than that of default integer. It is an INTENT (OUT) argument. It is
     assigned a processor-dependent approximation to the number of processor clock counts per second,
     or zero if there is no clock for the invoking image.
COUNT_MAX (optional) shallbeanintegerscalarwithadecimalexponentrangenosmallerthanthatofdefault
     integer. It is an INTENT (OUT) argument. It is assigned the maximum value that COUNT can
     have, or zero if there is no clock for the invoking image.
In a reference to SYSTEM_CLOCK, all integer arguments shall have the same kind type parameter.
Whether an image has no clock, has one or more clocks of its own, or shares a clock with another image, is
processor dependent.
If more than one clock is available, the types and kinds of the arguments to SYSTEM_CLOCK determine which
clock is accessed. The processor should document the relationship between the clock selection and the argument
characteristics.
Different invocations of SYSTEM_CLOCK should use the same types and kinds for the arguments, to ensure
that any timing calculations are based on the same clock.
It it recommended that all references to SYSTEM_CLOCK use integer arguments with a decimal exponent range
of at least 18. This lets the processor select the most accurate clock available while minimizing how often the
COUNT value resets to zero.
<b>Example.</b> If the processor clock is a 24-hour clock that registers time at approximately 18.20648193 ticks per
second, at 11:30 A.M. the reference
 CALL SYSTEM_CLOCK (COUNT = C, COUNT_RATE = R, COUNT_MAX = M)
definesC= (11x3600+30x60)x18<i>.</i>20648193 = 753748, R=18.20648193, andM= 24x3600x18<i>.</i>20648193-1 =
1573039.
<b>16.9.203</b> <b>TAN</b> <b>(X)</b>
<b>Description.</b> Tangent function.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real or complex.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has a value equal to a processor-dependent approximation to tan(X). If X is of type
real, it is regarded as a value in radians. If X is of type complex, its real part is regarded as a value in radians.
<b>Example.</b> TAN (1.0) has the value 1.5574077 (approximately).
<b>16.9.204</b> <b>TAND</b> <b>(X)</b>
<b>Description.</b> Degree tangent function.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has a value equal to a processor-dependent approximation to the tangent of X, which
is regarded as a value in degrees.
<b>Example.</b> TAND (180.0) has the value 0.0 (approximately).
<b>16.9.205</b> <b>TANH</b> <b>(X)</b>
<b>Description.</b> Hyperbolic tangent function.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real or complex.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has a value equal to a processor-dependent approximation to tanh(X). If X is of type
complex its imaginary part is regarded as a value in radians.
<b>Example.</b> TANH (1.0) has the value 0.76159416 (approximately).
<b>16.9.206</b> <b>TANPI</b> <b>(X)</b>
<b>Description.</b> Circular tangent function.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has a value equal to a processor-dependent approximation to the tangent of X, which
is regarded as a value in half-revolutions; thus, TANPI (X) is approximately equal to TAN (Xx).
<b>Example.</b> TAND (1.0) has the value 0.0 (approximately).
<b>16.9.207</b> <b>TEAM_NUMBER</b> <b>([TEAM])</b>
<b>Description.</b> Team number.
<b>Class.</b> Transformational function.
<b>Argument.</b> TEAM (optional) shall be a scalar of type TEAM_TYPE from the intrinsic module ISO_FOR-
TRAN_ENV, whose value identifies the current or an ancestor team. If TEAM is absent, the team specified is
the current team.
<b>Result</b> <b>Characteristics.</b> Default integer scalar.
<b>Result</b> <b>Value.</b> The result has the value-1 if the specified team is the initial team; otherwise, the result value
is equal to the positive integer that identifies the specified team among its sibling teams.
<b>Example.</b> The team number can be used to control which statements get executed, for example:
   TYPE(TEAM_TYPE) :: ODD_EVEN
   ...
   FORM TEAM (2-MOD(ME,2), ODD_EVEN)
   ...
   CHANGE TEAM (ODD_EVEN)
    SELECT CASE (TEAM_NUMBER())
    CASE (1)
     ! Case for images with odd image indices in the parent team.
    CASE (2)
     ! Case for images with even image indices in the parent team.
    END SELECT
   END TEAM
<b>16.9.208</b> <b>THIS_IMAGE</b> <b>([TEAM])</b> <b>or</b> <b>THIS_IMAGE</b> <b>(COARRAY</b> <b>[,</b> <b>TEAM])</b> <b>or</b>
    <b>THIS_IMAGE</b> <b>(COARRAY,</b> <b>DIM</b> <b>[,</b> <b>TEAM])</b>
<b>Description.</b> Cosubscript(s) for this image.
<b>Class.</b> Transformational function.
<b>Arguments.</b>
COARRAY shall be a coarray of any type. If it is allocatable it shall be allocated. If its <i>designator</i> has more
     than one <i>part-ref</i>, the rightmost <i>part-ref</i> shall have nonzero corank.
DIM shall be an integer scalar. Its value shall be in the range 1 DIM <i>n</i>, where <i>n</i> is the corank of
     COARRAY.
TEAM (optional) shall be a scalar of type TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV,
     whose value identifies the current or an ancestor team. If COARRAY appears, it shall be established
     in that team.
<b>Result</b> <b>Characteristics.</b> Default integer. It is scalar if COARRAY does not appear or DIM appears; otherwise,
the result has rank one and its size is equal to the corank of COARRAY.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> The result of THIS_IMAGE ([TEAM]) is a scalar with a value equal to the index of the invoking
     image in the team specified by TEAM, if present, or in the current team if absent.
<i>Case</i> <i>(ii):</i> The result of THIS_IMAGE (COARRAY [, TEAM = TEAM]) is the sequence of cosubscript values
     for COARRAY that would specify the invoking image in the team specified by TEAM, if present,
     or in the current team if absent.
<i>Case</i> <i>(iii):</i> The result of THIS_IMAGE (COARRAY, DIM [, TEAM = TEAM]) is the value of cosubscript
     DIM in the sequence of cosubscript values for COARRAY that would specify the invoking image in
     the team specified by TEAM, if present, or in the current team if absent.
<b>Examples.</b> If A is declared by the statement
 REAL A (10, 20) [10, 0:9, 0:*]
then on image 5, THIS_IMAGE ( ) has the value 5 and THIS_IMAGE (A) has the value [5, 0, 0]. For the same
coarray on image 213, THIS_IMAGE (A) has the value [3, 1, 2].
The following code uses image 1 to read data. The other images then copy the data.
 IF (THIS_IMAGE()==1) READ (*,*) P
 SYNC ALL
 P = P[1]
<b>16.9.209</b> <b>TINY</b> <b>(X)</b>
<b>Description.</b> Smallest positive model number.
<b>Class.</b> Inquiry function.
<b>Argument.</b> X shall be a real scalar or array.
<b>Result</b> <b>Characteristics.</b> Scalar with the same type and kind type parameter as X.
<b>Result</b> <b>Value.</b> The result has the value<i>b</i>
                   <i>e</i>min-1
                     where<i>b</i> and<i>e</i>
                             min
                            are as defined in 16.4 for the model representing
numbers of the same type and kind type parameter as X.
<b>Example.</b> TINY (X) has the value 2
          -127
                  for real X whose model is as in 16.4, NOTE.
<b>16.9.210</b> <b>TOKENIZE</b> <b>(STRING,</b> <b>SET,</b> <b>TOKENS</b> <b>[,</b> <b>SEPARATOR])</b> <b>or</b>
    <b>TOKENIZE</b> <b>(STRING,</b> <b>SET,</b> <b>FIRST,</b> <b>LAST)</b>
<b>Description.</b> Parse a string into tokens.
<b>Class.</b> Simple subroutine.
<b>Arguments.</b>
STRING shall be a scalar of type character. It is an INTENT (IN) argument.
SET shall be a scalar of type character with the same kind type parameter as STRING. It is an INTENT
     (IN) argument. Each character in SET is a token delimiter. A sequence of zero or more characters
     in STRING delimited by any token delimiter, or the beginning or end of STRING, comprise a token.
     Thus, two consecutive token delimiters in STRING, or a token delimiter in the first or last character
     of STRING, indicate a token with zero length.
TOKENS shall be of type character with the same kind type parameter as STRING. It is an INTENT (OUT)
     argument. It shall not be a coarray or a coindexed object. It shall be an allocatable array of rank
     one with deferred length. It is allocated with the lower bound equal to one and the upper bound
     equal to the number of tokens in STRING, and with character length equal to the length of the
     longest token.
     The tokens in STRING are assigned in the order found, as if by intrinsic assignment, to the elements
     of TOKENS, in array element order.
SEPARATOR (optional) shall be of type character with the same kind type parameter as STRING. It is an
     INTENT (OUT) argument. Itshall not be a coarray or a coindexed object. It shall be an allocatable
     array of rank one with deferred length. It is allocated with the lower bound equal to one and the
     upper bound equal to one less than the number of tokens in STRING, and with character length
     equal to one. Each element SEPARATOR(<i>i</i>) is assigned the value of the <i>i</i>
                                          <i>th</i>
                                         token delimiter in
     STRING.
FIRST shall be an allocatable array of type integer and rank one. It is an INTENT (OUT) argument. It
     shall not be a coarray or a coindexed object. It is allocated with the lower bound equal to one and
     the upper bound equal to the number of tokens in STRING. Each element is assigned, in array
     element order, the starting position of each token in STRING, in the order found. If a token has
     zero length, the starting position is equal to one if the token is at the beginning of STRING, and
     one greater than the position of the preceding delimiter otherwise.
LAST shall be an allocatable array of type integer and rank one. It is an INTENT (OUT) argument. It
     shall not be a coarray or a coindexed object. It is allocated with the lower bound equal to one and
     the upper bound equal to the number of tokens in STRING. Each element is assigned, in array
     element order, the ending position of each token in STRING, in the order found. If a token has zero
     length, the ending position is one less than the starting position.
<b>Examples.</b>
Execution of
   CHARACTER (LEN=:), ALLOCATABLE :: STRING
   CHARACTER (LEN=:), ALLOCATABLE, DIMENSION(:) :: TOKENS
   CHARACTER (LEN=2) :: SET = ',;'
   STRING = 'first,second,third'
   CALL TOKENIZE (STRING, SET, TOKENS)
will assign the value [ 'first ', 'second', 'third ' ] to TOKENS.
Execution of
   CHARACTER (LEN=:), ALLOCATABLE :: STRING
   CHARACTER (LEN=2) :: SET = ',;'
   INTEGER, DIMENSION(:):: FIRST, LAST
   STRING = 'first,second,,forth'
   CALL TOKENIZE (STRING, SET, FIRST, LAST)
will assign the value [ 1, 7, 14, 15 ] to FIRST, and the value [ 5, 12, 13, 19 ] to LAST.
<b>16.9.211</b> <b>TRAILZ</b> <b>(I)</b>
<b>Description.</b> Number of trailing zero bits.
<b>Class.</b> Elemental function.
<b>Argument.</b> I shall be of type integer.
<b>Result</b> <b>Characteristics.</b> Default integer.
<b>Result</b> <b>Value.</b> If all of the bits of I are zero, the result value is BIT_SIZE (I). Otherwise, the result value is the
position of the rightmost 1 bit in I. The model for the interpretation of an integer value as a sequence of bits is
in 16.3.
<b>Examples.</b> TRAILZ (8) has the value 3.
<b>16.9.212</b> <b>TRANSFER</b> <b>(SOURCE,</b> <b>MOLD</b> <b>[,</b> <b>SIZE])</b>
<b>Description.</b> Transfer physical representation.
<b>Class.</b> Transformational function.
<b>Arguments.</b>
SOURCE shall be a scalar or array of any type.
MOLD shall be a scalar or array of any type. If it is a variable, it need not be defined. If the storage size of
     SOURCE is greater than zero and MOLD is an array, a scalar with the type and type parameters
     of MOLD shall not have a storage size equal to zero.
SIZE (optional) shall be an integer scalar. The corresponding actual argument shall not be an optional dummy
     argument.
<b>Result</b> <b>Characteristics.</b> The result is of the same type and type parameters as MOLD.
<i>Case</i> <i>(i):</i> If MOLD is a scalar and SIZE is absent, the result is a scalar.
<i>Case</i> <i>(ii):</i> If MOLD is an array and SIZE is absent, the result is an array and of rank one. Its size is as small
     as possible such that its physical representation is not shorter than that of SOURCE.
<i>Case</i> <i>(iii):</i> If SIZE is present, the result is an array of rank one and size SIZE.
<b>Result</b> <b>Value.</b> If the physical representation of the result has the same length as that of SOURCE, the physical
representation of the result is that of SOURCE. If the physical representation of the result is longer than that
of SOURCE, the physical representation of the leading part is that of SOURCE and the remainder is processor
dependent. IfthephysicalrepresentationoftheresultisshorterthanthatofSOURCE,thephysicalrepresentation
of the result is the leading part of SOURCE. If D and E are scalar variables such that the physical representation
of D is as long as or longer than that of E, the value of TRANSFER (TRANSFER (E, D), E) shall be the value
of E. IF D is an array and E is an array of rank one, the value of TRANSFER (TRANSFER (E, D), E, SIZE (E))
shall be the value of E.
<b>Examples.</b>
<i>Case</i> <i>(i):</i> TRANSFER (1082130432, 0.0) has the value 4.0 on a processor that represents the values 4.0 and
     1082130432 as the string of binary digits 0100 0000 1000 0000 0000 0000 0000 0000.
<i>Case</i> <i>(ii):</i> TRANSFER ([1.1, 2.2, 3.3], [(0.0, 0.0)])) is a complex rank-one array of length two whose first
     element has the value (1.1, 2.2) and whose second element has a real part with the value 3.3. The
     imaginary part of the second element is processor dependent.
<i>Case</i> <i>(iii):</i> TRANSFER ([1.1, 2.2, 3.3], [(0.0, 0.0)], 1) is a complex rank-one array of length one whose only
     element has the value (1.1, 2.2).
<b>16.9.213</b> <b>TRANSPOSE</b> <b>(MATRIX)</b>
<b>Description.</b> Transpose of an array of rank two.
<b>Class.</b> Transformational function.
<b>Argument.</b> MATRIX shall be a rank-two array of any type.
<b>Result</b> <b>Characteristics.</b> The result is an array of the same type and type parameters as MATRIX and with
rank two and shape [<i>n,m</i>] where [<i>m,n</i>] is the shape of MATRIX.
<b>Result</b> <b>Value.</b> Element (<i>i,j</i>) of the result has the value MATRIX (<i>j</i> + LBOUND (MATRIX, 1)- 1, <i>i</i> +
LBOUND (MATRIX, 2)- 1).
<b>Example.</b> If A is the array
       ?
       ?
                        1 2 3
                        4 5 6
                        7 8 9
           ?
           ?
                  , then TRANSPOSE (A) has the value
                      ?
                      ?
                                                                  1 4 7
                                                                  2 5 8
                                                                  3 6 9
                         ?
                         ?
                                         .
<b>16.9.214</b> <b>TRIM</b> <b>(STRING)</b>
<b>Description.</b> String without trailing blanks.
<b>Class.</b> Transformational function.
<b>Argument.</b> STRING shall be a character scalar.
<b>Result</b> <b>Characteristics.</b> Character with the same kind type parameter value as STRING and with a length
that is the length of STRING less the number of trailing blanks in STRING. If STRING contains no nonblank
characters, the result has zero length.
<b>Result</b> <b>Value.</b> The value of the result is the same as STRING except any trailing blanks are removed.
<b>Example.</b> TRIM (' A B ') has the value ' A B'.
<b>16.9.215</b> <b>UBOUND</b> <b>(ARRAY</b> <b>[,</b> <b>DIM,</b> <b>KIND])</b>
<b>Description.</b> Upper bound(s).
<b>Class.</b> Inquiry function.
<b>Arguments.</b>
ARRAY shall be assumed-rank or an array. It shall not be an unallocated allocatable array or a pointer that
     is not associated. If ARRAY is an assumed-size array, DIM shall be present with a value less than
     the rank of ARRAY.
DIM (optional) shall be an integer scalar with a value in the range 1 DIM<i>n</i>, where<i>n</i> is the rank of ARRAY.
     The corresponding actual argument shall not be an optional dummy argument, a disassociated
     pointer, or an unallocated allocatable.
KIND (optional) shall be a scalar integer constant expression.
<b>Result</b> <b>Characteristics.</b> Integer. If KIND is present, the kind type parameter is that specified by the value of
KIND; otherwise the kind type parameter is that of default integer type. The result is scalar if DIM is present;
otherwise, the result is an array of rank one and size <i>n</i>, where <i>n</i> is the rank of ARRAY.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> If DIM is present, ARRAY is a whole array, and dimension DIM of ARRAY has nonzero extent,
     the result has a value equal to the upper bound for subscript DIM of ARRAY. Otherwise, if DIM
     is present and ARRAY is assumed-rank, the value of the result is as if ARRAY were a whole array,
     with the extent of the final dimension of ARRAY when ARRAY is associated with an assumed-size
     array being considered to be-1. Otherwise, if DIM is present, the result has a value equal to the
     number of elements in dimension DIM of ARRAY.
<i>Case</i> <i>(ii):</i> If ARRAY has rank zero, UBOUND (ARRAY) has a value that is a zero-sized array. Otherwise,
     UBOUND (ARRAY) has a value whose<i>i</i>
                        <i>th</i>
                        element is equal to UBOUND (ARRAY,<i>i</i>), for<i>i</i> = 1<i>,</i> 2<i>,</i>
    <i>...,</i> <i>n</i>, where <i>n</i> is the rank of ARRAY. UBOUND (ARRAY, KIND=KIND) has a value whose <i>i</i>
                                                   <i>th</i>
     element is equal to UBOUND (ARRAY, <i>i</i>, KIND=KIND), for <i>i</i> = 1<i>,</i> 2<i>,</i> <i>...,</i> <i>n</i>, where <i>n</i> is the
     rank of ARRAY.
<b>Examples.</b> If A is declared by the statement
 REAL A (2:3, 7:10)
then UBOUND (A) is [3, 10] and UBOUND (A, DIM = 2) is 10.
<b>NOTE</b>
If ARRAY is assumed-rank and has rank zero, DIM cannot be present since it cannot satisfy the requirement
1 DIM 0.
<b>16.9.216</b> <b>UCOBOUND</b> <b>(COARRAY</b> <b>[,</b> <b>DIM,</b> <b>KIND])</b>
<b>Description.</b> Upper cobound(s) of a coarray.
<b>Class.</b> Inquiry function.
<b>Arguments.</b>
COARRAY shall be a coarray of any type. It may be a scalar or an array. If it is allocatable it shall be allocated.
     If its <i>designator</i> has more than one <i>part-ref</i>, the rightmost <i>part-ref</i> shall have nonzero corank.
DIM (optional) shall be an integer scalar with a value in the range 1  DIM  <i>n</i>, where <i>n</i> is the corank
     of COARRAY. The corresponding actual argument shall not be an optional dummy argument, a
     disassociated pointer, or an unallocated allocatable.
KIND (optional) shall be a scalar integer constant expression.
<b>Result</b> <b>Characteristics.</b> Integer. If KIND is present, the kind type parameter is that specified by the value of
KIND; otherwise, the kind type parameter is that of default integer type. The result is scalar if DIM is present;
otherwise, the result is an array of rank one and size <i>n</i>, where <i>n</i> is the corank of COARRAY.
<b>Result</b> <b>Value.</b> The final upper cobound is the final cosubscript in the cosubscript list for the coarray that selects
the image whose index is equal to the number of images in the current team.
<i>Case</i> <i>(i):</i> If DIM is present, the result has a value equal to the upper cobound for codimension DIM of
     COARRAY.
<i>Case</i> <i>(ii):</i> If DIM is absent, the result has a value whose <i>i</i>
                             <i>th</i>
                             element is equal to the upper cobound for
     codimension <i>i</i> of COARRAY, for <i>i</i> = 1, 2,..., <i>n</i>, where <i>n</i> is the corank of COARRAY.
<b>Examples.</b> If NUM_IMAGES( ) has the value 30 and A is allocated by the statement
 ALLOCATE (A [2:3, 0:7, *])
then UCOBOUND (A) is [3, 7, 2] and UCOBOUND (A, DIM=2) is 7. Note that the cosubscripts [3, 7, 2] do
not correspond to an actual image.
<b>16.9.217</b> <b>UNPACK</b> <b>(VECTOR,</b> <b>MASK,</b> <b>FIELD)</b>
<b>Description.</b> Vector unpacked into an array.
<b>Class.</b> Transformational function.
<b>Arguments.</b>
VECTOR shall be a rank-one array of any type. Its size shall be at least <i>t</i> where <i>t</i> is the number of true
     elements in MASK.
MASK shall be a logical array.
FIELD shall be of the same type and type parameters as VECTOR and shall be conformable with MASK.
<b>Result</b> <b>Characteristics.</b> The result is an array of the same type and type parameters as VECTOR and the
same shape as MASK.
<b>Result</b> <b>Value.</b> The element of the result that corresponds to the <i>i</i>
                               <i>th</i>
                               true element of MASK, in array element
order, has the value VECTOR (<i>i</i>) for <i>i</i> = 1, 2, ..., <i>t</i>, where <i>t</i> is the number of true values in MASK. Each other
element has a value equal to FIELD if FIELD is scalar or to the corresponding element of FIELD if it is an array.
<b>Examples.</b> Particular values can be "scattered" to particular positions in an array by using UNPACK. If M is the
array
 ?
 ?
      1 0 0
      0 1 0
      0 0 1
    ?
    ?
        , V is the array [1, 2, 3], and Q is the logical mask
                   ?
                   ?
                                . T .
                               T . .
                                . . T
                       ?
                       ?
                                     , where "T" represents true
and "." represents false, then the result of UNPACK (V, MASK = Q, FIELD = M) has the value
                           ?
                           ?
                                                                                1 2 0
                                                                                1 1 0
                                                                                0 0 3
                              ?
                              ?
and the result of UNPACK (V, MASK = Q, FIELD = 0) has the value
                    ?
                    ?
                                                           0 2 0
                                                           1 0 0
                                                           0 0 3
                       ?
                       ?
                                     .
<b>16.9.218</b> <b>VERIFY</b> <b>(STRING,</b> <b>SET</b> <b>[,</b> <b>BACK,</b> <b>KIND])</b>
<b>Description.</b> Character set non-membership search.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
STRING shall be of type character.
SET shall be of type character with the same kind type parameter as STRING.
BACK (optional) shall be of type logical.
KIND (optional) shall be a scalar integer constant expression.
<b>Result</b> <b>Characteristics.</b> Integer. If KIND is present, the kind type parameter is that specified by the value of
KIND; otherwise the kind type parameter is that of default integer type.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> If BACK is absent or has the value false and if STRING contains at least one character that is not
     in SET, the value of the result is the position of the leftmost character of STRING that is not in
     SET.
<i>Case</i> <i>(ii):</i> If BACK is present with the value true and if STRING contains at least one character that is not
     in SET, the value of the result is the position of the rightmost character of STRING that is not in
     SET.
<i>Case</i> <i>(iii):</i> The value of the result is zero if each character in STRING is in SET or if STRING has zero length.
<b>Examples.</b>
<i>Case</i> <i>(i):</i> VERIFY ('ABBA', 'A') has the value 2.
<i>Case</i> <i>(ii):</i> VERIFY ('ABBA', 'A', BACK = .TRUE.) has the value 3.
<i>Case</i> <i>(iii):</i> VERIFY ('ABBA', 'AB') has the value 0.
<b>16.10</b> <b>Standard</b> <b>intrinsic</b> <b>modules</b>
<b>16.10.1</b> <b>General</b>
This document defines five standard intrinsic modules: a Fortran environment module, a set of three modules
to support floating-point exceptions and IEEE arithmetic, and a module to support interoperability with the C
programming language.
The intrinsic modules IEEE_EXCEPTIONS, IEEE_ARITHMETIC, and IEEE_FEATURES are described in
Clause 17. The intrinsic module ISO_C_BINDING is described in Clause 18. The module procedures described
in 16.10.2 are simple.
<b>NOTE</b>
The types and procedures defined in standard intrinsic modules are not themselves intrinsic.
A processor may extend the standard intrinsic modules to provide public entities in them in addition to those
specified in this document.
<b>16.10.2</b> <b>The</b> <b>ISO_FORTRAN_ENV</b> <b>intrinsic</b> <b>module</b>
<b>16.10.2.1</b> <b>General</b>
The intrinsic module ISO_FORTRAN_ENV provides public entities relating to the Fortran environment.
The processor shall provide the named constants, derived types, and procedures described in 16.10.2. In the
detailed descriptions below, procedure names are generic and not specific.
<b>16.10.2.2</b> <b>ATOMIC_INT_KIND</b>
The value of the default integer scalar constant ATOMIC_INT_KIND is the kind type parameter value of type
integer variables for which the processor supports atomic operations specified by atomic subroutines.
<b>16.10.2.3</b> <b>ATOMIC_LOGICAL_KIND</b>
The value of the default integer scalar constant ATOMIC_LOGICAL_KIND is the kind type parameter value
of type logical variables for which the processor supports atomic operations specified by atomic subroutines.
<b>16.10.2.4</b> <b>CHARACTER_KINDS</b>
The values of the elements of the default integer array constant CHARACTER_KINDS are the kind values
supported by the processor for variables of type character. The order of the values is processor dependent. The
rank of the array is one, its lower bound is one, and its size is the number of character kinds supported.
<b>16.10.2.5</b> <b>CHARACTER_STORAGE_SIZE</b>
The value of the default integer scalar constant CHARACTER_STORAGE_SIZE is the size expressed in bits
of the character storage unit (19.5.3.2).
<b>16.10.2.6</b> <b>COMPILER_OPTIONS</b> <b>(</b> <b>)</b>
<b>Description.</b> Processor-dependent string describing the options that controlled the program translation phase.
<b>Class.</b> Transformational function.
<b>Argument.</b> None.
<b>Result</b> <b>Characteristics.</b> Default character scalar with processor-dependent length.
<b>Result</b> <b>Value.</b> A processor-dependent value which describes the options that controlled the translation phase of
program execution. This value should include relevant information that could be useful for diagnosing problems
at a later date.
<b>Example.</b> COMPILER_OPTIONS ( ) might have the value '/OPTIMIZE /FLOAT=IEEE'.
<b>16.10.2.7</b> <b>COMPILER_VERSION</b> <b>(</b> <b>)</b>
<b>Description.</b> Processor-dependent string identifying the program translation phase.
<b>Class.</b> Transformational function.
<b>Argument.</b> None.
<b>Result</b> <b>Characteristics.</b> Default character scalar with processor-dependent length.
<b>Result</b> <b>Value.</b> A processor-dependent value that identifies the name and version of the program translation
phaseoftheprocessor. Thisvalueshouldincluderelevantinformationthatcouldbeusefulfordiagnosingproblems
at a later date.
<b>Example.</b> COMPILER_VERSION ( ) might have the value 'Fast KL-10 Compiler Version 7'.
<b>NOTE</b>
Relevant information that could be useful for diagnosing problems at a later date might include compiler release
and patch level, default compiler arguments, environment variable values, and run time library requirements.
A processor might include this information in an object file automatically, without the user needing to save the
result of this function in a variable.
<b>16.10.2.8</b> <b>CURRENT_TEAM</b>
The value of the default integer scalar constant CURRENT_TEAM identifies the current team when it is used
as the LEVEL argument to GET_TEAM.
<b>16.10.2.9</b> <b>ERROR_UNIT</b>
The value of the default integer scalar constant ERROR_UNIT identifies the processor-dependent preconnected
external unit used for the purpose of error reporting (12.5). This unit may be the same as OUTPUT_UNIT.
The value shall not be-1.
<b>16.10.2.10</b> <b>EVENT_TYPE</b>
EVENT_TYPE is a derived type with private components. It is an extensible type with no type parameters.
Each nonallocatable component is fully default-initialized.
A scalar variable of type EVENT_TYPE is an event variable. The value of an event variable includes its event
count, which is updated by execution of a sequence of EVENT POST or EVENT WAIT statements. The effect
of each change is as if the intrinsic subroutine ATOMIC_ADD were executed with a variable that stores the
event count as its ATOM argument. A coarray that is of type EVENT_TYPE may be referenced or defined
during execution of a segment that is unordered relative to the execution of another segment in which that
coarray is defined. The event count is of type integer with kind ATOMIC_INT_KIND from the intrinsic module
ISO_FORTRAN_ENV. The initial value of the event count of an event variable is zero.
C1603 A named entity with declared type EVENT_TYPE, or which has a noncoarray potential subobject
   component with declared type EVENT_TYPE, shall be a variable. A component that is of such a type
   shall be a data component.
C1604 A named variable with declared type EVENT_TYPE shall be a coarray. A named variable with a
   noncoarray potential subobject component of type EVENT_TYPE shall be a coarray.
C1605 An event variable shall not appear in a variable definition context except as the <i>event-variable</i> in an
   EVENT POST or EVENT WAIT statement, as an <i>allocate-object</i>, or as an actual argument in a reference
   to a procedure with an explicit interface if the corresponding dummy argument has INTENT (INOUT).
C1606 A variable with a nonpointer subobject of type EVENT_TYPE shall not appear in a variable definition
   context except as an <i>allocate-object</i> in an ALLOCATE statement without a SOURCE= specifier, as an
   <i>allocate-object</i> in a DEALLOCATE statement, or as an actual argument in a reference to a procedure
   with an explicit interface if the corresponding dummy argument has INTENT (INOUT).
<b>NOTE</b> <b>1</b>
The restrictions against changing an event variable except via EVENT POST and EVENT WAIT statements
ensure the integrity of its value and facilitate efficient implementation, particularly when special synchronization
is needed for correct event handling.
<b>NOTE</b> <b>2</b>
Updates to variables via atomic subroutines are coherent but not necessarily consistent, so a processor might
have to use extra synchronization to obtain the consistency required for the segments ordered by EVENT POST
and EVENT WAIT statements.
<b>16.10.2.11</b> <b>FILE_STORAGE_SIZE</b>
The value of the default integer scalar constant FILE_STORAGE_SIZE is the size expressed in bits of the file
storage unit (12.3.5).
<b>16.10.2.12</b> <b>INITIAL_TEAM</b>
The value of the default integer scalar constant INITIAL_TEAM identifies the initial team when it is used as
the LEVEL argument to GET_TEAM.
<b>16.10.2.13</b> <b>INPUT_UNIT</b>
The value of the default integer scalar constant INPUT_UNIT identifies the same processor-dependent external
unit as the one identified by an asterisk in a READ statement; this unit is the one used for a READ statement
that does not contain an input/output control list (12.6.4.3). This unit is preconnected for sequential formatted
input on image one in the initial team only, and is not preconnected on any other image. The value shall not be
-1.
<b>16.10.2.14</b> <b>INT8,</b> <b>INT16,</b> <b>INT32,</b> <b>and</b> <b>INT64</b>
The values of these default integer scalar named constants shall be those of the kind type parameters that specify
an INTEGER type whose storage size expressed in bits is 8, 16, 32, and 64 respectively. If, for any of these
constants, the processor supports more than one kind of that size, it is processor dependent which kind value is
provided. If the processor supports no kind of a particular size, that constant shall be equal to-2 if the processor
supports a kind with larger size and-1 otherwise.
<b>16.10.2.15</b> <b>INTEGER_KINDS</b>
The values of the elements of the default integer array constant INTEGER_KINDS are the kind values supported
by the processor for variables of type integer. The order of the values is processor dependent. The rank of the
array is one, its lower bound is one, and its size is the number of integer kinds supported.
<b>16.10.2.16</b> <b>IOSTAT_END</b>
ThevalueofthedefaultintegerscalarconstantIOSTAT_ENDisassignedtothevariablespecifiedinanIOSTAT=
specifier (12.11.5) if an end-of-file condition occurs during execution of an input statement and no error condition
occurs. This value shall be negative.
<b>16.10.2.17</b> <b>IOSTAT_EOR</b>
ThevalueofthedefaultintegerscalarconstantIOSTAT_EORisassignedtothevariablespecifiedinanIOSTAT=
specifier (12.11.5) if an end-of-record condition occurs during execution of an input statement and no end-of-file
or error condition occurs. This value shall be negative and different from the value of IOSTAT_END.
<b>16.10.2.18</b> <b>IOSTAT_INQUIRE_INTERNAL_UNIT</b>
The value of the default integer scalar constant IOSTAT_INQUIRE_INTERNAL_UNIT is assigned to the
variable specified in an IOSTAT= specifier in an INQUIRE statement (12.10) if a <i>file-unit-number</i> identifies an
internal unit in that statement.
<b>NOTE</b>
This can only occur when a defined input/output procedure is called by the processor as the result of executing
a parent data transfer statement (12.6.4.8.3) for an internal unit.
<b>16.10.2.19</b> <b>LOCK_TYPE</b>
LOCK_TYPE is a derived type with private components; no component is allocatable or a pointer. It is an
extensible type with no type parameters. All components have default initialization.
A scalar variable of type LOCK_TYPE is a lock variable. A lock variable can have one of two states: locked and
unlocked. The unlocked state is represented by the one value that is the default value of a LOCK_TYPE variable;
this is the value specified by the structure constructor LOCK_TYPE ( ). The locked state is represented by all
other values. The value of a lock variable can be changed with the LOCK and UNLOCK statements (11.7.10).
C1607 A named entity with declared type LOCK_TYPE, or which has a noncoarray potential subobject com-
   ponent with declared type LOCK_TYPE, shall be a variable. A component that is of such a type shall
   be a data component.
C1608 A named variable with declared type LOCK_TYPE shall be a coarray. A named variable with a
   noncoarray potential subobject component of type LOCK_TYPE shall be a coarray.
C1609 A lock variable shall not appear in a variable definition context except as the <i>lock-variable</i> in a LOCK or
   UNLOCK statement, as an <i>allocate-object</i>, or as an actual argument in a reference to a procedure with
   an explicit interface where the corresponding dummy argument has INTENT (INOUT).
C1610 A variable with a subobject of type LOCK_TYPE shall not appear in a variable definition context except
   as an <i>allocate-object</i> or as an actual argument in a reference to a procedure with an explicit interface
   where the corresponding dummy argument has INTENT (INOUT).
<b>NOTE</b>
The restrictions against changing a lock variable except via the LOCK and UNLOCK statements ensure the
integrity of its value and facilitate efficient implementation, particularly when special synchronization is needed
for correct lock operation.
<b>16.10.2.20</b> <b>LOGICAL_KINDS</b>
The values of the elements of the default integer array constant LOGICAL_KINDS are the kind values supported
by the processor for variables of type logical. The order of the values is processor dependent. The rank of the
array is one, its lower bound is one, and its size is the number of logical kinds supported.
<b>16.10.2.21</b> <b>LOGICAL8,</b> <b>LOGICAL16,</b> <b>LOGICAL32,</b> <b>and</b> <b>LOGICAL64</b>
The values of these default integer scalar named constants shall be those of the kind type parameters that specify
a LOGICAL type whose storage size expressed in bits is 8, 16, 32, and 64 respectively. If, for any of these
constants, the processor supports more than one kind of that size, it is processor dependent which kind value is
provided. If the processor supports no kind of a particular size, that constant shall be equal to-2 if the processor
supports a kind with larger size and-1 otherwise.
<b>16.10.2.22</b> <b>NOTIFY_TYPE</b>
NOTIFY_TYPE is a derived type with private components. It is an extensible type with no type parameters.
Each nonallocatable component is fully default-initialized.
A scalar variable of type NOTIFY_TYPE is a notify variable. The value of a notify variable includes its notify
count, which is updated by execution of assignment statements that have a NOTIFY= specifier and NOTIFY
WAIT statements.
The effect of each update is as if the intrinsic subroutine ATOMIC_ADD were executed with a variable that
stores the notify count as its ATOM argument. A coarray that is of type NOTIFY_TYPE may be referenced
or defined during execution of a segment that is unordered relative to the execution of another segment in which
that coarray is defined. The notify count is of type integer with kind ATOMIC_INT_KIND from the intrinsic
module ISO_FORTRAN_ENV. The initial value of the notify count of a notify variable is zero.
C1611 A named entity with declared type NOTIFY_TYPE, or which has a noncoarray potential subobject
   component with declared type NOTIFY_TYPE, shall be a variable. A component that is of such a type
   shall be a data component.
C1612 A named variable with declared type NOTIFY_TYPE shall be a coarray. A named variable with a
   noncoarray potential subobject component of type NOTIFY_TYPE shall be a coarray.
C1613 A notify variable shall not appear in a variable definition context except as the <i>notify-variable</i> of a
   NOTIFY= specifier or NOTIFY WAIT statement, as an <i>allocate-object</i>, or as an actual argument in a
   reference to a procedure with an explicit interface if the corresponding dummy argument has INTENT
   (INOUT).
C1614 A variable with a nonpointer subobject of type NOTIFY_TYPE shall not appear in a variable definition
   context except as an <i>allocate-object</i> in an ALLOCATE statement without a SOURCE= specifier, as an
   <i>allocate-object</i> in a DEALLOCATE statement, or as an actual argument in a reference to a procedure
   with an explicit interface if the corresponding dummy argument has INTENT (INOUT).
<b>NOTE</b>
The restrictions on changing a notify variable ensure the integrity of its value and facilitate efficient implement-
ation, particularly when special synchronization is needed for correct notify handling.
<b>16.10.2.23</b> <b>NUMERIC_STORAGE_SIZE</b>
The value of the default integer scalar constant NUMERIC_STORAGE_SIZE is the size expressed in bits of the
numeric storage unit (19.5.3.2).
<b>16.10.2.24</b> <b>OUTPUT_UNIT</b>
ThevalueofthedefaultintegerscalarconstantOUTPUT_UNITidentifiesthesameprocessor-dependentexternal
unit preconnected for sequential formatted output as the one identified by an asterisk in a WRITE statement
(12.6.4.3); this unit is the one used by a PRINT statement. The value shall not be-1.
<b>16.10.2.25</b> <b>PARENT_TEAM</b>
The value of the default integer scalar constant PARENT_TEAM identifies the parent team when it is used as
the LEVEL argument to GET_TEAM.
<b>16.10.2.26</b> <b>REAL_KINDS</b>
The values of the elements of the default integer array constant REAL_KINDS are the kind values supported by
the processor for variables of type real. The order of the values is processor dependent. The rank of the array is
one, its lower bound is one, and its size is the number of real kinds supported.
<b>16.10.2.27</b> <b>REAL16,</b> <b>REAL32,</b> <b>REAL64,</b> <b>and</b> <b>REAL128</b>
The values of these default integer scalar named constants shall be those of the kind type parameters that specify
a REAL type whose storage size expressed in bits is 16, 32, 64, and 128 respectively. If, for any of these constants,
the processor supports more than one kind of that size, it is processor dependent which kind value is provided. If
the processor supports no kind of a particular size, that constant shall be equal to-2 if the processor supports
kinds of a larger size and-1 otherwise.
<b>16.10.2.28</b> <b>STAT_FAILED_IMAGE</b>
If the processor has the ability to detect that an image has failed, the value of the default integer scalar constant
STAT_FAILED_IMAGE is positive; otherwise, the value of STAT_FAILED_IMAGE is negative. If an image
involved in execution of an image control statement, a reference to a coindexed object, or execution of a collective
or atomic subroutine has failed, and no other error condition occurs, the value of STAT_FAILED_IMAGE is
assigned to the variable specified in a STAT= specifier in the execution of an image control statement or reference
to a coindexed object, or to the STAT argument in an invocation of a collective or atomic subroutine.
<b>16.10.2.29</b> <b>STAT_LOCKED</b>
The value of the default integer scalar constant STAT_LOCKED is assigned to the variable specified in a STAT=
specifier (11.7.11) of a LOCK statement if the lock variable is locked by the executing image.
<b>16.10.2.30</b> <b>STAT_LOCKED_OTHER_IMAGE</b>
The value of the default integer scalar constant STAT_LOCKED_OTHER_IMAGE is assigned to the variable
specified in a STAT= specifier (11.7.11) of an UNLOCK statement if the lock variable is locked by another image.
<b>16.10.2.31</b> <b>STAT_STOPPED_IMAGE</b>
The value of the default integer scalar constant STAT_STOPPED_IMAGE is assigned to the variable specified
in a STAT= specifier (9.7.4, 11.7.11), if execution of the statement with that specifier requires synchronization
with an image that has initiated normal termination. It is assigned to a STAT argument in a reference to a
collective subroutine if any image of the current team has initiated normal termination. This value shall be
positive.
<b>16.10.2.32</b> <b>STAT_UNLOCKED</b>
The value of the default integer scalar constant STAT_UNLOCKED is assigned to the variable specified in a
STAT= specifier (11.7.11) of an UNLOCK statement if the lock variable is unlocked.
<b>16.10.2.33</b> <b>STAT_UNLOCKED_FAILED_IMAGE</b>
The value of the default integer scalar constant STAT_UNLOCKED_FAILED_IMAGE is assigned to the vari-
able specified in a STAT= specifier (11.7.11) of a LOCK statement if the lock variable is unlocked because of the
failure of the image that locked it.
<b>16.10.2.34</b> <b>TEAM_TYPE</b>
TEAM_TYPE is a derived type with private components. It is an extensible type with no type parameters.
Each nonallocatable component is fully default-initialized.
A scalar variable of type TEAM_TYPE is a team variable, and can identify a team. The default initial value of
a team variable does not identify any team.
<b>16.10.2.35</b> <b>Uniqueness</b> <b>of</b> <b>named</b> <b>constant</b> <b>values</b>
The values of these named constants shall be distinct:
  IOSTAT_INQUIRE_INTERNAL_UNIT STAT_STOPPED_IMAGE
  STAT_FAILED_IMAGE STAT_UNLOCKED
  STAT_LOCKED STAT_UNLOCKED_FAILED_IMAGE
  STAT_LOCKED_OTHER_IMAGE
<b>17</b> <b>Exceptions</b> <b>and</b> <b>IEEE</b> <b>arithmetic</b>
<b>17.1</b> <b>Overview</b> <b>of</b> <b>IEEE</b> <b>arithmetic</b> <b>support</b>
The intrinsic modules IEEE_EXCEPTIONS, IEEE_ARITHMETIC, and IEEE_FEATURES provide support
for the facilities defined by ISO/IEC 60559:2020
             *
                     . Whether the modules are provided is processor dependent. If
the module IEEE_FEATURES is provided, which of the named constants defined in this document are included
is processor dependent. The module IEEE_ARITHMETIC behaves as if it contained a USE statement for
IEEE_EXCEPTIONS; everything that is public in IEEE_EXCEPTIONS is public in IEEE_ARITHMETIC.
<b>NOTE</b> <b>1</b>
The types and procedures defined in these modules are not themselves intrinsic.
If IEEE_EXCEPTIONS or IEEE_ARITHMETIC is accessible in a scoping unit, the exceptions IEEE_OVER-
FLOW and IEEE_DIVIDE_BY_ZERO are supported in the scoping unit for all kinds of real and complex
IEEE floating-point data. Which other exceptions are supported in the scoping unit can be determined by the
function IEEE_SUPPORT_FLAG (17.11.55); whether control of halting is supported can be determined by
the function IEEE_SUPPORT_HALTING. The extent of support of the other exceptions can be influenced by
the accessibility of the named constants IEEE_INEXACT_FLAG, IEEE_INVALID_FLAG, and IEEE_UN-
DERFLOW_FLAG of the module IEEE_FEATURES. If IEEE_UNDERFLOW_FLAG is accessible, within
the scoping unit the processor shall support underflow for at least one kind of real. Similarly, if IEEE_INEX-
ACT_FLAG or IEEE_INVALID_FLAG is accessible, within the scoping unit the processor shall support the
exception for at least one kind of real. If IEEE_HALTING is accessible, within the scoping unit the processor
shall support control of halting.
<b>NOTE</b> <b>2</b>
IEEE_INVALID is not required to be supported whenever IEEE_EXCEPTIONS is accessed. This is to allow
a processor whose arithmetic does not conform to ISO/IEC 60559:2020 to provide support for overflow and
divide_by_zero. OnaprocessorwhichdoessupportISO/IEC60559:2020,invalidisanequallyseriouscondition.
If a scoping unit does not access IEEE_FEATURES, IEEE_EXCEPTIONS, or IEEE_ARITHMETIC, the level
of support is processor dependent, and need not include support for any exceptions. If a flag is signaling on entry
to such a scoping unit, the processor ensures that it is signaling on exit. If a flag is quiet on entry to such a
scoping unit, whether it is signaling on exit is processor dependent.
Additional ISO/IEC/IEEE 60559:2020 facilities are available from the module IEEE_ARITHMETIC. The extent
of support can be influenced by the accessibility of the named constants of the module IEEE_FEATURES. If
IEEE_DATATYPE of IEEE_FEATURES is accessible, within the scoping unit the processor shall support
IEEE arithmetic for at least one kind of real. Similarly, if IEEE_DENORMAL, IEEE_DIVIDE, IEEE_INF,
IEEE_NAN, IEEE_ROUNDING, IEEE_SQRT, or IEEE_SUBNORMAL is accessible, within the scoping unit
the processor shall support the feature for at least one kind of real. In the case of IEEE_ROUNDING, it shall
support the rounding modes IEEE_NEAREST, IEEE_TO_ZERO, IEEE_UP, and IEEE_DOWN; support for
IEEE_AWAY is also required if there is at least one kind of real X for which IEEE_SUPPORT_DATATYPE
(X) is true and RADIX (X) is equal to ten. Note that the effect of IEEE_DENORMAL is the same as that of
IEEE_SUBNORMAL.
Execution might be slowed on some processors by the support of some features. If IEEE_EXCEPTIONS or
IEEE_ARITHMETIC is accessed but IEEE_FEATURES is not accessed, the supported subset of features is
  *
  Because ISO/IEC 60559:2020 was originally an IEEE standard, its facilities are widely known as "IEEE arithmetic", and this
terminology is used by this document.
processor dependent. The processor's fullest support is provided when all of IEEE_FEATURES is accessed as in
   USE, INTRINSIC :: IEEE_ARITHMETIC; USE, INTRINSIC :: IEEE_FEATURES
but execution might then be slowed by the presence of a feature that is not needed.
<b>17.2</b> <b>Derived</b> <b>types,</b> <b>constants,</b> <b>and</b> <b>operators</b> <b>defined</b> <b>in</b> <b>the</b> <b>modules</b>
The modules IEEE_EXCEPTIONS, IEEE_ARITHMETIC, and IEEE_FEATURES define derived types whose
components are all private. No direct component of any of these types is allocatable or a pointer.
The module IEEE_EXCEPTIONS defines the following types and constants.
 IEEE_FLAG_TYPE is for identifying a particular exception flag. Its only possible values are those of
  named constants defined in the module: IEEE_INVALID, IEEE_OVERFLOW, IEEE_DIVIDE_BY_-
  ZERO, IEEE_UNDERFLOW, and IEEE_INEXACT. The module also defines the array named constants
  IEEE_USUAL = [ IEEE_OVERFLOW, IEEE_DIVIDE_BY_ZERO, IEEE_INVALID ] and IEEE_-
  ALL = [ IEEE_USUAL, IEEE_UNDERFLOW, IEEE_INEXACT ].
 IEEE_MODES_TYPE is for representing the floating-point modes.
 IEEE_STATUS_TYPE is for representing the floating-point status.
The module IEEE_ARITHMETIC defines the following types, constants, and operators.
 The type IEEE_CLASS_TYPE, for identifying a class of floating-point values. Its only possible values
  are those of named constants defined in the module: IEEE_SIGNALING_NAN, IEEE_QUIET_NAN,
  IEEE_NEGATIVE_INF, IEEE_NEGATIVE_NORMAL, IEEE_NEGATIVE_SUBNORMAL, IEEE_-
  NEGATIVE_ZERO,IEEE_POSITIVE_ZERO,IEEE_POSITIVE_SUBNORMAL,IEEE_POSITIVE_-
  NORMAL, IEEE_POSITIVE_INF, and IEEE_OTHER_VALUE. The named constants IEEE_NEGAT-
  IVE_DENORMAL and IEEE_POSITIVE_DENORMAL are defined with the same value as IEEE_NEG-
  ATIVE_SUBNORMAL and IEEE_POSITIVE_SUBNORMAL respectively.
 The type IEEE_ROUND_TYPE, for identifying a particular rounding mode. Its only possible values
  are those of named constants defined in the module: IEEE_NEAREST, IEEE_TO_ZERO, IEEE_UP,
  IEEE_DOWN, IEEE_AWAY and IEEE_OTHER for the rounding modes specified in this document.
 The simple elemental operator == for two values of one of these types to return true if the values are the
  same and false otherwise.
 The simple elemental operator /= for two values of one of these types to return true if the values differ and
  false otherwise.
The module IEEE_FEATURES defines the following types and constants.
 The type IEEE_FEATURES_TYPE, for expressing the need for particular ISO/IEC/IEEE 60559:2020
  features. Its only possible values are those of named constants defined in the module: IEEE_DATATYPE,
  IEEE_DENORMAL, IEEE_DIVIDE, IEEE_HALTING, IEEE_INEXACT_FLAG, IEEE_INF, IEEE_-
  INVALID_FLAG, IEEE_NAN, IEEE_ROUNDING, IEEE_SQRT, IEEE_SUBNORMAL, and IEEE_-
  UNDERFLOW_FLAG.
<b>17.3</b> <b>The</b> <b>exceptions</b>
The exceptions are the following.
 IEEE_OVERFLOW occurs in an intrinsic real addition, subtraction, multiplication, division, or conversion
  by the intrinsic function REAL, as specified by ISO/IEC/IEEE 60559:2020 if IEEE_SUPPORT_DATA-
  TYPE is true for the operands of the operation or conversion, and as determined by the processor otherwise.
  It occurs in an intrinsic real exponentiation as determined by the processor. It occurs in a complex op-
  eration, or conversion by the intrinsic function CMPLX, if it is caused by the calculation of the real or
  imaginary part of the result.
 IEEE_DIVIDE_BY_ZERO occurs in a real division as specified by ISO/IEC/IEEE 60559:2020 if IEEE_-
  SUPPORT_DATATYPE is true for the operands of the division, and as determined by the processor
  otherwise. It is processor-dependent whether it occurs in a real exponentiation with a negative exponent.
  It occurs in a complex division if it is caused by the calculation of the real or imaginary part of the result.
 IEEE_INVALID occurs when a real or complex operation or assignment is invalid; possible examples are
  SQRT (X) when X is real and has a nonzero negative value, and conversion to an integer (by assignment,
  an intrinsic procedure, or a procedure defined in an intrinsic module) when the result is too large to be
  representable. IEEE_INVALID occurs for numeric relational intrinsic operations as specified below.
 IEEE_UNDERFLOW occurs when the result for an intrinsic real operation or assignment has an absolute
  value less than a processor-dependent limit, or the real or imaginary part of the result for an intrinsic
  complex operation or assignment has an absolute value less than a processor-dependent limit.
 IEEE_INEXACT occurs when the result of a real or complex operation or assignment is not exact.
Each exception has a flag whose value is either quiet or signaling. The value can be determined by the subroutine
IEEE_GET_FLAG. Its initial value is quiet. It is set to signaling when the associated exception occurs, except
that the flag for IEEE_UNDERFLOW is not set if the result of the operation that caused the exception was exact
and default ISO/IEC/IEEE 60559:2020 exception handling is in effect for IEEE_UNDERFLOW. Its status can
also be changed by the subroutine IEEE_SET_FLAG or the subroutine IEEE_SET_STATUS. Once signaling
within a procedure, it remains signaling unless set quiet by an invocation of the subroutine IEEE_SET_FLAG
or the subroutine IEEE_SET_STATUS.
If a flag is signaling on entry to a procedure other than IEEE_GET_FLAG or IEEE_GET_STATUS, the
processor will set it to quiet on entry and restore it to signaling on return. If a flag signals during execution of a
procedure, the processor shall not set it to quiet on return.
Evaluation of a specification expression might cause an exception to signal.
In a scoping unit that has access to IEEE_EXCEPTIONS or IEEE_ARITHMETIC, if an intrinsic procedure
or a procedure defined in an intrinsic module executes normally, the values of the flags IEEE_OVERFLOW,
IEEE_DIVIDE_BY_ZERO, and IEEE_INVALID shall be as on entry to the procedure, even if one or more of
them signals during the calculation. If a real or complex result is too large for the procedure to handle, IEEE_-
OVERFLOW may signal. If a real or complex result is a NaN because of an invalid operation (for example,
LOG (-1<i>.</i>0)), IEEE_INVALID may signal. Similar rules apply to format processing and to intrinsic operations:
no signaling flag shall be set quiet and no quiet flag shall be set signaling because of an intermediate calculation
that does not affect the result.
In a scoping unit that has access to IEEE_EXCEPTIONS or IEEE_ARITHMETIC, if <i>x</i>
                                             1
                                        and <i>x</i>
                                                 2
                                           are numeric
entities, the type of <i>x</i>
          1
                  +<i>x</i>
             2
            is real, and IEEE_SUPPORT_NAN (<i>x</i>
                                  1
                              + <i>x</i>
                                     2
                                ) is true, the relational intrinsic oper-
ation <i>x</i>
   1
   <i>rel-op</i> <i>x</i>
        2
        shall signal IEEE_INVALID as specified for the conditional predicate of ISO/IEC 60559:2020
corresponding to <i>rel-op</i> indicated by Table 17.1. If the types or kind type parameters of <i>x</i>
                                             1
                                        or <i>x</i>
                                                2
                                          differ, the con-
versions (10.1.5.5.1) might signal exceptions instead of or in addition to an IEEE_INVALID exception signaled
by the comparison.
<b>NOTE</b>
Each comparison predicate defined by ISO/IEC 60559:2020 is either unordered signaling or unordered quiet.
An unordered signaling predicate signals an invalid operation exception if and only if one of the values being
compared is a NaN. An unordered quiet predicate signals an invalid operation exception if and only if one of
the values being compared is a signaling NaN. The comparison predicates do not signal any other exceptions.
         <b>Table</b> <b>17.1</b> <b>-</b> <b>IEEE</b> <b>relational</b> <b>operator</b> <b>correspondence</b>
           Operator ISO/IEC/IEEE 60559:2020 comparison predicate
           .LT. or <i><</i> compareSignalingLess
          .LE. or <= compareSignalingLessEqual
          .GT. or > compareSignalingGreater
          .GE. or >= compareSignalingGreaterEqual
          .EQ. or == compareQuietEqual
          .NE. or /= compareQuietNotEqual
In a scoping unit that has access to IEEE_EXCEPTIONS or IEEE_ARITHMETIC, if <i>x</i>
                                              1
                                         or <i>x</i>
                                                 2
                                           are numeric
entities, the type of <i>x</i>
           1
                   +<i>x</i>
              2
            is complex, and IEEE_SUPPORT_NAN (REAL (<i>x</i>
                                         1
                                                                  +<i>x</i>
                                            2
                                       )) is true, the intrinsic
equality or inequality operation between <i>x</i>
                      1
                    and <i>x</i>
                          2
                       may signal IEEE_INVALID if the value of the real or
imaginary part of either operand is a signaling NaN. If any conversions are done before the values are compared,
those conversions might signal exceptions instead of or in addition to an IEEE_INVALID exception signaled by
the comparison.
In a sequence of statements that has no invocations of IEEE_GET_FLAG, IEEE_SET_FLAG, IEEE_GET_-
STATUS, IEEE_SET_HALTING_MODE, or IEEE_SET_STATUS, if the execution of an operation would
cause an exception to signal but after execution of the sequence no value of a variable depends on the operation,
whether the exception is signaling is processor dependent. For example, when Y has the value zero, whether the
code
   X = 1.0/Y
   X = 3.0
signals IEEE_DIVIDE_BY_ZERO is processor dependent. Another example is the following:
   REAL, PARAMETER :: X=0.0, Y=6.0
   IF (1.0/X == Y) PRINT *,'Hello world'
where the processor is permitted to discard the IF statement because the logical expression can never be true
and no value of a variable depends on it.
An exception shall not signal if this could arise only during execution of an operation beyond those required or
permitted by the standard. For example, the statement
   IF (F (X) > 0.0) Y = 1.0/Z
shall not signal IEEE_DIVIDE_BY_ZERO when both F (X) and Z are zero and the statement
   WHERE (A > 0.0) A = 1.0/A
shall not signal IEEE_DIVIDE_BY_ZERO. On the other hand, when X has the value 1.0 and Y has the value
0.0, the expression
   X>0.00001 .OR. X/Y>0.00001
is permitted to cause the signaling of IEEE_DIVIDE_BY_ZERO.
The processor need not support IEEE_INVALID, IEEE_UNDERFLOW, and IEEE_INEXACT. If an exception
is not supported, its flag is always quiet.
<b>17.4</b> <b>The</b> <b>rounding</b> <b>modes</b>
This document specifies a binary rounding mode that affects floating-point arithmetic with radix two, and a
decimal rounding mode that affects floating-point arithmetic with radix ten. Unqualified references to the round-
ing mode with respect to a particular arithmetic operation or operands refers to the mode for the radix of the
operation or operands, and other unqualified references to the rounding mode refers to both binary and decimal
rounding modes.
ISO/IEC 60559:2020 specifies five possible rounding-direction attributes: roundTiesToEven, roundTowardZero,
roundTowardPositive, roundTowardNegative, and roundTiesToAway. These correspond to the rounding modes
IEEE_NEAREST,IEEE_TO_ZERO,IEEE_UP,IEEE_DOWN,andIEEE_AWAYrespectively. Therounding
mode IEEE_OTHER does not correspond to any ISO/IEC/IEEE 60559:2020 rounding-direction attribute; if
supported, the effect of this rounding mode is processor dependent.
The subroutine IEEE_GET_ROUNDING_MODE can be used to get the rounding modes. The initial rounding
modes are processor dependent.
If the processor supports the alteration of the rounding modes during execution, the subroutine IEEE_SET_-
ROUNDING_MODE can be used to alter them.
In a procedure other than IEEE_SET_ROUNDING_MODE or IEEE_SET_STATUS, the processor shall not
change the rounding modes on entry, and on return shall ensure that the rounding modes are the same as they
were on entry.
<b>NOTE</b> <b>1</b>
ISO/IEC 60559:2020 requires support for roundTiesToAway only for decimal floating-point.
<b>NOTE</b> <b>2</b>
ISO/IEC60559:2020requiresthatthereisalanguage-definedmeanstospecifyaconstantvaluefortherounding-
direction attribute for all standard operations in a block. The means provided by this document are a CALL
to IEEE_GET_ROUNDING_MODE at the beginning of the block followed by a CALL to IEEE_SET_-
ROUNDING_MODE with constant arguments, together with another CALL to IEEE_SET_ROUNDING_-
MODE at the end of the block to restore the rounding mode.
<b>NOTE</b> <b>3</b>
Within a program, all literal constants that have the same form have the same value (7.1.4). Therefore, the
value of a literal constant is not affected by the rounding modes.
<b>17.5</b> <b>Underflow</b> <b>mode</b>
Some processors allow control during program execution of whether underflow produces a subnormal number in
conformancewithISO/IEC60559:2020(gradualunderflow)orproduceszeroinstead(abruptunderflow). Onsome
processors, floating-point performance is typically better in abrupt underflow mode than in gradual underflow
mode.
Control over the underflow mode is exercised by invocation of IEEE_SET_UNDERFLOW_MODE. The sub-
routine IEEE_GET_UNDERFLOW_MODE can be used to get the underflow mode. The inquiry function
IEEE_SUPPORT_UNDERFLOW_CONTROL can be used to inquire whether this facility is available. The
initial underflow mode is processor dependent. In a procedure other than IEEE_SET_UNDERFLOW_MODE
or IEEE_SET_STATUS, the processor shall not change the underflow mode on entry, and on return shall ensure
that the underflow mode is the same as it was on entry.
The underflow mode affects only floating-point calculations whose type is that of an X for which IEEE_SUP-
PORT_UNDERFLOW_CONTROL returns true.
<b>17.6</b> <b>Halting</b>
Some processors allow control during program execution of whether to abort or continue execution after an
exception. Such control is exercised by invocation of the subroutine IEEE_SET_HALTING_MODE. Halting
is not precise and may occur any time after the exception has occurred. The initial halting mode is processor
dependent. In a procedure other than IEEE_SET_HALTING_MODE or IEEE_SET_STATUS, the processor
shall not change the halting mode on entry, and on return shall ensure that the halting mode is the same as it
was on entry.
<b>17.7</b> <b>The</b> <b>floating-point</b> <b>modes</b> <b>and</b> <b>status</b>
The values of the rounding modes, underflow mode, and halting mode are collectively called the floating-point
modes. The values of all the supported flags for exceptions and the floating-point modes are collectively called the
floating-point status. The floating-point modes can be stored in a scalar variable of type IEEE_MODES_TYPE
with the subroutine IEEE_GET_MODES and restored with the subroutine IEEE_SET_MODES. The floating-
point status can be stored in a scalar variable of type IEEE_STATUS_TYPE with the subroutine IEEE_GET_-
STATUS and restored with the subroutine IEEE_SET_STATUS. There are no facilities for finding the values of
particular flags represented by such a variable.
<b>NOTE</b> <b>1</b>
Each image has its own floating-point status (5.3.4).
<b>NOTE</b> <b>2</b>
Some processors hold all these flags and modes in one or two status registers that can be obtained and set as
a whole faster than all individual flags and modes can be obtained and set. These procedures are provided to
exploit this feature.
<b>NOTE</b> <b>3</b>
The processor is required to ensure that a call to a Fortran procedure does not change the floating-point status
other than by setting exception flags to signaling.
<b>17.8</b> <b>Exceptional</b> <b>values</b>
ISO/IEC 60559:2020 specifies the following exceptional floating-point values.
 Subnormal values have very small absolute values and reduced precision.
 Infinite values (+infinity and-infinity) are created by overflow or division by zero.
 Not-a-Number ( NaN) values are undefined values or values created by an invalid operation.
A value that does not fall into the above classes is called a normal number.
The functions IEEE_IS_FINITE, IEEE_IS_NAN, IEEE_IS_NEGATIVE, and IEEE_IS_NORMAL are
provided to test whether a value is finite, NaN, negative, or normal. The function IEEE_VALUE is provided to
generate an IEEE number of any class, including an infinity or a NaN. The inquiry functions IEEE_SUPPORT_-
SUBNORMAL, IEEE_SUPPORT_INF, and IEEE_SUPPORT_NAN are provided to determine whether these
facilities are available for a particular kind of real.
<b>17.9</b> <b>IEEE</b> <b>arithmetic</b>
The inquiry function IEEE_SUPPORT_DATATYPE can be used to inquire whether IEEE arithmetic is sup-
ported for a particular kind of real. Complete conformance with ISO/IEC 60559:2020 is not required, but
 the normal numbers shall be exactly those of an ISO/IEC/IEEE 60559:2020 floating-point format,
 for at least one rounding mode, the intrinsic operations of addition, subtraction and multiplication shall
  conform whenever the operands and result specified by ISO/IEC 60559:2020 are normal numbers,
 the IEEE function abs shall be provided by the intrinsic function ABS,
 the IEEE operation remainder shall be provided by the function IEEE_REM, and
 the IEEE functions copySign, logB, and compareQuietUnordered shall be provided by the functions IEEE_-
  COPY_SIGN, IEEE_LOGB, and IEEE_UNORDERED, respectively,
for that kind of real.
The inquiry function IEEE_SUPPORT_NAN is provided to inquire whether the processor supports IEEE NaNs.
Where these are supported, the result of the intrinsic operations +,-, and *, and the functions IEEE_REM and
IEEE_RINT from the intrinsic module IEEE_ARITHMETIC, shall conform to ISO/IEC 60559:2020 when the
result is an IEEE NaN.
The inquiry function IEEE_SUPPORT_INF is provided to inquire whether the processor supports IEEE infinit-
ies. Where these are supported, the result of the intrinsic operations +,-, and *, and the functions IEEE_REM
and IEEE_RINT from the intrinsic module IEEE_ARITHMETIC, shall conform to ISO/IEC 60559:2020 when
exactly one operand or the result specified by ISO/IEC 60559:2020 is an IEEE infinity.
The inquiry function IEEE_SUPPORT_SUBNORMAL is provided to inquire whether the processor supports
subnormal numbers. Where these are supported, the result of the intrinsic operations +,-, and *, and the func-
tions IEEE_REM and IEEE_RINT from the intrinsic module IEEE_ARITHMETIC, shall conform to ISO/IEC
60559:2020 when the result specified by ISO/IEC 60559:2020 is subnormal, or any operand is subnormal and
either the result is not an IEEE infinity or IEEE_SUPPORT_INF is true.
The inquiry function IEEE_SUPPORT_DIVIDE is provided to inquire whether, on kinds of real for which
IEEE_SUPPORT_DATATYPE returns true, the intrinsic division operation conforms to ISO/IEC 60559:2020
when both operands and the result specified by ISO/IEC 60559:2020 are normal numbers. If IEEE_SUPPORT_-
NAN is also true for a particular kind of real, the intrinsic division operation on that kind conforms to ISO/IEC
60559:2020 when the result specified by ISO/IEC 60559:2020 is a NaN. If IEEE_SUPPORT_INF is also true for
a particular kind of real, the intrinsic division operation on that kind conforms to ISO/IEC 60559:2020 when one
operand or the result specified by ISO/IEC 60559:2020 is an IEEE infinity. If IEEE_SUPPORT_SUBNORMAL
is also true for a particular kind of real, the intrinsic division operation on that kind conforms to ISO/IEC
60559:2020 when the result specified by ISO/IEC 60559:2020 is subnormal, or when any operand is subnormal
and either the result specified by ISO/IEC 60559:2020 is not an infinity or IEEE_SUPPORT_INF is true.
ISO/IEC 60559:2020 specifies a square root function that returns negative real zero for the square root of neg-
ative real zero and has certain accuracy requirements. The inquiry function IEEE_SUPPORT_SQRT can be
used to inquire whether the intrinsic function SQRT conforms to ISO/IEC 60559:2020 for a particular kind of
real. If IEEE_SUPPORT_NAN is also true for a particular kind of real, the intrinsic function SQRT on that
kind conforms to ISO/IEC 60559:2020 when the result specified by ISO/IEC 60559:2020 is a NaN. If IEEE_-
SUPPORT_INF is also true for a particular kind of real, the intrinsic function SQRT on that kind conforms
to ISO/IEC 60559:2020 when the result specified by ISO/IEC 60559:2020 is an IEEE infinity. If IEEE_SUP-
PORT_SUBNORMALisalsotrueforaparticular kindof real, the intrinsic function SQRTon that kindconforms
to ISO/IEC 60559:2020 when the argument is subnormal.
The inquiry function IEEE_SUPPORT_STANDARD is provided to inquire whether the processor supports all
the ISO/IEC/IEEE 60559:2020 facilities defined in this document for a particular kind of real.
<b>17.10</b> <b>Summary</b> <b>of</b> <b>the</b> <b>procedures</b>
For all of the procedures defined in the modules, the arguments shown are the names that shall be used for
argument keywords if the keyword form is used for the actual arguments.
A procedure classified in 17.10 as an inquiry function depends on the properties of one or more of its arguments
instead of their values; in fact, these argument values may be undefined. Unless the description of one of these
inquiry functions states otherwise, these arguments are permitted to be unallocated allocatable variables or
pointers that are undefined or disassociated. A procedure that is classified as a transformational function is
neither an inquiry function nor elemental.
In the Class column of Tables 17.2 and 17.3,
 E indicates that the procedure is an elemental function,
ES indicates that the procedure is a simple elemental subroutine,
 I indicates that the procedure is an inquiry function,
SS indicates that the procedure is a simple subroutine, and
 T indicates that the procedure in a transformational function.
       <b>Table</b> <b>17.2</b> <b>-</b> <b>IEEE_ARITHMETIC</b> <b>module</b> <b>procedure</b> <b>summary</b>
 Procedure (arguments) Class Description
 IEEE_CLASS (X) E Classify number.
 IEEE_COPY_SIGN (X, Y) E Copy sign.
 IEEE_FMA (A, B, C) E Fused multiply-add operation.
 IEEE_GET_ROUNDING_MODE (ROUND_VALUE SS Get rounding mode.
  [, RADIX])
 IEEE_GET_UNDERFLOW_MODE (GRADUAL) SS Get underflow mode.
 IEEE_INT (A, ROUND [, KIND]) E Conversion to integer type.
 IEEE_IS_FINITE (X) E Whether a value is finite.
 IEEE_IS_NAN (X) E Whether a value is an IEEE NaN.
 IEEE_IS_NEGATIVE (X) E Whether a value is negative.
 IEEE_IS_NORMAL (X) E Whether a value is a normal number.
 IEEE_LOGB (X) E Exponent.
 IEEE_MAX (X, Y) E Maximum value.
 IEEE_MAX_MAG (X, Y) E Maximum magnitude value.
 IEEE_MAX_NUM (X, Y) E Maximum numeric value.
 IEEE_MAX_NUM_MAG (X, Y) E Maximum magnitude numeric value.
 IEEE_MIN (X, Y) E Minimum value.
 IEEE_MIN_MAG (X, Y) E Minimum magnitude value.
 IEEE_MIN_NUM (X, Y) E Minimum numeric value.
 IEEE_MIN_NUM_MAG (X, Y) E Minimum magnitude numeric value.
 IEEE_NEXT_AFTER (X, Y) E Adjacent machine number.
 IEEE_NEXT_DOWN (X) E Adjacent lower machine number.
 IEEE_NEXT_UP (X) E Adjacent higher machine number.
 IEEE_QUIET_EQ (A, B) E Quiet compares equal.
 IEEE_QUIET_GE (A, B) E Quiet compares greater than or equal.
 IEEE_QUIET_GT (A, B) E Quiet compares greater than.
 IEEE_QUIET_LE (A, B) E Quiet compares less than or equal.
 IEEE_QUIET_LT (A, B) E Quiet compares less than.
 IEEE_QUIET_NE (A, B) E Quiet compares not equal.
 IEEE_REAL (A [, KIND]) E Conversion to real type.
 IEEE_REM (X, Y) E Exact remainder.
 IEEE_RINT (X) E Round to integer.
 IEEE_SCALB (X, I) E <i>X</i>x 2
                                  <i>I</i>
                                 .
 IEEE_SELECTED_REAL_KIND ([P, R, RADIX]) T IEEE kind type parameter value.
 IEEE_SET_ROUNDING_MODE (ROUND_VALUE SS Set rounding mode.
  [, RADIX])
 IEEE_SET_UNDERFLOW_MODE (GRADUAL) SS Set underflow mode.
 IEEE_SIGNALING_EQ (A, B) E Signaling compares equal.
 IEEE_SIGNALING_GE (A, B) E Signalingcomparesgreaterthanorequal.
 IEEE_SIGNALING_GT (A, B) E Signaling compares greater than.
      <b>Table</b> <b>17.2:</b> <b>IEEE_ARITHMETIC</b> <b>module</b> <b>procedure</b> <b>summary</b> (cont.)
 Procedure (arguments) Class Description
 IEEE_SIGNALING_LE (A, B) E Signaling compares less than or equal.
 IEEE_SIGNALING_LT (A, B) E Signaling compares less than.
 IEEE_SIGNALING_NE (A, B) E Signaling compares not equal.
 IEEE_SIGNBIT (X) E Test sign bit.
 IEEE_SUPPORT_DATATYPE ([X]) I Query IEEE arithmetic support.
 IEEE_SUPPORT_DENORMAL ([X]) I Query subnormal number support.
 IEEE_SUPPORT_DIVIDE ([X]) I Query IEEE division support.
 IEEE_SUPPORT_INF ([X]) I Query IEEE infinity support.
 IEEE_SUPPORT_IO ([X]) I Query IEEE formatting support.
 IEEE_SUPPORT_NAN ([X]) I Query IEEE NaN support.
 IEEE_SUPPORT_ROUNDING (ROUND_VALUE [, X]) T Query IEEE rounding support.
 IEEE_SUPPORT_SQRT ([X]) I Query IEEE square root support.
 IEEE_SUPPORT_SUBNORMAL ([X]) I Query subnormal number support.
 IEEE_SUPPORT_STANDARD ([X]) I Query IEEE standard support.
 IEEE_SUPPORT_UNDERFLOW_CONTROL ([X]) I Query underflow control support.
 IEEE_UNORDERED (X, Y) E Whether two values are unordered.
 IEEE_VALUE (X, CLASS) E Return number in a class.
       <b>Table</b> <b>17.3</b> <b>-</b> <b>IEEE_EXCEPTIONS</b> <b>module</b> <b>procedure</b> <b>summary</b>
   Procedure (arguments) Class Description
   IEEE_GET_FLAG (FLAG, FLAG_VALUE) ES Get an exception flag.
   IEEE_GET_HALTING_MODE (FLAG, HALTING) ES Get a halting mode.
   IEEE_GET_MODES (MODES) SS Get floating-point modes.
   IEEE_GET_STATUS (STATUS_VALUE) SS Get floating-point status.
   IEEE_SET_FLAG (FLAG, FLAG_VALUE) SS Set an exception flag.
   IEEE_SET_HALTING_MODE (FLAG, HALTING) SS Set a halting mode.
   IEEE_SET_MODES (MODES) SS Set floating-point modes.
   IEEE_SET_STATUS (STATUS_VALUE) SS Restore floating-point status.
   IEEE_SUPPORT_FLAG (FLAG [, X]) T Query exception support.
   IEEE_SUPPORT_HALTING (FLAG) T Query halting mode support.
In the intrinsic module IEEE_ARITHMETIC, the elemental functions listed are provided for all reals X and Y.
<b>17.11</b> <b>Specifications</b> <b>of</b> <b>the</b> <b>procedures</b>
<b>17.11.1</b> <b>General</b>
In the detailed descriptions in 17.11, procedure names are generic and are not specific. All the functions are
simple and all the subroutines are impure unless otherwise stated. All dummy arguments have INTENT (IN) if
the intent is not stated explicitly. In the examples, it is assumed that the processor supports IEEE arithmetic
for default real.
For the elemental functions of IEEE_ARITHMETIC that return a floating-point result, if X or Y has a value
that is an infinity or a NaN, the result shall be consistent with the general rules in 6.1 and 6.2 of ISO/IEC
60559:2020. For example, the result for an infinity shall be constructed as the limiting case of the result with a
value of arbitrarily large magnitude, if such a limit exists.
A program may contain statements that, if executed, would violate the requirements listed in a <b>Restriction</b>
paragraph.
<b>NOTE</b>
A program can avoid violating those requirements by using IF constructs to check whether particular features
are supported. For example,
   IF (IEEE_SUPPORT_DATATYPE (X)) THEN
    C = IEEE_CLASS (X)
   ELSE
     ...
   END IF
avoids invoking IEEE_CLASS except on a processor which supports that facility.
<b>17.11.2</b> <b>IEEE_CLASS</b> <b>(X)</b>
<b>Description.</b> Classify number.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real.
<b>Restriction.</b> IEEE_CLASS (X) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the value false.
<b>Result</b> <b>Characteristics.</b> IEEE_CLASS_TYPE.
<b>Result</b> <b>Value.</b> The result value shall be IEEE_SIGNALING_NAN or IEEE_QUIET_NAN if IEEE_SUP-
PORT_NAN (X) has the value true and the value of X is a signaling or quiet NaN, respectively. The result
value shall be IEEE_NEGATIVE_INF or IEEE_POSITIVE_INF if IEEE_SUPPORT_INF (X) has the value
true and the value of X is negative or positive infinity, respectively. The result value shall be IEEE_NEG-
ATIVE_SUBNORMAL or IEEE_POSITIVE_SUBNORMAL if IEEE_SUPPORT_SUBNORMAL (X) has the
value true and the value of X is a negative or positive subnormal value, respectively. The result value shall
be IEEE_NEGATIVE_NORMAL, IEEE_NEGATIVE_ZERO, IEEE_POSITIVE_ZERO, or IEEE_POSIT-
IVE_NORMAL if the value of X is negative normal, negative zero, positive zero, or positive normal, respectively.
Otherwise, the result value shall be IEEE_OTHER_VALUE.
<b>Example.</b> IEEE_CLASS (-1.0) has the value IEEE_NEGATIVE_NORMAL.
<b>NOTE</b>
The result value IEEE_OTHER_VALUE is useful on systems that are almost IEEE-compatible, but do not
implement all of it. For example, if a subnormal value is encountered on a system that does not support them.
<b>17.11.3</b> <b>IEEE_COPY_SIGN</b> <b>(X,</b> <b>Y)</b>
<b>Description.</b> Copy sign.
<b>Class.</b> Elemental function.
<b>Arguments.</b> The arguments shall be of type real.
<b>Restriction.</b> IEEE_COPY_SIGN (X, Y) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) or
IEEE_SUPPORT_DATATYPE (Y) has the value false.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has the absolute value of X with the sign of Y. This is true even for IEEE special
values, such as a NaN or an infinity (on processors supporting such values).
<b>Example.</b> The value of IEEE_COPY_SIGN (X, 1.0) is ABS (X) even when X is a NaN.
<b>17.11.4</b> <b>IEEE_FMA</b> <b>(A,</b> <b>B,</b> <b>C)</b>
<b>Description.</b> Fused multiply-add operation.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
A shall be of type real.
B shall be of the same type and kind type parameter as A.
C shall be of the same type and kind type parameter as A.
<b>Restriction.</b> IEEE_FMA (A, B, C) shall not be invoked if IEEE_SUPPORT_DATATYPE (A) has the value
false.
<b>Result</b> <b>Characteristics.</b> Same as A.
<b>Result</b> <b>Value.</b> The result has the value specified by ISO/IEC 60559:2020 for the fusedMultiplyAdd operation;
that is, when the result is in range, its value is equal to the mathematical value of (AxB) +C rounded to the
representation method of A according to the rounding mode. IEEE_OVERFLOW, IEEE_UNDERFLOW, and
IEEE_INEXACT shall be signaled according to the final step in the calculation and not by any intermediate
calculation.
<b>Example.</b> The value of IEEE_FMA (TINY (0.0), TINY (0.0), 1.0), when the rounding mode is IEEE_-
NEAREST, is equal to 1.0; only the IEEE_INEXACT exception is signaled.
<b>17.11.5</b> <b>IEEE_GET_FLAG</b> <b>(FLAG,</b> <b>FLAG_VALUE)</b>
<b>Description.</b> Get an exception flag.
<b>Class.</b> Simple elemental subroutine.
<b>Arguments.</b>
FLAG shall be of type IEEE_FLAG_TYPE. It specifies the exception flag to be obtained.
FLAG_VALUE shall be of type logical. It is an INTENT (OUT) argument. If the value of FLAG is IEEE_-
     INVALID, IEEE_OVERFLOW, IEEE_DIVIDE_BY_ZERO, IEEE_UNDERFLOW, or IEEE_-
     INEXACT,FLAG_VALUEisassignedthevaluetrueifthecorrespondingexceptionflagissignaling
     and is assigned the value false otherwise.
<b>Example.</b> Following CALL IEEE_GET_FLAG (IEEE_OVERFLOW, FLAG_VALUE), FLAG_VALUE is
true if the IEEE_OVERFLOW flag is signaling and is false if it is quiet.
<b>17.11.6</b> <b>IEEE_GET_HALTING_MODE</b> <b>(FLAG,</b> <b>HALTING)</b>
<b>Description.</b> Get a halting mode.
<b>Class.</b> Simple elemental subroutine.
<b>Arguments.</b>
FLAG shall be of type IEEE_FLAG_TYPE. It specifies the exception flag. It shall have one of the val-
     ues IEEE_INVALID, IEEE_OVERFLOW, IEEE_DIVIDE_BY_ZERO, IEEE_UNDERFLOW,
     or IEEE_INEXACT.
HALTING shall be of type logical. It is an INTENT (OUT) argument. It is assigned the value true if the
     exception specified by FLAG will cause halting. Otherwise, it is assigned the value false.
<b>Example.</b> To store the halting mode for IEEE_OVERFLOW, do a calculation without halting, and restore the
halting mode later:
   USE, INTRINSIC :: IEEE_ARITHMETIC
   LOGICAL HALTING
   ...
   CALL IEEE_GET_HALTING_MODE (IEEE_OVERFLOW, HALTING) ! Store halting mode
   CALL IEEE_SET_HALTING_MODE (IEEE_OVERFLOW, .FALSE.) ! No halting
   ... ! calculation without halting
   CALL IEEE_SET_HALTING_MODE (IEEE_OVERFLOW, HALTING) ! Restore halting mode
<b>17.11.7</b> <b>IEEE_GET_MODES</b> <b>(MODES)</b>
<b>Description.</b> Get floating-point modes.
<b>Class.</b> Simple subroutine.
<b>Argument.</b> MODES shall be a scalar of type IEEE_MODES_TYPE. It is an INTENT (OUT) argument that
is assigned the value of the floating-point modes.
<b>Example.</b> To save the floating-point modes, do a calculation with specific rounding and underflow modes, and
restore them later:
   USE, INTRINSIC :: IEEE_ARITHMETIC
   TYPE (IEEE_MODES_TYPE) SAVE_MODES
   ...
   CALL IEEE_GET_MODES (SAVE_MODES) ! Save all modes.
   CALL IEEE_SET_ROUNDING_MODE (IEEE_TO_ZERO)
   CALL IEEE_SET_UNDERFLOW_MODE (GRADUAL=.FALSE.)
   ... ! calculation with abrupt round-to-zero.
   CALL IEEE_SET_MODES (SAVE_MODES) ! Restore all modes.
<b>17.11.8</b> <b>IEEE_GET_ROUNDING_MODE</b> <b>(ROUND_VALUE</b> <b>[,</b> <b>RADIX])</b>
<b>Description.</b> Get rounding mode.
<b>Class.</b> Simple subroutine.
<b>Arguments.</b>
ROUND_VALUE shall be a scalar of type IEEE_ROUND_TYPE. It is an INTENT (OUT) argument. It is
     assigned the value IEEE_NEAREST, IEEE_TO_ZERO, IEEE_UP, IEEE_DOWN, or IEEE_-
     AWAY if the corresponding rounding mode is in operation and IEEE_OTHER otherwise.
RADIX (optional) shall be an integer scalar with the value two or ten. If RADIX is present with the value ten,
     the rounding mode queried is the decimal rounding mode, otherwise it is the binary rounding mode.
<b>Example.</b> To save the binary rounding mode, do a calculation with round to nearest, and restore the rounding
mode later:
   USE, INTRINSIC :: IEEE_ARITHMETIC
   TYPE (IEEE_ROUND_TYPE) ROUND_VALUE
   ...
   CALL IEEE_GET_ROUNDING_MODE (ROUND_VALUE) ! Store the rounding mode
   CALL IEEE_SET_ROUNDING_MODE (IEEE_NEAREST)
   ... ! calculation with round to nearest
   CALL IEEE_SET_ROUNDING_MODE (ROUND_VALUE) ! Restore the rounding mode
<b>17.11.9</b> <b>IEEE_GET_STATUS</b> <b>(STATUS_VALUE)</b>
<b>Description.</b> Get floating-point status.
<b>Class.</b> Simple subroutine.
<b>Argument.</b> STATUS_VALUE shall be a scalar of type IEEE_STATUS_TYPE. It is an INTENT (OUT)
argument. It is assigned the value of the floating-point status.
<b>Example.</b> To store all the exception flags, do a calculation involving exception handling, and restore them later:
   USE, INTRINSIC :: IEEE_ARITHMETIC
   TYPE (IEEE_STATUS_TYPE) STATUS_VALUE
   ...
   CALL IEEE_GET_STATUS (STATUS_VALUE) ! Get the flags
   CALL IEEE_SET_FLAG (IEEE_ALL, .FALSE.) ! Set the flags quiet.
   ... ! calculation involving exception handling
   CALL IEEE_SET_STATUS (STATUS_VALUE) ! Restore the flags
<b>17.11.10</b> <b>IEEE_GET_UNDERFLOW_MODE</b> <b>(GRADUAL)</b>
<b>Description.</b> Get underflow mode.
<b>Class.</b> Simple subroutine.
<b>Argument.</b> GRADUAL shall be a logical scalar. It is an INTENT (OUT) argument. It is assigned the value
true if the underflow mode is gradual underflow, and false if the underflow mode is abrupt underflow.
<b>Restriction.</b> IEEE_GET_UNDERFLOW_MODE shall not be invoked unless IEEE_SUPPORT_UNDER-
FLOW_CONTROL (X) is true for some X.
<b>Example.</b> After CALL IEEE_SET_UNDERFLOW_MODE (.FALSE.), a subsequent CALL IEEE_GET_-
UNDERFLOW_MODE (GRADUAL) will set GRADUAL to false.
<b>17.11.11</b> <b>IEEE_INT</b> <b>(A,</b> <b>ROUND</b> <b>[,</b> <b>KIND])</b>
<b>Description.</b> Conversion to integer type.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
A shall be of type real.
ROUND shall be of type IEEE_ROUND_TYPE.
KIND (optional) shall be a scalar integer constant expression.
<b>Restriction.</b> IEEE_INT (A, ROUND, KIND) shall not be invoked if IEEE_SUPPORT_DATATYPE (A) has
the value false.
<b>Result</b> <b>Characteristics.</b> Integer. If KIND is present, the kind type parameter is that specified by the value of
KIND; otherwise, the kind type parameter is that of default integer.
<b>Result</b> <b>Value.</b> The result has the value specified by ISO/IEC 60559:2020 for the convertToInteger{round} or
the convertToIntegerExact{round} operation; the processor shall consistently choose which operation it provides.
That is, the value of A is converted to an integer according to the rounding mode specified by ROUND; if this
value is representable in the representation method of the result, the result has this value, otherwise IEEE_-
INVALID is signaled and the result is processor dependent. If the processor provides the convertToIntegerExact
operation, IEEE_INVALID did not signal, and the value of the result differs from that of A, IEEE_INEXACT
will be signaled.
<b>Example.</b> The value of IEEE_INT (12.5, IEEE_UP) is 13; IEEE_INEXACT will be signaled if the processor
provides the convertToIntegerExact operation.
<b>17.11.12</b> <b>IEEE_IS_FINITE</b> <b>(X)</b>
<b>Description.</b> Whether a value is finite.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real.
<b>Restriction.</b> IEEE_IS_FINITE (X) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the value
false.
<b>Result</b> <b>Characteristics.</b> Default logical.
<b>Result</b> <b>Value.</b> The result has the value true if the value of X is finite, that is, IEEE_CLASS (X) has one
of the values IEEE_NEGATIVE_NORMAL, IEEE_NEGATIVE_SUBNORMAL, IEEE_NEGATIVE_ZERO,
IEEE_POSITIVE_ZERO, IEEE_POSITIVE_SUBNORMAL, or IEEE_POSITIVE_NORMAL; otherwise, the
result has the value false.
<b>Example.</b> IEEE_IS_FINITE (1.0) has the value true.
<b>17.11.13</b> <b>IEEE_IS_NAN</b> <b>(X)</b>
<b>Description.</b> Whether a value is an IEEE NaN.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real.
<b>Restriction.</b> IEEE_IS_NAN (X) shall not be invoked if IEEE_SUPPORT_NAN (X) has the value false.
<b>Result</b> <b>Characteristics.</b> Default logical.
<b>Result</b> <b>Value.</b> The result has the value true if the value of X is an IEEE NaN; otherwise, it has the value false.
<b>Example.</b> IEEE_IS_NAN (SQRT (-1.0)) has the value true if IEEE_SUPPORT_SQRT (1.0) has the value
true.
<b>17.11.14</b> <b>IEEE_IS_NEGATIVE</b> <b>(X)</b>
<b>Description.</b> Whether a value is negative.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real.
<b>Restriction.</b> IEEE_IS_NEGATIVE (X) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the
value false.
<b>Result</b> <b>Characteristics.</b> Default logical.
<b>Result</b> <b>Value.</b> The result has the value true if IEEE_CLASS (X) has one of the values IEEE_NEGATIVE_-
NORMAL, IEEE_NEGATIVE_SUBNORMAL, IEEE_NEGATIVE_ZERO or IEEE_NEGATIVE_INF; oth-
erwise, the result has the value false.
<b>Example.</b> IEEE_IS_NEGATIVE (0.0) has the value false.
<b>17.11.15</b> <b>IEEE_IS_NORMAL</b> <b>(X)</b>
<b>Description.</b> Whether a value is a normal number.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real.
<b>Restriction.</b> IEEE_IS_NORMAL (X) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the
value false.
<b>Result</b> <b>Characteristics.</b> Default logical.
<b>Result</b> <b>Value.</b> The result has the value true if IEEE_CLASS (X) has one of the values IEEE_NEGATIVE_-
NORMAL, IEEE_NEGATIVE_ZERO, IEEE_POSITIVE_ZERO or IEEE_POSITIVE_NORMAL; otherwise,
the result has the value false.
<b>Example.</b> IEEE_IS_NORMAL (SQRT (-1.0) has the value false if IEEE_SUPPORT_SQRT (1.0) has the
value true.
<b>17.11.16</b> <b>IEEE_LOGB</b> <b>(X)</b>
<b>Description.</b> Exponent.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real.
<b>Restriction.</b> IEEE_LOGB (X) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the value false.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> If the value of X is neither zero, infinity, nor NaN, the result has the value of the unbiased exponent
     of X. Note: this value is equal to EXPONENT (X)- 1.
<i>Case</i> <i>(ii):</i> If X==0, the result is-infinity if IEEE_SUPPORT_INF (X) is true and-HUGE (X) otherwise;
     IEEE_DIVIDE_BY_ZERO signals.
<i>Case</i> <i>(iii):</i> If IEEE_SUPPORT_INF (X) is true and X is infinite, the result is +infinity.
<i>Case</i> <i>(iv):</i> If IEEE_SUPPORT_NAN (X) is true and X is a NaN, the result is a NaN.
<b>Example.</b> IEEE_LOGB (-1.1) has the value 0.0.
<b>17.11.17</b> <b>IEEE_MAX</b> <b>(X,</b> <b>Y)</b>
<b>Description.</b> Maximum value.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
X shall be of type real.
Y shall be of the same type and kind type parameter as X.
<b>Restriction.</b> IEEE_MAX shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the value false.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has the value specified for the maximum operation in ISO/IEC 60559:2020; that is,
 if X <i>></i> Y the result has the value of X;
 if Y <i>></i> X the result has the value of Y;
 if either operand is a NaN, the result is a quiet Nan;
 if X = Y and the signs are the same, the result is the value of either X or Y;
 otherwise (one argument is negative zero and the other is positive zero), the result is positive zero.
If one or both of X and Y are signaling NaNs, IEEE_INVALID signals; otherwise, no exception is signaled.
<b>Example.</b> The value of IEEE_MAX (1.5, IEEE_VALUE (1.0, IEEE_QUIET_NAN)) is a quiet NaN.
<b>17.11.18</b> <b>IEEE_MAX_MAG</b> <b>(X,</b> <b>Y)</b>
<b>Description.</b> Maximum magnitude value.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
X shall be of type real.
Y shall be of the same type and kind type parameter as X.
<b>Restriction.</b> IEEE_MAX_MAG shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the value
false.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b>
The result has the value specified for the maximumMagnitude operation in ISO/IEC 60559:2020; that is,
 if|X|<i>></i>|Y| the result has the value of X;
 if|Y|<i>></i>|X| the result has the value of Y;
 otherwise, the result has the value of IEEE_MAX (X, Y).
If one or both of X and Y are signaling NaNs, IEEE_INVALID signals; otherwise, no exception is signaled.
<b>Example.</b> The value of IEEE_MAX_MAG (1.5,-2.5) is-2<i>.</i>5.
<b>17.11.19</b> <b>IEEE_MAX_NUM</b> <b>(X,</b> <b>Y)</b>
<b>Description.</b> Maximum numeric value.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
X shall be of type real.
Y shall be of the same type and kind type parameter as X.
<b>Restriction.</b> IEEE_MAX_NUM shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the value
false.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has the value specified for the maximumNumber operation in ISO/IEC 60559:2020;
that is,
 if X<i>></i> Y the result has the value of X;
 if Y <i>></i> X the result has the value of Y;
 if exactly one of X and Y is a NaN the result has the value of the other argument;
 if both X and Y are NaNs, the result is a quiet NaN;
 if X = Y and the signs are the same, the result is either X or Y;
 otherwise (one argument is negative zero and the other is positive zero), the result is positive zero.
If one or both of X and Y are signaling NaNs, IEEE_INVALID signals, but unless X and Y are both signaling
NaNs, thesignalingNaNisotherwiseignoredandnotconvertedtoaquietNaN.Nootherexceptionsaresignaled.
<b>Example.</b> The value of IEEE_MAX_NUM (1.5, IEEE_VALUE (1.0, IEEE_QUIET_NAN)) is 1.5.
<b>17.11.20</b> <b>IEEE_MAX_NUM_MAG</b> <b>(X,</b> <b>Y)</b>
<b>Description.</b> Maximum magnitude numeric value.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
X shall be of type real.
Y shall be of the same type and kind type parameter as X.
<b>Restriction.</b> IEEE_MAX_NUM_MAG shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the
value false.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has the value specified for the maximumMagnitudeNumber operation in ISO/IEC
60559:2020; that is,
 if|X|<i>></i>|Y| the result has the value of X;
 if|Y|<i>></i>|X| the result has the value of Y;
 otherwise, the result has the value of IEEE_MAX_NUM (X, Y).
If one or both of X and Y are signaling NaNs, IEEE_INVALID signals, but unless X and Y are both signaling
NaNs, thesignalingNaNisotherwiseignoredandnotconvertedtoaquietNaN.Nootherexceptionsaresignaled.
<b>Example.</b> The value of IEEE_MAX_NUM_MAG (1.5,-2<i>.</i>5) is-2<i>.</i>5.
<b>17.11.21</b> <b>IEEE_MIN</b> <b>(X,</b> <b>Y)</b>
<b>Description.</b> Minimum value.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
X shall be of type real.
Y shall be of the same type and kind type parameter as X.
<b>Restriction.</b> IEEE_MIN shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the value false.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has the value specified for the minimum operation in ISO/IEC 60559:2020; that is,
 if X <i><</i> Y the result has the value of X;
 if Y <i><</i> X the result has the value of Y;
 if either operand is a NaN, the result is a quiet NaN;
 if X = Y and the signs are the same, the result is the value of either X or Y;
 otherwise (one argument is negative zero and the other is positive zero), the result is negative zero.
If one or both of X and Y are signaling NaNs, IEEE_INVALID signals; otherwise, no exception is signaled.
<b>Example.</b> The value of IEEE_MIN (1.5, IEEE_VALUE (1.0, IEEE_QUIET_NAN)) is a quiet NaN.
<b>17.11.22</b> <b>IEEE_MIN_MAG</b> <b>(X,</b> <b>Y)</b>
<b>Description.</b> Minimum magnitude value.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
X shall be of type real.
Y shall be of the same type and kind type parameter as X.
<b>Restriction.</b> IEEE_MIN_MAG shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the value false.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b>
The result has the value specified for the minimumMagnitude operation in ISO/IEC 60559:2020; that is,
 if|X|<i><</i>|Y| the result has the value of X;
 if|Y|<i><</i>|X| the result has the value of Y;
 otherwise, the result has the value of IEEE_MIN (X, Y).
If one or both of X and Y are signaling NaNs, IEEE_INVALID signals; otherwise, no exception is signaled.
<b>Example.</b> The value of IEEE_MIN_MAG (1.5,-2<i>.</i>5) is 1.5.
<b>17.11.23</b> <b>IEEE_MIN_NUM</b> <b>(X,</b> <b>Y)</b>
<b>Description.</b> Minimum numeric value.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
X shall be of type real.
Y shall be of the same type and kind type parameter as X.
<b>Restriction.</b> IEEE_MIN_NUM shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the value false.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has the value specified for the minimumNumber operation in ISO/IEC 60559:2020;
that is,
 if X <i><</i> Y the result has the value of X;
 if Y <i><</i> X the result has the value of Y;
 if exactly one of X and Y is a NaN the result has the value of the other argument;
 if both X and Y are NaNs, the result is a quiet NaN;
 if X = Y and the signs are the same, the result is either X or Y;
 otherwise (one argument is negative zero and the other is positive zero), the result is negative zero.
If one or both of X and Y are signaling NaNs, IEEE_INVALID signals, but unless X and Y are both signaling
NaNs, thesignalingNaNisotherwiseignoredandnotconvertedtoaquietNaN.Nootherexceptionsaresignaled.
<b>Example.</b> The value of IEEE_MIN_NUM (1.5, IEEE_VALUE (1.0, IEEE_QUIET_NAN)) is 1.5.
<b>17.11.24</b> <b>IEEE_MIN_NUM_MAG</b> <b>(X,</b> <b>Y)</b>
<b>Description.</b> Minimum magnitude numeric value.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
X shall be of type real.
Y shall be of the same type and kind type parameter as X.
<b>Restriction.</b> IEEE_MIN_NUM_MAG shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the
value false.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has the value specified for the minimumMagnitudeNumber operation in ISO/IEC
60559:2020; that is,
 if|X|<i><</i>|Y| the result has the value of X;
 if|Y|<i><</i>|X| the result has the value of Y;
 otherwise, the result has the value of IEEE_MIN_NUM (X, Y).
If one or both of X and Y are signaling NaNs, IEEE_INVALID signals, but unless X and Y are both signaling
NaNs, thesignalingNaNisotherwiseignoredandnotconvertedtoaquietNaN.Nootherexceptionsaresignaled.
<b>Example.</b> The value of IEEE_MIN_NUM_MAG (1.5,-2<i>.</i>5) is 1.5.
<b>17.11.25</b> <b>IEEE_NEXT_AFTER</b> <b>(X,</b> <b>Y)</b>
<b>Description.</b> Adjacent machine number.
<b>Class.</b> Elemental function.
<b>Arguments.</b> The arguments shall be of type real.
<b>Restriction.</b> IEEE_NEXT_AFTER (X, Y) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) or
IEEE_SUPPORT_DATATYPE (Y) has the value false.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> If X == Y, the result is X and no exception is signaled.
<i>Case</i> <i>(ii):</i> If X?= Y, the result has the value of the next representable neighbor of X in the direction of Y.
     The neighbors of zero (of either sign) are both nonzero. IEEE_OVERFLOW is signaled when
     X is finite but IEEE_NEXT_AFTER (X, Y) is infinite; IEEE_UNDERFLOW is signaled when
     IEEE_NEXT_AFTER (X, Y) is subnormal; in both cases, IEEE_INEXACT signals.
<b>Example.</b> The value of IEEE_NEXT_AFTER (1.0, 2.0) is 1.0 + EPSILON (X).
<b>17.11.26</b> <b>IEEE_NEXT_DOWN</b> <b>(X)</b>
<b>Description.</b> Adjacent lower machine number.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real.
<b>Restriction.</b> IEEE_NEXT_DOWN (X) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the
value false. IEEE_NEXT_DOWN (-HUGE (X)) shall not be invoked if IEEE_SUPPORT_INF (X) has the
value false.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has the value specified for the nextDown operation in ISO/IEC 60559:2020; that is, it
is the greatest value in the representation method of X that compares less than X, except when X is equal to-
the result has the value-, and when X is a NaN the result is a NaN. If X is a signaling NaN, IEEE_INVALID
signals; otherwise, no exception is signaled.
<b>Example.</b> If IEEE_SUPPORT_SUBNORMAL (0.0) is true, the value of IEEE_NEXT_DOWN (+0.0) is the
negative subnormal number with least magnitude.
<b>17.11.27</b> <b>IEEE_NEXT_UP</b> <b>(X)</b>
<b>Description.</b> Adjacent higher machine number.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real.
<b>Restriction.</b> IEEE_NEXT_UP (X) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the value
false. IEEE_NEXT_UP (HUGE (X)) shall not be invoked if IEEE_SUPPORT_INF (X) has the value false.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result has the value specified for the nextUp operation in ISO/IEC 60559:2020; that is,
it is the least value in the representation method of X that compares greater than X, except when X is equal
to + the result has the value +, and when X is a NaN the result is a NaN. If X is a signaling NaN,
IEEE_INVALID_signals; otherwise, no exception is signaled.
<b>Example.</b> If IEEE_SUPPORT_INF (X) is true, the value of IEEE_NEXT_UP (HUGE (X)) is +.
<b>17.11.28</b> <b>IEEE_QUIET_EQ</b> <b>(A,</b> <b>B)</b>
<b>Description.</b> Quiet compares equal.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
A shall be of type real.
B shall have the same type and kind type parameter as A.
<b>Restriction.</b> IEEE_QUIET_EQ (A, B) shall not be invoked if IEEE_SUPPORT_DATATYPE (A) has the
value false.
<b>Result</b> <b>Characteristics.</b> Default logical.
<b>Result</b> <b>Value.</b> The result has the value specified for the compareQuietEqual operation in ISO/IEC 60559:2020;
that is, it is true if and only if A compares equal to B. If A or B is a NaN, the result will be false. If A or B is a
signaling NaN, IEEE_INVALID signals; otherwise, no exception is signaled.
<b>Example.</b> IEEE_QUIET_EQ (1.0, IEEE_VALUE (1.0, IEEE_QUIET_NAN)) has the value false and no
exception is signaled.
<b>17.11.29</b> <b>IEEE_QUIET_GE</b> <b>(A,</b> <b>B)</b>
<b>Description.</b> Quiet compares greater than or equal.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
A shall be of type real.
B shall have the same type and kind type parameter as A.
<b>Restriction.</b> IEEE_QUIET_GE (A, B) shall not be invoked if IEEE_SUPPORT_DATATYPE (A) has the
value false.
<b>Result</b> <b>Characteristics.</b> Default logical.
<b>Result</b> <b>Value.</b> The result has the value specified for the compareQuietGreaterEqual operation in ISO/IEC
60559:2020; that is, it is true if and only if A compares greater than or equal to B. If A or B is a NaN, the result
will be false. If A or B is a signaling NaN, IEEE_INVALID signals; otherwise, no exception is signaled.
<b>Example.</b> IEEE_QUIET_GE (1.0, IEEE_VALUE (1.0, IEEE_QUIET_NAN)) has the value false and no
exception is signaled.
<b>17.11.30</b> <b>IEEE_QUIET_GT</b> <b>(A,</b> <b>B)</b>
<b>Description.</b> Quiet compares greater than.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
A shall be of type real.
B shall have the same type and kind type parameter as A.
<b>Restriction.</b> IEEE_QUIET_GT (A, B) shall not be invoked if IEEE_SUPPORT_DATATYPE (A) has the
value false.
<b>Result</b> <b>Characteristics.</b> Default logical.
<b>ResultValue.</b> Theresulthasthevaluespecified forthecompareQuietGreateroperationin ISO/IEC60559:2020;
that is, it is true if and only if A compares greater than B. If A or B is a NaN, the result will be false. If A or B
is a signaling NaN, IEEE_INVALID signals; otherwise, no exception is signaled.
<b>Example.</b> IEEE_QUIET_GT (1.0, IEEE_VALUE (1.0, IEEE_QUIET_NAN)) has the value false and no
exception is signaled.
<b>17.11.31</b> <b>IEEE_QUIET_LE</b> <b>(A,</b> <b>B)</b>
<b>Description.</b> Quiet compares less than or equal.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
A shall be of type real.
B shall have the same type and kind type parameter as A.
<b>Restriction.</b> IEEE_QUIET_LE (A, B) shall not be invoked if IEEE_SUPPORT_DATATYPE (A) has the
value false.
<b>Result</b> <b>Characteristics.</b> Default logical.
<b>Result</b> <b>Value.</b> The result has the value specified for the compareQuietLessEqual operation in ISO/IEC
60559:2020; that is, it is true if and only if A compares less than or equal to B. If A or B is a NaN, the
result will be false. If A or B is a signaling NaN, IEEE_INVALID signals; otherwise, no exception is signaled.
<b>Example.</b> IEEE_QUIET_LE (1.0, IEEE_VALUE (1.0, IEEE_QUIET_NAN)) has the value false and no
exception is signaled.
<b>17.11.32</b> <b>IEEE_QUIET_LT</b> <b>(A,</b> <b>B)</b>
<b>Description.</b> Quiet compares less than.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
A shall be of type real.
B shall have the same type and kind type parameter as A.
<b>Restriction.</b> IEEE_QUIET_LT (A, B) shall not be invoked if IEEE_SUPPORT_DATATYPE (A) has the
value false.
<b>Result</b> <b>Characteristics.</b> Default logical.
<b>Result</b> <b>Value.</b> The result has the value specified for the compareQuietLess operation in ISO/IEC 60559:2020;
that is, it is true if and only if A compares less than B. If A or B is a NaN, the result will be false. If A or B is a
signaling NaN, IEEE_INVALID signals; otherwise, no exception is signaled.
<b>Example.</b> IEEE_QUIET_LT (1.0, IEEE_VALUE (1.0, IEEE_QUIET_NAN)) has the value false and no
exception is signaled.
<b>17.11.33</b> <b>IEEE_QUIET_NE</b> <b>(A,</b> <b>B)</b>
<b>Description.</b> Quiet compares not equal.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
A shall be of type real.
B shall have the same type and kind type parameter as A.
<b>Restriction.</b> IEEE_QUIET_NE (A, B) shall not be invoked if IEEE_SUPPORT_DATATYPE (A) has the
value false.
<b>Result</b> <b>Characteristics.</b> Default logical.
<b>Result</b> <b>Value.</b> The result has the value specified for the compareQuietNotEqual operation in ISO/IEC
60559:2020; that is, it is true if and only if A compares not equal to B. If A or B is a NaN, the result will
be true. If A or B is a signaling NaN, IEEE_INVALID signals; otherwise, no exception is signaled.
<b>Example.</b> IEEE_QUIET_NE (1.0, IEEE_VALUE (1.0, IEEE_QUIET_NAN)) has the value true and no
exception is signaled.
<b>17.11.34</b> <b>IEEE_REAL</b> <b>(A</b> <b>[,</b> <b>KIND])</b>
<b>Description.</b> Conversion to real type.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
A shall be of type integer or real.
KIND (optional) shall be a scalar integer constant expression.
<b>Restriction.</b> IEEE_REAL shall not be invoked if A is of type real and IEEE_SUPPORT_DATATYPE (A)
has the value false, or if IEEE_SUPPORT_DATATYPE (IEEE_REAL (A, KIND)) has the value false.
<b>Result</b> <b>Characteristics.</b> Real. If KIND is present, the kind type parameter is that specified by the value of
KIND; otherwise, the kind type parameter is that of default real.
<b>Result</b> <b>Value.</b> The result has the same value as A if that value is representable in the representation method
of the result, and is rounded according to the rounding mode otherwise. This shall be consistent with the
specification of ISO/IEC 60559:2020 for the convertFromInt operation when A is of type integer, and with the
convertFormat operation otherwise.
<b>Example.</b> The value of IEEE_REAL (123) is 123.0.
<b>17.11.35</b> <b>IEEE_REM</b> <b>(X,</b> <b>Y)</b>
<b>Description.</b> Exact remainder.
<b>Class.</b> Elemental function.
<b>Arguments.</b> The arguments shall be of type real and have the same radix.
<b>Restriction.</b> IEEE_REM (X, Y) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) or IEEE_SUP-
PORT_DATATYPE (Y) has the value false.
<b>Result</b> <b>Characteristics.</b> Real with the kind type parameter of whichever argument has the greater precision.
<b>Result</b> <b>Value.</b> This function computes the remainder operation specified in ISO/IEC 60559:2020.
The result value when X and Y are finite, and Y is nonzero, regardless of the rounding mode, shall be exactly X
- Y*N, where N is the integer nearest to the exact value X/Y; whenever|N-X<i>/</i>Y| =
                                            1
                                            2
                                      , N shall be even. If the
result value is zero, the sign shall be that of X.
When X is finite and Y is infinite, the result value is X. If Y is zero or X is infinite, and neither is a NaN, the
IEEE_INVALID exception shall occur; if IEEE_SUPPORT_NAN(X+Y) is true, the result is a NaN. If X is
subnormal and Y is infinite, the IEEE_UNDERFLOW exception shall occur. No exception shall signal if X is
finite and normal, and Y is infinite.
<b>Examples.</b> The value of IEEE_REM (4.0, 3.0) is 1.0, the value of IEEE_REM (3.0, 2.0) is-1<i>.</i>0, and the value
of IEEE_REM (5.0, 2.0) is 1.0.
<b>17.11.36</b> <b>IEEE_RINT</b> <b>(X</b> <b>[,</b> <b>ROUND])</b>
<b>Description.</b> Round to integer.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
X shall be of type real.
ROUND (optional) shall be of type IEEE_ROUND_TYPE.
<b>Restriction.</b> IEEE_RINT (X) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the value false.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> If ROUND is present, the value of the result is the value of X rounded to an integer according
to the mode specified by ROUND; this is the ISO/IEC/IEEE 60559:2020 operation roundToIntegral{rounding}.
Otherwise, thevalueoftheresultisthatspecifiedfortheoperationroundToIntegralExactinISO/IEC60559:2020;
this is the value of X rounded to an integer according to the rounding mode. If the result has the value zero, the
sign is that of X.
<b>Examples.</b> If the rounding mode is round to nearest, the value of IEEE_RINT (1.1) is 1.0. The value of
IEEE_RINT (1.1, IEEE_UP) is 2.0.
<b>17.11.37</b> <b>IEEE_SCALB</b> <b>(X,</b> <b>I)</b>
<b>Description.</b> <i>X</i>x 2
         <i>I</i>
         .
<b>Class.</b> Elemental function.
<b>Arguments.</b>
X shall be of type real.
I shall be of type integer.
<b>Restriction.</b> IEEE_SCALB (X) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the value false.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> If <i>X</i>x 2
          <i>I</i>
          is representable as a normal number, the result has this value.
<i>Case</i> <i>(ii):</i> If X is finite and <i>X</i>x 2
                 <i>I</i>
                 is too large, the IEEE_OVERFLOW exception shall occur. If IEEE_-
     SUPPORT_INF (X) is true, the result value is infinity with the sign of X; otherwise, the result
     value is SIGN (HUGE (X), X).
<i>Case</i> <i>(iii):</i> If<i>X</i>x2
         <i>I</i>
          is too small and there is loss of accuracy, the IEEE_UNDERFLOW exception shall occur.
     The result is the representable number having a magnitude nearest to|2
                                       <i>I</i>
                   | and the same sign as X.
<i>Case</i> <i>(iv):</i> If X is infinite, the result is the same as X; no exception signals.
<b>Example.</b> The value of IEEE_SCALB (1.0, 2) is 4.0.
<b>17.11.38</b> <b>IEEE_SELECTED_REAL_KIND</b> <b>([P,</b> <b>R,</b> <b>RADIX])</b>
<b>Description.</b> IEEE kind type parameter value.
<b>Class.</b> Transformational function.
<b>Arguments.</b> At least one argument shall be present.
P (optional) shall be an integer scalar.
R (optional) shall be an integer scalar.
RADIX (optional) shall be an integer scalar.
<b>Result</b> <b>Characteristics.</b> Default integer scalar.
<b>Result</b> <b>Value.</b> If P or R is absent, the result value is the same as if it were present with the value zero. If
RADIX is absent, there is no requirement on the radix of the selected kind. The result has a value equal to a
value of the kind type parameter of an ISO/IEC/IEEE 60559:2020 floating-point format with decimal precision,
as returned by the intrinsic function PRECISION, of at least P digits, a decimal exponent range, as returned
by the intrinsic function RANGE, of at least R, and a radix, as returned by the intrinsic function RADIX, of
RADIX, if such a kind type parameter is available on the processor.
Otherwise, the result is-1 if the processor supports an IEEE real type with radix RADIX and exponent range
of at least R but not with precision of at least P,-2 if the processor supports an IEEE real type with radix
RADIX and precision of at least P but not with exponent range of at least R,-3 if the processor supports an
IEEE real type with radix RADIX but with neither precision of at least P nor exponent range of at least R,-4 if
the processor supports an IEEE real type with radix RADIX and either precision of at least P or exponent range
of at least R but not both together, and-5 if the processor supports no IEEE real type with radix RADIX.
If more than one kind type parameter value meets the criteria, the value returned is the one with the smallest
decimal precision, unless there are several such values, in which case the smallest of these kind values is returned.
<b>Example.</b> IEEE_SELECTED_REAL_KIND (6, 30) has the value KIND (0.0) on a machine that supports
ISO/IEC/IEEE 60559:2020 binary32 arithmetic for its default real approximation method.
<b>17.11.39</b> <b>IEEE_SET_FLAG</b> <b>(FLAG,</b> <b>FLAG_VALUE)</b>
<b>Class.</b> Simple subroutine.
<b>Arguments.</b>
FLAG shall be a scalar or array of type IEEE_FLAG_TYPE. If a value of FLAG is IEEE_INVALID,
     IEEE_OVERFLOW, IEEE_DIVIDE_BY_ZERO, IEEE_UNDERFLOW, or IEEE_INEXACT,
     the corresponding exception flag is assigned a value. No two elements of FLAG shall have the same
     value.
FLAG_VALUE shall be a logical scalar or array. It shall be conformable with FLAG. If an element has the value
     true, the corresponding flag is set to be signaling; otherwise, the flag is set to be quiet.
<b>Example.</b> CALL IEEE_SET_FLAG (IEEE_OVERFLOW, .TRUE.) sets the IEEE_OVERFLOW flag to be
signaling.
<b>17.11.40</b> <b>IEEE_SET_HALTING_MODE</b> <b>(FLAG,</b> <b>HALTING)</b>
<b>Description.</b> Set a halting mode.
<b>Class.</b> Simple subroutine.
<b>Arguments.</b>
FLAG shall be a scalar or array of type IEEE_FLAG_TYPE. It shall have only the values IEEE_-
     INVALID, IEEE_OVERFLOW, IEEE_DIVIDE_BY_ZERO, IEEE_UNDERFLOW, or IEEE_-
     INEXACT. No two elements of FLAG shall have the same value.
HALTING shall be a logical scalar or array. It shall be conformable with FLAG. If an element has the value
     true, the corresponding exception specified by FLAG will cause halting. Otherwise, execution will
     continue after this exception.
<b>Restriction.</b> IEEE_SET_HALTING_MODE (FLAG, HALTING) shall not be invoked if IEEE_SUPPORT_-
HALTING (FLAG) has the value false.
<b>Example.</b> CALL IEEE_SET_HALTING_MODE (IEEE_DIVIDE_BY_ZERO, .TRUE.) causes halting after
a divide_by_zero exception.
<b>17.11.41</b> <b>IEEE_SET_MODES</b> <b>(MODES)</b>
<b>Description.</b> Set floating-point modes.
<b>Class.</b> Simple subroutine.
<b>Argument.</b> MODES shall be a scalar of type IEEE_MODES_TYPE. Its value shall be one that was assigned
by a previous invocation of IEEE_GET_MODES to its MODES argument. The floating-point modes (17.7) are
restored to the state at that invocation.
<b>Example.</b>
To save the floating-point modes, do a calculation with specific rounding and underflow modes, and restore them
later:
   USE, INTRINSIC :: IEEE_ARITHMETIC
   TYPE (IEEE_MODES_TYPE) SAVE_MODES
   ...
   CALL IEEE_GET_MODES (SAVE_MODES) ! Save all modes.
   CALL IEEE_SET_ROUNDING_MODE (IEEE_TO_ZERO))
   CALL IEEE_SET_UNDERFLOW_MODE (GRADUAL=.FALSE.)
   ... ! calculation with abrupt round-to-zero.
   CALL IEEE_SET_MODES (SAVE_MODES) ! Restore all modes.
<b>17.11.42</b> <b>IEEE_SET_ROUNDING_MODE</b> <b>(ROUND_VALUE</b> <b>[,</b> <b>RADIX])</b>
<b>Description.</b> Set rounding mode.
<b>Class.</b> Simple subroutine.
<b>Arguments.</b>
ROUND_VALUE shall be a scalar of type IEEE_ROUND_TYPE. It specifies the rounding mode to be set.
RADIX (optional) shall be an integer scalar with the value two or ten. If RADIX is present with the value ten,
     the rounding mode set is the decimal rounding mode; otherwise it is the binary rounding mode.
<b>Restriction.</b> IEEE_SET_ROUNDING_MODE (ROUND_VALUE) shall not be invoked unless IEEE_SUP-
PORT_ROUNDING (ROUND_VALUE, X) is true for some X such that IEEE_SUPPORT_DATATYPE (X)
is true. IEEE_SET_ROUNDING_MODE (ROUND_VALUE, RADIX) shall not be invoked unless IEEE_-
SUPPORT_ROUNDING (ROUND_VALUE, X) is true for some X with radix RADIX such that IEEE_SUP-
PORT_DATATYPE (X) is true.
<b>Example.</b> To save the binary rounding mode, do a calculation with round to nearest, and restore the rounding
mode later:
   USE, INTRINSIC :: IEEE_ARITHMETIC
   TYPE (IEEE_ROUND_TYPE) ROUND_VALUE
   ...
   CALL IEEE_GET_ROUNDING_MODE (ROUND_VALUE) ! Store the rounding mode
   CALL IEEE_SET_ROUNDING_MODE (IEEE_NEAREST)
   ... ! calculation with round to nearest
   CALL IEEE_SET_ROUNDING_MODE (ROUND_VALUE) ! Restore the rounding mode
<b>17.11.43</b> <b>IEEE_SET_STATUS</b> <b>(STATUS_VALUE)</b>
<b>Description.</b> Restore floating-point status.
<b>Class.</b> Simple subroutine.
<b>Argument.</b> STATUS_VALUE shall be a scalar of type IEEE_STATUS_TYPE. Its value shall be one that was
assigned by a previous invocation of IEEE_GET_STATUS to its STATUS_VALUE argument. The floating-
point status (17.7 is restored to the state at that invocation).
<b>Example.</b> To store all the exceptions flags, do a calculation involving exception handling, and restore them
later:
   USE, INTRINSIC :: IEEE_EXCEPTIONS
   TYPE (IEEE_STATUS_TYPE) STATUS_VALUE
   ...
   CALL IEEE_GET_STATUS (STATUS_VALUE) ! Store the flags
   CALL IEEE_SET_FLAG (IEEE_ALL, .FALSE.) ! Set them quiet
   ... ! calculation involving exception handling
   CALL IEEE_SET_STATUS (STATUS_VALUE) ! Restore the flags
<b>17.11.44</b> <b>IEEE_SET_UNDERFLOW_MODE</b> <b>(GRADUAL)</b>
<b>Description.</b> Set underflow mode.
<b>Class.</b> Simple subroutine.
<b>Argument.</b> GRADUAL shall be a logical scalar. If it is true, the underflow mode is set to gradual underflow.
If it is false, the underflow mode is set to abrupt underflow.
<b>Restriction.</b> IEEE_SET_UNDERFLOW_MODE shall not be invoked unless IEEE_SUPPORT_UNDER-
FLOW_CONTROL (X) is true for some X.
<b>Example.</b> To perform some calculations with abrupt underflow and then restore the previous mode:
   USE, INTRINSIC :: IEEE_ARITHMETIC
   LOGICAL SAVE_UNDERFLOW_MODE
   ...
   CALL IEEE_GET_UNDERFLOW_MODE (SAVE_UNDERFLOW_MODE)
   CALL IEEE_SET_UNDERFLOW_MODE (GRADUAL=.FALSE.)
   ... ! Perform some calculations with abrupt underflow
   CALL IEEE_SET_UNDERFLOW_MODE (SAVE_UNDERFLOW_MODE)
<b>17.11.45</b> <b>IEEE_SIGNALING_EQ</b> <b>(A,</b> <b>B)</b>
<b>Description.</b> Signaling compares equal.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
A shall be of type real.
B shall be of the same type and kind type parameter as A.
<b>Restriction.</b> IEEE_SIGNALING_EQ (A, B) shall not be invoked if IEEE_SUPPORT_DATATYPE (A) has
the value false.
<b>Result</b> <b>Characteristics.</b> Default logical.
<b>Result</b> <b>Value.</b> The result has the value specified for the compareSignalingEqual operation in ISO/IEC
60559:2020; that is, it is true if and only if A compares equal to B. If A or B is a NaN, the result will be
false and IEEE_INVALID signals; otherwise, no exception is signaled.
<b>Example.</b> IEEE_SIGNALING_EQ (1.0, IEEE_VALUE (1.0, IEEE_QUIET_NAN)) has the value false and
signals IEEE_INVALID.
<b>17.11.46</b> <b>IEEE_SIGNALING_GE</b> <b>(A,</b> <b>B)</b>
<b>Description.</b> Signaling compares greater than or equal.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
A shall be of type real.
B shall be of the same type and kind type parameter as A.
<b>Restriction.</b> IEEE_SIGNALING_GE (A, B) shall not be invoked if IEEE_SUPPORT_DATATYPE (A) has
the value false.
<b>Result</b> <b>Characteristics.</b> Default logical.
<b>Result</b> <b>Value.</b> The result has the value specified for the compareSignalingGreaterEqual operation in ISO/IEC
60559:2020; that is, it is true if and only if A compares greater than or equal to B. If A or B is a NaN, the result
will be false and IEEE_INVALID signals; otherwise, no exception is signaled.
<b>Example.</b> IEEE_SIGNALING_GE (1.0, IEEE_VALUE (1.0, IEEE_QUIET_NAN)) has the value false and
signals IEEE_INVALID.
<b>17.11.47</b> <b>IEEE_SIGNALING_GT</b> <b>(A,</b> <b>B)</b>
<b>Description.</b> Signaling compares greater than.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
A shall be of type real.
B shall be of the same type and kind type parameter as A.
<b>Restriction.</b> IEEE_SIGNALING_GT (A, B) shall not be invoked if IEEE_SUPPORT_DATATYPE (A) has
the value false.
<b>Result</b> <b>Characteristics.</b> Default logical.
<b>Result</b> <b>Value.</b> The result has the value specified for the compareSignalingGreater operation in ISO/IEC
60559:2020; that is, it is true if and only if A compares greater than B. If A or B is a NaN, the result will
be false and IEEE_INVALID signals; otherwise, no exception is signaled.
<b>Example.</b> IEEE_SIGNALING_GT (1.0, IEEE_VALUE (1.0, IEEE_QUIET_NAN)) has the value false and
signals IEEE_INVALID.
<b>17.11.48</b> <b>IEEE_SIGNALING_LE</b> <b>(A,</b> <b>B)</b>
<b>Description.</b> Signaling compares less than or equal.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
A shall be of type real.
B shall be of the same type and kind type parameter as A.
<b>Restriction.</b> IEEE_SIGNALING_LE (A, B) shall not be invoked if IEEE_SUPPORT_DATATYPE (A) has
the value false.
<b>Result</b> <b>Characteristics.</b> Default logical.
<b>Result</b> <b>Value.</b> The result has the value specified for the compareSignalingLessEqual operation in ISO/IEC
60559:2020; that is, it is true if and only if A compares less than or equal to B. If A or B is a NaN, the result will
be false and IEEE_INVALID signals; otherwise, no exception is signaled.
<b>Example.</b> IEEE_SIGNALING_LE (1.0, IEEE_VALUE (1.0, IEEE_QUIET_NAN)) has the value false and
signals IEEE_INVALID.
<b>17.11.49</b> <b>IEEE_SIGNALING_LT</b> <b>(A,</b> <b>B)</b>
<b>Description.</b> Signaling compares less than.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
A shall be of type real.
B shall be of the same type and kind type parameter as A.
<b>Restriction.</b> IEEE_SIGNALING_LT (A, B) shall not be invoked if IEEE_SUPPORT_DATATYPE (A) has
the value false.
<b>Result</b> <b>Characteristics.</b> Default logical.
<b>ResultValue.</b> TheresulthasthevaluespecifiedforthecompareSignalingLessoperationinISO/IEC60559:2020;
that is, it is true if and only if A compares less than B. If A or B is a NaN, the result will be false and IEEE_-
INVALID signals; otherwise, no exception is signaled.
<b>Example.</b> IEEE_SIGNALING_LT (1.0, IEEE_VALUE (1.0, IEEE_QUIET_NAN)) has the value false and
signals IEEE_INVALID.
<b>17.11.50</b> <b>IEEE_SIGNALING_NE</b> <b>(A,</b> <b>B)</b>
<b>Description.</b> Signaling compares not equal.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
A shall be of type real.
B shall be of the same type and kind type parameter as A.
<b>Restriction.</b> IEEE_SIGNALING_NE (A, B) shall not be invoked if IEEE_SUPPORT_DATATYPE (A) has
the value false.
<b>Result</b> <b>Characteristics.</b> Default logical.
<b>Result</b> <b>Value.</b> The result has the value specified for the compareSignalingNotEqual operation in ISO/IEC
60559:2020; that is, it is true if and only if A compares not equal to B. If A or B is a NaN, the result will be true
and IEEE_INVALID signals; otherwise, no exception is signaled.
<b>Example.</b> IEEE_SIGNALING_NE (1.0, IEEE_VALUE (1.0, IEEE_QUIET_NAN)) has the value true and
signals IEEE_INVALID.
<b>17.11.51</b> <b>IEEE_SIGNBIT</b> <b>(X)</b>
<b>Description.</b> Test sign bit.
<b>Class.</b> Elemental function.
<b>Argument.</b> X shall be of type real.
<b>Restriction.</b> IEEE_SIGNBIT (X) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the value
false.
<b>Result</b> <b>Characteristics.</b> Default logical.
<b>Result</b> <b>Value.</b> The result has the value specified for the isSignMinus operation in ISO/IEC 60559:2020; that is,
it is true if and only if the sign bit of X is nonzero. No exception is signaled even if X is a signaling NaN.
<b>Example.</b> IEEE_SIGNBIT (-1<i>.</i>0) has the value true.
<b>17.11.52</b> <b>IEEE_SUPPORT_DATATYPE</b> <b>()</b> <b>or</b>
    <b>IEEE_SUPPORT_DATATYPE</b> <b>(X)</b>
<b>Description.</b> Query IEEE arithmetic support.
<b>Class.</b> Inquiry function.
<b>Argument.</b> X shall be of type real. It may be a scalar or an array.
<b>Result</b> <b>Characteristics.</b> Default logical scalar.
<b>Result</b> <b>Value.</b> The result has the value true if the processor supports IEEE arithmetic for all reals (X does
not appear) or for real variables of the same kind type parameter as X; otherwise, it has the value false. Here,
support is as defined in the first paragraph of 17.9.
<b>Example.</b> If default real kind conforms to ISO/IEC 60559:2020 except that underflow values flush to zero instead
of being subnormal, IEEE_SUPPORT_DATATYPE (1.0) has the value true.
<b>17.11.53</b> <b>IEEE_SUPPORT_DENORMAL</b> <b>()</b> <b>or</b>
    <b>IEEE_SUPPORT_DENORMAL</b> <b>(X)</b>
<b>Description.</b> Query subnormal number support.
<b>Class.</b> Inquiry function.
<b>Argument.</b> X shall be of type real. It may be a scalar or an array.
<b>Result</b> <b>Characteristics.</b> Default logical scalar.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> IEEE_SUPPORT_DENORMAL(X)hasthevaluetrueifIEEE_SUPPORT_DATATYPE(X)has
     the value true and the processor supports arithmetic operations and assignments with subnormal
     numbers (biased exponent <i>e</i> = 0 and fraction<i>f</i>?= 0, see ISO/IEC 60559:2020, 3.2) for real variables
     of the same kind type parameter as X; otherwise, it has the value false.
<i>Case</i> <i>(ii):</i> IEEE_SUPPORT_DENORMAL () has the value true if IEEE_SUPPORT_DENORMAL (X) has
     the value true for all real X; otherwise, it has the value false.
<b>Example.</b> IEEE_SUPPORT_DENORMAL (X) has the value true if the processor supports subnormal values
for X.
<b>NOTE</b>
A reference to IEEE_SUPPORT_DENORMAL will have the same result value as a reference to IEEE_-
SUPPORT_SUBNORMAL with the same argument list.
<b>17.11.54</b> <b>IEEE_SUPPORT_DIVIDE</b> <b>()</b> <b>or</b> <b>IEEE_SUPPORT_DIVIDE</b> <b>(X)</b>
<b>Description.</b> Query IEEE division support.
<b>Class.</b> Inquiry function.
<b>Argument.</b> X shall be of type real. It may be a scalar or an array.
<b>Result</b> <b>Characteristics.</b> Default logical scalar.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> IEEE_SUPPORT_DIVIDE (X) has the value true if the processor supports division with the
     accuracy specified by ISO/IEC 60559:2020 for real variables of the same kind type parameter as X;
     otherwise, it has the value false.
<i>Case</i> <i>(ii):</i> IEEE_SUPPORT_DIVIDE () has the value true if IEEE_SUPPORT_DIVIDE (X) has the value
     true for all real X; otherwise, it has the value false.
<b>Example.</b> IEEE_SUPPORT_DIVIDE (X) has the value true if division of operands with the same kind as X
conforms to ISO/IEC 60559:2020.
<b>17.11.55</b> <b>IEEE_SUPPORT_FLAG</b> <b>(FLAG)</b> <b>or</b> <b>IEEE_SUPPORT_FLAG</b> <b>(FLAG,</b>
    <b>X)</b>
<b>Description.</b> Query exception support.
<b>Class.</b> Transformational function.
<b>Arguments.</b>
FLAG shall be a scalar of type IEEE_FLAG_TYPE. Its value shall be one of IEEE_INVALID, IEEE_-
     OVERFLOW, IEEE_DIVIDE_BY_ZERO, IEEE_UNDERFLOW, or IEEE_INEXACT.
X shall be of type real. It may be a scalar or an array.
<b>Result</b> <b>Characteristics.</b> Default logical scalar.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> IEEE_SUPPORT_FLAG (FLAG, X) has the value true if the processor supports detection of the
     specified exception for real variables of the same kind type parameter as X; otherwise, it has the
     value false.
<i>Case</i> <i>(ii):</i> IEEE_SUPPORT_FLAG (FLAG) has the value true if IEEE_SUPPORT_FLAG (FLAG, X) has
     the value true for all real X; otherwise, it has the value false.
<b>Example.</b> IEEE_SUPPORT_FLAG(IEEE_INEXACT)hasthevaluetrueiftheprocessorsupportstheinexact
exception.
<b>17.11.56</b> <b>IEEE_SUPPORT_HALTING</b> <b>(FLAG)</b>
<b>Description.</b> Query halting mode support.
<b>Class.</b> Transformational function.
<b>Argument.</b> FLAG shall be a scalar of type IEEE_FLAG_TYPE. Its value shall be one of IEEE_INVALID,
IEEE_OVERFLOW, IEEE_DIVIDE_BY_ZERO, IEEE_UNDERFLOW, or IEEE_INEXACT.
<b>Result</b> <b>Characteristics.</b> Default logical scalar.
<b>Result</b> <b>Value.</b> The result has the value true if the processor supports the ability to control during program
execution whether to abort or continue execution after the exception specified by FLAG; otherwise, it has the
value false. Support includes the ability to change the mode by CALL IEEE_SET_HALTING_MODE (FLAG).
<b>Example.</b> IEEE_SUPPORT_HALTING (IEEE_OVERFLOW) has the value true if the processor supports
control of halting after an overflow.
<b>17.11.57</b> <b>IEEE_SUPPORT_INF</b> <b>()</b> <b>or</b> <b>IEEE_SUPPORT_INF</b> <b>(X)</b>
<b>Description.</b> Query IEEE infinity support.
<b>Class.</b> Inquiry function.
<b>Argument.</b> X shall be of type real. It may be a scalar or an array.
<b>Result</b> <b>Characteristics.</b> Default logical scalar.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> IEEE_SUPPORT_INF (X) has the value true if the processor supports IEEE infinities (positive
     and negative) for real variables of the same kind type parameter as X; otherwise, it has the value
     false.
<i>Case</i> <i>(ii):</i> IEEE_SUPPORT_INF () has the value true if IEEE_SUPPORT_INF (X) has the value true for
     all real X; otherwise, it has the value false.
<b>Example.</b> IEEE_SUPPORT_INF (X) has the value true if the processor supports IEEE infinities for X.
<b>17.11.58</b> <b>IEEE_SUPPORT_IO</b> <b>()</b> <b>or</b> <b>IEEE_SUPPORT_IO</b> <b>(X)</b>
<b>Description.</b> Query IEEE formatting support.
<b>Class.</b> Inquiry function.
<b>Argument.</b> X shall be of type real. It may be a scalar or an array.
<b>Result</b> <b>Characteristics.</b> Default logical scalar.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> IEEE_SUPPORT_IO (X) has the value true if base conversion during formatted input/output
     (12.5.6.17, 12.6.2.14, 13.7.2.3.8)conformstoISO/IEC60559:2020forthemodesUP,DOWN,ZERO,
     and NEAREST for real variables of the same kind type parameter as X; otherwise, it has the value
     false.
<i>Case</i> <i>(ii):</i> IEEE_SUPPORT_IO () has the value true if IEEE_SUPPORT_IO (X) has the value true for all
     real X; otherwise, it has the value false.
<b>Example.</b> IEEE_SUPPORT_IO (X) has the value true if formatted input/output base conversions conform to
ISO/IEC 60559:2020.
<b>17.11.59</b> <b>IEEE_SUPPORT_NAN</b> <b>()</b> <b>or</b> <b>IEEE_SUPPORT_NAN</b> <b>(X)</b>
<b>Description.</b> Query IEEE NaN support.
<b>Class.</b> Inquiry function.
<b>Argument.</b> X shall be of type real. It may be a scalar or an array.
<b>Result</b> <b>Characteristics.</b> Default logical scalar.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> IEEE_SUPPORT_NAN (X) has the value true if the processor supports IEEE NaNs for real
     variables of the same kind type parameter as X; otherwise, it has the value false.
<i>Case</i> <i>(ii):</i> IEEE_SUPPORT_NAN () has the value true if IEEE_SUPPORT_NAN (X) has the value true
     for all real X; otherwise, it has the value false.
<b>Example.</b> IEEE_SUPPORT_NAN (X) has the value true if the processor supports IEEE NaNs for X.
<b>17.11.60</b> <b>IEEE_SUPPORT_ROUNDING</b> <b>(ROUND_VALUE)</b> <b>or</b>
    <b>IEEE_SUPPORT_ROUNDING</b> <b>(ROUND_VALUE,</b> <b>X)</b>
<b>Description.</b> Query IEEE rounding support.
<b>Class.</b> Transformational function.
<b>Arguments.</b>
ROUND_VALUE shall be of type IEEE_ROUND_TYPE.
X shall be of type real. It may be a scalar or an array.
<b>Result</b> <b>Characteristics.</b> Default logical scalar.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> IEEE_SUPPORT_ROUNDING(ROUND_VALUE,X)hasthevaluetrueiftheprocessorsupports
     the rounding mode defined by ROUND_VALUE for real variables of the same kind type parameter
     as X; otherwise, it has the value false. Support includes the ability to change the mode by CALL
     IEEE_SET_ROUNDING_MODE (ROUND_VALUE).
<i>Case</i> <i>(ii):</i> IEEE_SUPPORT_ROUNDING (ROUND_VALUE) has the value true if IEEE_SUPPORT_-
     ROUNDING (ROUND_VALUE, X) has the value true for all real X; otherwise, it has the value
     false.
<b>Example.</b> IEEE_SUPPORT_ROUNDING (IEEE_TO_ZERO) has the value true if the processor supports
rounding to zero for all reals.
<b>17.11.61</b> <b>IEEE_SUPPORT_SQRT</b> <b>()</b> <b>or</b> <b>IEEE_SUPPORT_SQRT</b> <b>(X)</b>
<b>Description.</b> Query IEEE square root support.
<b>Class.</b> Inquiry function.
<b>Argument.</b> X shall be of type real. It may be a scalar or an array.
<b>Result</b> <b>Characteristics.</b> Default logical scalar.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> IEEE_SUPPORT_SQRT (X) has the value true if the intrinsic function SQRT conforms to
     ISO/IEC 60559:2020 for real variables of the same kind type parameter as X; otherwise, it has
     the value false.
<i>Case</i> <i>(ii):</i> IEEE_SUPPORT_SQRT () has the value true if IEEE_SUPPORT_SQRT (X) has the value true
     for all real X; otherwise, it has the value false.
<b>Example.</b> If IEEE_SUPPORT_SQRT (1.0) has the value true, SQRT (-0<i>.</i>0) will have the value-0<i>.</i>0.
<b>17.11.62</b> <b>IEEE_SUPPORT_STANDARD</b> <b>()</b> <b>or</b>
    <b>IEEE_SUPPORT_STANDARD</b> <b>(X)</b>
<b>Description.</b> Query IEEE standard support.
<b>Class.</b> Inquiry function.
<b>Argument.</b> X shall be of type real. It may be a scalar or an array.
<b>Result</b> <b>Characteristics.</b> Default logical scalar.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> IEEE_SUPPORT_STANDARD (X) has the value true if the results of all the func-
     tions IEEE_SUPPORT_DATATYPE (X), IEEE_SUPPORT_DIVIDE (X), IEEE_SUPPORT_-
     FLAG(FLAG,X)forvalidFLAG,IEEE_SUPPORT_HALTING(FLAG)forvalidFLAG,IEEE_-
     SUPPORT_INF (X), IEEE_SUPPORT_NAN (X), IEEE_SUPPORT_ROUNDING (ROUND_-
     VALUE, X) for valid ROUND_VALUE, IEEE_SUPPORT_SQRT (X), and IEEE_SUPPORT_-
     SUBNORMAL (X) are all true; otherwise, it has the value false.
<i>Case</i> <i>(ii):</i> IEEE_SUPPORT_STANDARD () has the value true if IEEE_SUPPORT_STANDARD (X) has
     the value true for all real X; otherwise, it has the value false.
<b>Example.</b> IEEE_SUPPORT_STANDARD () has the value false if some but not all kinds of reals conform to
ISO/IEC 60559:2020.
<b>17.11.63</b> <b>IEEE_SUPPORT_SUBNORMAL</b> <b>()</b> <b>or</b>
    <b>IEEE_SUPPORT_SUBNORMAL</b> <b>(X)</b>
<b>Description.</b> Query subnormal number support.
<b>Class.</b> Inquiry function.
<b>Argument.</b> X shall be of type real. It may be a scalar or an array.
<b>Result</b> <b>Characteristics.</b> Default logical scalar.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> IEEE_SUPPORT_SUBNORMAL (X) has the value true if IEEE_SUPPORT_DATATYPE (X)
     hasthevaluetrueandtheprocessorsupportsarithmeticoperationsandassignmentswithsubnormal
     numbers (biased exponent <i>e</i> = 0 and fraction<i>f</i>?= 0, see ISO/IEC 60559:2020, 3.2) for real variables
     of the same kind type parameter as X; otherwise, it has the value false.
<i>Case</i> <i>(ii):</i> IEEE_SUPPORT_SUBNORMAL () has the value true if IEEE_SUPPORT_SUBNORMAL (X)
     has the value true for all real X; otherwise, it has the value false.
<b>Example.</b> IEEE_SUPPORT_SUBNORMAL (X) has the value true if the processor supports subnormal values
for X.
<b>NOTE</b>
The subnormal numbers are not included in the 16.4 model for real numbers; they satisfy the inequality ABS (X)
<i><</i> TINY (X). They usually occur as a result of an arithmetic operation whose exact result is less than TINY (X).
Such an operation causes IEEE_UNDERFLOW to signal unless the result is exact. IEEE_SUPPORT_-
SUBNORMAL (X) is false if the processor never returns a subnormal number as the result of an arithmetic
operation.
<b>17.11.64</b> <b>IEEE_SUPPORT_UNDERFLOW_CONTROL</b> <b>()</b> <b>or</b>
    <b>IEEE_SUPPORT_UNDERFLOW_CONTROL</b> <b>(X)</b>
<b>Description.</b> Query underflow control support.
<b>Class.</b> Inquiry function.
<b>Argument.</b> X shall be of type real. It may be a scalar or an array.
<b>Result</b> <b>Characteristics.</b> Default logical scalar.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> IEEE_SUPPORT_UNDERFLOW_CONTROL (X) has the value true if the processor supports
     control of the underflow mode for floating-point calculations with the same type as X, and false
     otherwise.
<i>Case</i> <i>(ii):</i> IEEE_SUPPORT_UNDERFLOW_CONTROL () has the value true if the processor supports
     control of the underflow mode for all floating-point calculations, and false otherwise.
<b>Example.</b> IEEE_SUPPORT_UNDERFLOW_CONTROL (2.5) has the value true if the processor supports
underflow mode control for default real calculations.
<b>17.11.65</b> <b>IEEE_UNORDERED</b> <b>(X,</b> <b>Y)</b>
<b>Description.</b> Whether two values are unordered.
<b>Class.</b> Elemental function.
<b>Arguments.</b> The arguments shall be of type real.
<b>Restriction.</b> IEEE_UNORDERED (X, Y) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) or
IEEE_SUPPORT_DATATYPE (Y) has the value false.
<b>Result</b> <b>Characteristics.</b> Default logical.
<b>Result</b> <b>Value.</b> The result has the value true if X or Y is a NaN or both are NaNs; otherwise, it has the value
false. If X or Y is a signaling NaN, IEEE_INVALID may signal.
<b>Example.</b> IEEE_UNORDERED (0.0, SQRT (-1<i>.</i>0)) has the value true if IEEE_SUPPORT_SQRT (1.0) has
the value true.
<b>17.11.66</b> <b>IEEE_VALUE</b> <b>(X,</b> <b>CLASS)</b>
<b>Description.</b> Return number in a class.
<b>Class.</b> Elemental function.
<b>Arguments.</b>
X shall be of type real.
CLASS shall be of type IEEE_CLASS_TYPE. The value is permitted to be: IEEE_SIGNALING_NAN or
     IEEE_QUIET_NAN if IEEE_SUPPORT_NAN (X) has the value true, IEEE_NEGATIVE_INF
     or IEEE_POSITIVE_INF if IEEE_SUPPORT_INF (X) has the value true, IEEE_NEGATIVE_-
     SUBNORMALorIEEE_POSITIVE_SUBNORMALifIEEE_SUPPORT_SUBNORMAL(X)has
     the value true, IEEE_NEGATIVE_NORMAL, IEEE_NEGATIVE_ZERO, IEEE_POSITIVE_-
     ZERO or IEEE_POSITIVE_NORMAL.
<b>Restriction.</b> IEEE_VALUE (X, CLASS) shall not be invoked if IEEE_SUPPORT_DATATYPE (X) has the
value false.
<b>Result</b> <b>Characteristics.</b> Same as X.
<b>Result</b> <b>Value.</b> The result value is an IEEE value as specified by CLASS. Although in most cases the value is
processor dependent, the value shall not vary between invocations for any particular X kind type parameter and
CLASS value.
<b>Example.</b> IEEE_VALUE (1.0, IEEE_NEGATIVE_INF) has the value-infinity.
Whenever IEEE_VALUE returns a signaling NaN, it is processor dependent whether or not invalid is raised and
processor dependent whether or not the signaling NaN is converted into a quiet NaN.
<b>NOTE</b>
If the <i>expr</i> in an assignment statement is a reference to the IEEE_VALUE function that returns a signaling
NaN and the <i>variable</i> is of the same type and kind as the function result, it is recommended that the signaling
NaN be preserved.
<b>17.12</b> <b>Examples</b>
<b>NOTE</b> <b>1</b>
   MODULE DOT
     ! Module for dot product of two real arrays of rank 1.
     ! The caller needs to ensure that exceptions do not cause halting.
     USE, INTRINSIC :: IEEE_EXCEPTIONS
     LOGICAL :: MATRIX_ERROR = .FALSE.
<b>498</b> <b>J3/23-007r1</b>
<b>NOTE</b> <b>1</b> <b>(cont.)</b>
     INTERFACE OPERATOR(.dot.)
      MODULE PROCEDURE MULT
     END INTERFACE
   CONTAINS
     REAL FUNCTION MULT (A, B)
      REAL, INTENT (IN) :: A(:), B(:)
      INTEGER I
      LOGICAL OVERFLOW
      IF (SIZE(A) /= SIZE(B)) THEN
        MATRIX_ERROR = .TRUE.
        RETURN
      END IF
      ! The processor ensures that IEEE_OVERFLOW is quiet.
      MULT = 0.0
      DO I = 1, SIZE (A)
        MULT = MULT + A(I)*B(I)
      END DO
      CALL IEEE_GET_FLAG (IEEE_OVERFLOW, OVERFLOW)
      IF (OVERFLOW) MATRIX_ERROR = .TRUE.
     END FUNCTION MULT
   END MODULE DOT
This module provides a function that computes the dot product of two real arrays of rank 1. If the sizes of the
arrays are different, an immediate return occurs with MATRIX_ERROR true. If overflow occurs during the
actual calculation, the IEEE_OVERFLOW flag will signal and MATRIX_ERROR will be true.
<b>NOTE</b> <b>2</b>
   USE, INTRINSIC :: IEEE_EXCEPTIONS
   USE, INTRINSIC :: IEEE_FEATURES, ONLY: IEEE_INVALID_FLAG
   ! The other exceptions of IEEE_USUAL (IEEE_OVERFLOW and
   ! IEEE_DIVIDE_BY_ZERO) are always available with IEEE_EXCEPTIONS
   TYPE (IEEE_STATUS_TYPE) STATUS_VALUE
   LOGICAL, DIMENSION(3) :: FLAG_VALUE
    ...
   CALL IEEE_GET_STATUS (STATUS_VALUE)
   CALL IEEE_SET_HALTING_MODE (IEEE_USUAL, .FALSE.) ! Needed in case the
   ! default on the processor is to halt on exceptions
   CALL IEEE_SET_FLAG (IEEE_USUAL, .FALSE.)
   ! First try the "fast" algorithm for inverting a matrix:
   MATRIX1 = FAST_INV (MATRIX) ! This shall not alter MATRIX.
   CALL IEEE_GET_FLAG (IEEE_USUAL, FLAG_VALUE)
   IF (ANY(FLAG_VALUE)) THEN
     ! "Fast" algorithm failed; try "slow" one:
     CALL IEEE_SET_FLAG (IEEE_USUAL, .FALSE.)
     MATRIX1 = SLOW_INV (MATRIX)
                <b>J3/23-007r1</b> <b>499</b>
<b>NOTE</b> <b>2</b> <b>(cont.)</b>
     CALL IEEE_GET_FLAG (IEEE_USUAL, FLAG_VALUE)
     IF (ANY (FLAG_VALUE)) THEN
      WRITE (*, *) 'Cannot invert matrix'
      STOP
     END IF
   END IF
   CALL IEEE_SET_STATUS (STATUS_VALUE)
In this example, the function FAST_INV might cause a condition to signal. If it does, another try is made with
SLOW_INV. If this still fails, a message is printed and the program stops. Note, also, that it is important to
set the flags quiet before the second try. The state of all the flags is stored and restored.
<b>NOTE</b> <b>3</b>
   USE, INTRINSIC :: IEEE_EXCEPTIONS
   LOGICAL FLAG_VALUE
    ...
   CALL IEEE_SET_HALTING_MODE (IEEE_OVERFLOW, .FALSE.)
   ! First try a fast algorithm for inverting a matrix.
   CALL IEEE_SET_FLAG (IEEE_OVERFLOW, .FALSE.)
   DO K = 1, N
     ...
     CALL IEEE_GET_FLAG (IEEE_OVERFLOW, FLAG_VALUE)
     IF (FLAG_VALUE) EXIT
   END DO
   IF (FLAG_VALUE) THEN
   ! Alternative code which knows that K-1 steps have executed normally.
    ...
   END IF
Here the code for matrix inversion is in line and the transfer is made more precise by adding extra tests of the
flag.
<b>18</b> <b>Interoperability</b> <b>with</b> <b>C</b>
<b>18.1</b> <b>General</b>
Fortran provides a means of referencing procedures that are defined by means of the C programming language or
procedures that can be described by C prototypes as defined in ISO/IEC 9899:2018, 6.7.6.3, even if they are not
actually defined by means of C. Conversely, there is a means of specifying that a procedure defined by a Fortran
subprogram can be referenced from a function defined by means of C. In addition, there is a means of declaring
global variables that are associated with C variables whose names have external linkage as defined in ISO/IEC
9899:2018, 6.2.2.
The ISO_C_BINDING module provides access to named constants that represent kind type parameters of data
representations compatible with C types. Fortran also provides facilities for defining derived types (7.5) and
interoperable enumerations (7.6.1) that correspond to C types.
ThesourcefileISO_Fortran_binding.hprovidesdefinitionsandprototypestoenableaCfunctiontointeroperate
withaFortranprocedurethathasadummydataobjectthatisallocatable,assumed-shape,assumed-rank,pointer,
or is of type character with an assumed length.
The conditions under which a Fortran entity is interoperable are defined in 18.3. If a Fortran entity is interoper-
able, an equivalent entity could be defined by means of C and the Fortran entity would interoperate with the C
entity. There does not have to be such an interoperating C entity.
<b>NOTE</b>
A Fortran entity can be interoperable with more than one C entity.
<b>18.2</b> <b>The</b> <b>ISO_C_BINDING</b> <b>intrinsic</b> <b>module</b>
<b>18.2.1</b> <b>Summary</b> <b>of</b> <b>contents</b>
The processor shall provide the intrinsic module ISO_C_BINDING. This module shall make accessible the
following entities: the named constants C_NULL_PTR, C_NULL_FUNPTR, and those with names listed in
the first column of Table 18.1 and the second column of Table 18.2, the types C_PTR and C_FUNPTR, and the
procedures in 18.2.3. A processor may provide other public entities in the ISO_C_BINDING intrinsic module
in addition to those listed here.
<b>18.2.2</b> <b>Named</b> <b>constants</b> <b>and</b> <b>derived</b> <b>types</b> <b>in</b> <b>the</b> <b>module</b>
The entities listed in the second column of Table 18.2 shall be default integer named constants.
A Fortran intrinsic type whose kind type parameter is one of the values in the module shall have the same
representation as the C type with which it interoperates, for each value that a variable of that type can have.
For C_BOOL, the internal representation of .TRUE._C_BOOL and .FALSE._C_BOOL shall be the same as those of
the C values (_Bool)1 and (_Bool)0 respectively.
The value of C_INT shall be a valid value for an integer kind parameter on the processor. The values of
C_SHORT, C_LONG, C_LONG_LONG, C_SIGNED_CHAR, C_SIZE_T, C_INT8_T, C_INT16_T,
C_INT32_T, C_INT64_T, C_INT_LEAST8_T, C_INT_LEAST16_T, C_INT_LEAST32_T, C_INT_-
LEAST64_T, C_INT_FAST8_T, C_INT_FAST16_T, C_INT_FAST32_T, C_INT_FAST64_T, C_INT-
MAX_T, C_INTPTR_T, and C_PTRDIFF_T shall each be a valid value for an integer kind type parameter
on the processor or shall be-1 if the companion processor (5.5.7) defines the corresponding C type and there is
no interoperating Fortran processor kind, or-2 if the companion processor does not define the corresponding C
type.
The values of C_FLOAT, C_DOUBLE, and C_LONG_DOUBLE shall each be a valid value for a real kind
type parameter on the processor or shall be-1 if the companion processor's type does not have a precision equal
to the precision of any of the Fortran processor's real kinds,-2 if the companion processor's type does not have
a range equal to the range of any of the Fortran processor's real kinds,-3 if the companion processor's type
has neither the precision nor range of any of the Fortran processor's real kinds, and equal to-4 if there is no
interoperating Fortran processor kind for other reasons. The values of C_FLOAT_COMPLEX, C_DOUBLE_-
COMPLEX, and C_LONG_DOUBLE_COMPLEX shall be the same as those of C_FLOAT, C_DOUBLE, and
C_LONG_DOUBLE, respectively.
The value of C_BOOL shall be a valid value for a logical kind parameter on the processor or shall be-1.
The value of C_CHAR shall be a valid value for a character kind type parameter on the processor or shall be-1.
If the value of C_CHAR is nonnegative, the character kind specified is the C character kind; otherwise, there is
no C character kind.
The following entities shall be named constants of type character with a length parameter of one. The kind
parameter value shall be equal to the value of C_CHAR unless C_CHAR =-1, in which case the kind parameter
value shall be the same as for default kind. The values of these constants are specified in Table 18.1. In the
case that C_CHAR?=-1 the value is specified using C syntax. The semantics of these values are explained in
ISO/IEC 9899:2018, 5.2.1 and 5.2.2.
        <b>Table</b> <b>18.1</b> <b>-</b> <b>Names</b> <b>of</b> <b>C</b> <b>characters</b> <b>with</b> <b>special</b> <b>semantics</b>
                                 Value
      Name C definition C_CHAR =-1 C_CHAR?=-1
      C_NULL_CHAR null character CHAR(0) '\0'
      C_ALERT alert ACHAR(7) '\a'
      C_BACKSPACE backspace ACHAR(8) '\b'
      C_FORM_FEED form feed ACHAR(12) '\f'
      C_NEW_LINE new line ACHAR(10) '\n'
      C_CARRIAGE_RETURN carriage return ACHAR(13) '\r'
      C_HORIZONTAL_TAB horizontal tab ACHAR(9) '\t'
      C_VERTICAL_TAB vertical tab ACHAR(11) '\v'
The entities C_PTR and C_FUNPTR are described in 18.3.2.
The entity C_NULL_PTR shall be a named constant of type C_PTR. The value of C_NULL_PTR shall be the
same as the value NULL in C. The entity C_NULL_FUNPTR shall be a named constant of type C_FUNPTR.
The value of C_NULL_FUNPTR shall be that of a null pointer to a function in C.
<b>NOTE</b>
The value of NEW_LINE (C_NEW_LINE) is C_NEW_LINE (16.9.150).
<b>18.2.3</b> <b>Procedures</b> <b>in</b> <b>the</b> <b>module</b>
<b>18.2.3.1</b> <b>General</b>
In the detailed descriptions below, procedure names are generic and not specific. The C_F_POINTER, C_-
F_PROCPOINTER, and C_F_STRPOINTER subroutines are impure; all other procedures in the module are
simple.
<b>18.2.3.2</b> <b>C_ASSOCIATED</b> <b>(C_PTR_1</b> <b>[,</b> <b>C_PTR_2])</b>
<b>Description.</b> Query C pointer status.
<b>Class.</b> Transformational function.
<b>Arguments.</b>
C_PTR_1 shall be a scalar of type C_PTR or C_FUNPTR.
C_PTR_2 (optional) shall be a scalar of the same type as C_PTR_1.
<b>Result</b> <b>Characteristics.</b> Default logical scalar.
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> If C_PTR_2 is absent, the result is false if C_PTR_1 is a C null pointer and true otherwise.
<i>Case</i> <i>(ii):</i> If C_PTR_2 is present, the result is false if C_PTR_1 is a C null pointer. If C_PTR_1 is not a C
     null pointer, the result is true if C_PTR_1 compares equal to C_PTR_2 in the sense of ISO/IEC
     9899:2018, 6.3.2.3 and 6.5.9, and false otherwise.
<b>Examples.</b>
<i>Case</i> <i>(i):</i> If variable P of type C_PTR has been assigned the value of C_NULL_PTR, the value of C_-
     ASSOCIATED (P) is false.
<i>Case</i> <i>(ii):</i> For the interoperable variable REAL (C_DOUBLE), TARGET, BIND (C) :: X, if variable P of
     type C_PTR has been assigned the address of X, perhaps by a C function that used "&x", the
     value of C_ASSOCIATED (P, C_LOC (X)) is true.
<b>18.2.3.3</b> <b>C_F_POINTER</b> <b>(CPTR,</b> <b>FPTR</b> <b>[,</b> <b>SHAPE,</b> <b>LOWER])</b>
<b>Description.</b> Associate a data pointer with the target of a C pointer and specify its shape.
<b>Class.</b> Subroutine.
<b>Arguments.</b>
CPTR shall be a scalar of type C_PTR. It is an INTENT (IN) argument. Its value shall be
     the C address of an interoperable data entity,
     the result of a reference to C_LOC with a noninteroperable argument, or
     the C address of a storage sequence that is not in use by any other Fortran entity.
     The value of CPTR shall not be the C address of a Fortran variable that does not have the TARGET
     attribute.
FPTR shall be a pointer, shall not have a deferred type parameter, and shall not be a coindexed object. It
     is an INTENT (OUT) argument. If FPTR is an array, its shape is specified by SHAPE; the lower
     bounds are specified by LOWER if it is present, otherwise each lower bound is equal to 1.
       <i>Case</i> <i>(i):</i> If the value of CPTR is the C address of an interoperable data entity, FPTR
             shall be a data pointer with type and type parameter values interoperable with
             the type of the entity. If the target T of CPTR is scalar, FPTR becomes pointer
             associated with T; if FPTR is an array, SHAPE shall specify a size of 1. If T is
             an array, and FPTR is scalar, FPTR becomes associated with the first element of
             T. If both T and FPTR are arrays, SHAPE shall specify a size that is less than or
             equal to the size of T, and FPTR becomes associated with the first PRODUCT
             (SHAPE) elements of T (this could be the entirety of T).
       <i>Case</i> <i>(ii):</i> If the value of CPTR is the result of a reference to C_LOC with a noninter-
             operable effective argument X, FPTR shall be a nonpolymorphic pointer with
             the same type and type parameters as X. In this case, X shall not have been
             deallocated or have become undefined due to execution of a RETURN or END
             statement since the reference. If X is scalar, FPTR becomes pointer associated
             with X; if FPTR is an array, SHAPE shall specify a size of 1. If X is an array and
             FPTR is scalar, FPTR becomes associated with the first element of X. If both X
             and FPTR are arrays, SHAPE shall specify a size that is less than or equal to
             the size of X, and FPTR becomes associated with the first PRODUCT (SHAPE)
             elements of X (this could be the entirety of X).
       <i>Case</i> <i>(iii):</i> If the value of CPTR is the C address of a storage sequence that is not in use by
             any other Fortran entity, FPTR becomes associated with that storage sequence.
             The storage sequence shall be large enough to contain the target object described
             by FPTR and shall satisfy any other processor-dependent requirement for asso-
             ciation.
SHAPE (optional) shall be a rank-one integer array. It is an INTENT (IN) argument. SHAPE shall be present
     if and only if FPTR is an array; its size shall be equal to the rank of FPTR.
LOWER (optional) shall be a rank-one integer array. It is an INTENT (IN) argument. It shall not be present if
     SHAPE is not present. If LOWER is present, its size shall be equal to the rank of FPTR.
<b>Examples.</b>
<i>Case</i> <i>(i):</i> extern double c_x;
     void *address_of_x (void)
     {
      return &c_x;
     }
     ! Assume interface to "address_of_x" is available.
     Real (C_double), Pointer :: xp
     Call C_F_Pointer (address_of_x (), xp)
<i>Case</i> <i>(ii):</i> Type t
      Real, Allocatable :: v(:,:)
     End Type
     Type(t), Target :: x(0:2)
     Type(C_ptr) :: xloc
     xloc = C_Loc (x)
     ...
     Type(t), Pointer :: y(:)
     Call C_F_Pointer (xloc, y, [3], [0])
<i>Case</i> <i>(iii):</i> void *getmem (int nbits)
     {
       return malloc ((nbits+CHAR_BIT-1)/CHAR_BIT);
     }
     ! Assume interface to "getmem" is available,
     ! and there is a derived type "mytype" accessible.
     Type(mytype), Pointer :: x
     Call C_F_Pointer (getmem (Storage_Size (x)), x)
<i>Case</i> <i>(iv):</i> The following statements illustrate the use of C_F_POINTER when the pointer to be set has a
     deferred type parameter:
         Character(42), Pointer :: C1
         Character(:), Pointer :: C2
         Call C_F_Pointer (CPTR, C1)
         C2 => C1
     This will associate C2 with the entity at the C address specified by CPTR, and specify its length
     to be the same as that of C1.
<b>NOTE</b>
In the case of associating FPTR with a storage sequence, there might be processor-dependent requirements such
as alignment of the memory address or placement in memory.
<b>18.2.3.4</b> <b>C_F_PROCPOINTER</b> <b>(CPTR,</b> <b>FPTR)</b>
<b>Description.</b> Associate a procedure pointer with the target of a C function pointer.
<b>Class.</b> Subroutine.
<b>Arguments.</b>
CPTR shall be a scalar of type C_FUNPTR. It is an INTENT (IN) argument. Its value shall be the C
     address of a procedure that is interoperable, or the result of a reference to the function C_FUNLOC
     from the intrinsic module ISO_C_BINDING.
FPTR shall be a procedure pointer, and shall not be a component of a coindexed object. It is an INTENT
     (OUT) argument. If the target of CPTR is interoperable, the interface for FPTR shall be interoper-
     able with the prototype that describes the target of CPTR; otherwise, the interface for FPTR shall
     have the same characteristics as that target. FPTR becomes pointer associated with the target of
     CPTR.
<b>Example.</b>
The following C code provides a function, dispatch, that returns a C function pointer to the C library cube root
function:
   #include <math.h>
   typedef double (*simplefun)(double);
   simplefun dispatch (void) {
    return &cbrt;
   }
The following Fortran interface interoperates with dispatch:
   Interface
    Type(C_FUNPTR) Function dispatch () Bind(C)
     Use Iso_C_Binding, Only: C_FUNPTR
    End Function dispatch
   End Interface
With the abstract interface SIMPLE_FUNCTION (analogous to simplefun), a procedure pointer suitable for
referring to the C library function cbrt can be created:
   Abstract Interface
     Real (C_double) Function simple_function (x) Bind(C)
      Use Iso_C_Binding, Only: C_double
      Real (C_double), Value :: x
     End Function simple_function
   End Interface
   Procedure (simple_function), Pointer :: psimp
Once the procedure pointer is associated, it can be used to invoke cbrt:
   Call C_F_Procpointer (dispatch (), psimp)
   Write (*,*) psimp (4.5_C_double)
<b>NOTE</b>
The term "target" in the descriptions of C_F_POINTER and C_F_PROCPOINTER denotes the entity
referenced by a C pointer, as described in ISO/IEC 9899:2018, 6.2.5.
<b>18.2.3.5</b> <b>C_F_STRPOINTER</b> <b>(CSTRARRAY,</b> <b>FSTRPTR</b> <b>[,</b> <b>NCHARS])</b> <b>or</b>
     <b>C_F_STRPOINTER</b> <b>(CSTRPTR,</b> <b>FSTRPTR</b> <b>[,</b> <b>NCHARS])</b>
<b>Description.</b> Associate a character pointer with a C string.
<b>Class.</b> Subroutine.
<b>Arguments.</b>
CSTRARRAY shall be a rank one character array of kind C_CHAR, with a length type parameter equal to
     one. It is an INTENT (IN) argument. Its actual argument shall be simply contiguous and have the
     TARGET attribute.
CSTRPTR shall be a scalar of type C_PTR. It is an INTENT (IN) argument. Its value shall be the C address
     of a contiguous array S of NCHARS characters. Its value shall not be the C address of a Fortran
     variable that does not have the TARGET attribute.
FSTRPTR shall be a scalar deferred-length character pointer of kind C_CHAR. It is an INTENT (OUT) argu-
     ment. FSTRPTR becomes pointer associated with the leftmost characters of the actual argument
     element sequence (15.5.2.12) of CSTRARRAY if it appears, or with the leftmost characters (in array
     element order) of the array S if CSTRPTR appears.
     The length type parameter of FSTRPTR becomes the largest value for which no C null characters
     appear in the sequence, and which is less than or equal to NCHARS if present, and the size of
     CSTRARRAY otherwise.
NCHARS (optional) shall be an integer scalar with a nonnegative value. It is an INTENT (IN) argument.
     NCHARS shall be present if CSTRARRAY is assumed-size, or if CSTRPTR appears. If CSTRAR-
     RAY appears, NCHARS shall not be greater than the size of CSTRARRAY.
If C_CHAR has the value-1, indicating that there is no C character kind, the generic subroutine C_F_-
STRPOINTER does not have any specific procedure.
<b>Example.</b>
<i>Case</i> <i>(i):</i> This interoperable procedure prints a C string to a Fortran file.
         Subroutine logstring (str) Bind (C)
          Use Iso_C_Binding
          Character (Kind=C_char), Dimension(*), Target :: str
          Character (:, C_char), Pointer :: sval
          Integer, Parameter :: logunit = 17
          Call C_F_Strpointer (str, sval, 1020) ! Limit result to 1020 characters.
          Write (logunit, *) 'C: ', sval
         End Subroutine
<i>Case</i> <i>(ii):</i> This program shows how to use C_F_STRPOINTER to display the result of calling the C library
     function getenv.
         Program cfs_example
          Use Iso_C_Binding
          Character (:, C_char), Pointer :: evalue
          Type (C_ptr) :: envptr
          Interface
           Function getenv (name) Bind (C)
            Import C_char, C_ptr
            Character (Kind=C_char), Intent (In) :: name (*)
            Type (C_ptr) :: getenv
           End Function
          End Interface
          envptr = getenv ("CFS")
          If (C_associated (envptr)) Then
           Call C_F_Strpointer (envptr, evalue, 1023) ! Max length 1023.
           Print *, 'CFS value is "', evalue, '"'
          Else
           Print *, 'CFS has no value'
          End If
         End Program
<b>18.2.3.6</b> <b>C_FUNLOC</b> <b>(X)</b>
<b>Description.</b> C address of the argument.
<b>Class.</b> Transformational function.
<b>Argument.</b> X shall be a procedure; if it is a procedure pointer it shall be associated. It shall not be a coindexed
object.
<b>Result</b> <b>Characteristics.</b> Scalar of type C_FUNPTR.
<b>Result</b> <b>Value.</b> The result value is described using the result name FUNPTR. The result is determined as if
C_FUNPTR were a derived type containing a procedure pointer component PX with an implicit interface and
the pointer assignment FUNPTR%PX =<i>></i> X were executed. The result value can be used as an actual CPTR
argument in a call to C_F_PROCPOINTER where the FPTR argument has attributes that would allow the
pointer assignment FPTR =<i>></i> X. Such a call to C_F_PROCPOINTER shall have the effect of the pointer
assignment FPTR =<i>></i> X.
<b>Example.</b> This code fragment shows how C_FUNLOC can be used to register an "atexit" procedure with the
C library.
   Use Iso_C_Binding
   Interface
    Function atexit (func) Bind (C)
     Import
     Integer (C_int) :: atexit
     Type (C_funptr), Value :: func
    End Function
    Subroutine my_atexit_sub() Bind(C)
    End Subroutine
   End Interface
   Integer (C_int) :: errno
   errno = atexit (C_funloc (my_atexit_sub))
   If (errno==0) Then
    Print *, 'At exit sub registered'
   Else
    Print *, 'Error', errno, 'from atexit'
   End If
<b>18.2.3.7</b> <b>C_LOC</b> <b>(X)</b>
<b>Description.</b> C address of the argument.
<b>Class.</b> Transformational function.
<b>Argument.</b> X shall have either the POINTER or TARGET attribute. It shall not be a coindexed object. It shall
be a variable with interoperable type and kind type parameters, an assumed-type variable, or a nonpolymorphic
variable that has no length type parameter. If it is allocatable, it shall be allocated. If it is a pointer, it shall be
associated. If it is an array, it shall be contiguous and have nonzero size. It shall not be a zero-length string.
<b>Result</b> <b>Characteristics.</b> Scalar of type C_PTR.
<b>Result</b> <b>Value.</b> The result value is described using the result name CPTR.
<i>Case</i> <i>(i):</i> If X is a scalar data entity, the result is determined as if C_PTR were a derived type containing
     a scalar pointer component PX of the type and type parameters of X and the pointer assignment
     CPTR%PX =<i>></i> X were executed.
<i>Case</i> <i>(ii):</i> If X is an array data entity, the result is determined as if C_PTR were a derived type containing a
     scalar pointer component PX of the type and type parameters of X and the pointer assignment of
     CPTR%PX to the first element of X were executed.
<i>Case</i> <i>(iii):</i> If X is a data entity that is interoperable or has interoperable type and type parameters, the result
     is the value that the C processor returns as the result of applying the unary "&" operator (as defined
     in ISO/IEC 9899:2018, 6.5.3.2) to the target of CPTR%PX.
The result value can be used as an actual CPTR argument in a call to C_F_POINTER where FPTR has
attributes that would allow the pointer assignment FPTR =<i>></i> X. Such a call to C_F_POINTER shall have the
effect of the pointer assignment FPTR =<i>></i> X.
<b>Example.</b> This function uses C_LOC to return the address of a Fortran floating-point vector to a C caller.
   Function new_fortran_float_vec (n) Bind (C) Result (r)
    Use Iso_C_Binding
    Integer (C_size_t), Value :: n
    Type (C_ptr) :: r
    Real (C_float), Pointer :: rp (:)
    Allocate (rp (n), Stat=istat)
    If (istat==0) Then
     r = C_loc (rp (1))
    Else
     r = C_null_ptr
    End If
   End Function
An example using C_LOC on an array of noninteroperable type appears in <i>Case</i> <i>(ii)</i> of the Examples paragraph
of 18.2.3.3.
<b>NOTE</b>
Where the actual argument is of noninteroperable type or type parameters, the result of C_LOC provides an
opaque "handle" for it. In an actual implementation, this handle might be the C address of the argument;
however, only a C function that treats it as a void (generic) C pointer that cannot be dereferenced (ISO/IEC
9899:2018, 6.5.3.2) is likely to be portable.
<b>18.2.3.8</b> <b>C_SIZEOF</b> <b>(X)</b>
<b>Description.</b> Size of X in bytes.
<b>Class.</b> Inquiry function.
<b>Argument.</b> X shall be a data entity with interoperable type and type parameters, and shall not be an assumed-
size array, an assumed-rank array that is associated with an assumed-size array, an unallocated allocatable
variable, or a pointer that is not associated.
<b>Result</b> <b>Characteristics.</b> Scalar integer of kind C_SIZE_T (18.3.1).
<b>Result</b> <b>Value.</b>
<i>Case</i> <i>(i):</i> If X is scalar, the result value is the value that the companion processor returns as the result of
     applying the sizeof operator (ISO/IEC 9899:2018, 6.5.3.4) to an object of a type that interoperates
     with the type and type parameters of X.
<i>Case</i> <i>(ii):</i> If X is an array, the result value is the value that the companion processor returns as the result
     of applying the sizeof operator to an object of a type that interoperates with the type and type
     parameters of X, multiplied by the number of elements in X.
<b>Example.</b> With eight-bit bytes and the declaration INTEGER (C_INT32_T) :: X (3), the result value of
C_SIZEOF (X) is twelve.
<b>18.2.3.9</b> <b>F_C_STRING</b> <b>(STRING</b> <b>[,</b> <b>ASIS])</b>
<b>Description.</b> String with appended null character.
<b>Class.</b> Transformational function.
<b>Arguments.</b>
STRING shall be a character scalar of kind C_CHAR. If C_CHAR has the value-1, indicating that there
     is no C character kind, the generic function F_C_STRING has no specific procedure.
ASIS (optional) shall be a logical scalar.
<b>Result</b> <b>Characteristics.</b> Character scalar of kind C_CHAR. If ASIS is present with the value true, the length
type parameter of the result is equal to one plus the length of STRING, otherwise it is equal to one plus the
length of STRING without trailing blanks.
<b>Result</b> <b>Value.</b> The leftmost characters of the result, up to the penultimate character, are equal to the corres-
ponding characters of STRING. The final character of the result is equal to C_NULL_CHAR.
<b>Example.</b> If X is declared as CHARACTER(6,C_CHAR), and has the value 'abc ' (with three trailing
blanks), then F_C_STRING (X, .TRUE.) has length seven and the value 'abc '//C_NULL_CHAR, and F_C_-
STRING (X) has length four and the value 'abc'//C_NULL_CHAR.
<b>18.3</b> <b>Interoperability</b> <b>between</b> <b>Fortran</b> <b>and</b> <b>C</b> <b>entities</b>
<b>18.3.1</b> <b>Interoperability</b> <b>of</b> <b>intrinsic</b> <b>types</b>
Table 18.2 shows the interoperability between Fortran intrinsic types and C types. A Fortran intrinsic type with
particulartypeparametervaluesisinteroperablewithaCtypeifthetypeandkindtypeparametervaluearelisted
in the table on the same row as that C type. If the type is character, the length type parameter is interoperable
if and only if its value is one. A combination of Fortran type and type parameters that is interoperable with a
C type listed in the table is also interoperable with any unqualified C type that is compatible with the listed C
type.
The second column of the table refers to the named constants made accessible by the ISO_C_BINDING intrinsic
module. If the value of any of these named constants is negative, there is no combination of Fortran type and
type parameters interoperable with the C type shown in that row.
A combination of intrinsic type and type parameters is interoperable if it is interoperable with a C type. The C
types mentioned in Table 18.2 are defined in ISO/IEC 9899:2018, 6.2.5, 7.19, and 7.20.1.
        <b>Table</b> <b>18.2</b> <b>-</b> <b>Interoperability</b> <b>between</b> <b>Fortran</b> <b>and</b> <b>C</b> <b>types</b>
  Fortran type
          Named constant from the ISO_C_BINDING module
          (kind type parameter if value is positive)
                                    C type
          C_INT int
          C_SHORT short int
          C_LONG long int
          C_LONG_LONG long long int
          C_SIGNED_CHAR
                                    signed char
                                    unsigned char
          C_SIZE_T size_t
          C_INT8_T int8_t
          C_INT16_T int16_t
          C_INT32_T int32_t
          C_INT64_T int64_t
          C_INT_LEAST8_T int_least8_t
          C_INT_LEAST16_T int_least16_t
          C_INT_LEAST32_T int_least32_t
  INTEGER C_INT_LEAST64_T int_least64_t
          C_INT_FAST8_T int_fast8_t
          C_INT_FAST16_T int_fast16_t
          C_INT_FAST32_T int_fast32_t
          C_INT_FAST64_T int_fast64_t
          C_INTMAX_T intmax_t
          C_INTPTR_T intptr_t
          C_PTRDIFF_T ptrdiff_t
          C_FLOAT float
  REAL C_DOUBLE double
          C_LONG_DOUBLE long double
          C_FLOAT_COMPLEX float _Complex
  COMPLEX C_DOUBLE_COMPLEX double _Complex
          C_LONG_DOUBLE_COMPLEX long double _Complex
  LOGICAL C_BOOL _Bool
  CHARACTER C_CHAR char
<b>NOTE</b>
ISO/IEC 9899:2018 specifies that the representations for nonnegative signed integers are the same as the cor-
responding values of unsigned integers. Because Fortran does not provide direct support for unsigned kinds of
integers, theISO_C_BINDINGmoduledoesnotmakeaccessiblenamedconstantsfortheirkindtypeparameter
values. A user can use the signed kinds of integers to interoperate with the unsigned types and all their qualified
versions as well. This has the potentially surprising side effect that the C type unsigned char is interoperable
with the type integer with a kind type parameter of C_SIGNED_CHAR.
<b>18.3.2</b> <b>Interoperability</b> <b>with</b> <b>C</b> <b>pointer</b> <b>types</b>
C_PTR and C_FUNPTR shall be derived types with only private components. No direct component of either
of these types is allocatable or a pointer. C_PTR is interoperable with any C object pointer type. C_FUNPTR
is interoperable with any C function pointer type.
<b>NOTE</b> <b>1</b>
This means that only a C processor with the same representation method for all C object pointer types, and the
same representation method for all C function pointer types, can be the target of interoperability of a Fortran
processor. ISO/IEC 9899:2018 does not require this to be the case.
<b>NOTE</b> <b>2</b>
The function C_LOC can be used to return a value of type C_PTR that is the C address of an allocated
allocatable variable. The function C_FUNLOC can be used to return a value of type C_FUNPTR that is the
C address of a procedure. For C_LOC and C_FUNLOC the returned value is of an interoperable type and
thus can be used in contexts where the procedure or allocatable variable is not directly allowed. For example,
it could be passed as an actual argument to a C function.
Similarly, type C_FUNPTR or C_PTR can be used in a dummy argument or structure component and can
have a value that is the C address of a procedure or allocatable variable, even in contexts where a procedure or
allocatable variable is not directly allowed.
<b>18.3.3</b> <b>Interoperability</b> <b>of</b> <b>enum</b> <b>types</b>
An enum type interoperates with its corresponding C enumerated type. It also interoperates with the C integer
type that interoperates with its enumerators.
<b>18.3.4</b> <b>Interoperability</b> <b>of</b> <b>derived</b> <b>types</b> <b>and</b> <b>C</b> <b>structure</b> <b>types</b>
Interoperability between a derived type in Fortran and a structure type in C is provided by the BIND attribute
on the Fortran type.
C1801 (R726) A derived type with the BIND attribute shall not have the SEQUENCE attribute.
C1802 (R726) A derived type with the BIND attribute shall not have type parameters.
C1803 (R726) A derived type with the BIND attribute shall not have the EXTENDS attribute.
C1804 (R726) A <i>derived-type-def</i> that defines a derived type with the BIND attribute shall not have a <i>type-</i>
   <i>bound-procedure-part</i>.
C1805 (R726) A derived type with the BIND attribute shall have at least one component.
C1806 (R726) Each component of a derived type with the BIND attribute shall be a nonpointer, nonallocatable
   data component with interoperable type and type parameters.
<b>NOTE</b> <b>1</b>
The syntax rules and their constraints require that a derived type that is interoperable with a C structure type
have components that are all data entities that are interoperable. No component is permitted to be allocatable
or a pointer, but the value of a component of type C_FUNPTR or C_PTR can be the C address of such an
entity.
A derived type is interoperable with a C structure type if and only if the derived type has the BIND attribute
(7.5.2), the derived type and the C structure type have the same number of components, and the components of
the derived type would interoperate with corresponding components of the C structure type as described in 18.3.5
and 18.3.6 if the components were variables. A component of a derived type and a component of a C structure
type correspond if they are declared in the same relative position in their respective type definitions.
<b>NOTE</b> <b>2</b>
The names of the corresponding components of the derived type and the C structure type need not be the same.
There is no Fortran type that is interoperable with a C structure type that contains a bit field or that contains
a flexible array member. There is no Fortran type that is interoperable with a C union type.
<b>NOTE</b> <b>3</b>
For example, the C type myctype, declared below, is interoperable with the Fortran type myftype, declared
below.
   typedef struct {
    int m, n;
    float r;
   } myctype;
   USE, INTRINSIC :: ISO_C_BINDING
   TYPE, BIND(C) :: MYFTYPE
    INTEGER(C_INT) :: I, J
    REAL(C_FLOAT) :: S
   END TYPE MYFTYPE
The names of the types and the names of the components are not significant for the purposes of determining
whether a Fortran derived type is interoperable with a C structure type.
<b>NOTE</b> <b>4</b>
ISO/IEC 9899:2018 requires the names and component names to be the same in order for the types to be
compatible (ISO/IEC 9899:2018, 6.2.7). This is similar to Fortran's rule describing when different derived type
definitions describe the same sequence type. This rule was not extended to determine whether a Fortran derived
type is interoperable with a C structure type because the case of identifiers is significant in C but not in Fortran.
<b>18.3.5</b> <b>Interoperability</b> <b>of</b> <b>scalar</b> <b>variables</b>
A named scalar Fortran variable is interoperable if and only if its type and type parameters are interoperable, it
is not a coarray, it has neither the ALLOCATABLE nor the POINTER attribute, and if it is of type character
its length is not assumed or declared by an expression that is not a constant expression.
An interoperable scalar Fortran variable is interoperable with a scalar C entity if their types and type parameters
are interoperable.
<b>18.3.6</b> <b>Interoperability</b> <b>of</b> <b>array</b> <b>variables</b>
A Fortran variable that is a named array is interoperable if and only if its type and type parameters are interop-
erable, it is not a coarray, it is of explicit shape or assumed size, and if it is of type character its length is not
assumed or declared by an expression that is not a constant expression.
An explicit-shape or assumed-size array of rank <i>r</i>, with a shape of
                  ?
                        <i>e</i>
                                  1
                          <i>...</i> <i>e</i>
                                    <i>r</i>
                      ?
                                   is interoperable with a C array
if its size is nonzero and
  (1) either
     (a) the array is assumed-size, and the C array does not specify a size, or
     (b) the array is an explicit-shape array, and the extent of the last dimension (<i>e</i>
                                            <i>r</i>
                                          ) is the same as
        the size of the C array, and
  (2) either
     (a) <i>r</i> is equal to one, and an element of the array is interoperable with an element of the C array,
        or
     (b) <i>r</i> is greater than one, and an explicit-shape array with shape of
                       ?
                               <i>e</i>
                                            1
                                 <i>...</i> <i>e</i>
                                            <i>r</i>-1
                            ?
                                            , with the
        same type and type parameters as the original array, is interoperable with a C array of a type
        equal to the element type of the original C array.
<b>NOTE</b> <b>1</b>
An element of a multi-dimensional C array is an array type, so a Fortran array of rank one is not interoperable
with a multidimensional C array.
<b>NOTE</b> <b>2</b>
An allocatable array or array pointer is never interoperable. Such an array does not meet the requirement of
being an explicit-shape or assumed-size array.
<b>NOTE</b> <b>3</b>
For example, a Fortran array declared as
   INTEGER(C_INT) :: A(18, 3:7, *)
is interoperable with a C array declared as
   int b[][5][18];
<b>NOTE</b> <b>4</b>
The C programming language defines null-terminated strings, which are actually arrays of the C type char that
have a C null character in them to indicate the last valid element. A Fortran array of type character with a
kind type parameter equal to C_CHAR is interoperable with a C string.
Fortran's rules of sequence association (15.5.2.12) permit a character scalar actual argument to correspond to
a dummy argument array. This makes it possible to argument associate a Fortran character string with a C
string.
18.3.7, NOTE 4 has an example of interoperation between Fortran and C strings.
<b>18.3.7</b> <b>Interoperability</b> <b>of</b> <b>procedures</b> <b>and</b> <b>procedure</b> <b>interfaces</b>
A Fortran procedure is interoperable if and only if it has the BIND attribute, that is, if its interface is specified
with a <i>proc-language-binding-spec</i>.
A Fortran procedure interface is interoperable with a C function prototype if
  (1) the interface has the BIND attribute,
  (2) either
     (a) the interface describes a function whose result is a scalar variable that is interoperable with
        the result of the prototype or
     (b) the interface describes a subroutine and the prototype has a result type of void,
  (3) the number of dummy arguments of the interface is equal to the number of formal parameters of the
     prototype,
  (4) any scalar dummy argument with the VALUE attribute is interoperable with the corresponding
     formal parameter of the prototype,
  (5) any dummy argument without the VALUE attribute corresponds to a formal parameter of the pro-
     totype that is of a pointer type, and either
     thedummyargumentisinteroperablewithanentityofthereferencedtype(ISO/IEC9899:2018,
        6.2.5, 7.19, and 7.20.1) of the formal parameter,
     the dummy argument is a nonallocatable nonpointer variable of type CHARACTER with
        assumed character length and the formal parameter is a pointer to CFI_cdesc_t,
     the dummy argument is allocatable, assumed-shape, assumed-rank, or a pointer without the
        CONTIGUOUS attribute, and the formal parameter is a pointer to CFI_cdesc_t, or
     the dummy argument is assumed-type and not allocatable, assumed-shape, assumed-rank, or
        a pointer, and the formal parameter is a pointer to void,
  (6) each allocatable or pointer dummy argument of type CHARACTER has deferred character length,
     and
  (7) the prototype does not have variable arguments as denoted by the ellipsis (...).
<b>NOTE</b> <b>1</b>
The <b>referenced</b> <b>type</b> of a C pointer type is the C type of the object that the C pointer type points to. For
example, the referenced type of the pointer type int * is int.
<b>NOTE</b> <b>2</b>
The C language allows specification of a C function that can take a variable number of arguments (ISO/IEC
9899:2018, 7.16). This document does not provide a mechanism for Fortran procedures to interoperate with
such C functions.
A formal parameter of a C function prototype corresponds to a dummy argument of a Fortran interface if they
are in the same relative positions in the C parameter list and the dummy argument list, respectively.
In a reference from C to a Fortran procedure with an interoperable interface, a C actual argument shall be the
address of a C descriptor for the intended effective argument if the corresponding dummy argument interoperates
with a C formal parameter that is a pointer to CFI_cdesc_t. In this C descriptor, the members other than
attribute and type shall describe an object with the same characteristics as the intended effective argument.
The value of theattribute member of the C descriptor shall be compatible with the characteristics of the dummy
argument. The type member shall have a value that depends on the intended effective argument as follows:
 if the dynamic type of the intended effective argument is an interoperable type listed in Table 18.4, the
  corresponding value for that type;
 if the dynamic type of the intended effective argument is an intrinsic type for which the processor defines
  a nonnegative type specifier value not listed in Table 18.4, that type specifier value;
 otherwise, CFI_type_other.
When an interoperable Fortran procedure that is invoked from C has a dummy argument with the CONTIGU-
OUS attribute or that is an assumed-length CHARACTER explicit-shape or assumed-size array, and the actual
argument is the address of a C descriptor for a discontiguous object, the Fortran processor shall handle the
difference in contiguity.
When an interoperable C procedure whose Fortran interface has a dummy argument with the CONTIGUOUS
attributeorthatisanassumed-lengthCHARACTERexplicit-shapeorassumed-sizearrayisinvokedfromFortran
and the effective argument is discontiguous, the Fortran processor shall ensure that the C procedure receives a
descriptor for a contiguous object.
If an interoperable procedure defined by means other than Fortran has an optional dummy argument, and the
corresponding actual argument in a reference from Fortran is absent, the procedure is invoked with a null pointer
for that argument. If an interoperable procedure defined by means of Fortran is invoked by a C function, an
optional dummy argument is absent if and only if the corresponding argument in the invocation is a null pointer.
<b>NOTE</b> <b>3</b>
For example, a Fortran procedure interface described by
   INTERFACE
    FUNCTION FUNC(I, J, K, L, M) BIND(C)
     USE, INTRINSIC :: ISO_C_BINDING
     INTEGER(C_SHORT) :: FUNC
     INTEGER(C_INT), VALUE :: I
     REAL(C_DOUBLE) :: J
     INTEGER(C_INT) :: K, L(10)
     TYPE(C_PTR), VALUE :: M
    END FUNCTION FUNC
   END INTERFACE
is interoperable with the C function prototype
   short func(int i, double *j, int *k, int l[10], void *m);
A C pointer can correspond to a Fortran dummy argument of type C_PTR with the VALUE attribute or
to a Fortran scalar that does not have the VALUE attribute. In the above example, the C pointers j and k
correspond to the Fortran scalars J and K, respectively, and the C pointer m corresponds to the Fortran dummy
argument M of type C_PTR.
<b>NOTE</b> <b>4</b>
The interoperability of Fortran procedure interfaces with C function prototypes is only one part of invocation
of a C function from Fortran. There are four pieces to consider in such an invocation: the procedure reference,
the Fortran procedure interface, the C function prototype, and the C function. Conversely, the invocation of
a Fortran procedure from C involves the function reference, the C function prototype, the Fortran procedure
interface, and the Fortran procedure. In order to determine whether a reference is allowed, it is necessary to
consider all four pieces.
For example, consider a C function that can be described by the C function prototype
   void copy(char in[], char out[]);
Such a function can be invoked from Fortran as follows:
   USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_CHAR, C_NULL_CHAR
   INTERFACE
    SUBROUTINE COPY(IN, OUT) BIND(C)
     IMPORT C_CHAR
     CHARACTER(KIND=C_CHAR), DIMENSION(*) :: IN, OUT
    END SUBROUTINE COPY
   END INTERFACE
                <b>J3/23-007r1</b> <b>515</b>
<b>NOTE</b> <b>4</b> <b>(cont.)</b>
   CHARACTER(LEN=10, KIND=C_CHAR) :: &
   & DIGIT_STRING = C_CHAR_'123456789' // C_NULL_CHAR
   CHARACTER(KIND=C_CHAR) :: DIGIT_ARR(10)
   CALL COPY(DIGIT_STRING, DIGIT_ARR)
   PRINT '(1X, A1)', DIGIT_ARR(1:9)
   END
The procedure reference has character string actual arguments. These correspond to character array dummy
arguments in the procedure interface body as allowed by Fortran's rules of sequence association (15.5.2.12).
Those array dummy arguments in the procedure interface are interoperable with the formal parameters of the
C function prototype. The C function is not shown here, but is assumed to be compatible with the C function
prototype.
<b>NOTE</b> <b>5</b>
If an interoperable C procedure whose Fortran interface has a dummy argument which has the CONTIGUOUS
attribute, or is an assumed-length CHARACTER explicit-shape or assumed-size array, is invoked from C,
because the invoking routine is responsible for the contents of the C descriptor, it therefore might not describe
a contiguous data object.
<b>18.4</b> <b>C</b> <b>descriptors</b>
A C descriptor is a C structure of type CFI_cdesc_t. Together with library functions that have standard
prototypes, it provides a means for describing and manipulating Fortran data objects from within a C function.
This C structure is defined in the source file ISO_Fortran_binding.h.
<b>18.5</b> <b>The</b> <b>source</b> <b>file</b> <b>ISO_Fortran_binding.h</b>
<b>18.5.1</b> <b>Summary</b> <b>of</b> <b>contents</b>
The source file ISO_Fortran_binding.h shall contain the C structure definitions, typedef declarations, macro
definitions, and function prototypes specified in 18.5.2 to 18.5.5. The definitions and declarations in ISO_-
Fortran_binding.h can be used by a C function to interpret and manipulate a C descriptor. These provide a
means to specify a C prototype that interoperates with a Fortran interface that has a non-interoperable dummy
variable (18.3.7).
The source file ISO_Fortran_binding.h may be included in any order relative to the standard C headers, and
may be included more than once in a given scope, with no effect different from being included only once, other
than the effect on line numbers.
A C source file that includes the ISO_Fortran_binding.h header file shall not use any names starting with
CFI_ that are not defined in the header, and shall not define any of the structure names defined in the header
as macro names. All names other than structure member names defined in the header begin with CFI_ or an
underscore character, or are defined by a standard C header that it includes.
<b>18.5.2</b> <b>The</b> <b>CFI_dim_t</b> <b>structure</b> <b>type</b>
CFI_dim_t is a typedef name for a C structure. It is used to represent lower bound, extent, and memory stride
information for one dimension of an array. The type CFI_index_t is described in 18.5.4. CFI_dim_t contains
at least the following members in any order.
<b>CFI_index_t</b> <b>lower_bound;</b> The value is equal to the value of the lower bound for the dimension being
  described.
<b>CFI_index_t</b> <b>extent;</b> The value is equal to the number of elements in the dimension being described, or-1
  for the final dimension of an assumed-size array.
<b>CFI_index_t</b> <b>sm;</b> The value is equal to the memory stride for a dimension; this is the difference in bytes
  between the addresses of successive elements in the dimension being described.
<b>18.5.3</b> <b>The</b> <b>CFI_cdesc_t</b> <b>structure</b> <b>type</b>
CFI_cdesc_t is a typedef name for a C structure, which contains a flexible array member. It shall contain at least
the members described in this subclause. The values of these members of a structure of type CFI_cdesc_t that
is produced by the functions and macros specified in this document, or received by a C function when invoked
by a Fortran procedure, shall have the properties described in this subclause.
The first three members of the structure shall be base_addr, elem_len, and version in that order. The final
member shall be dim. All other members shall be between version and dim, in any order. The types CFI_-
attribute_t, CFI_rank_t, and CFI_type_t are described in 18.5.4. The type CFI_dim_t is described in 18.5.2.
<b>void</b> <b>*</b> <b>base_addr;</b> If the object is an unallocated allocatable variable or a pointer that is disassociated, the
  value is a null pointer; otherwise, if the object has zero size, the value is not a null pointer but is otherwise
  processor-dependent. Otherwise, the value is the base address of the object being described. The base
  address of a scalar is its C address. The base address of an array is the C address of the first element in
  Fortran array element order.
<b>size_t</b> <b>elem_len;</b> If the object is scalar, the value is the storage size in bytes of the object; otherwise, the value
  is the storage size in bytes of an element of the object.
<b>int</b> <b>version;</b> The value is equal to the value of CFI_VERSION in the source file ISO_Fortran_binding.h that
  defined the format and meaning of this C descriptor.
<b>CFI_rank_t</b> <b>rank;</b> The value is equal to the number of dimensions of the Fortran object being described; if
  the object is scalar, the value is zero.
<b>CFI_type_t</b> <b>type;</b> The value is equal to the specifier for the type of the object. Each interoperable intrinsic C
  type has a specifier. Specifiers are also provided to indicate that the type of the object is an interoperable
  structure, or is unknown. The macros listed in Table 18.4 provide values that correspond to each specifier.
<b>CFI_attribute_t</b> <b>attribute;</b> The value is equal to the value of an attribute code that indicates whether the
  object described is allocatable, a data pointer, or a nonallocatable nonpointer data object. The macros
  listed in Table 18.3 provide values that correspond to each code.
<b>CFI_dim_t</b> <b>dim;</b> The number of elements in the dim array is equal to the rank of the object. Each element of
  the array contains the lower bound, extent, and memory stride information for the corresponding dimension
  of the Fortran object.
For a C descriptor of an array pointer or allocatable array, the value of the lower_bound member of each element
of the dim member of the descriptor is determined by argument association, allocation, or pointer association.
For a C descriptor of a nonallocatable nonpointer object, the value of the lower_bound member of each element
of the dim member of the descriptor is zero.
There shall be an ordering of the dimensions such that the absolute value of the sm member of the first dimension
is not less than the elem_len member of the C descriptor and the absolute value of the sm member of each
subsequent dimension is not less than the absolute value of the sm member of the previous dimension multiplied
by the extent of the previous dimension.
In a C descriptor of an assumed-size array, the extent member of the last element of the dim member has the
value-1.
<b>NOTE</b> <b>1</b>
The reason for the restriction on the absolute values of the sm members is to ensure that there is no overlap
between the elements of the array that is being described, while allowing for the reordering of subscripts. Within
Fortran, such a reordering can be achieved with the intrinsic function TRANSPOSE or the intrinsic function
RESHAPE with the optional argument ORDER, and an optimizing compiler can accommodate it without
making a copy by constructing the appropriate descriptor whenever it can determine that a copy is not needed.
<b>NOTE</b> <b>2</b>
The value of elem_len for a Fortran CHARACTER object is equal to the character length times the number
of bytes of a single character of that kind. If the kind is C_CHAR, this value will be equal to the character
length.
<b>18.5.4</b> <b>Macros</b> <b>and</b> <b>typedefs</b> <b>in</b> <b>ISO_Fortran_binding.h</b>
Except for CFI_CDESC_T, each macro defined in ISO_Fortran_binding.h expands to an integer constant
expression that is either a single token or a parenthesized expression that is suitable for use in #if preprocessing
directives.
CFI_CDESC_T is a function-like macro that takes one argument, which is the rank of the C descriptor to create,
and evaluates to an unqualified type of suitable size and alignment for defining a variable to use as a C descriptor
of that rank. The argument shall be an integer constant expression with a value that is greater than or equal to
zero and less than or equal to CFI_MAX_RANK. A pointer to a variable declared using CFI_CDESC_T can
be cast to CFI_cdesc_t *. A variable declared using CFI_CDESC_T shall not have an initializer.
<b>NOTE</b> <b>1</b>
The CFI_CDESC_T macro provides the memory for a C descriptor. The address of an entity declared using
the macro is not usable as an actual argument corresponding to a formal parameter of type CFI_cdesc_t *
without an explicit cast. For example, the following code uses CFI_CDESC_T to declare a C descriptor of
rank 5 and pass it to CFI_deallocate (18.5.5.4).
   CFI_CDESC_T(5) object;
   int ind;
    ... <i>Code</i> <i>to</i> <i>define</i> <i>and</i> <i>use</i> <i>C</i> <i>descriptor.</i>
   ind = CFI_deallocate((CFI_cdesc_t *)&object);
CFI_index_tisatypedefnameforastandardsignedintegertypecapableofrepresentingtheresultofsubtracting
two pointers.
The CFI_MAX_RANK macro has a processor-dependent value equal to the largest rank supported. The value
shall be greater than or equal to 15. CFI_rank_t is a typedef name for a standard integer type capable of
representing the largest supported rank.
The CFI_VERSION macro has a processor-dependent value that encodes the version of the ISO_Fortran_-
binding.h source file containing this macro. This value should be increased if a new version of the source file is
incompatible with the previous version.
The macros in Table 18.3 are for use as attribute codes. The values shall be nonnegative and distinct. CFI_-
attribute_t is a typedef name for a standard integer type capable of representing the values of the attribute
codes.
      <b>Table</b> <b>18.3</b> <b>-</b> <b>ISO_Fortran_binding.h</b> <b>macros</b> <b>for</b> <b>attribute</b> <b>codes</b>
               Macro name Attribute
            CFI_attribute_pointer data pointer
            CFI_attribute_allocatable allocatable
            CFI_attribute_other nonallocatable nonpointer
CFI_attribute_pointer specifies a data object with the Fortran POINTER attribute. CFI_attribute_allocatable
specifies an object with the Fortran ALLOCATABLE attribute. CFI_attribute_other specifies a nonallocatable
nonpointer object.
The macros in Table 18.4 are for use as type specifiers. The value for CFI_type_other shall be negative and
distinct from all other type specifiers. CFI_type_struct specifies a C structure that is interoperable with a
Fortran derived type; its value shall be positive and distinct from all other type specifiers. If a C type is not
interoperable with a Fortran type and kind supported by the Fortran processor, its macro shall evaluate to a
negative value. Otherwise, the value for a macro listed in Table 18.4 shall be positive.
If the processor supports interoperability of a Fortran intrinsic type with a C type not listed in Table 18.4,
the processor shall define a type specifier value for that type which is positive and distinct from all other type
specifiers.
CFI_type_t is a typedef name for a standard integer type capable of representing the values for the supported
type specifiers.
       <b>Table</b> <b>18.4</b> <b>-</b> <b>ISO_Fortran_binding.h</b> <b>macros</b> <b>for</b> <b>type</b> <b>codes</b>
               Macro name C Type
          CFI_type_signed_char signed char
          CFI_type_short short int
          CFI_type_int int
          CFI_type_long long int
          CFI_type_long_long long long int
          CFI_type_size_t size_t
          CFI_type_int8_t int8_t
          CFI_type_int16_t int16_t
          CFI_type_int32_t int32_t
          CFI_type_int64_t int64_t
          CFI_type_int_least8_t int_least8_t
          CFI_type_int_least16_t int_least16_t
          CFI_type_int_least32_t int_least32_t
          CFI_type_int_least64_t int_least64_t
          CFI_type_int_fast8_t int_fast8_t
          CFI_type_int_fast16_t int_fast16_t
          CFI_type_int_fast32_t int_fast32_t
          CFI_type_int_fast64_t int_fast64_t
          CFI_type_intmax_t intmax_t
          CFI_type_intptr_t intptr_t
          CFI_type_ptrdiff_t ptrdiff_t
          CFI_type_float float
          CFI_type_double double
          CFI_type_long_double long double
          CFI_type_float_Complex float _Complex
          CFI_type_double_Complex double _Complex
          CFI_type_long_double_Complex long double _Complex
          CFI_type_Bool _Bool
          CFI_type_char char
          CFI_type_cptr void *
          CFI_type_struct interoperable C structure
          CFI_type_other Not otherwise specified
<b>NOTE</b> <b>2</b>
The values for different C types can be the same; for example, CFI_type_int and CFI_type_int32_t might
have the same value.
The macros in Table 18.5 are for use as error codes. The macro CFI_SUCCESS shall be defined to be the
integer constant zero. The value of each macro other than CFI_SUCCESS shall be nonzero and shall be different
from the values of the other macros specified in this subclause. Error conditions other than those listed in this
subclause should be indicated by error codes different from the values of the macros named in this subclause.
The values of the macros in Table 18.5 indicate the error condition described.
       <b>Table</b> <b>18.5</b> <b>-</b> <b>ISO_Fortran_binding.h</b> <b>macros</b> <b>for</b> <b>error</b> <b>codes</b>
Macro name Error condition
CFI_SUCCESS No error detected.
CFI_ERROR_BASE_ADDR_NULL The base address member of a C descriptor is a null pointer
                     in a context that requires a non-null pointer value.
CFI_ERROR_BASE_ADDR_NOT_NULL In a context that requires a null pointer value, the base
                     address member of a C descriptor is not a null pointer.
CFI_INVALID_ELEM_LEN The value supplied for the element length member of a
                     C descriptor is not valid.
CFI_INVALID_RANK The value supplied for the rank member of a C descriptor is
                     not valid.
CFI_INVALID_TYPE The value supplied for the type member of a C descriptor is
                     not valid.
CFI_INVALID_ATTRIBUTE The value supplied for the attribute member of a
                     C descriptor is not valid.
CFI_INVALID_EXTENT The value supplied for the extent member of a CFI_dim_t
                     structure is not valid.
CFI_INVALID_DESCRIPTOR A C descriptor is invalid in some way.
CFI_ERROR_MEM_ALLOCATION Memory allocation failed.
CFI_ERROR_OUT_OF_BOUNDS A reference is out of bounds.
<b>18.5.5</b> <b>Functions</b> <b>declared</b> <b>in</b> <b>ISO_Fortran_binding.h</b>
<b>18.5.5.1</b> <b>Arguments</b> <b>and</b> <b>results</b> <b>of</b> <b>the</b> <b>functions</b>
Some of the functions described in 18.5.5 return an error indicator; this is an integer value that indicates whether
an error condition was detected. The value zero indicates that no error condition was detected, and a nonzero
value indicates which error condition was detected. Table 18.5 lists standard error conditions and macro names
for their corresponding error codes. A processor is permitted to detect other error conditions. If an invocation of
a function defined in 18.5.5 could detect more than one error condition and an error condition is detected, which
error condition is detected is processor dependent.
In function arguments representing subscripts, bounds, extents, or strides, the ordering of the elements is the
same as the ordering of the elements of the dim member of a C descriptor.
Prototypesforthesefunctions, orequivalentmacros, areprovidedinthe ISO_Fortran_binding.hfileasdescribed
in 18.5.5. It is unspecified whether the functions defined by this header are macros or identifiers declared with
externallinkage. Ifamacrodefinitionissuppressedinordertoaccessanactualfunction, thebehaviorisundefined.
<b>NOTE</b>
These functions are allowed to be macros to provide extra implementation flexibility. For example, CFI_-
establish could include the value of CFI_VERSION in the header used to compile the call to CFI_establish as
an extra argument of the actual function used to establish the C descriptor.
<b>18.5.5.2</b> <b>The</b> <b>CFI_address</b> <b>function</b>
<b>Synopsis.</b> C address of an object described by a C descriptor.
void *CFI_address(const CFI_cdesc_t *dv, const CFI_index_t subscripts[]);
<b>Formal</b> <b>Parameters.</b>
dv shall be the address of a C descriptor describing the object. The object shall not be an unallocated
     allocatable variable or a pointer that is not associated.
subscripts shall be a null pointer or the address of an array of type CFI_index_t. If the object is an array,
     subscripts shall be the address of an array of CFI_index_t with at least <i>n</i> elements, where <i>n</i>
     is the rank of the object. The value of subscripts[<i>i</i>] shall be within the bounds of dimension <i>i</i>
     specified by the dim member of the C descriptor except for the last dimension of a C descriptor for
     an assumed-size array. For the C descriptor of an assumed-size array, the value of the subscript for
     the last dimension shall not be less than the lower bound, and the subscript order value specified
     by the subscripts shall not exceed the size of the array.
<b>Result</b> <b>Value.</b> If the object is an array of rank <i>n</i>, the result is the C address of the element of the object that
the first <i>n</i> elements of the subscripts argument would specify if used as subscripts. If the object is scalar, the
result is its C address.
<b>Example.</b> If dv is the address of a C descriptor for the Fortran array A declared as
    REAL(C_FLOAT) :: A(100, 100)
the following code calculates the C address of A(5, 10):
    CFI_index_t subscripts[2];
    float *address;
    subscripts[0] = 4;
    subscripts[1] = 9;
    address = (float *) CFI_address(dv, subscripts );
<b>18.5.5.3</b> <b>The</b> <b>CFI_allocate</b> <b>function</b>
<b>Synopsis.</b> Allocate memory for an object described by a C descriptor.
int CFI_allocate(CFI_cdesc_t *dv, const CFI_index_t lower_bounds[],
        const CFI_index_t upper_bounds[], size_t elem_len);
<b>Formal</b> <b>Parameters.</b>
dv shall be the address of a C descriptor specifying the rank and type of the object. The base_-
     addr member of the C descriptor shall be a null pointer. If the type is not a character type, the
     elem_len member shall specify the element length. The attribute member shall have a value of
     CFI_attribute_allocatable or CFI_attribute_pointer.
lower_bounds shall be the address of an array with at least dv->rank elements, if dv->rank>0.
upper_bounds shall be the address of an array with at least dv->rank elements, if dv->rank>0.
elem_len If the type specified in the C descriptor type is a Fortran character type, the value of elem_len
     shall be the storage size in bytes of an element of the object; otherwise, elem_len is ignored.
<b>Description.</b> Successful execution of CFI_allocate allocates memory for the object described by the C
descriptor with the address dv using the same mechanism as the Fortran ALLOCATE statement, and assigns the
address of that memory to dv->base_addr. The first dv->rank elements of the lower_bounds and upper_bounds
arguments provide the lower and upper Fortran bounds, respectively, for each corresponding dimension of the
object. The supplied lower and upper bounds override any current dimension information in the C descriptor.
If the rank is zero, the lower_bounds and upper_bounds arguments are ignored. If the type specified in the C
descriptor is a character type, the supplied element length overrides the current element-length information in
the descriptor.
If an error is detected, the C descriptor is not modified.
<b>Result</b> <b>Value.</b> The result is an error indicator.
<b>Example.</b> If dv is the address of a C descriptor for the Fortran array A declared as
    REAL, ALLOCATABLE :: A(:, :)
and the array is not allocated, the following code allocates it to be of shape [100, 500]:
    CFI_index_t lower[2], upper[2];
    int ind;
    lower[0] = 1; lower[1] = 1;
    upper[0] = 100; upper[1] = 500;
    ind = CFI_allocate(dv, lower, upper, 0);
<b>18.5.5.4</b> <b>The</b> <b>CFI_deallocate</b> <b>function</b>
<b>Synopsis.</b> Deallocate memory for an object described by a C descriptor.
int CFI_deallocate(CFI_cdesc_t *dv);
<b>Formal</b> <b>Parameter.</b> dv shall be the address of a C descriptor describing the object. It shall have been allocated
using the same mechanism as the Fortran ALLOCATE statement. If the object is a pointer, it shall be associated
with a target satisfying the conditions for successful deallocation by the Fortran DEALLOCATE statement
(9.7.3).
<b>Description.</b> Successful execution of CFI_deallocate deallocates memory for the object using the same mech-
anism as the Fortran DEALLOCATE statement, and the base_addr member of the C descriptor becomes a null
pointer.
If an error is detected, the C descriptor is not modified.
<b>Result</b> <b>Value.</b> The result is an error indicator.
<b>Example.</b> If dv is the address of a C descriptor for the Fortran array A declared as
    REAL, ALLOCATABLE :: A(:, :)
and the array is allocated, the following code deallocates it:
    int ind;
    ind = CFI_deallocate(dv);
<b>18.5.5.5</b> <b>The</b> <b>CFI_establish</b> <b>function</b>
<b>Synopsis.</b> Establish a C descriptor.
int CFI_establish(CFI_cdesc_t *dv, void *base_addr, CFI_attribute_t attribute,
        CFI_type_t type, size_t elem_len, CFI_rank_t rank,
        const CFI_index_t extents[]);
<b>Formal</b> <b>Parameters.</b>
dv shall be the address of a data object large enough to hold a C descriptor of the rank specified by
     rank. It shall not have the same value as either a C formal parameter that corresponds to a Fortran
     actual argument or a C actual argument that corresponds to a Fortran dummy argument. It shall
     not be the address of a C descriptor that describes an allocated allocatable object.
base_addr shall be a null pointer or the base address of the object to be described. If it is not a null pointer,
     it shall be the address of a storage sequence that is appropriately aligned (ISO/IEC 9899:2018, 3.2)
     for an object of the type specified by type.
attribute shall be one of the attribute codes in Table 18.3. If it is CFI_attribute_allocatable, base_addr
     shall be a null pointer.
type shall have the value of one of the type codes in Table 18.4, or have a positive value corresponding
     to an interoperable C type.
elem_len If type is equal to CFI_type_struct, CFI_type_other, or a Fortran character type code, elem_-
     len shall be greater than zero and equal to the storage size in bytes of an element of the object.
     Otherwise, elem_len will be ignored.
rank shall have a value in the range 0 rank CFI_MAX_RANK. It specifies the rank of the object.
extents is ignored if rank is equal to zero or if base_addr is a null pointer. Otherwise, it shall be the address
     of an array with rank elements; the value of each element shall be nonnegative, and extents[<i>i</i>]
     specifies the extent of dimension <i>i</i> of the object.
<b>Description.</b> Successful execution of CFI_establish updates the object with the address dv to be an established
C descriptor for a nonallocatable nonpointer data object of known shape, an unallocated allocatable object, or a
data pointer. If base_addr is not a null pointer, it is for a nonallocatable entity that is a scalar or a contiguous
array; if the attribute argument has the value CFI_attribute_pointer, the lower bounds of the object described
by dv are set to zero. If base_addr is a null pointer, the established C descriptor is for an unallocated allocatable,
a disassociated pointer, or is a C descriptor that has the attribute CFI_attribute_other but does not describe
a data object. If base_addr is the C address of a Fortran data object, the type and elem_len arguments shall be
consistent with the type and type parameters of the Fortran data object. The remaining properties of the object
are given by the other arguments.
If an error is detected, the object with the address dv is not modified.
<b>Result</b> <b>Value.</b> The result is an error indicator.
<b>NOTE</b> <b>1</b>
CFI_establish is used to initialize a C descriptor declared in C with CFI_CDESC_T before passing it to any
other functions as an actual argument, in order to set the rank, attribute, type and element length.
<b>NOTE</b> <b>2</b>
ACdescriptorwithattributeCFI_attribute_otherandbase_addra nullpointer can be usedas the argument
result in calls to CFI_section or CFI_select_part, which will produce a C descriptor for a nonallocatable
nonpointer data object.
<b>Examples.</b>
<i>Case</i> <i>(i):</i> The following code fragment establishes a C descriptor for an unallocated rank-one allocatable array
     that can be passed to Fortran for allocation there.
       CFI_rank_t rank;
       CFI_CDESC_T(1) field;
       int ind;
       rank = 1;
       ind = CFI_establish((CFI_cdesc_t *)&field, NULL, CFI_attribute_allocatable,
                 CFI_type_double, 0, rank, NULL);
<i>Case</i> <i>(ii):</i> Given the Fortran type definition
       TYPE, BIND(C) :: T
        REAL(C_DOUBLE) :: X
        COMPLEX(C_DOUBLE_COMPLEX) :: Y
       END TYPE
     and a Fortran subprogram that has an assumed-shape dummy argument of type T, the following
     code fragment creates a descriptor a_fortran for an array of size 100 that can be used as the actual
     argument in an invocation of the subprogram from C:
       typedef struct {double x; double _Complex y;} t;
       t a_c[100];
       CFI_CDESC_T(1) a_fortran;
       int ind;
       CFI_index_t extent[1];
       extent[0] = 100;
       ind = CFI_establish((CFI_cdesc_t *)&a_fortran, a_c, CFI_attribute_other,
                 CFI_type_struct, sizeof(t), 1, extent);
<b>18.5.5.6</b> <b>The</b> <b>CFI_is_contiguous</b> <b>function</b>
<b>Synopsis.</b> Test contiguity of an array.
int CFI_is_contiguous(const CFI_cdesc_t * dv);
<b>Formal</b> <b>Parameter.</b> dv shall be the address of a C descriptor describing an array. The base_addr member of
the C descriptor shall not be a null pointer.
<b>Result</b> <b>Value.</b> The value of the result is 1 if the array described by dv is contiguous, and 0 otherwise.
<b>NOTE</b>
Assumed-size and allocatable arrays are always contiguous, and therefore the result of CFI_is_contiguous on
a C descriptor for such an array will be equal to 1.
<b>18.5.5.7</b> <b>The</b> <b>CFI_section</b> <b>function</b>
<b>Synopsis.</b> Update a C descriptor for an array section for which each element is an element of a given array.
int CFI_section(CFI_cdesc_t *result, const CFI_cdesc_t *source,
        const CFI_index_t lower_bounds[], const CFI_index_t upper_bounds[],
        const CFI_index_t strides[]);
<b>Formal</b> <b>Parameters.</b>
result shall be the address of a C descriptor with rank equal to the rank of source minus the number of
     zero strides. Theattribute member shall have the value CFI_attribute_other or CFI_attribute_-
     pointer. If the value of result is the same as either a C formal parameter that corresponds to a
     Fortran actual argument or a C actual argument that corresponds to a Fortran dummy argument,
     the attribute member shall have the value CFI_attribute_pointer.
source shall be the address of a C descriptor that describes a nonallocatable nonpointer array, an allocated
     allocatable array, or an associated array pointer. The elem_len and type members of source shall
     have the same values as the corresponding members of result.
lower_bounds shall be a null pointer or the address of an array with at least source->rank elements. If it is not
     a null pointer, and <i>stride</i>
                  <i>i</i>
                 is zero or (<i>upper</i>
                          <i>i</i>
            -lower_bounds[<i>i</i>] +<i>stride</i>
                                        <i>i</i>
                                                                     )<i>/stride</i>
                                            <i>i</i>
                                    <i>></i> 0, the value
     of lower_bounds[<i>i</i>] shall be within the bounds of dimension <i>i</i> of SOURCE.
upper_bounds shall be a null pointer or the address of an array with at least source->rank elements. If source
     describes an assumed-size array, upper_bounds shall not be a null pointer. If it is not a null pointer
     and <i>stride</i>
           <i>i</i>
           is zero or (upper_bounds[<i>i</i>]- <i>lower</i>
                             <i>i</i>
                                                   + <i>stride</i>
                                  <i>i</i>
                                                           )<i>/stride</i>
                                      <i>i</i>
                               <i>></i> 0, the value of upper_-
     bounds[<i>i</i>] shall be within the bounds of dimension <i>i</i> of SOURCE.
strides shall be a null pointer or the address of an array with at least source->rank elements.
<b>Description.</b> Successful execution of CFI_section updates the base_addr and dim members of the C descriptor
with the address result to describe the array section determined by source, lower_bounds, upper_bounds, and
strides, as follows.
The array section is equivalent to the Fortran array section SOURCE(<i>sectsub</i>
                                        1
                                   , <i>sectsub</i>
                                             2
                                       , ... <i>sectsub</i>
                                               <i>n</i>
                                             ), where
SOURCE is the array described by source, <i>n</i> is the rank of that array, and <i>sectsub</i>
                                       <i>i</i>
                                      is the subscript <i>lower</i>
                                                  <i>i</i>
                                                if
<i>stride</i>
  <i>i</i>
   is zero, and the section subscript <i>lower</i>
                      <i>i</i>
                     : <i>upper</i>
                          <i>i</i>
                         : <i>stride</i>
                              <i>i</i>
                             otherwise. The value of <i>lower</i>
                                             <i>i</i>
                                           is the lower
bound of dimension <i>i</i> of SOURCE if lower_bounds is a null pointer and lower_bounds[<i>i</i>] otherwise. The value
of <i>upper</i>
   <i>i</i>
    is the upper bound of dimension <i>i</i> of SOURCE if upper_bounds is a null pointer and upper_bounds[<i>i</i>]
otherwise. The value of <i>stride</i>
              <i>i</i>
              is 1 if strides is a null pointer and strides[<i>i</i>] otherwise. If <i>stride</i>
                                               <i>i</i>
                                             has the
value zero, <i>lower</i>
       <i>i</i>
        shall have the same value as <i>upper</i>
                        <i>i</i>
                       .
If an error is detected, the C descriptor with the address result is not modified.
<b>Result</b> <b>Value.</b> The result is an error indicator.
<b>Examples.</b>
<i>Case</i> <i>(i):</i> If source is already the address of a C descriptor for the rank-one Fortran array A, the lower
     bounds of A are equal to 1, and the lower bounds in the C descriptor are equal to 0, the following
     code fragment establishes a new C descriptor section and updates it to describe the array section
     A(3::5):
       CFI_index_t lower[1], strides[1];
       CFI_CDESC_T(1) section;
       int ind;
       lower[0] = 2;
       strides[0] = 5;
       ind = CFI_establish((CFI_cdesc_t *)&section, NULL, CFI_attribute_other,
                 CFI_type_float, 0, 1, NULL);
       ind = CFI_section((CFI_cdesc_t *)&section, source, lower, NULL, strides);
<i>Case</i> <i>(ii):</i> If source is already the address of a C descriptor for a rank-two Fortran assumed-shape array A
     with lower bounds equal to 1, the following code fragment establishes a C descriptor and updates
     it to describe the rank-one array section A(:, 42).
       CFI_index_t lower[2], upper[2], strides[2];
       CFI_CDESC_T(1) section;
       int ind;
       lower[0] = source->dim[0].lower_bound;
       upper[0] = source->dim[0].lower_bound + source->dim[0].extent - 1;
       strides[0] = 1;
       lower[1] = upper[1] = source->dim[1].lower_bound + 41;
       strides[1] = 0;
       ind = CFI_establish((CFI_cdesc_t *)&section, NULL, CFI_attribute_other,
                 CFI_type_float, 0, 1, NULL);
       ind = CFI_section((CFI_cdesc_t *)&section, source, lower, upper, strides);
<b>18.5.5.8</b> <b>The</b> <b>CFI_select_part</b> <b>function</b>
<b>Synopsis.</b> Update a C descriptor for an array section for which each element is a part of the corresponding
element of an array.
int CFI_select_part(CFI_cdesc_t *result, const CFI_cdesc_t *source, size_t displacement,
          size_t elem_len);
<b>Formal</b> <b>Parameters.</b>
result shall be the address of a C descriptor; result->rank shall have the same value as source->rank
     and result->attribute shall have the value CFI_attribute_other or CFI_attribute_pointer. If
     the address specified by result is the value of a C formal parameter that corresponds to a For-
     tran actual argument or of a C actual argument that corresponds to a Fortran dummy argument,
     result->attribute shall have the value CFI_attribute_pointer. The value of result->type spe-
     cifies the type of the array section.
source shall be the address of a C descriptor for an allocated allocatable array, an associated array pointer,
     or a nonallocatable nonpointer array that is not assumed-size.
displacement shall have a value 0 displacement source->elem_len-1, and the sum of the displacement
     and the size in bytes of an element of the array section shall be less than or equal to source->elem_-
     len. The address displacement bytes greater than the value of source->base_addr is the base of
     the array section and shall be appropriately aligned (ISO/IEC 9899:2018, 3.2) for an object of the
     type of the array section.
elem_len shallhaveavalueequaltothestoragesizeinbytesofanelementofthearraysectionif result->type
     specifies a Fortran character type; otherwise, elem_len is ignored.
<b>Description.</b> Successful execution of CFI_select_part updates the base_addr, dim, and elem_len members of
the C descriptor with the address result for an array section for which each element is a part of the corresponding
element of the array described by the C descriptor with the address source. The part shall be a component of a
structure, a substring, or the real or imaginary part of a complex value.
If an error is detected, the C descriptor with the address result is not modified.
<b>Result</b> <b>Value.</b> The result is an error indicator.
<b>Example.</b> If source is already the address of a C descriptor for the Fortran array A declared with
   TYPE, BIND(C) :: T
    REAL(C_DOUBLE) :: X
    COMPLEX(C_DOUBLE_COMPLEX) :: Y
   END TYPE
   TYPE(T) A(100)
the following code fragment establishes a C descriptor for the array A%Y:
   typedef struct {
    double x; double _Complex y;
   } t;
   CFI_CDESC_T(1) component;
   CFI_cdesc_t * comp_cdesc = (CFI_cdesc_t *)&component;
   CFI_index_t extent[] = { 100 };
   (void)CFI_establish(comp_cdesc, NULL, CFI_attribute_other, CFI_type_double_Complex,
             sizeof(double _Complex), 1, extent);
   (void)CFI_select_part(comp_cdesc, source, offsetof(t,y), 0);
<b>18.5.5.9</b> <b>The</b> <b>CFI_setpointer</b> <b>function</b>
<b>Synopsis.</b> Update a C descriptor for a Fortran pointer to be associated with the whole of a given object or to
be disassociated.
int CFI_setpointer(CFI_cdesc_t *result, CFI_cdesc_t *source,
         const CFI_index_t lower_bounds[]);
<b>Formal</b> <b>Parameters.</b>
result shall be the address of a C descriptor for a Fortran pointer. It is updated using information from
     the source and lower_bounds arguments.
source shall be a null pointer or the address of a C descriptor for an allocated allocatable object, a data
     pointer object, or a nonallocatable nonpointer data object that is not an assumed-size array. If
     source is not a null pointer, the corresponding values of the rank and type members shall be the
     same in the C descriptors with the addresses source and result. If source is not a null pointer
     and the C descriptor with the address result does not describe a deferred length character pointer,
     the corresponding values of the elem_len member shall be the same in the C descriptors with the
     addresses source and result.
lower_bounds If source is not a null pointer and source->rank is nonzero, lower_bounds shall be a null pointer
     or the address of an array with at least source->rank elements.
<b>Description.</b> Successful execution of CFI_setpointer updates the base_addr, dim, and possibly elem_len
members of the C descriptor with the address result as follows:
 if source is a null pointer or the address of a C descriptor for a disassociated pointer, the updated C
  descriptor describes a disassociated pointer;
 otherwise, the C descriptor with the address result becomes a C descriptor for the object described by
  the C descriptor with the address source, except that if source->rank is nonzero and lower_bounds is
  not a null pointer, the lower bounds are replaced by the values of the first source->rank elements of the
  lower_boundsarray. IftheCdescriptorwiththeaddress resultdescribes acharacterpointerwithdeferred
  length, the value of its elem_len member is set to source->elem_len.
If an error is detected, the C descriptor with the address result is not modified.
<b>Result</b> <b>Value.</b> The result is an error indicator.
<b>Example.</b> If ptr is already the address of a C descriptor for an array pointer of rank 1, the following code
updates it to be a C descriptor for a pointer to the same array with lower bound 0.
     CFI_index_t lower_bounds[1];
     int ind;
     lower_bounds[0] = 0;
     ind = CFI_setpointer(ptr, ptr, lower_bounds);
<b>18.6</b> <b>Restrictions</b> <b>on</b> <b>C</b> <b>descriptors</b>
A C descriptor shall not be initialized, updated, or copied other than by calling the functions specified in 18.5.5.
If the address of a C descriptor is a formal parameter that corresponds to a Fortran actual argument or a C
actual argument that corresponds to a Fortran dummy argument,
 the C descriptor shall not be modified if either the corresponding dummy argument in the Fortran interface
  has the INTENT (IN) attribute or the C descriptor is for a nonallocatable nonpointer object, and
 thebase_addrmemberoftheCdescriptorshallnotbeaccessedbeforeitisgivenavalueifthecorresponding
  dummy argument in the Fortran interface has the POINTER and INTENT (OUT) attributes.
<b>NOTE</b>
In this context, modification refers to any change to the location or contents of the C descriptor, including
establishment and update. The intent of these restrictions is that C descriptors remain intact at all times they
are accessible to an active Fortran procedure, so that the Fortran code is not required to copy them.
If the address of a C descriptor is a C actual argument that corresponds to an assumed-shape Fortran dummy
argument, that descriptor shall not be for an assumed-size array.
<b>18.7</b> <b>Restrictions</b> <b>on</b> <b>formal</b> <b>parameters</b>
Within a C function, an allocatable object shall be allocated or deallocated only by execution of the CFI_-
allocate and CFI_deallocate functions. A Fortran pointer can become associated with a target by execution of
the CFI_allocate function.
Calling CFI_allocate or CFI_deallocate for a C descriptor changes the allocation status of the Fortran variable
it describes.
If the address of an object is the value of a formal parameter that corresponds to a nonpointer dummy argument
in an interface with the BIND attribute, then
 ifthedummyargumenthastheINTENT(IN)attribute, theobjectshallnotbedefinedorbecomeundefined,
  and
 if the dummy argument has the INTENT (OUT) attribute, the object shall not be referenced before it is
  defined.
If a formal parameter that is a pointer to CFI_cdesc_t corresponds to a dummy argument in an interoperable
procedure interface, a pointer based on the base_addr in that C descriptor shall not be used to access memory
that is not part of the object described by the C descriptor.
<b>18.8</b> <b>Restrictions</b> <b>on</b> <b>lifetimes</b>
A C descriptor of, or C pointer to, any part of a Fortran object becomes undefined under the same conditions
that the association status of a Fortran pointer associated with that object would become undefined, and any
further use of it is undefined behavior (ISO/IEC 9899:2018, 3.4.3).
A C descriptor whose address is a formal parameter that corresponds to a Fortran dummy argument becomes
undefined on return from a call to the function from Fortran. If the dummy argument does not have either the
TARGET or ASYNCHRONOUS attribute, all C pointers to any part of the object described by the C descriptor
become undefined on return from the call, and any further use of them is undefined behavior.
If the address of a C descriptor is passed as an actual argument to a Fortran procedure, the lifetime (ISO/IEC
9899:2018, 6.2.4) of the C descriptor shall not end before the return from the procedure call. If an object is passed
to a Fortran procedure as a nonallocatable, nonpointer dummy argument, its lifetime shall not end before the
return from the procedure call.
If the lifetime of a C descriptor for an allocatable object that was established by C ends before the program exits,
the object shall be unallocated at that time.
If a Fortran pointer becomes associated with a data object defined by the companion processor, the association
status of the Fortran pointer becomes undefined when the lifetime of that data object ends.
<b>NOTE</b>
The following example illustrates how a C descriptor becomes undefined upon returning from a call to a C
function.
   REAL, TARGET :: X(1000), B
   INTERFACE
     REAL FUNCTION CFUN(ARRAY) BIND(C, NAME="Cfun")
      REAL ARRAY(:)
     END FUNCTION
   END INTERFACE
   B = CFUN(X)
Cfun is a C function. Before or during the invocation of Cfun, the processor will create a C descriptor for
the array x. On return from Cfun, that C descriptor will become undefined. In addition, because the dummy
argument ARRAY does not have the TARGET or ASYNCHRONOUS attribute, a C pointer whose value was
set during execution of Cfun to be the address of any part of X will become undefined.
<b>18.9</b> <b>Interoperation</b> <b>with</b> <b>C</b> <b>global</b> <b>variables</b>
<b>18.9.1</b> <b>General</b>
A C variable whose name has external linkage may interoperate with a common block or with a variable declared in
the scope of a module. The common block or variable shall be specified to have the BIND attribute.
At most one variable that is associated with a particular C variable whose name has external linkage is permitted
to be declared within all the Fortran program units of a program. A variable shall not be initially defined by
more than one processor.
If a common block is specified in a BIND statement, it shall be specified in a BIND statement with the same binding label in each
scoping unit in which it is declared. A C variable whose name has external linkage interoperates with a common block that has been
specified in a BIND statement if
  the C variable is of a structure type and the variables that are members of the common block are interoperable with corres-
  ponding components of the structure type, or
  the common block contains a single variable, and the variable is interoperable with the C variable.
There does not have to be an associated C entity for a Fortran entity with the BIND attribute.
<b>NOTE</b>
The following are examples of the usage of the BIND attribute for variables and for a common block. The Fortran
variables, C_EXTERN and C2, interoperate with the C variables, c_extern and myVariable, respectively. The
Fortran common blocks, COM and SINGLE, interoperate with the C variables, com and single, respectively.
   MODULE LINK_TO_C_VARS
    USE, INTRINSIC :: ISO_C_BINDING
    INTEGER(C_INT), BIND(C) :: C_EXTERN
                <b>J3/23-007r1</b> <b>529</b>
<b>NOTE</b> <b>(cont.)</b>
    INTEGER(C_LONG) :: C2
    BIND(C, NAME='myVariable') :: C2
      COMMON /COM/ R, S
    REAL(C_FLOAT) :: R, S, T
      BIND(C) :: /COM/, /SINGLE/
    COMMON /SINGLE/ T
   END MODULE LINK_TO_C_VARS
   /* Global variables. */
   int c_extern;
   long myVariable;
    struct { float r, s; } com;
   float single;
<b>18.9.2</b> <b>Binding</b> <b>labels</b> <b>for</b> <b>common</b> <b>blocks</b> <b>and</b> <b>variables</b>
The binding label of a variable or common block is a default character value that specifies the name by which the
variable or common block is known to the companion processor.
If a variable or common block has the BIND attribute with the NAME= specifier and the value of its expression,
after discarding leading and trailing blanks, has nonzero length, the variable or common block has this as its binding
label. The case of letters in the binding label is significant. If a variable or common block has the BIND attribute
specified without a NAME= specifier, the binding label is the same as the name of the entity using lower case
letters. Otherwise, the variable or common block has no binding label.
The binding label of a C variable whose name has external linkage is the same as the name of the C variable. A
Fortran variable or common block with the BIND attribute that has the same binding label as a C variable whose
name has external linkage is linkage associated (19.5.1.5) with that variable.
<b>18.10</b> <b>Interoperation</b> <b>with</b> <b>C</b> <b>functions</b>
<b>18.10.1</b> <b>Definition</b> <b>and</b> <b>reference</b> <b>of</b> <b>interoperable</b> <b>procedures</b>
A procedure that is interoperable may be defined either by means other than Fortran or by means of a Fortran
subprogram, but not both. A C function that has an inline definition and no external definition is not considered
to be defined in this sense.
If the procedure is defined by means other than Fortran,
 it shall be describable by a C prototype that is interoperable with the interface, and
 if it is accessed using its binding label, it shall
   <b>-</b> have a name that has external linkage as defined by ISO/IEC 9899:2018, 6.2.2, and
   <b>-</b> have the same binding label as the interface.
A reference to such a procedure causes the function described by the C prototype to be called as specified in
ISO/IEC 9899:2018.
A reference in C to a procedure that has the BIND attribute, has the same binding label, and is defined by means
of Fortran, causes the Fortran procedure to be invoked. A C function shall not invoke a function pointer whose
value is the result of a reference to C_FUNLOC with a noninteroperable argument.
A procedure defined by means of Fortran shall not invoke setjmp or longjmp (ISO/IEC 9899:2018, 7.13). If a
procedure defined by means other than Fortran invokes setjmp or longjmp, that procedure shall not cause any
procedure defined by means of Fortran to be invoked. A procedure defined by means of Fortran shall not be
invoked as a signal handler (ISO/IEC 9899:2018, 7.14.1).
If a procedure defined by means of Fortran and a procedure defined by means other than Fortran perform
input/output operations on the same external file, the results are processor dependent (12.5.4).
If the value of a C function pointer will be the result of a reference to C_FUNLOC with a noninteroperable
argument, it is recommended that the C function pointer be declared to have the type void (*)().
<b>18.10.2</b> <b>Binding</b> <b>labels</b> <b>for</b> <b>procedures</b>
The binding label of a procedure is a default character value that specifies the name by which a procedure with
the BIND attribute is known to the companion processor.
If a procedure has the BIND attribute with the NAME= specifier and the value of its expression, after discarding
leading and trailing blanks, has nonzero length, the procedure has this as its binding label. The case of letters
in the binding label is significant. If a procedure has the BIND attribute with no NAME= specifier, and the
procedure is not a dummy procedure, internal procedure, or procedure pointer, then the binding label of the
procedure is the same as the name of the procedure using lower case letters. Otherwise, the procedure has no
binding label.
C1807 A procedure defined in a submodule shall not have a binding label unless its interface is declared in the
   ancestor module.
The binding label for a C function whose name has external linkage is the same as the C function name.
<b>NOTE</b>
In the following sample, the binding label of C_SUB is c_sub, and the binding label of C_FUNC is C_funC.
   SUBROUTINE C_SUB() BIND(C)
     ...
   END SUBROUTINE C_SUB
   INTEGER(C_INT) FUNCTION C_FUNC() BIND(C, NAME="C_funC")
    USE, INTRINSIC :: ISO_C_BINDING
     ...
   END FUNCTION C_FUNC
ISO/IEC 9899:2018 permits functions to have names that are not permitted as Fortran names; it also distin-
guishes between names that would be considered as the same name in Fortran. For example, a C name can
begin with an underscore, and C names that differ in case are distinct names.
The specification of a binding label allows a program to use a Fortran name to refer to a procedure defined by
a companion processor.
<b>18.10.3</b> <b>Exceptions</b> <b>and</b> <b>IEEE</b> <b>arithmetic</b> <b>procedures</b>
A procedure defined by means other than Fortran shall not use signal (ISO/IEC 9899:2018, 7.14.1) to change the
handling of any exception that is being handled by the Fortran processor.
A procedure defined by means other than Fortran shall not alter the floating-point status (17.7) other than by
setting an exception flag to signaling.
The values of the floating-point exception flags on entry to a procedure defined by means other than Fortran are
processor dependent.
<b>18.10.4</b> <b>Asynchronous</b> <b>communication</b>
Asynchronous communication for a Fortran variable with the ASYNCHRONOUS attribute occurs through the
action of procedures defined by means other than Fortran. It is initiated by execution of an asynchronous
communication initiation procedure and completed by execution of an asynchronous communication completion
procedure. Between the execution of the initiation and completion procedures, any variable of which any part
is associated with any part of the asynchronous communication variable is a pending communication affector.
Whether a procedure is an asynchronous communication initiation or completion procedure is processor depend-
ent.
Asynchronouscommunicationiseitherinputcommunicationoroutputcommunication. Forinputcommunication,
a pending communication affector shall not be referenced, become defined, become undefined, become associated
with a dummy argument that has the VALUE attribute, or have its pointer association status changed. For
output communication, a pending communication affector shall not be redefined, become undefined, or have its
pointer association status changed. The restrictions for asynchronous input communication are the same as for
asynchronous input data transfer. The restrictions for asynchronous output communication are the same as for
asynchronous output data transfer.
<b>NOTE</b>
Asynchronous communication can be used for nonblocking MPI calls such as MPI_IRECV and MPI_ISEND.
For example,
   REAL :: BUF(100, 100)
    ... <i>Code</i> <i>that</i> <i>involves</i> <i>BUF.</i>
   BLOCK
    ASYNCHRONOUS :: BUF
    CALL MPI_IRECV(BUF,... REQ, ...)
     ... <i>Code</i> <i>that</i> <i>does</i> <i>not</i> <i>involve</i> <i>BUF.</i>
    CALL MPI_WAIT(REQ, ...)
   END BLOCK
    ... <i>Code</i> <i>that</i> <i>involves</i> <i>BUF.</i>
In this example, there is asynchronous input communication and BUF is a pending communication affector
between the two calls. MPI_IRECV can return while the communication (reading values into BUF) is still
underway. The intent is that the code between MPI_IRECV and MPI_WAIT can execute without waiting for
this communication to complete.
Similar code with the call of MPI_IRECV replaced by a call of MPI_ISEND is asynchronous output commu-
nication.
<b>19</b> <b>Scope,</b> <b>association,</b> <b>and</b> <b>definition</b>
<b>19.1</b> <b>Scopes,</b> <b>identifiers,</b> <b>and</b> <b>entities</b>
An entity is identified by an identifier.
The scope of
 a global identifier is a program (5.2.2),
 a local identifier is an inclusive scope,
 an identifier of a construct entity is that construct (10.2.4, 11.1), and
 an identifier of a statement entity is that statement or part of that statement (6.3),
excluding any nested scope where the identifier is treated as the identifier of a different entity (19.3, 19.4), or
where an IMPORT statement (8.8) makes the identifier inaccessible.
An entity may be identified by
 an image index (3.81),
 a name (3.100),
 a statement label (3.132),
 an external input/output unit number (12.5),
 an identifier of a pending data transfer operation (12.6.2.9, 12.7),
 a submodule identifier (14.2.3),
 a generic identifier (3.75), or
 a binding label (3.15).
By means of association, an entity may be referred to by the same identifier or a different identifier in a different
scope, or by a different identifier in the same scope.
<b>19.2</b> <b>Global</b> <b>identifiers</b>
Program units, common blocks, external procedures, entities with binding labels, external input/output units,
pending data transfer operations, and images are global entities of a program. The name of a common block with
no binding label, external procedure with no binding label, or program unit that is not a submodule is a global
identifier. The submodule identifier of a submodule is a global identifier. A binding label of an entity of the
program is a global identifier. An entity of the program shall not be identified by more than one binding label.
The global identifier of an entity shall not be the same as the global identifier of any other entity. Furthermore, a
binding label shall not be the same as the global identifier of any other global entity, ignoring differences in case.
A processor may assign a global identifier to an entity that is not specified by this document to have a global
identifier (such as an intrinsic procedure); in such a case, the processor shall ensure that this assigned global
identifier differs from all other global identifiers in the program.
<b>NOTE</b> <b>1</b>
An intrinsic module is not a program unit, so a global identifier can be the same as the name of an intrinsic
module.
<b>NOTE</b> <b>2</b>
Submodule identifiers are global identifiers, but because they consist of a module name and a descendant
submodule name, the name of a submodule can be the same as the name of another submodule so long as they
do not have the same ancestor module.
<b>19.3</b> <b>Local</b> <b>identifiers</b>
<b>19.3.1</b> <b>Classes</b> <b>of</b> <b>local</b> <b>identifiers</b>
Identifiers of entities, other than statement or construct entities (19.4), in the classes
  (1) named variables, named constants, named procedure pointers, named constructs, statement functions,
     internalprocedures,moduleprocedures,dummyprocedures,intrinsicprocedures,externalprocedures
     that have binding labels, intrinsic modules, abstract interfaces, generic interfaces, nonintrinsic types,
     namelist groups, external procedures accessed via USE, and statement labels,
  (2) type parameters, components, and type-bound procedure bindings, in a separate class for each type,
  (3) argument keywords, in a separate class for each procedure with an explicit interface, and
  (4) common blocks that have binding labels
are local identifiers.
Within its scope, a local identifier of an entity of class (1) or class (4) shall not be the same as a global identifier
used in that scope unless the global identifier
 is used only as the <i>use-name</i> of a <i>rename</i> in a USE statement,
 is a common block name (19.3.2),
 is an external procedure name that is also a generic name, or
 is an external function name and the inclusive scope is its defining subprogram (19.3.3).
Within its scope, a local identifier of one class shall not be the same as another local identifier of the same class,
except that a generic name may be the same as the name of a procedure as explained in 15.4.3.4 or the same as
the name of a derived type (7.5.10). A local identifier of one class may be the same as a local identifier of another
class.
<b>NOTE</b>
An intrinsic procedure is inaccessible by its own name in a scoping unit that uses the same name as a local
identifier of class (1) for a different entity. For example, in the program fragment
   SUBROUTINE SUB
     ...
     A = SIN (K)
     ...
   CONTAINS
     FUNCTION SIN (X)
       ...
     END FUNCTION SIN
   END SUBROUTINE SUB
any reference to function SIN in subroutine SUB refers to the internal function SIN, not to the intrinsic function
of the same name.
A local identifier identifies an entity in a scope and may be used to identify an entity in another scope except in
the following cases.
 The name that appears as a <i>subroutine-name</i> in a <i>subroutine-stmt</i> has limited use within the scope estab-
  lished by the <i>subroutine-stmt</i>. It can be used to identify recursive references of the subroutine or to identify
  a common block (the latter is possible only for internal and module subroutines).
 The name that appears as a <i>function-name</i> in a <i>function-stmt</i> has limited use within the scope established
  by that <i>function-stmt</i>. It can be used to identify the function result, to identify recursive references of the
  function, or to identify a common block (the latter is possible only for internal and module functions).
 The name that appears as an <i>entry-name</i> in an <i>entry-stmt</i> has limited use within the scope of the subprogram in which
  the <i>entry-stmt</i> appears. It can be used to identify the function result if the subprogram is a function, to identify recursive
  references, or to identify a common block (the latter is possible only if the <i>entry-stmt</i> is in a module subprogram).
<b>19.3.2</b> <b>Local</b> <b>identifiers</b> <b>that</b> <b>are</b> <b>the</b> <b>same</b> <b>as</b> <b>common</b> <b>block</b> <b>names</b>
A name that identifies a common block in a scoping unit shall not be used to identify a constant or an intrinsic procedure in that
scoping unit. If a local identifier of class (1) is also the name of a common block, the appearance of that name in any context other
than as a common block name in a BIND, COMMON, or SAVE statement is an appearance of the local identifier.
<b>19.3.3</b> <b>Function</b> <b>results</b>
For each FUNCTION statement or ENTRY statement in a function subprogram, there is a function result. A function
result is either a variable or a procedure pointer, and thus the name of a function result is a local identifier of
class (1).
<b>19.3.4</b> <b>Components,</b> <b>type</b> <b>parameters,</b> <b>and</b> <b>bindings</b>
A component name has the scope of its derived-type definition. Outside the type definition, it can also appear
within a designator of a component of a structure of that type or as a component keyword in a structure
constructor for that type.
A type parameter name has the scope of its derived-type definition. Outside the derived-type definition, it can
also appear as a type parameter keyword in a <i>derived-type-spec</i> for the type or as the <i>type-param-name</i> of a
<i>type-param-inquiry</i>.
The binding name (7.5.5) of a type-bound procedure has the scope of its derived-type definition. Outside of the
derived-type definition, it can also appear as the <i>binding-name</i> in a procedure reference.
A generic binding for which the <i>generic-spec</i> is not a <i>generic-name</i> has a scope that consists of all scoping units
in which an entity of the type is accessible.
A component name or binding name can appear only in a scope in which it is accessible.
The accessibility of components and bindings is specified in 7.5.4.8 and 7.5.5.
<b>19.3.5</b> <b>Argument</b> <b>keywords</b>
As an argument keyword, a dummy argument name in an internal procedure, module procedure, or an interface
body has a scope of the scoping unit of the host of the procedure or interface body. As an argument keyword,
the name of a dummy argument of a procedure declared by a procedure declaration statement that specifies an
explicit interface has a scope of the scoping unit containing the procedure declaration statement. It may appear
only in a procedure reference for the procedure of which it is a dummy argument. If the procedure is accessible
in another scoping unit by use or host association (19.5.1.3, 19.5.1.4), the argument keyword is accessible for
procedure references for that procedure in that scoping unit.
A dummy argument name in an intrinsic procedure has a scope as an argument keyword of the scoping unit
in which the reference to the procedure occurs. As an argument keyword, it may appear only in a procedure
reference for the procedure of which it is a dummy argument.
<b>19.4</b> <b>Statement</b> <b>and</b> <b>construct</b> <b>entities</b>
A variable that appears as a <i>data-i-do-variable</i> in a DATA statement or an <i>ac-do-variable</i> in an array constructor,
as a dummy argument in a statement function statement, or as an <i>index-name</i> in a FORALL statement is a statement entity.
Even if the name of a statement entity is the same as another identifier and the statement is in the scope of that
identifier, within the scope of the statement entity the name is interpreted as that of the statement entity.
The name of a statement entity shall not be the same as an accessible global identifier or local identifier of class
(1) (19.3.1), except for a common block name or a scalar variable name. Within the scope of a statement entity,
another statement entity shall not have the same name.
A variable that appears as an <i>index-name</i> in a FORALL or DO CONCURRENT construct, as an <i>associate-name</i>
in an ASSOCIATE, SELECT RANK, SELECT TYPE construct, or as a <i>coarray-name</i> in a <i>codimension-decl</i> in
a CHANGE TEAM construct is a construct entity. A variable that has LOCAL or LOCAL_INIT locality in a
DO CONCURRENT construct is a construct entity. An entity that is declared in a specification in a BLOCK
construct, other than only in ASYNCHRONOUS, IMPORT, and VOLATILE statements, is a construct entity.
A USE statement in a BLOCK construct specifies that all the entities it accesses by use association are construct
entities. If an entity is a construct entity instead of a host entity only because it is wholly or partially initialized
in a DATA statement, the construct entity shall not be used prior to the DATA statement.
Two construct entities of the same construct shall not have the same identifier.
The name of a <i>data-i-do-variable</i> in a DATA statement or an <i>ac-do-variable</i> in an array constructor has a scope
of its <i>data-implied-do</i> or <i>ac-implied-do</i>. It is a scalar variable. If <i>integer-type-spec</i> appears in <i>data-implied-do</i> or
<i>ac-implied-do-control</i> it has the specified type and type parameters; otherwise it has the type and type parameters
that it would have if it were the name of a variable in the innermost executable construct or scoping unit that
includes the DATA statement or array constructor, and this type shall be integer type. It has no other attributes.
The appearance of a name as a <i>data-i-do-variable</i> of an implied DO in a DATA statement or an <i>ac-do-variable</i>
in an array constructor is not an implicit declaration of a variable whose scope is the scoping unit that contains
the statement.
The name of a variable that appears as an <i>index-name</i> in a DO CONCURRENT construct, FORALL statement, or
FORALL construct has a scope of the statement or construct. It is a scalar variable. If <i>integer-type-spec</i> appears in
<i>concurrent-header</i> it has the specified type and type parameters; otherwise it has the type and type parameters
that it would have if it were the name of a variable in the innermost executable construct or scoping unit that
includes the DO CONCURRENT or FORALL, and this type shall be integer type. It has no other attributes.
The appearance of a name as an <i>index-name</i> in a DO CONCURRENT construct, FORALL statement, or FORALL
construct is not an implicit declaration of a variable whose scope is the scoping unit that contains the statement or
construct.
A variable that has LOCAL or LOCAL_INIT locality in a DO CONCURRENT construct has the scope of that
construct. Its attributes are specified in 11.1.7.5.
If <i>integer-type-spec</i> does not appear in a <i>concurrent-header</i>, an <i>index-name</i> shall not be the same as an accessible
global identifier, local identifier, or identifier of an outer construct entity, except for a common block name or
a scalar variable name. An <i>index-name</i> of a contained DO CONCURRENT construct, FORALL statement, or
FORALL construct shall not be the same as an <i>index-name</i> of any of its containing DO CONCURRENT or FORALL
constructs.
The associate names of an ASSOCIATE construct have the scope of the block. They have the declared type,
dynamic type, type parameters, rank, and bounds specified in 11.1.3.2.
The associate names of a CHANGE TEAM construct have the scope of the block. They have the declared type,
dynamic type, type parameters, rank, corank, bounds, and cobounds specified in 11.1.5.
The associate name of a SELECT RANK construct has a separate scope for each block of the construct. It has
the attributes specified in 11.1.10.3.
The associate name of a SELECT TYPE construct has a separate scope for each block of the construct. Within
each block, it has the declared type, dynamic type, type parameters, rank, and bounds specified in 11.1.11.2.
The name of a variable that appears as a dummy argument in a statement function statement has a scope of the statement in which
it appears. It is a scalar that has the type and type parameters that it would have if it were the name of a variable in the scoping
unit that includes the statement function; it has no other attributes.
<b>19.5</b> <b>Association</b>
<b>19.5.1</b> <b>Name</b> <b>association</b>
<b>19.5.1.1</b> <b>Forms</b> <b>of</b> <b>name</b> <b>association</b>
There are five forms of name association: argument association, use association, host association, linkage asso-
ciation, and construct association. Argument, use, and host association provide mechanisms by which entities
known in one scope may be accessed in another scope.
<b>19.5.1.2</b> <b>Argument</b> <b>association</b>
The rules governing argument association are given in Clause 15. As explained in 15.5, execution of a procedure
reference establishes a correspondence between each actual argument and a dummy argument and thus an associ-
ation between each present dummy argument and its effective argument. Argument association can be sequence
association (15.5.2.12).
The name of the dummy argument may be different from the name, if any, of its effective argument. The dummy
argument name is the name by which the effective argument is known, and by which it may be accessed, in the
referenced procedure.
<b>NOTE</b>
An effective argument can be a nameless data entity, such as the result of evaluating an expression that is not
simply a variable or constant.
Upon termination of execution of a procedure reference, all argument associations established by that reference
are terminated. A dummy argument of that procedure can be associated with an entirely different effective
argument in a subsequent invocation of the procedure.
<b>19.5.1.3</b> <b>Use</b> <b>association</b>
Use association is the association of names in different scopes specified by a USE statement. The rules governing
use association are given in 14.2.2. They allow for renaming of entities being accessed. Use association allows
access in one scope to entities defined or declared in another scope; it remains in effect throughout the execution
of the program.
<b>19.5.1.4</b> <b>Host</b> <b>association</b>
A derived-type definition, interface body, internal subprogram, module subprogram, or submodule has access
to entities from its host as specified in 8.8. A host-associated variable is considered to have been previously
declared; any other host-associated entity is considered to have been previously defined. In the case of an internal
subprogram, the access is to the entities in its host instance. The accessed entities are identified by the same
identifier and have the same attributes as in the host, except that a local entity may have the ASYNCHRONOUS
attribute even if the host entity does not, and a noncoarray local entity may have the VOLATILE attribute even
if the host entity does not. The accessed entities are named data objects, nonintrinsic types, abstract interfaces,
procedures, generic identifiers, and namelist groups.
If an entity that is accessed by use association has the same nongeneric name as a host entity, the host entity is
inaccessible by that name. The name of an external procedure that is given the EXTERNAL attribute (8.5.9)
within the scoping unit, or a name that appears within the scoping unit as a <i>module-name</i> in a <i>use-stmt</i> is a
global identifier; any entity of the host that has this as its nongeneric name is inaccessible by that name. A name
that appears in the scoping unit as
  (1) a <i>function-name</i> in a <i>stmt-function-stmt</i> or in an <i>entity-decl</i> in a <i>type-declaration-stmt</i>, unless it is a
     global identifier,
  (2) an <i>object-name</i> in an <i>entity-decl</i> in a <i>type-declaration-stmt</i>, in a <i>pointer-stmt</i>, in a <i>save-stmt</i>, in an
     <i>allocatable-stmt</i>, or in a <i>target-stmt</i>,
  (3) a <i>type-param-name</i> in a <i>derived-type-stmt</i>,
  (4) a <i>named-constant</i> in a <i>named-constant-def</i> in a <i>parameter-stmt</i>,
  (5) a <i>coarray-name</i> in a <i>codimension-stmt</i>,
  (6) an <i>array-name</i> in a <i>dimension-stmt</i>,
  (7) a <i>variable-name</i> in a <i>common-block-object</i> in a <i>common-stmt</i>,
  (8) a procedure pointer given the EXTERNAL attribute in the scoping unit,
  (9) the name of a variable that is wholly or partially initialized in a <i>data-stmt</i>,
  (10) the name of an object that is wholly or partially equivalenced in an <i>equivalence-stmt</i>,
  (11) a <i>dummy-arg-name</i> in a <i>function-stmt</i>, in a <i>subroutine-stmt</i>, in an <i>entry-stmt</i>, or in a <i>stmt-function-stmt</i>,
  (12) a <i>result-name</i> in a <i>function-stmt</i> or in an <i>entry-stmt</i>,
  (13) the name of an entity declared by an interface body, unless it is a global identifier,
  (14) an <i>intrinsic-procedure-name</i> in an <i>intrinsic-stmt</i>,
  (15) a <i>namelist-group-name</i> in a <i>namelist-stmt</i>,
  (16) an <i>enum-type-name</i> in an <i>enum-def</i>,
  (17) an <i>enumeration-type-name</i> in an <i>enumeration-type-stmt</i>,
  (18) a <i>generic-name</i> in a <i>generic-spec</i> in an <i>interface-stmt</i>, or
  (19) the name of a named construct
is a local identifier in the scopingunit and any entity of the host that has this as its nongeneric name is inaccessible
by that name by host association. If a scoping unit is the host of a derived-type definition or a subprogram that
does not define a separate module procedure, the name of the derived type or of any procedure defined by the
subprogram is a local identifier in the scoping unit; any entity of the host that has this as its nongeneric name is
inaccessible by that name. Local identifiers of a subprogram are not accessible to its host.
<b>NOTE</b> <b>1</b>
A name that appears in an ASYNCHRONOUS or VOLATILE statement is not necessarily the name of a local
variable. In an internal or module procedure, if a variable that is accessible via host association is specified in an
ASYNCHRONOUS orVOLATILEstatement, that host variable is given the ASYNCHRONOUS or VOLATILE
attribute in the local scope.
If a host entity is inaccessible only because a local variable with the same name is wholly or partially initialized
in a DATA statement, the local variable shall not be referenced or defined prior to the DATA statement.
If a derived-type name of a host is inaccessible, data entities of that type or subobjects of such data entities still
can be accessible.
<b>NOTE</b> <b>2</b>
An interface body that is not a module procedure interface body accesses by host association only those entities
made accessible by IMPORT statements.
If an external or dummy procedure with an implicit interface is accessed via host association, then it shall have
the EXTERNAL attribute in the host scoping unit; if it is invoked as a function in the inner scoping unit, its type
and type parameters shall be established in the host scoping unit. The type and type parameters of a function
with the EXTERNAL attribute are established in a scoping unit if that scoping unit explicitly declares them,
invokes the function, accesses the function from a module, or accesses the function from its host where its type
and type parameters are established.
If an intrinsic procedure is accessed via host association, then it shall be established to be intrinsic in the host
scoping unit. An intrinsic procedure is established to be intrinsic in a scoping unit if that scoping unit explicitly
gives it the INTRINSIC attribute, invokes it as an intrinsic procedure, accesses it from a module, or accesses it
from its host where it is established to be intrinsic.
<b>NOTE</b> <b>3</b>
A host subprogram and an internal subprogram can contain the same and differing use-associated entities, as
illustrated in the following example.
   MODULE B; REAL BX, Q; INTEGER IX, JX; END MODULE B
   MODULE C; REAL CX; END MODULE C
   MODULE D; REAL DX, DY, DZ; END MODULE D
   MODULE E; REAL EX, EY, EZ; END MODULE E
   MODULE F; REAL FX; END MODULE F
   MODULE G; USE F; REAL GX; END MODULE G
   PROGRAM A
     USE B; USE C; USE D
     ...
   CONTAINS
     SUBROUTINE INNER_PROC (Q)
      USE C ! Not needed, but prevents CX from being declared locally.
                <b>J3/23-007r1</b> <b>539</b>
<b>NOTE</b> <b>3</b> <b>(cont.)</b>
      USE B, ONLY: BX ! Entities accessible are BX, and also IX and JX if
              ! no other IX or JX is accessible to INNER_PROC.
              ! Q is local to INNER_PROC, because it is a dummy argument.
      USE D, X => DX ! Entities accessible are DX, DY, and DZ
              ! X is local name for DX in INNER_PROC; if no other DX is
              ! accessible in INNER_PROC, X and DX denote the same entity
      USE E, ONLY: EX ! EX is accessible in INNER_PROC, not in program A.
              ! EY and EZ are not accessible in INNER_PROC or program A.
      USE G ! FX and GX are accessible in INNER_PROC.
       ...
     END SUBROUTINE INNER_PROC
   END PROGRAM A
Because program A contains the statement
   USE B
all of the entities in module B, except for Q, are accessible in INNER_PROC, even though INNER_PROC
contains the statement
   USE B, ONLY: BX
The USE statement with the ONLY option means that this particular statement brings in only the entity
named, not that this is the only variable from the module accessible in this scoping unit.
<b>NOTE</b> <b>4</b>
For more examples of host association, see C.14.2.
<b>19.5.1.5</b> <b>Linkage</b> <b>association</b>
Linkage association occurs between a module variable that has the BIND attribute and the C variable with which
it interoperates, or between a Fortran common block and the C variable with which it interoperates (18.9). Such association
remains in effect throughout the execution of the program.
<b>19.5.1.6</b> <b>Construct</b> <b>association</b>
Execution of a SELECT RANK or SELECT TYPE statement establishes an association between the selector and
the associate name of the construct. Execution of an ASSOCIATE or CHANGE TEAM statement establishes
an association between each selector and the corresponding associate name of the construct.
In an ASSOCIATE or SELECT TYPE construct, the following rules apply.
 If a selector is allocatable, it shall be allocated; the associate name is associated with the data object and
  does not have the ALLOCATABLE attribute.
 If a selector has the POINTER attribute, it shall be associated; the associate name is associated with the
  target of the pointer and does not have the POINTER attribute.
If the selector is a variable other than an array section having a vector subscript, the association is with the data
object specified by the selector; otherwise, the association is with the value of the selector expression, which is
evaluated prior to execution of the block.
Each associate name remains associated with the corresponding selector throughout the execution of the executed
block. Within the block, each selector is known by and may be accessed by the corresponding associate name.
On completion of execution of the construct, the association is terminated.
<b>NOTE</b>
The association between the associate name and a data object is established prior to execution of the block
and is not affected by subsequent changes to variables that were used in subscripts or substring ranges in the
<i>selector</i>.
<b>19.5.2</b> <b>Pointer</b> <b>association</b>
<b>19.5.2.1</b> <b>General</b>
Pointer association between a pointer and a target allows the target to be referenced by a reference to the pointer.
At different times during the execution of a program, a pointer may be undefined, associated with different targets
on its own image, or be disassociated. The definition status of an associated data pointer is that of its target.
If the pointer has deferred type parameters or shape, their values are assumed from the target. If the pointer is
polymorphic, its dynamic type is assumed from the dynamic type of the target.
<b>19.5.2.2</b> <b>Pointer</b> <b>association</b> <b>status</b>
A pointer has a pointer association status of associated, disassociated, or undefined. Its association status may
change during execution of a program. Unless a pointer is initialized (explicitly or by default), it has an initial
association status of undefined. A pointer may be initialized to have an association status of disassociated or
associated.
<b>NOTE</b>
A pointer from a module program unit might be accessible in a subprogram via use association. Such pointers
have a lifetime that is greater than targets that are declared in the subprogram, unless such targets are saved.
Therefore, if such a pointer is associated with a local target, there is the possibility that when a procedure
defined by the subprogram completes execution, the target will cease to exist, leaving the pointer "dangling".
This document considers such pointers to have an undefined association status. They are neither associated nor
disassociated. They cannot be used again in the program until their status has been reestablished. A processor
is not required to detect when a pointer target ceases to exist.
<b>19.5.2.3</b> <b>Events</b> <b>that</b> <b>cause</b> <b>pointers</b> <b>to</b> <b>become</b> <b>associated</b>
A pointer becomes associated when any of the following events occur.
  (1) The pointer is allocated (9.7.1) as the result of the successful execution of an ALLOCATE statement
     referencing the pointer.
  (2) Thepointerispointer-assignedtoatarget(10.2.2)thatisassociatedorisspecifiedwiththeTARGET
     attribute and, if allocatable, is allocated.
  (3) The pointer is a subobject of an object that is allocated by an ALLOCATE statement in which
     SOURCE= appears and the corresponding subobject of <i>source-expr</i> is associated.
  (4) The pointer is a dummy argument and its corresponding actual argument is not a pointer.
  (5) The pointer is a default-initialized subcomponent of an object, the corresponding initializer is not a
     reference to the intrinsic function NULL, and
     (a) a procedure is invoked with this object as an actual argument corresponding to a nonpointer
        nonallocatable dummy argument with INTENT (OUT),
     (b) a procedure with this object as an unsaved nonpointer nonallocatable local variable is invoked,
     (c) a BLOCK construct is entered and this object is an unsaved local nonpointer nonallocatable
        local variable of the BLOCK construct, or
     (d) this object is allocated other than by an ALLOCATE statement in which SOURCE= appears.
<b>19.5.2.4</b> <b>Events</b> <b>that</b> <b>cause</b> <b>pointers</b> <b>to</b> <b>become</b> <b>disassociated</b>
A pointer becomes disassociated when
  (1) the pointer is nullified (9.7.2),
  (2) the pointer is deallocated (9.7.3),
  (3) the pointer is pointer-assigned (10.2.2) to a disassociated pointer,
  (4) the pointer is a subobject of an object that is allocated by an ALLOCATE statement in which
     SOURCE= appears and the corresponding subobject of <i>source-expr</i> is disassociated, or
  (5) the pointer is a default-initialized subcomponent of an object, the corresponding initializer is a
     reference to the intrinsic function NULL, and
     (a) a procedure is invoked with this object as an actual argument corresponding to a nonpointer
        nonallocatable dummy argument with INTENT (OUT),
     (b) a procedure with this object as an unsaved nonpointer nonallocatable local variable is invoked,
     (c) a BLOCK construct is entered and this object is an unsaved local nonpointer nonallocatable
        local variable of the BLOCK construct, or
     (d) this object is allocated other than by an ALLOCATE statement in which SOURCE= appears.
<b>19.5.2.5</b> <b>Events</b> <b>that</b> <b>cause</b> <b>the</b> <b>association</b> <b>status</b> <b>of</b> <b>pointers</b> <b>to</b> <b>become</b> <b>undefined</b>
The association status of a pointer becomes undefined when
  (1) the pointer is pointer-assigned to a target that has an undefined association status,
  (2) the pointer is pointer-assigned to a target on a different image,
  (3) the target of the pointer is deallocated other than through the pointer,
  (4) the target of the pointer is a data object defined by the companion processor and the lifetime of that
     data object ends,
  (5) the allocation transfer procedure (16.9.147) is executed, the pointer is associated with the argument
     FROM, and the argument TO does not have the TARGET attribute,
  (6) completion of execution of an instance of a subprogram causes the pointer's target to become un-
     defined (item (3) of 19.6.6),
  (7) completion of execution of a BLOCK construct causes the pointer's target to become undefined (item
     (23) of 19.6.6),
  (8) execution of the host instance of a procedure pointer is completed,
  (9) execution of an instance of a subprogram completes and the pointer is declared or accessed in the
     subprogram that defines the procedure if the pointer
     (a) does not have the SAVE attribute,
     (b) is not in blank common,
     (c) is not in a named common block that is declared in any other scoping unit that is in execution,
     (d) is not accessed by host association, and
     (e) is not the result of a function declared to have the POINTER attribute,
  (10) executionofaninstanceofasubprogramcompletes, thepointerisassociatedwithadummyargument
     of the procedure, and
     (a) the effective argument does not have the TARGET attribute or is an array section with a
        vector subscript, or
     (b) the dummy argument has the VALUE attribute,
  (11) a BLOCK construct completes execution and the pointer is an unsaved construct entity of that
     BLOCK construct,
  (12) a DO CONCURRENT construct is terminated and the pointer's association status was changed in
     more than one iteration of the construct,
  (13) an iteration of a DO CONCURRENT construct completes and the pointer is associated with a
     variable of that construct that has LOCAL or LOCAL_INIT locality,
  (14) the pointer is a subcomponent of an object that is allocated and either
     (a) the pointer is not default-initialized and SOURCE= does not appear, or
     (b) SOURCE= appears and the association status of the corresponding subcomponent of <i>source-</i>
       <i>expr</i> is undefined,
  (15) the pointer is a subcomponent of an object, the pointer is not default-initialized, and a procedure is
     invoked with this object as an actual argument corresponding to a dummy argument with INTENT
     (OUT),
  (16) a procedure is invoked with the pointer as an actual argument corresponding to a pointer dummy
     argument with INTENT (OUT), or
  (17) evaluation of an expression containing a function reference that need not be evaluated completes, if
     execution of that function would change the association status of the pointer.
<b>19.5.2.6</b> <b>Other</b> <b>events</b> <b>that</b> <b>change</b> <b>the</b> <b>association</b> <b>status</b> <b>of</b> <b>pointers</b>
When a pointer becomes associated with another pointer by argument association, construct association, or host
association, the effects on its association status are specified in 19.5.5.
While two pointers are name associated, storage associated, or inheritance associated, if the association status of
one pointer changes, the association status of the other changes accordingly.
The association status of a pointer object with the VOLATILE attribute might change by means not specified
by the program.
<b>19.5.2.7</b> <b>Pointer</b> <b>definition</b> <b>status</b>
The definition status of an associated data pointer is that of its target. If a pointer is associated with a definable
target, it becomes defined or undefined according to the rules for a variable (19.6). The definition status of a
pointer that is not associated is undefined.
<b>19.5.3</b> <b>Storage</b> <b>association</b>
<b>19.5.3.1</b> <b>General</b>
Storage sequences are used to describe relationships that exist among variables and common blocks. Storage asso-
ciation is the association of two or more data objects that occurs when two or more storage sequences share or
are aligned with one or more storage units.
<b>19.5.3.2</b> <b>Storage</b> <b>sequence</b>
A storage sequence is a sequence of storage units. The size of a storage sequence is the number of storage units
in the storage sequence. A storage unit is a character storage unit, a numeric storage unit, a file storage unit
(12.3.5), or an unspecified storage unit. The sizes of the numeric storage unit, the character storage unit and the
file storage unit are the values of constants in the ISO_FORTRAN_ENV intrinsic module (16.10.2).
In a storage association context
  (1) a nonpointer scalar object that is default integer, default real, or default logical occupies a single
     numeric storage unit,
  (2) a nonpointer scalar object that is double precision real or default complex occupies two contiguous
     numeric storage units,
  (3) a default character nonpointer scalar object of character length <i>len</i> occupies <i>len</i> contiguous character
     storage units,
  (4) if C character kind is not the same as default character kind a nonpointer scalar object of type char-
     acter with the C character kind (18.2.2) and character length <i>len</i> occupies <i>len</i> contiguous unspecified
     storage units,
  (5) a nonpointer scalar object of sequence type occupies a sequence of storage sequences corresponding
     to the sequence of its ultimate components,
  (6) a nonpointer scalar object of any type not specified in items (1)-(5) occupies a single unspecified
     storage unit that is different for each case and each set of type parameter values, and that is different
     from the unspecified storage units of item (4),
  (7) a nonpointer array occupies a sequence of contiguous storage sequences, one for each array element,
     in array element order (9.5.3.3), and
  (8) a data pointer occupies a single unspecified storage unit that is different from that of any nonpointer
     object and is different for each combination of type, type parameters, and rank. A data pointer that
     has the CONTIGUOUS attribute occupies a storage unit that is different from that of a data pointer
     that does not have the CONTIGUOUS attribute.
A sequence of storage sequences forms a storage sequence. The order of the storage units in such a composite
storage sequence is that of the individual storage units in each of the constituent storage sequences taken in
succession, ignoring any zero-sized constituent sequences.
Each common block has a storage sequence (8.10.2.2).
<b>19.5.3.3</b> <b>Association</b> <b>of</b> <b>storage</b> <b>sequences</b>
Two nonzero-sized storage sequences <i>s</i>
                   1
                 and <i>s</i>
                       2
                    are storage associated if the <i>i</i>th storage unit of <i>s</i>
                                                1
                                          is the same as
the <i>j</i>th storage unit of <i>s</i>
            2
           . This causes the (<i>i</i> +<i>k</i>)th storage unit of <i>s</i>
                                   1
                               to be the same as the (<i>j</i> +<i>k</i>)th storage
unit of <i>s</i>
    2
    , for each integer <i>k</i> such that 1<i>i</i> +<i>k</i> <i>size</i> <i>of</i> <i>s</i>
                              1
                           and 1<i>j</i> +<i>k</i> <i>size</i> <i>of</i> <i>s</i>
                                            2
                                       where <i>size</i> <i>of</i> measures
the number of storage units.
Storage association also is defined between two zero-sized storage sequences, and between a zero-sized storage
sequence and a storage unit. A zero-sized storage sequence in a sequence of storage sequences is storage associated
with its successor, if any. If the successor is another zero-sized storage sequence, the two sequences are storage
associated. If the successor is a nonzero-sized storage sequence, the zero-sized sequence is storage associated with
the first storage unit of the successor. Two storage units that are each storage associated with the same zero-sized
storage sequence are the same storage unit.
<b>19.5.3.4</b> <b>Association</b> <b>of</b> <b>scalar</b> <b>data</b> <b>objects</b>
Two scalar data objects are storage associated if their storage sequences are storage associated. Two scalar entities
are totally associated if they have the same storage sequence. Two scalar entities are partially associated if they
are associated without being totally associated.
The definition status and value of a data object affects the definition status and value of any storage associated
entity. An EQUIVALENCE statement, a COMMON statement, or an ENTRY statement can cause storage association of storage
sequences.
An EQUIVALENCE statement causes storage association of data objects only within one scoping unit, unless one of the equivalenced
entities is also in a common block (8.10.1.2, 8.10.2.2).
COMMON statements cause data objects in one scoping unit to become storage associated with data objects in another scoping unit.
A common block is permitted to contain a sequence of differing storage units. All scoping units that access named common blocks
with the same name shall specify an identical sequence of storage units. Blank common blocks may be declared with differing sizes
in different scoping units. For any two blank common blocks, the initial sequence of storage units of the longer blank common block
shall be identical to the sequence of storage units of the shorter common block. If two blank common blocks are the same length,
they shall have the same sequence of storage units.
An ENTRY statement in a function subprogram causes storage association of the function results that are variables.
Partial association shall exist only between
 an object that is default character or of character sequence type and an object that is default character or
  of character sequence type, or
 an object that is default complex, double precision real, or of numeric sequence type and an object that is
  default integer, default real, default logical, double precision real, default complex, or of numeric sequence
  type.
For noncharacter entities, partial association shall occur only through the use of COMMON, EQUIVALENCE, or ENTRY statements.
For character entities, partial association shall occur only through argument association or the use of COMMON or
EQUIVALENCE statements.
Partial association of character entities occurs when some, but not all, of the storage units of the entities are the
same.
A storage unit shall not be explicitly initialized more than once in a program. Explicit initialization overrides
default initialization, and default initialization for an object of derived type overrides default initialization for
a component of the object (7.5.4.6). Default initialization may be specified for a storage unit that is storage
associated provided the objects supplying the default initialization are of the same type and type parameters,
and supply the same value for the storage unit.
<b>19.5.4</b> <b>Inheritance</b> <b>association</b>
Inheritance association occurs between components of the parent component and components inherited by type
extension into an extended type (7.5.7.2). This association is persistent; it is not affected by the accessibility of
the inherited components.
<b>19.5.5</b> <b>Establishing</b> <b>associations</b>
When an association is established between two entities by argument association, host association, or construct
association, certain properties of the associating entity become those of the pre-existing entity.
For argument association, the pre-existing entity is the effective argument and the associating entity is the dummy
argument.
For host association, the associating entity is the entity in the contained scoping unit. When a procedure is
invoked, the pre-existing entity that participates in the association is the one from its host instance (15.6.2.4).
Otherwise the pre-existing entity that participates in the association is the entity in the host scoping unit.
For construct association, the associating entity is identified by the associate name and the pre-existing entity is
the selector.
When an association is established by argument association, host association, or construct association, the fol-
lowing applies.
 If the entities have the POINTER attribute, the pointer association status of the associating entity becomes
  the same as that of the pre-existing entity. If the pre-existing entity has a pointer association status of
  associated, the associating entity becomes pointer associated with the same target and, if they are arrays,
  the bounds of the associating entity become the same as those of the pre-existing entity.
 If the associating entity has the ALLOCATABLE attribute, its allocation status becomes the same as that
  of the pre-existing entity. If the pre-existing entity is allocated, the bounds (if it is an array), values of
  deferred type parameters, definition status, and value (if it is defined) become the same as those of the
  pre-existing entity. If the associating entity is polymorphic and the pre-existing entity is allocated, the
  dynamic type of the associating entity becomes the same as that of the pre-existing entity.
 If the associating entity is neither a pointer nor allocatable, its definition status, value (if it is defined), and
  dynamic type (if it is polymorphic) become the same as those of the pre-existing entity. If the entities are
  arrays and the association is not argument association, the bounds of the associating entity become the
  same as those of the pre-existing entity.
 If the associating entity is a pointer dummy argument and the pre-existing entity is a nonpointer actual
  argument the associating entity becomes pointer associated with the pre-existing entity and, if the entities
  are arrays, the bounds of the associating entity become the same as those of the pre-existing entity.
<b>19.6</b> <b>Definition</b> <b>and</b> <b>undefinition</b> <b>of</b> <b>variables</b>
<b>19.6.1</b> <b>Definition</b> <b>of</b> <b>objects</b> <b>and</b> <b>subobjects</b>
A variable may be defined or may be undefined and its definition status may change during execution of a
program. An action that causes a variable to become undefined does not imply that the variable was previously
defined. An action that causes a variable to become defined does not imply that the variable was previously
undefined.
Arrays, including sections, and variables of derived, character, or complex type are objects that consist of zero
or more subobjects. Associations may be established between variables and subobjects and between subobjects
of different variables. These subobjects may become defined or undefined.
An array is defined if and only if all of its elements are defined.
A derived-type scalar object is defined if and only if all of its nonpointer components are defined.
A complex or character scalar object is defined if and only if all of its subobjects are defined.
If an object is undefined, at least one (but not necessarily all) of its subobjects are undefined.
<b>19.6.2</b> <b>Variables</b> <b>that</b> <b>are</b> <b>always</b> <b>defined</b>
Zero-sized arrays and zero-length strings are always defined.
<b>19.6.3</b> <b>Variables</b> <b>that</b> <b>are</b> <b>initially</b> <b>defined</b>
The following variables are initially defined:
  (1) variables specified to have initial values by DATA statements;
  (2) variables specified to have initial values by type declaration statements;
  (3) nonpointer default-initialized subcomponents of saved variables that do not have the ALLOCAT-
     ABLE or POINTER attribute;
  (4) pointers specified to be initially associated with a variable that is initially defined;
  (5) variables that are always defined;
  (6) variables with the BIND attribute that are initialized by means other than Fortran.
<b>NOTE</b>
Fortran code:
   module mod
    integer, bind(c,name="blivet") :: foo
   end module mod
C code:
   int blivet = 123;
In the above example, the Fortran variable foo is initially defined to have the value 123 by means other than
Fortran.
<b>19.6.4</b> <b>Variables</b> <b>that</b> <b>are</b> <b>initially</b> <b>undefined</b>
Variables that are not initially defined are initially undefined.
<b>19.6.5</b> <b>Events</b> <b>that</b> <b>cause</b> <b>variables</b> <b>to</b> <b>become</b> <b>defined</b>
Variables become defined by the following events.
  (1) Execution of an intrinsic assignment statement other than a masked array assignment or FORALL
      assignment statement causes the variable that precedes the equals to become defined.
  (2) Execution of a masked array assignment or FORALL assignment statement might cause some or all of
     the array elements in the assignment statement to become defined (10.2.3).
  (3) As execution of an input statement proceeds, each variable that is assigned a value from the input
     file becomes defined at the time that data are transferred to it. (See (4) in 19.6.6.) Execution of a
     WRITE statement whose unit specifier identifies an internal file causes each record that is written
     to become defined.
  (4) Execution of a DO statement causes the DO variable, if any, to become defined.
  (5) Beginning of execution of the action specified by an <i>io-implied-do</i> in a synchronous data transfer
     statement causes the <i>do-variable</i> to become defined.
  (6) A reference to a procedure causes an entire dummy data object to become defined if the dummy data
     object does not have INTENT (OUT) and the entire effective argument is defined.
     A reference to a procedure causes a subobject of a dummy argument to become defined if the dummy
     argument does not have INTENT (OUT) and the corresponding subobject of the effective argument
     is defined.
  (7) Executionofaninput/outputstatementcontaininganIOSTAT=specifiercausesthespecifiedinteger
     variable to become defined.
  (8) Execution of a synchronous input statement containing a SIZE= specifier causes the specified integer
     variable to become defined.
  (9) Execution of a wait operation (12.7.1) corresponding to an asynchronous input statement containing
     a SIZE= specifier causes the specified integer variable to become defined.
  (10) ExecutionofanINQUIREstatement causesanyvariablethat is assigneda valueduring the execution
     of the statement to become defined if no error condition exists.
  (11) If an error, end-of-file, or end-of-record condition occurs during execution of an input/output state-
     ment that has an IOMSG= specifier, the <i>iomsg-variable</i> becomes defined.
  (12) Whenacharacterstorageunitbecomesdefined, allassociatedcharacterstorageunitsbecomedefined.
     When a numeric storage unit becomes defined, all associated numeric storage units of the same type
     become defined. When an entity of double precision real type becomes defined, all totally associated
     entities of double precision real type become defined.
     When an unspecified storage unit becomes defined, all associated unspecified storage units become
     defined.
  (13) When a default complex entity becomes defined, all partially associated default real entities become
     defined.
  (14) When both parts of a default complex entity become defined as a result of partially associated default
     real or default complex entities becoming defined, the default complex entity becomes defined.
  (15) When all components of a structure of a numeric sequence type or character sequence type become
     defined as a result of partially associated objects becoming defined, the structure becomes defined.
  (16) ExecutionofastatementwithaSTAT=specifier causes thevariablespecifiedby the STAT=specifier
     to become defined.
  (17) If an error condition occurs during execution of a statement that has an ERRMSG= specifier, the
     variable specified by the ERRMSG= specifier becomes defined.
  (18) Allocation of a zero-sized array or zero-length character variable causes the array or variable to
     become defined.
  (19) Allocation of an object that has a nonpointer default-initialized subcomponent, except by an AL-
     LOCATE statement with a SOURCE= specifier, causes that subcomponent to become defined.
  (20) Successful execution of an ALLOCATE statement with a SOURCE= specifier causes a subobject of
     the allocated object to become defined if the corresponding subobject of the SOURCE= expression
     is defined.
  (21) Invocation of a procedure causes any automatic data object of zero size or zero character length in
     that procedure to become defined.
  (22) When a pointer becomes associated with a target that is defined, the pointer becomes defined.
  (23) Invocation of a procedure that contains an unsaved nonpointer nonallocatable local variable causes
     all nonpointer default-initialized subcomponents of the object to become defined.
  (24) Invocation of a procedure that has a nonpointer nonallocatable INTENT (OUT) dummy argument
     causes all nonpointer default-initialized subcomponents of the dummy argument to become defined.
  (25) In a DO CONCURRENT or FORALL construct, the <i>index-name</i> becomes defined when the <i>index-</i>
     <i>name</i> value set is evaluated.
  (26) In a DO CONCURRENT construct, a variable with LOCAL_INIT locality becomes defined at the
     beginning of each iteration.
  (27) An object with the VOLATILE attribute that is changed by a means not specified by the program
     might become defined (see 8.5.20).
  (28) Execution of the BLOCK statement of a BLOCK construct that has an unsaved nonpointer non-
     allocatable local variable causes all nonpointer default-initialized subcomponents of the variable to
     become defined.
  (29) Execution of an OPEN statement containing a NEWUNIT= specifier causes the specified integer
     variable to become defined.
  (30) Execution of a LOCK statement containing an ACQUIRED_LOCK= specifier causes the specified
     logical variable to become defined. If the logical variable becomes defined with the value true, the
     lock variable in the LOCK statement also becomes defined.
  (31) Successful execution of a LOCK statement that does not contain an ACQUIRED_LOCK= specifier
     causes the lock variable to become defined.
  (32) Successful execution of an UNLOCK statement causes the lock variable to become defined.
  (33) Failure of an image that locked a lock variable without unlocking it causes the lock variable to become
     defined.
  (34) Successful execution of an EVENT POST or EVENT WAIT statement causes the event variable to
     become defined.
  (35) Successful execution of a FORM TEAM statement causes the team variable to become defined.
  (36) Execution of a FORM TEAM statement with a STAT= specifier that assigns the value STAT_-
     FAILED_IMAGE from the intrinsic module ISO_FORTRAN_ENV to its <i>stat-variable</i> causes the
     team variable to become defined.
  (37) Execution of a NOTIFY WAIT statement or an assignment statement with a NOTIFY= specifier
     causes the notify variable to become defined.
<b>19.6.6</b> <b>Events</b> <b>that</b> <b>cause</b> <b>variables</b> <b>to</b> <b>become</b> <b>undefined</b>
Variables become undefined by the following events.
  (1) Whenascalarvariableofintrinsictypebecomesdefined,alltotallyassociatedvariablesofdifferenttypebecomeundefined.
    Whenadoubleprecisionscalarvariablebecomesdefined, allpartiallyassociatedscalarvariablesbecome
    undefined. When a scalar variable becomes undefined, all partially associated double precision scalar
    variables become undefined.
  (2) If the evaluation of a function would cause a variable to become defined and if a reference to the
    function appears in an expression in which the value of the function is not needed to determine the
    value of the expression, the variable becomes undefined when the expression is evaluated.
  (3) When execution of an instance of a subprogram completes,
    (a) its unsaved local variables become undefined,
    (b) unsaved variables in a named common block that appears in the subprogram become undefined if they have been
        defined or redefined, unless another active scoping unit is referencing the common block, and
    (c) a variable of type C_PTR from the intrinsic module ISO_C_BINDING whose value is the C
       address of an unsaved local variable of the subprogram becomes undefined.
  (4) When an error condition or end-of-file condition occurs during execution of an input statement, all of
    the variables specified by the input list or namelist group of the statement become undefined.
  (5) Whenanerrorconditionoccursduring executionof an output statement in whichthe unit isaninternal
    file, the internal file becomes undefined.
  (6) When an error condition, end-of-file condition, or end-of-record condition occurs during execution of
    an input/output statement and the statement contains any <i>io-implied-do</i>s, all of the <i>do-variable</i>s in
    the statement become undefined (12.11).
  (7) Execution of a direct access input statement that specifies a record that has not been written previously
    causes all of the variables specified by the input list of the statement to become undefined.
  (8) Execution of an INQUIRE statement might cause the NAME=, RECL=, and NEXTREC= variables
    to become undefined (12.10).
  (9) When a character storage unit becomes undefined, all associated character storage units become un-
    defined.
    Whenanumericstorageunitbecomesundefined, allassociatednumericstorageunitsbecomeundefined
    unless the undefinition is a result of defining an associated numeric storage unit of different type (see
    (1) above).
    When an entity of double precision real type becomes undefined, all totally associated entities of double
    precision real type become undefined.
    When an unspecified storage unit becomes undefined, all associated unspecified storage units become
    undefined.
  (10) When an allocatable entity is deallocated, it becomes undefined.
  (11) When the allocation transfer procedure (16.9.147) causes the allocation status of an allocatable entity
    to become unallocated, the entity becomes undefined.
  (12) Successful execution of an ALLOCATE statement with no SOURCE= specifier causes a subcomponent
    of an allocated object to become undefined if default initialization has not been specified for that
    subcomponent.
  (13) Successful execution of an ALLOCATE statement with a SOURCE= specifier causes a subobject of
    the allocated object to become undefined if the corresponding subobject of the SOURCE= expression
    is undefined.
  (14) Execution of an INQUIRE statement causes all inquiry specifier variables to become undefined if an
    error condition exists, except for any variable in an IOSTAT= or IOMSG= specifier.
  (15) When a procedure is invoked
    (a) an optional dummy argument that has no corresponding actual argument becomes undefined,
    (b) a dummy argument with INTENT (OUT) becomes undefined except for any nonpointer default-
       initialized subcomponents of the argument,
    (c) an actual argument corresponding to a dummy argument with INTENT (OUT) becomes un-
       defined except for any nonpointer default-initialized subcomponents of the argument,
    (d) a subobject of a dummy argument that does not have INTENT (OUT) becomes undefined if the
       corresponding subobject of the effective argument is undefined, and
    (e) a variable that is the function result of that procedure becomes undefined except for any of its
       nonpointer default-initialized subcomponents.
  (16) When the association status of a pointer becomes undefined or disassociated (19.5.2.4, 19.5.2.5), the
    pointer becomes undefined.
  (17) When a DO CONCURRENT construct terminates, a variable that is defined or becomes undefined
    during more than one iteration of the construct becomes undefined.
  (18) When execution of an iteration of a DO CONCURRENT construct completes, a construct entity of
    that construct which has LOCAL or LOCAL_INIT locality becomes undefined.
  (19) Execution of an asynchronous READ statement causes all of the variables specified by the input list or
    SIZE= specifier to become undefined. Execution of an asynchronous namelist READ statement causes
    any variable in the namelist group to become undefined if that variable will subsequently be defined
    during the execution of the READ statement or the corresponding wait operation (12.7.1).
  (20) When a variable with the TARGET attribute is deallocated, a variable of type C_PTR from the
    intrinsic module ISO_C_BINDING becomes undefined if its value is the C address of any part of the
    variable that is deallocated.
  (21) When a pointer is deallocated, a variable of type C_PTR from the intrinsic module ISO_C_BINDING
    becomes undefined if its value is the C address of any part of the target that is deallocated.
  (22) Execution of the allocation transfer procedure (16.9.147) where the argument TO does not have the
    TARGET attribute causes a variable of type C_PTR from the intrinsic module ISO_C_BINDING to
    become undefined if its value is the C address of any part of the argument FROM.
  (23) When a BLOCK construct completes execution,
    its unsaved local variables become undefined, and
    a variable of type C_PTR from the intrinsic module ISO_C_BINDING, whose value is the C
       address of an unsaved local variable of the BLOCK construct, becomes undefined.
  (24) When execution of the host instance of the target of a variable of type C_FUNPTR from the intrinsic
    module ISO_C_BINDING is completed by execution of a RETURN or END statement, the variable
    becomes undefined.
  (25) Execution of an intrinsic assignment of the type C_PTR or C_FUNPTR from the intrinsic module
    ISO_C_BINDING, or of the type TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV,
    in which the variable and <i>expr</i> are not on the same image, causes the variable to become undefined.
  (26) An object with the VOLATILE attribute (8.5.20) might become undefined by means not specified by
    the program.
  (27) When a pointer becomes associated with a target that is undefined, the pointer becomes undefined.
  (28) When an image fails during execution of a segment, a data object on a nonfailed image becomes
    undefined if it is not a lock variable and it might become undefined by execution of a statement of
    the segment other than an invocation of an atomic subroutine with the object as an actual argument
    corresponding to the ATOM dummy argument.
  (29) Execution of a FORM TEAM statement with a STAT= specifier that assigns a nonzero value other
    than that of STAT_FAILED_IMAGE from the intrinsic module ISO_FORTRAN_ENV to the <i>stat-</i>
    <i>variable</i> causes the team variable to become undefined.
  (30) When the STAT argument in a reference to a collective subroutine is assigned a nonzero value, the A
    argument becomes undefined.
  (31) When an image which references a collective subroutine with a present RESULT_IMAGE argument
    is not the image identified by RESULT_IMAGE, the A argument on that image becomes undefined.
  (32) When an error condition occurs during execution of an atomic subroutine whose STAT argument is
    present, any other argument that is not INTENT (IN) becomes undefined.
<b>NOTE</b>
Execution of a defined assignment statement could leave all or part of the variable undefined.
<b>19.6.7</b> <b>Variable</b> <b>definition</b> <b>context</b>
Some variables are prohibited from appearing in a syntactic context that would imply definition or undefinition
of the variable (8.5.10, 8.5.15, 15.7). The following are the contexts in which the appearance of a variable implies
such definition or undefinition of the variable:
  (1) the <i>variable</i> of an <i>assignment-stmt</i>;
  (2) a <i>do-variable</i> in a <i>do-stmt</i> or <i>io-implied-do</i>;
  (3) an <i>input-item</i> in a <i>read-stmt</i>;
  (4) a <i>variable-name</i> in a <i>namelist-stmt</i> if the <i>namelist-group-name</i> appears in a NML= specifier in a
     <i>read-stmt</i>;
  (5) an <i>internal-file-variable</i> in a <i>write-stmt</i>;
  (6) a SIZE= or IOMSG= specifier in an input/output statement;
  (7) a specifier in an INQUIRE statement other than FILE=, ID=, and UNIT=;
  (8) a NEWUNIT= specifier in an OPEN statement;
  (9) an <i>allocate-object</i>, <i>errmsg-variable</i>, <i>notify-variable</i>, or <i>stat-variable</i>;
  (10) an actual argument in a reference to a procedure with an explicit interface if the corresponding
     dummy argument is not a pointer and has INTENT (OUT) or INTENT (INOUT);
  (11) a <i>variable</i> that is a <i>selector</i> in an ASSOCIATE, CHANGE TEAM, SELECT RANK, or SELECT
     TYPE construct if the corresponding associate name or any subobject thereof appears in a variable
     definition context;
  (12) an <i>event-variable</i> in an EVENT POST or EVENT WAIT statement;
  (13) a <i>lock-variable</i> in a LOCK or UNLOCK statement;
  (14) a <i>scalar-logical-variable</i> in an ACQUIRED_LOCK= specifier;
  (15) a <i>team-variable</i> in a FORM TEAM statement.
If a reference to a function appears in a variable definition context the result of the function reference shall be a
pointer that is associated with a definable target. That target is the variable that becomes defined or undefined.
<b>19.6.8</b> <b>Pointer</b> <b>association</b> <b>context</b>
Some pointers are prohibited from appearing in a syntactic context that would imply alteration of the pointer
association status (19.5.2.2, 8.5.10, 8.5.15, 15.7). The following are the contexts in which the appearance of a
pointer implies such alteration of its pointer association status:
 a <i>pointer-object</i> in a <i>nullify-stmt</i>;
 a <i>data-pointer-object</i> or <i>proc-pointer-object</i> in a <i>pointer-assignment-stmt</i>;
 an <i>allocate-object</i> in an <i>allocate-stmt</i> or <i>deallocate-stmt</i>;
 an actual argument in a reference to a procedure if the corresponding dummy argument is a pointer with
  the INTENT (OUT) or INTENT (INOUT) attribute.
           <b>Annex</b> <b>A</b>
                     (Informative)
       <b>Processor</b> <b>dependencies</b>
<b>A.1</b> <b>Unspecified</b> <b>items</b>
This document does not specify the following:
 the properties excluded in 1;
 a processor's error detection capabilities beyond those listed in 4.2;
 which additional intrinsic procedures or modules a processor provides (4.2);
 the number and kind of companion processors (5.5.7);
 the number of representation methods and associated kind type parameter values of the intrinsic types
  (7.4), except that there shall be at least two representation methods for type real, and a representation
  method of type complex that corresponds to each representation method for type real.
<b>A.2</b> <b>Processor</b> <b>dependencies</b>
According to this document, the following are processor dependent:
 the order of evaluation of the specification expressions within the specification part of an invoked Fortran
  procedure (5.3.5);
 how soon an image terminates if another image initiates error termination (5.3.5);
 the value of a reference to a coindexed object on a failed image (5.3.6);
 the conditions that cause an image to fail (5.3.6);
 whether the processor has the ability to detect that an image has failed (5.3.6);
 whether the processor supports a concept of process exit status, and if so, the process exit status on program
  termination (5.3.7);
 themechanismofacompanionprocessor, andthemeansofselectingbetweenmultiplecompanionprocessors
  (5.5.7);
 the processor character set (6.1);
 the maximum number of unique statement labels in a program unit (6.2.5);
 the means for specifying the source form of a program unit (6.3);
 in fixed source form, the maximum number of characters allowed on a source line containing characters not
  of default kind (6.3.3);
 the maximum depth of nesting of include lines (6.4);
 the interpretation of the <i>char-literal-constant</i> in the include line (6.4);
 the set of values supported by an intrinsic type, other than logical (7.1.3);
 the kind type parameter value of a complex literal constant, if both the real part and imaginary part are of
  type real with the same precision, but have different kind type parameter values (7.4.3.3);
 the kind of a character length type parameter (7.4.4.1);
 the blank padding character for nondefault character kind (7.4.4.2)
 whether particular control characters can appear within a character literal constant in fixed source form
  (7.4.4.3);
 the collating sequence for each character set (7.4.4.4);
 the order of finalization of components of objects of derived type (7.5.6.2);
 the order of finalization when several objects are finalized as the consequence of a single event (7.5.6.2);
 whether and when an object is finalized if it is allocated by pointer allocation and it later becomes un-
  reachable due to all pointers associated with the object having their pointer association status changed
  (7.5.6.3);
 whether an object is finalized by a deallocation in which an error condition occurs (7.5.6.3);
 the kind type parameter of the enumerators of an interoperable enumeration (7.6.1);
 whether an array is contiguous, except as specified in 8.5.7;
 the set of error conditions that can occur in ALLOCATE and DEALLOCATE statements (9.7.1, 9.7.3);
 the allocation status of a variable after evaluation of an expression if the evaluation of a function would
  change the allocation status of the variable and if a reference to the function appears in the expression in
  which the value of the function is not needed to determine the value of the expression (9.7.1.3);
 the order of deallocation when several objects are deallocated by a DEALLOCATE statement (9.7.3);
 the order of deallocation when several objects are deallocated due to the occurence of an event described
  in 9.7.3.2;
 whether an allocated allocatable subobject is deallocated when an error condition occurs in the deallocation
  of an object (9.7.3.2);
 the positive integer values assigned to the <i>stat-variable</i> in a STAT= specifier as the result of an error
  condition (9.7.4, 11.7.11);
 the allocation status or pointer association status of an <i>allocate-object</i> if an error condition occurs during
  execution of an ALLOCATE or DEALLOCATE statement (9.7.4);
 the value assigned to the <i>errmsg-variable</i> in an ERRMSG= specifier as the result of an error condition
  (9.7.5, 11.7.11);
 the kind type parameter value of the result of a numeric intrinsic binary operation where
   <b>-</b> both operands are of type integer but with different kind type parameters, and the decimal exponent
    ranges are the same,
   <b>-</b> one operand is of type real or complex and the other is of type real or complex with a different kind
    type parameter, and the decimal precisions are the same,
  andforalogicalintrinsicbinaryoperationwheretheoperandshavedifferentkindtypeparameters(10.1.9.3);
 the character assigned to the variable in an intrinsic assignment statement if the kind of the expression is
  different and the character is not representable in the kind of the variable (10.2.1.3);
 the order of evaluation of the specification expressions within the specification part of a BLOCK construct
  when the construct is executed (11.1.4);
 theorderingbetweenrecordswrittenbydifferentiterationsofaDOCONCURRENTconstructiftherecords
  are written to a file connected for sequential access by more than one iteration (11.1.7);
 the order in which values are combined in a DO CONCURRENT reduction (11.1.7.5);
 the manner in which the stop code of a STOP or ERROR STOP statement is made available (11.4);
 the value of the count of the notify variable in a NOTIFY WAIT statement if an error condition occurs
  (11.6);
 the mechanisms available for creating dependencies for cooperative synchronization (11.7.5);
 the value of the count of the event variable in an EVENT POST or EVENT WAIT statement if an error
  condition occurs (11.7.7, 11.7.8);
 the image index value established for each image in a team by a FORM TEAM statement without a
  NEW_INDEX= specifier (11.7.9);
 the set of error conditions that can occur in image control statements (11.7.11);
 the relationship between the file storage units when viewing a file as a stream file, and the records when
  viewing that file as a record file (12);
 whether particular control characters can appear in a formatted record or a formatted stream file (12.2.2);
 the form of values in an unformatted record (12.2.3);
 at any time, the set of allowed access methods, set of allowed forms, set of allowed actions, and set of
  allowed record lengths for a file (12.3);
 the set of allowable names for a file (12.3);
 whether a named file on one image is the same as a file with the same name on another image (12.3.1);
 the set of external files that exist for a program (12.3.2);
 the relationship between positions of successive file storage units in an external file that is connected for
  formatted stream access (12.3.3.4);
 the external unit preconnected for sequential formatted input and identified by an asterisk or the named
  constant INPUT_UNIT of the ISO_FORTRAN_ENV intrinsic module (12.5);
 the external unit preconnected for sequential formatted output and identified by an asterisk or the named
  constant OUTPUT_UNIT of the ISO_FORTRAN_ENV intrinsic module (12.5);
 the external unit preconnected for sequential formatted output and identified by the named constant ER-
  ROR_UNIT of the ISO_FORTRAN_ENV intrinsic module, and whether this unit is the same as OUT-
  PUT_UNIT (12.5);
 at any time, the set of external units that exist for an image (12.5.3);
 whether a unit can be connected to a file that is also connected to a C stream (12.5.4);
 whether a file can be connected to more than one unit at the same time (12.5.4);
 the effect of performing input/output operations on multiple units while they are connected to the same
  external file (12.5.4);
 the result of performing input/output operations on a unit connected to a file that is also connected to a C
  stream (12.5.4);
 whether the files connected to the units INPUT_UNIT, OUTPUT_UNIT, and ERROR_UNIT correspond
  to the predefined C text streams standard input, standard output, and standard error, respectively (12.5.4);
 theresultsofperforminginput/outputoperationsonanexternalfilebothfromFortranandfromaprocedure
  defined by means other than Fortran (12.5.4);
 the default value for the ACTION= specifier in an OPEN statement (12.5.6.4);
 the encoding of a file opened with ENCODING='DEFAULT' (12.5.6.9);
 the file connected by an OPEN statement with STATUS='SCRATCH' (12.5.6.10);
 the interpretation of case in a file name (12.5.6.10, 12.10.2.2);
 the position of a file after executing an OPEN statement with a POSITION= specifier of ASIS, when the
  file previously existed but was not connected (12.5.6.15);
 the default value for the RECL= specifier in an OPEN statement (12.5.6.16);
 the effect of RECL= on a record containing any nondefault characters (12.5.6.16);
 the default input/output rounding mode (12.5.6.17);
 the default sign mode (12.5.6.18);
 the file status when STATUS='UNKNOWN' is specified in an OPEN statement (12.5.6.19);
 the value assigned to the variable in the ID= specifier in an asynchronous data transfer statement when
  execution of the statement is successfully completed (12.6.2.9);
 whether POS= is permitted with particular files, and whether POS= can position a particular file to a
  position prior to its current position (12.6.2.12);
 the form in which a single value of derived type is treated in an unformatted input/output statement if the
  effective item is not processed by a defined input/output procedure (12.6.3);
 the result of unformatted input when the type or type parameters of the value stored in the file differ from
  those of the corresponding effective item (12.6.4.5.2);
 the negative value of the unit argument to a defined input/output procedure if the parent data transfer
  statement accesses an internal file (12.6.4.8.2);
 the manner in which the processor makes the value of the iomsg argument of a defined input/output
  procedure available if the procedure assigns a nonzero value to the iostat argument and the processor
  therefore terminates execution of the program (12.6.4.8.2);
 the action caused by the flush operation, whether the processor supports the flush operation for the specified
  unit, and the negative value assigned to the IOSTAT= variable if the processor does not support the flush
  operation for the specified unit (12.9);
 the case of characters assigned to the variable in a NAME= specifier in an INQUIRE statement (12.10.2.16);
 which of the connected external unit numbers is assigned to the <i>scalar-int-variable</i> in the NUMBER=
  specifier in an INQUIRE by file statement, if more than one unit on an image is connected to the file
  (12.10.2.19);
 thevalueofthevariableinaPOSITION=specifierinanINQUIREstatementifthefilehasbeenrepositioned
  since connection (12.10.2.24);
 the relationship between file size and the data stored in records in a sequential or direct access file
  (12.10.2.31);
 the number of file storage units needed to store data in an unformatted file (12.10.3);
 the set of error conditions that can occur in input/output statements (12.11.1);
 when an input/output error condition occurs or is detected (12.11.1);
 the positive integer value assigned to the variable in an IOSTAT= specifier as the result of an error condition
  (12.11.5);
 the value assigned to the variable in an IOMSG= specifier as the result of an error condition (12.11.6);
 the result of output of non-representable characters to a Unicode file (13.7.1);
 the interpretation of the optional non-blank characters within the parentheses of a real NaN input field
  (13.7.2.3.2);
 the interpretation of a sign in a NaN input field (13.7.2.3.2);
 for output of an IEEE NaN, whether after the letters 'NaN', the processor produces additional alphanumeric
  characters enclosed in parentheses (13.7.2.3.2);
 the choice of binary exponent in EX output editing (13.7.2.3.6);
 the effect of the input/output rounding mode PROCESSOR_DEFINED (13.7.2.3.8);
 which value is chosen if the input/output rounding mode is NEAREST and the value to be converted is
  exactly halfway between the two nearest representable values in the result format (13.7.2.3.8);
 the field width, decimal part width, and exponent width used for the G0 edit descriptor (13.7.5);
 the file position when position editing skips a character of nondefault kind in an internal file of default
  character kind or an external unit that is not connected to a Unicode file (13.8.1.1);
 when the sign mode is PROCESSOR_DEFINED, whether a plus sign appears in a numeric output field
  for a nonnegative value (13.8.4);
 whether a leading zero is produced when the leading zero mode is PROCESSOR_DEFINED (13.8.5);
 the results of list-directed output (13.10.4);
 the results of namelist output (13.11.4);
 the interaction between argument association and pointer association (15.5.2.5);
 the values returned by some intrinsic functions (16);
 how the sequences of atomic actions in unordered segments interleave (16.5);
 the value assigned to a STAT argument in a reference to an atomic subroutine when an error condition
  occurs (16.5);
 the effect of calling EXECUTE_COMMAND_LINE on any image other than image 1 in the initial team
  (16.7);
 whether the results returned from CPU_TIME, DATE_AND_TIME and SYSTEM_CLOCK are depend-
  ent on which image calls them (16.7);
 the set of error conditions that can occur in some intrinsic subroutines (16.9);
 the value assigned to a CMDSTAT, ERRMSG, EXITSTAT, STAT, or STATUS argument to indicate a
  processor-dependent error condition (16.9);
 the computed value of the intrinsic subroutine CO_REDUCE (16.9.57) and the intrinsic subroutine CO_-
  SUM (16.9.58);
 whether command arguments are available (16.9.59, 16.9.93);
 the value assigned to the TIME argument by the intrinsic subroutine CPU_TIME (16.9.67);
 whether date, clock, and time zone information is available (16.9.69);
 whether date, clock, and time zone information on one image is the same as that on another image (16.9.69);
 whether asynchronous command line execution is available (16.9.83);
 whether the program invocation command is available (16.9.92);
 the value of command argument zero, if the processor does not support the concept of a command name
  (16.9.93);
 the order of command arguments (16.9.93);
 whether the significant length of a command argument includes trailing blanks (16.9.93);
 the interpretation of case for the NAME argument of the intrinsic subroutine GET_ENVIRONMENT_-
  VARIABLE (16.9.94);
 whether an environment variable that exists on an image also exists on another image, and if it does exist
  on both images, whether the values are the same or different (16.9.94);
 thevalueassignedtothepseudorandomnumberseedbytheintrinsicsubroutineRANDOM_INIT(16.9.167);
 the computation of the seed value used by the pseudorandom number generator (16.9.169);
 the value assigned to the seed by the intrinsic subroutine RANDOM_SEED when no argument is present
  (16.9.169);
 the values assigned to its arguments by the intrinsic subroutine SYSTEM_CLOCK (16.9.202);
 the values of the named constants in the intrinsic module ISO_FORTRAN_ENV (16.10.2);
 the values returned by the functions COMPILER_OPTIONS and COMPILER_VERSION in the intrinsic
  module ISO_FORTRAN_ENV (16.10.2);
 the extent to which a processor supports IEEE arithmetic (17);
 whether a flag that is quiet on entry to a scoping unit that does not access IEEE_FEATURES, IEEE_-
  EXCEPTIONS, or IEEE_ARITHMETIC is signaling on exit (17.1);
 the conditions under which IEEE_OVERFLOW is raised in a calculation involving non-ISO/IEC/IEEE
  60559:2020 floating-point data (17.3);
 the conditions under which IEEE_OVERFLOW and IEEE_DIVIDE_BY_ZERO are raised in a floating-
  point exponentiation operation (17.3);
 the conditions under which IEEE_DIVIDE_BY_ZERO is raised in a calculation involving floating-point
  data that do not conform to ISO/IEC/IEEE 60559:2020 (17.3);
 whetheranexceptionsignalsattheendofasequenceofstatementsthathasnoinvocationsofIEEE_GET_-
  FLAG, IEEE_SET_FLAG, IEEE_GET_STATUS, IEEE_SET_STATUS, or IEEE_SET_HALTING_-
  MODE, in which execution of an operation would cause it to signal, if no value of a variable depends upon
  the result of the operation (17.3);
 the initial rounding modes (17.4);
 whether the processor supports a particular rounding mode (17.4);
 the effect of the rounding mode IEEE_OTHER, if supported (17.4);
 the initial underflow mode (17.5);
 the initial halting mode (17.6);
 whether IEEE_INT implements the convertToInteger{round} or convertToIntegerExact{round} operation
  specified by ISO/IEC 60559:2020 (17.11.11);
 which argument is the result value of IEEE_MAX_NUM, IEEE_MAX_NUM_MAG, IEEE_MIN_NUM,
  orIEEE_MIN_NUM_MAGwhenbothargumentsarequietNaNsorarezeros(17.11.19, 17.11.20, 17.11.23,
  17.11.24);
 the requirements on the storage sequence to be associated with the pointer FPTR by the C_F_POINTER
  subroutine (18.2.3.4);
 the order of the members of the CFI_dim_t structure defined in the source file CFI_Fortran_binding.h
  (18.5.2);
 members of the CFI_cdesc_t structure defined in the source file CFI_Fortran_binding.h beyond the re-
  quirements of 18.5.3;
 the value of CFI_MAX_RANK in the source file CFI_Fortran_binding.h (18.5.4);
 the value of CFI_VERSION in the source file CFI_Fortran_binding.h (18.5.4);
 which error condition is detected if more than one error condition could be detected for an invocation of
  one of the functions declared in the source file CFI_Fortran_binding.h (18.5.5.1);
 the values of the attribute specifier macros defined in the source file CFI_Fortran_binding.h (18.5.4);
 the values of the type specifier macros defined in the source file CFI_Fortran_binding.h;
 which additional type specifier values are defined in the source file CFI_Fortran_binding.h (18.5.4);
 the values of the error code macros other than CFI_SUCCESS that are defined in the source file CFI_-
  Fortran_binding.h (18.5.4);
 the base address of a zero-sized array (18.5.3);
 the values of the floating-point exception flags on entry to a procedure defined by means other than Fortran
  (18.10.3);
 whether a procedure defined by means other than Fortran is an asynchronous communication initiation or
  completion procedure (18.10.4).
           <b>Annex</b> <b>B</b>
                     (Informative)
     <b>Deleted</b> <b>and</b> <b>obsolescent</b> <b>features</b>
<b>B.1</b> <b>Deleted</b> <b>features</b> <b>from</b> <b>Fortran</b> <b>90</b>
These deleted features are those features of Fortran 90 that were redundant and considered largely unused.
The following Fortran 90 features are not required.
  (1) Real and double precision DO variables.
     In Fortran 77 and Fortran 90, a DO variable was allowed to be of type real or double precision
     in addition to type integer; this has been deleted. A similar result can be achieved by using a DO
     construct with no loop control and the appropriate exit test.
  (2) Branching to an END IF statement from outside its block.
     InFortran 77 and Fortran 90, it was possible to branch to an END IF statement from outside the
     IF construct; this has been deleted. A similar result can be achieved by branching to a CONTINUE
     statement that is immediately after the END IF statement.
  (3) PAUSE statement.
     The PAUSE statement, provided in Fortran 66, Fortran 77, and Fortran 90, has been deleted.
     A similar result can be achieved by writing a message to the appropriate unit, followed by reading
     from the appropriate unit.
  (4) ASSIGN and assigned GO TO statements, and assigned format specifiers.
     The ASSIGN statement and the related assigned GO TO statement, provided in Fortran 66,
    Fortran 77, and Fortran 90, have been deleted. Further, the ability to use an assigned integer as a
     format, provided inFortran 77 and Fortran 90, has been deleted. A similar result can be achieved
     by using other control constructs instead of the assigned GO TO statement and by using a default
     character variable to hold a format specification instead of using an assigned integer.
  (5) H edit descriptor.
     In Fortran 77 and Fortran 90, there was an alternative form of character string edit descriptor,
     which had been the only such form in Fortran 66; this has been deleted. A similar result can be
     achieved by using a character string edit descriptor.
  (6) Vertical format control.
     InFortran66,Fortran77, Fortran 90, and Fortran 95 formatted output to certain units resulted
     in the first character of each record being interpreted as controlling vertical spacing. There was no
     standard way to detect whether output to a unit resulted in this vertical format control, and no
     way to specify that it needs to be applied; this has been deleted. The effect can be achieved by
     post-processing a formatted file.
See ISO/IEC 1539:1991 for detailed rules of how these deleted features worked.
<b>B.2</b> <b>Deleted</b> <b>features</b> <b>from</b> <b>Fortran</b> <b>2008</b>
These deleted features are those features of Fortran 2008 that were redundant and considered largely unused.
The following Fortran 2008 features are not required.
  (1) Arithmetic IF statement.
     The arithmetic IF statement is incompatible with ISO/IEC 60559:2020 and necessarily involves the
     use of statement labels; statement labels can hinder optimization, and make code hard to read and
     maintain. Similar logic can be more clearly encoded using other conditional statements.
  (2) Nonblock DO construct
     The nonblock forms of the DO loop were confusing and hard to maintain. Shared termination and
     dual use of labeled action statements as do termination and branch targets were especially error-
     prone.
<b>B.3</b> <b>Obsolescent</b> <b>features</b>
<b>B.3.1</b> <b>General</b>
The obsolescent features are those features of Fortran 90 that were redundant and for which better methods were
available in Fortran 90. The nature of the obsolescent features is described in 4.4.3. The obsolescent features in
this document are the following.
  (1) Alternate return - see B.3.2.
  (2) Computed GO TO - see B.3.3.
  (3) Statement functions - see B.3.4.
  (4) DATA statements amongst executable statements - see B.3.5.
  (5) Assumed length character functions - see B.3.6.
  (6) Fixed form source - see B.3.7.
  (7) CHARACTER* form of CHARACTER declaration - see B.3.8.
  (8) ENTRY statements - see B.3.9.
  (9) Label form of DO statement - see B.3.10.
  (10) COMMON and EQUIVALENCE statements, and the block data program unit - see B.3.11.
  (11) Specific names for intrinsic functions - see B.3.12.
  (12) FORALL construct and statement - see B.3.13
<b>B.3.2</b> <b>Alternate</b> <b>return</b>
An alternate return introduces labels into an argument list to allow the called procedure to direct the execution
of the caller upon return. The same effect can be achieved with a return code that is used in a SELECT CASE
constructonreturn. Thisavoidsanirregularityinthesyntaxandsemanticsofargumentassociation. Forexample,
 CALL SUBR_NAME (X, Y, Z, *100, *200, *300)
can be replaced by
 CALL SUBR_NAME (X, Y, Z, RETURN_CODE)
 SELECT CASE (RETURN_CODE)
   CASE (1)
    ...
   CASE (2)
    ...
   CASE (3)
    ...
   CASE DEFAULT
    ...
 END SELECT
<b>B.3.3</b> <b>Computed</b> <b>GO</b> <b>TO</b> <b>statement</b>
The computed GO TO statement has been superseded by the SELECT CASE construct, which is a generalized,
easier to use, and clearer means of expressing the same computation.
<b>B.3.4</b> <b>Statement</b> <b>functions</b>
Statementfunctionsaresubjecttoanumberofnonintuitiverestrictionsandareapotentialsourceoferrorbecause
their syntax is easily confused with that of an assignment statement.
The internal function is a more generalized form of the statement function and completely supersedes it.
<b>B.3.5</b> <b>DATA</b> <b>statements</b> <b>among</b> <b>executables</b>
The statement ordering rules allow DATA statements to appear anywhere in a program unit after the specific-
ation statements. The ability to position DATA statements amongst executable statements is very rarely used,
unnecessary, and a potential source of error.
<b>B.3.6</b> <b>Assumed</b> <b>character</b> <b>length</b> <b>functions</b>
Assumed character length for functions is an irregularity in the language in that elsewhere in Fortran the philo-
sophy is that the attributes of a function result depend only on the actual arguments of the invocation and on
any data accessible by the function through host or use association. Some uses of this facility can be replaced
with an automatic character length function, where the length of the function result is declared in a specification
expression. Other uses can be replaced by the use of a subroutine whose arguments correspond to the function
result and the function arguments.
Note that dummy arguments of a function can have assumed character length.
<b>B.3.7</b> <b>Fixed</b> <b>form</b> <b>source</b>
Fixedformsourcewasdesignedwhentheprincipalmachine-readableinputmediumfornewprogramswaspunched
cards. Now that new and amended programs are generally entered via keyboards with screen displays, it is an
unnecessary overhead, and is potentially error-prone, to have to locate positions 6, 7, or 72 on a line. Free form
source was designed expressly for this more modern technology.
It is a simple matter for a software tool to convert from fixed to free form source.
<b>B.3.8</b> <b>CHARACTER*</b> <b>form</b> <b>of</b> <b>CHARACTER</b> <b>declaration</b>
In addition to the CHARACTER*<i>char-length</i> form introduced in Fortran 77, Fortran 90 provided the CHAR-
ACTER([ LEN = ] <i>type-param-value</i>) form. The older form (CHARACTER*<i>char-length</i>) is redundant.
<b>B.3.9</b> <b>ENTRY</b> <b>statements</b>
ENTRY statements allow more than one entry point to a subprogram, facilitating sharing of data items and
executable statements local to that subprogram.
This can be replaced by a module containing the (private) data items, with a module procedure for each entry
point and the shared code in a private module procedure.
<b>B.3.10</b> <b>Label</b> <b>DO</b> <b>statement</b>
The label in the DO statement is redundant with the construct name. Furthermore, the label allows unrestricted
branches and, for its main purpose (the target of a conditional branch to skip the rest of the current iteration),
is redundant with the CYCLE statement, which is clearer.
<b>B.3.11</b> <b>COMMON</b> <b>and</b> <b>EQUIVALENCE</b> <b>statements</b> <b>and</b> <b>the</b> <b>block</b> <b>data</b> <b>program</b> <b>unit</b>
Common blocks are error-prone and have largely been superseded by modules. EQUIVALENCE similarly is
error-prone. Whilst use of these statements was invaluable prior to Fortran 90 they are now redundant and
can inhibit performance. The block data program unit exists only to serve common blocks and hence is also
redundant.
<b>B.3.12</b> <b>Specific</b> <b>names</b> <b>for</b> <b>intrinsic</b> <b>functions</b>
The specific names of the intrinsic functions are often obscure and hinder portability. They have been redundant
since Fortran 90. Use generic names for references to intrinsic procedures.
<b>B.3.13</b> <b>FORALL</b> <b>construct</b> <b>and</b> <b>statement</b>
The FORALL construct and statement were added to the language in the expectation that they would enable
highly efficient execution, especially on parallel processors. However, experience indicates that they are too
complex and have too many restrictions for compilers to take advantage of them. They are redundant with the
DO CONCURRENT construct, and many of the manipulations for which they might be used can be done more
effectively using pointers, especially using pointer rank remapping.
           <b>Annex</b> <b>C</b>
                     (Informative)
         <b>Extended</b> <b>notes</b>
<b>C.1</b> <b>Features</b> <b>that</b> <b>were</b> <b>new</b> <b>in</b> <b>Fortran</b> <b>2018</b>
 Data declaration:
  Constant properties of an object declared in its <i>entity-decl</i> can be used in its <i>initialization</i>. The EQUIVAL-
  ENCE and COMMON statements and the block data program unit have been redundant since Fortran 90
  and are now specified to be obsolescent. Diagnosis of the appearance of a PROTECTED TARGET variable
  accessed by use association as a <i>data-target</i> in a structure constructor is required.
 Data usage and computation:
  The declared type of the value supplied for a polymorphic allocatable component in a structure constructor
  is no longer required to be the same as the declared type of the component. FORALL is now specified to
  be obsolescent. The type and kind of an implied DO variable in an array constructor or DATA statement
  can be specified within the constructor or statement. The SELECT RANK construct provides structured
  access to the elements of an assumed-rank array. Completing execution of a BLOCK construct can cause
  the association status of a pointer with the PROTECTED attribute to become undefined. The standard
  intrinsic operations<i><</i>,<i><</i>=,<i>></i>, and<i>></i>= (also known as .LT., .LE., .GT., and .GE.) on IEEE numbers provide
  compareSignaling{relation} operations; the = and /= operations (also known as .EQ. and .NE.) provide
  compareQuiet{relation} operations. Finalization of an allocatable subobject during intrinsic assignment
  has been clarified. The <i>char-length</i> in an executable statement is no longer required to be a specification
  expression.
 Input/output:
  The SIZE= specifier can be used with advancing input. It is no longer prohibited to open a file on more than
  one unit. The value assigned by the RECL= specifier in an INQUIRE statement has been standardized.
  The values assigned by the POS= and SIZE= specifiers in an INQUIRE statement for a unit that has
  pending asynchronous operations have been standardized. The G0.<i>d</i> edit descriptor can be used for effective
  items of type Integer, Logical, and Character. The D, E, EN, and ES edit descriptors can have a field
  width of zero, analogous to the F edit descriptor. The exponent width <i>e</i> in a data edit descriptor can be
  zero, analogous to a field width of zero. Floating-point formatted input accepts hexadecimal-significand
  numbers that conform to ISO/IEC 60559:2020. The EX edit descriptor provides hexadecimal-significand
  formatted output conforming to ISO/IEC 60559:2020. An error condition occurs if unacceptable characters
  are presented for logical or numeric editing during execution of a formatted input statement.
 Execution control:
  The arithmetic IF statement has been deleted. Labeled DO loops have been redundant since Fortran 90
  and are now specified to be obsolescent. The nonblock DO construct has been deleted. The locality of a
  variable used in a DO CONCURRENT construct can be explicitly specified. The stop code in a STOP or
  ERROR STOP statement can be nonconstant. Output of the stop code and exception summary from the
  STOP and ERROR STOP statements can be controlled.
 Intrinsic procedures and modules:
  In a reference to the intrinsic function CMPLX with an actual argument of type complex, no keyword
  is needed for a KIND argument. In references to the intrinsic functions ALL, ANY, FINDLOC, IALL,
  IANY, IPARITY, MAXLOC, MAXVAL, MINLOC, MINVAL, NORM2, PARITY, PRODUCT, SUM, and
  THIS_IMAGE,theactualargumentforDIMcanbeapresentoptionaldummyargument. Thenewintrinsic
  function COSHAPE returns the coshape of a coarray. The new intrinsic function OUT_OF_RANGE tests
  whether a numeric value can be safely converted to a different type or kind. The new intrinsic subroutine
  RANDOM_INIT establishes the initial state of the pseudorandom number generator used by RANDOM_-
  NUMBER. The new intrinsic function REDUCE performs user-specified array reductions. A processor is
  required to report use of a nonstandard intrinsic procedure, use of a nonstandard intrinsic module, and use
  of a nonstandard procedure from a standard intrinsic module. Integer and logical arguments to intrinsic pro-
  cedures and intrinsic module procedures that were previously required to be of default kind no longer have
  that requirement, except for RANDOM_SEED. Specific names for intrinsic functions are now deemed ob-
  solescent. All standard procedures in the intrinsic module ISO_C_BINDING, other than C_F_POINTER
  and C_F_PROCPOINTER, are now pure. The arguments to the intrinsic function SIGN can be of dif-
  ferent kind. Nonpolymorphic pointer arguments to the intrinsic functions EXTENDS_TYPE_OF and
  SAME_TYPE_AS need not have defined pointer association status. The effects of invoking the intrinsic
  procedures COMMAND_ARGUMENT_COUNT, GET_COMMAND, and GET_COMMAND_ARGU-
  MENT, on images other than image one, are no longer processor dependent. Access to error messages
  from the intrinsic subroutines GET_COMMAND, GET_COMMAND_ARGUMENT, and GET_ENVIR-
  ONMENT_VARIABLE is provided by an optional ERRMSG argument. The result of NORM2 for a
  zero-sized array argument has been clarified.
 Program units and procedures:
  The IMPORT statement can appear in a contained subprogram or BLOCK construct, and can restrict
  access via host association; diagnosis of violation of the IMPORT restrictions is required. The GENERIC
  statement can be used to declare generic interfaces. The number of procedure arguments is used in generic
  resolution. In a module, the default accessibility of entities accessed from another module can be controlled
  separately from the default accessibility of entities declared in the using module. An IMPLICIT NONE
  statement can require explicit declaration of the EXTERNAL attribute throughout a scoping unit and its
  contained scoping units. A defined operation need not specify INTENT (IN) for a dummy argument with
  the VALUE. A defined assignment need not specify INTENT (IN) for the second dummy argument if it
  has the VALUE. Procedures that are not declared with an asterisk <i>type-param-value</i>, including elemental
  procedures, can be invoked recursively by default; the RECURSIVE keyword is advisory only. The NON_-
  RECURSIVE keyword specifies that a procedure is not recursive. The ERROR STOP statement can appear
  in a pure subprogram. A dummy argument of a pure function is permitted in a variable definition context,
  if it has the VALUE attribute. A coarray dummy argument, or a coarray ultimate component of a dummy
  argument, can be referenced or defined by another image.
 Features previously described by ISO/IEC TS 29113:2012:
  A dummy data object can assume its rank from its effective argument. A dummy data object can assume
  the type from its effective argument, without having the ability to perform type selection. An interoper-
  able procedure can have dummy arguments that are assumed-type and/or assumed-rank. An interoperable
  procedure can have dummy data objects that are allocatable, assumed-shape, optional, or pointers. The
  character length of a dummy data object of an interoperable procedure can be assumed. The argument
  to C_LOC can be a noninteroperable array. The FPTR argument to C_F_POINTER can be a noninter-
  operable array pointer. The argument to C_FUNLOC can be a noninteroperable procedure. The FPTR
  argument to C_F_PROCPOINTER can be a noninteroperable procedure pointer. There is a new named
  constant C_PTRDIFF_T to provide interoperability with the C type ptrdiff_t.
  Additionally to ISO/IEC TS 29113:2012, a scalar actual argument can be associated with an assumed-
  type assumed-size dummy argument, an assumed-rank dummy data object that is not associated with an
  assumed-size array can be used as the argument to the function C_SIZEOF from the intrinsic module
  ISO_C_BINDING, and the type argument to CFI_establish can have a positive value corresponding to
  an interoperable C type.
 Changes to the intrinsic modules IEEE_ARITHMETIC, IEEE_EXCEPTIONS, and IEEE_FEATURES
  for conformance with ISO/IEC 60559:2020:
  There is a new, optional, rounding mode IEEE_AWAY. The new type IEEE_MODES_TYPE encapsu-
  lates all floating-point modes. Features associated with subnormal numbers can be accessed with func-
  tions and types named ...SUBNORMAL...(the old ...DENORMAL...names remain). The new function
  IEEE_FMA performs fused multiply-add operations. The function IEEE_INT performs rounded conver-
  sions to integer type. The new functions IEEE_MAX_NUM, IEEE_MAX_NUM_MAG, IEEE_MIN_-
  NUM, and IEEE_MIN_NUM_MAG calculate maximum and minimum numeric values. The new func-
  tions IEEE_NEXT_DOWN and IEEE_NEXT_UP return the adjacent machine numbers. The new func-
  tions IEEE_QUIET_EQ, IEEE_QUIET_GE, IEEE_QUIET_GT, IEEE_QUIET_LE, IEEE_QUIET_-
  LT, and IEEE_QUIET_NE perform quiet comparisons. The new functions IEEE_SIGNALING_EQ,
  IEEE_SIGNALING_GE, IEEE_SIGNALING_GT, IEEE_SIGNALING_GE, IEEE_SIGNALING_LE,
  IEEE_SIGNALING_LT,andIEEE_SIGNALING_NEperformsignalingcomparisons. Thedecimalround-
  ing mode can be inquired and set independently of the binary rounding mode, using the RADIX argument
  to IEEE_GET_ROUNDING_MODE and IEEE_SET_ROUNDING_MODE. The new function IEEE_-
  REAL performs rounded conversions to real type. The function IEEE_REM now requires its arguments to
  have the same radix. The function IEEE_RINT now has a ROUND argument to perform specific rounding.
  The new function IEEE_SIGNBIT tests the sign bit of an IEEE number.
 Features previously described by ISO/IEC TS 18508:2015:
  The CRITICAL statement has optional ERRMSG= and STAT= specifiers. The intrinsic subroutines
  ATOMIC_DEFINE and ATOMIC_REF have an optional STAT argument. The new intrinsic subroutines
  ATOMIC_ADD,ATOMIC_AND,ATOMIC_CAS,ATOMIC_FETCH_ADD,ATOMIC_FETCH_AND,
  ATOMIC_FETCH_OR, ATOMIC_FETCH_XOR, ATOMIC_OR, and ATOMIC_XOR perform atomic
  operations. The new intrinsic functions FAILED_IMAGES and STOPPED_IMAGES return indices of im-
  ages known to have failed or stopped respectively. The new intrinsic function IMAGE_STATUS returns the
  image execution status of an image. The intrinsic subroutine MOVE_ALLOC has optional ERRMSG and
  STATarguments. TheintrinsicfunctionsIMAGE_INDEXandNUM_IMAGEShaveadditionalformswith
  a TEAM or TEAM_NUMBER argument. The intrinsic function THIS_IMAGE has an optional TEAM
  argument. The EVENT POST and EVENT WAIT statements, the intrinsic subroutine EVENT_QUERY,
  and the type EVENT_TYPE provide an event facility for one-sided segment ordering. The CHANGE
  TEAM construct, derived type TEAM_TYPE, FORM TEAM and SYNC TEAM statements, intrinsic
  functions GET_TEAM and TEAM_NUMBER, and the TEAM= and TEAM_NUMBER= specifiers on
  image selectors, provide a team facility for a subset of the program's images to act in concert as if it were the
  set of all images. This team facility allows an allocatable coarray to be allocated or deallocated on a sub-
  set of images. The new intrinsic subroutines CO_BROADCAST, CO_MAX, CO_MIN, CO_REDUCE,
  and CO_SUM perform collective reduction operations on the images of the current team. The concept
  of failed images, the FAIL IMAGE statement, the STAT= specifier on image selectors, and the named
  constant STAT_FAILED_IMAGE from the intrinsic module ISO_FORTRAN_ENV provide support for
  fault-tolerant parallel execution.
 Changes to features previously described by ISO/IEC TS 18508:2015:
  The CHANGE TEAM and SYNC TEAM statements, and the TEAM= specifier on image selectors, permit
  the team to be specified by an expression. The intrinsic functions FAILED_IMAGES and STOPPED_-
  IMAGES have no restriction on the kind of their result. The name of the function argument to the
  intrinsic function CO_REDUCE is OPERATION instead of OPERATOR; this argument is not required to
  be commutative. The named constant STAT_UNLOCKED_FAILED_IMAGE from the intrinsic module
  ISO_FORTRAN_ENV indicates that a lock variable was locked by an image that failed. The team number
  for the initial team can be used in image selectors, and in the intrinsic functions NUM_IMAGES and
  IMAGE_INDEX. A team variable that appears in a CHANGE TEAM statement can no longer be defined
  or become undefined during execution of the CHANGE TEAM construct. All images of the current team
  are no longer required to execute the same CHANGE TEAM statement. A variable of type TEAM_-
  TYPE from the intrinsic module ISO_FORTRAN_ENV is not permitted to be a coarray. A variable
  of type TEAM_TYPE from the intrinsic module ISO_FORTRAN_ENV can have a pointer component,
  and a team variable becomes undefined if assigned a value from another image. The intrinsic function
  UCOBOUND produces a value for the final upper cobound that is always relative to the current team. An
  EXIT statement can be used to complete execution of a CHANGE TEAM or CRITICAL construct.
<b>C.2</b> <b>Fortran</b> <b>2008</b> <b>features</b> <b>not</b> <b>mentioned</b> <b>in</b> <b>its</b> <b>Introduction</b>
The following features were new in Fortran 2008 but not originally listed in its Introduction as being new features:
 An array or object with a nonconstant length type parameter can have the VALUE attribute.
 Multiple allocations are permitted in a single ALLOCATE statement with the SOURCE= specifier.
 A PROCEDURE statement can have a double colon before the first procedure name.
 An argument to a pure procedure can have default INTENT if it has the VALUE attribute.
 The PROTECTED attribute can be specified by the procedure declaration statement.
 A <i>defined-operator</i> can be used in a specification expression.
 All transformational functions from the intrinsic module ISO_C_BINDING can be used in specification
  expressions.
 A contiguous array variable that is not interoperable but which has interoperable type and kind type
  parameter (if any), and a scalar character variable with length greater than one and kind C_CHAR in the
  intrinsic module ISO_C_BINDING, can be used as the argument of the function C_LOC in the intrinsic
  module ISO_C_BINDING, provided the variable has the POINTER or TARGET attribute.
 The name of an external procedure that has a binding label is a local identifier and not a global identifier.
 A procedure that is not a procedure pointer can be an actual argument that corresponds to a procedure
  pointer dummy argument with the INTENT (IN) attribute.
 An interface body for an external procedure that does not exist in a program can be used to specify an
  explicit specific interface.
 An internal procedure name can appear in a <i>procedure-stmt</i> in a generic interface block.
All but the last three of the above list were subsequently added to the Introduction by Technical Corrigenda.
<b>C.3</b> <b>Clause</b> <b>7</b> <b>notes</b>
<b>C.3.1</b> <b>Selection</b> <b>of</b> <b>the</b> <b>approximation</b> <b>methods</b> <b>(7.4.3.2)</b>
One can select the real approximation method for an entire program through the use of a module and the
parameterized real type. This is accomplished by defining a named integer constant to have a particular kind
type parameter value and using that named constant in all real, complex, and derived-type declarations. For
example, the specification statements
   INTEGER, PARAMETER :: LONG_FLOAT = 8
   REAL (LONG_FLOAT) X, Y
   COMPLEX (LONG_FLOAT) Z
specify that the approximation method corresponding to a kind type parameter value of 8 is supplied for the data
objects X, Y, and Z in the program unit. The kind type parameter value LONG_FLOAT can be made available
to an entire program by placing the INTEGER specification statement in a module and accessing the named
constant LONG_FLOAT with a USE statement. Note that by changing 8 to 4 once in the module, a different
approximation method is selected.
To avoid the use of the processor-dependent values 4 or 8, replace 8 by KIND (0.0) or KIND (0.0D0). Another
way to avoid these processor-dependent values is to select the kind value using the intrinsic function SELEC-
TED_REAL_KIND (16.9.183). In the above specification statement, the 8 might be replaced by, for instance,
SELECTED_REAL_KIND (10, 50), which requires an approximation method to be selected with at least 10
decimal digits of precision and a range from 10
            -50
                     to 10
                           50
                        . There are no magnitude or ordering constraints placed
on kind values, in order that implementers have flexibility in assigning such values and can add new kinds without
changing previously assigned kind values.
As kind values have no portable meaning, a good practice is to use them in programs only through named
constants as described above (for example, SINGLE, IEEE_SINGLE, DOUBLE, and QUAD), rather than using
the kind values directly.
<b>C.3.2</b> <b>Type</b> <b>extension</b> <b>and</b> <b>component</b> <b>accessibility</b> <b>(7.5.2.2,</b> <b>7.5.4)</b>
The default accessibility of the components of an extended type can be specified in the type definition. The
accessibility of its components can be specified individually. For example:
   module types
    type base_type
     private !-- Sets default accessibility
     integer :: i !-- a private component
     integer, private :: j !-- another private component
     integer, public :: k !-- a public component
    end type base_type
    type, extends(base_type) :: my_type
     private !-- Sets default for components declared in my_type
     integer :: l !-- A private component.
     integer, public :: m !-- A public component.
    end type my_type
   end module types
   subroutine sub
    use types
    type (my_type) :: x
    ...
    call another_sub( &
     x%base_type, & !-- ok because base_type is a public subobject of x
     x%base_type%k, & !-- ok because x%base_type is ok and has k as a
               !-- public component.
     x%k, & !-- ok because it is shorthand for x%base_type%k
     x%base_type%i, & !-- Invalid because i is private.
     x%i) !-- Invalid because it is shorthand for x%base_type%i
   end subroutine sub
<b>C.3.3</b> <b>Generic</b> <b>type-bound</b> <b>procedures</b> <b>(7.5.5)</b>
<b>Example</b> <b>of</b> <b>a</b> <b>derived</b> <b>type</b> <b>with</b> <b>generic</b> <b>type-bound</b> <b>procedures:</b>
The only difference between this example and the same thing rewritten to use generic interface blocks is that
with type-bound procedures,
   USE rational_numbers, ONLY: rational
does not block the type-bound procedures; the user still gets access to the defined assignment and extended
operations.
   MODULE rational_numbers
    IMPLICIT NONE
    PRIVATE
    TYPE,PUBLIC :: rational
     PRIVATE
     INTEGER n,d
    CONTAINS
     ! ordinary type-bound procedure
     PROCEDURE :: real => rat_to_real
     ! specific type-bound procedures for generic support
     PROCEDURE,PRIVATE :: rat_asgn_i, rat_plus_i, rat_plus_rat => rat_plus
     PROCEDURE,PRIVATE,PASS(b) :: i_plus_rat
     ! generic type-bound procedures
     GENERIC :: ASSIGNMENT(=) => rat_asgn_i
     GENERIC :: OPERATOR(+) => rat_plus_rat, rat_plus_i, i_plus_rat
    END TYPE
   CONTAINS
    ELEMENTAL REAL FUNCTION rat_to_real(this) RESULT(r)
     CLASS(rational),INTENT(IN) :: this
     r = REAL(this%n)/this%d
    END FUNCTION
    ELEMENTAL SUBROUTINE rat_asgn_i(a,b)
     CLASS(rational),INTENT(INOUT) :: a
     INTEGER,INTENT(IN) :: b
     a%n = b
     a%d = 1
    END SUBROUTINE
    ELEMENTAL TYPE(rational) FUNCTION rat_plus_i(a,b) RESULT(r)
     CLASS(rational),INTENT(IN) :: a
     INTEGER,INTENT(IN) :: b
     r%n = a%n + b*a%d
     r%d = a%d
    END FUNCTION
    ELEMENTAL TYPE(rational) FUNCTION i_plus_rat(a,b) RESULT(r)
     INTEGER,INTENT(IN) :: a
     CLASS(rational),INTENT(IN) :: b
     r%n = b%n + a*b%d
     r%d = b%d
    END FUNCTION
    ELEMENTAL TYPE(rational) FUNCTION rat_plus(a,b) RESULT(r)
     CLASS(rational),INTENT(IN) :: a,b
     r%n = a%n*b%d + b%n*a%d
     r%d = a%d*b%d
    END FUNCTION
   END
<b>C.3.4</b> <b>Abstract</b> <b>types</b> <b>(7.5.7.1)</b>
The following illustrates how an abstract type can be used as the basis for a collection of related types, and how
a non-abstract member of that collection can be created by type extension.
   TYPE, ABSTRACT :: DRAWABLE_OBJECT
     REAL, DIMENSION(3) :: RGB_COLOR = (/1.0,1.0,1.0/) ! White
     REAL, DIMENSION(2) :: POSITION = (/0.0,0.0/) ! Centroid
   CONTAINS
     PROCEDURE(RENDER_X), PASS(OBJECT), DEFERRED :: RENDER
   END TYPE DRAWABLE_OBJECT
   ABSTRACT INTERFACE
     SUBROUTINE RENDER_X(OBJECT, WINDOW)
      IMPORT DRAWABLE_OBJECT, X_WINDOW
      CLASS(DRAWABLE_OBJECT), INTENT(IN) :: OBJECT
      CLASS(X_WINDOW), INTENT(INOUT) :: WINDOW
     END SUBROUTINE RENDER_X
   END INTERFACE
   ...
   TYPE, EXTENDS(DRAWABLE_OBJECT) :: DRAWABLE_TRIANGLE ! Not ABSTRACT
     REAL, DIMENSION(2,3) :: VERTICES ! In relation to centroid
   CONTAINS
     PROCEDURE, PASS(OBJECT) :: RENDER=>RENDER_TRIANGLE_X
   END TYPE DRAWABLE_TRIANGLE
The actual drawing procedure will draw a triangle in WINDOW with vertices at x and y coordinates at
OBJECT%POSITION(1)+OBJECT%VERTICES(1,1:3) and OBJECT%POSITION(2)+OBJECT%VERTICES(2,1:3):
   SUBROUTINE RENDER_TRIANGLE_X(OBJECT, WINDOW)
     CLASS(DRAWABLE_TRIANGLE), INTENT(IN) :: OBJECT
     CLASS(X_WINDOW), INTENT(INOUT) :: WINDOW
     ...
   END SUBROUTINE RENDER_TRIANGLE_X
<b>C.3.5</b> <b>Structure</b> <b>constructors</b> <b>and</b> <b>generic</b> <b>names</b> <b>(7.5.10)</b>
A generic name can be the same as a type name. This can be used to emulate user-defined structure constructors
for that type, even if the type has private components. For example:
   MODULE mytype_module
    TYPE mytype
     PRIVATE
     COMPLEX value
     LOGICAL exact
    END TYPE
    INTERFACE mytype
     MODULE PROCEDURE int_to_mytype
    END INTERFACE
    ! Operator definitions etc.
    ...
   CONTAINS
    TYPE(mytype) FUNCTION int_to_mytype(i)
     INTEGER,INTENT(IN) :: i
     int_to_mytype%value = i
     int_to_mytype%exact = .TRUE.
    END FUNCTION
    ! Procedures to support operators etc.
    ...
   END
   PROGRAM example
    USE mytype_module
    TYPE(mytype) x
    x = mytype(17)
   END
The type name can still be used as a generic name if the type has type parameters. For example:
   MODULE m
    TYPE t(kind)
     INTEGER, KIND :: kind
     COMPLEX(kind) value
    END TYPE
    INTEGER,PARAMETER :: single = KIND(0.0), double = KIND(0d0)
    INTERFACE t
     MODULE PROCEDURE real_to_t1, dble_to_t2, int_to_t1, int_to_t2
    END INTERFACE
    ...
   CONTAINS
    TYPE(t(single)) FUNCTION real_to_t1(x)
     REAL(single) x
     real_to_t1%value = x
    END FUNCTION
    TYPE(t(double)) FUNCTION dble_to_t2(x)
     REAL(double) x
     dble_to_t2%value = x
    END FUNCTION
    TYPE(t(single)) FUNCTION int_to_t1(x,mold)
     INTEGER x
     TYPE(t(single)) mold
     int_to_t1%value = x
    END FUNCTION
    TYPE(t(double)) FUNCTION int_to_t2(x,mold)
     INTEGER x
     TYPE(t(double)) mold
     int_to_t2%value = x
    END FUNCTION
    ...
   END
   PROGRAM example
    USE m
    TYPE(t(single)) x
    TYPE(t(double)) y
    x = t(1.5) ! References real_to_t1
    x = t(17,mold=x) ! References int_to_t1
    y = t(1.5d0) ! References dble_to_t2
    y = t(42,mold=y) ! References int_to_t2
    y = t(kind(0d0)) ((0,1)) ! Uses the structure constructor for type t
   END
<b>C.3.6</b> <b>Final</b> <b>subroutines</b> <b>(7.5.6,</b> <b>7.5.6.2,</b> <b>7.5.6.3,</b> <b>7.5.6.4)</b>
<b>Example</b> <b>of</b> <b>a</b> <b>parameterized</b> <b>derived</b> <b>type</b> <b>with</b> <b>final</b> <b>subroutines:</b>
   MODULE m
    TYPE t(k)
     INTEGER, KIND :: k
     REAL(k),POINTER :: vector(:) => NULL()
    CONTAINS
     FINAL :: finalize_t1s, finalize_t1v, finalize_t2e
    END TYPE
   CONTAINS
    SUBROUTINE finalize_t1s(x)
     TYPE(t(KIND(0.0))) x
     IF (ASSOCIATED(x%vector)) DEALLOCATE(x%vector)
    END SUBROUTINE
    SUBROUTINE finalize_t1v(x)
     TYPE(t(KIND(0.0))) x(:)
     DO i=LBOUND(x,1),UBOUND(x,1)
      IF (ASSOCIATED(x(i)%vector)) DEALLOCATE(x(i)%vector)
     END DO
    END SUBROUTINE
    ELEMENTAL SUBROUTINE finalize_t2e(x)
     TYPE(t(KIND(0.0d0))),INTENT(INOUT) :: x
     IF (ASSOCIATED(x%vector)) DEALLOCATE(x%vector)
    END SUBROUTINE
   END MODULE
   SUBROUTINE example(n)
    USE m
    TYPE(t(KIND(0.0))) a,b(10),c(n,2)
    TYPE(t(KIND(0.0d0))) d(n,n)
    ...
    ! Returning from this subroutine will effectively do
    ! CALL finalize_t1s(a)
    ! CALL finalize_t1v(b)
    ! CALL finalize_t2e(d)
    ! No final subroutine will be called for variable C because the user
    ! omitted to define a suitable specific procedure for it.
   END SUBROUTINE
<b>Example</b> <b>of</b> <b>extended</b> <b>types</b> <b>with</b> <b>final</b> <b>subroutines:</b>
   MODULE m
    TYPE t1
     REAL a,b
    END TYPE
    TYPE,EXTENDS(t1) :: t2
     REAL,POINTER :: c(:),d(:)
    CONTAINS
     FINAL :: t2f
    END TYPE
    TYPE,EXTENDS(t2) :: t3
     REAL,POINTER :: e
    CONTAINS
     FINAL :: t3f
    END TYPE
    ...
   CONTAINS
    SUBROUTINE t2f(x) ! Finalizer for TYPE(t2)'s extra components
     TYPE(t2) :: x
     IF (ASSOCIATED(x%c)) DEALLOCATE(x%c)
     IF (ASSOCIATED(x%d)) DEALLOCATE(x%d)
    END SUBROUTINE
    SUBROUTINE t3f(y) ! Finalizer for TYPE(t3)'s extra components
     TYPE(t3) :: y
     IF (ASSOCIATED(y%e)) DEALLOCATE(y%e)
    END SUBROUTINE
   END MODULE
   SUBROUTINE example
    USE m
    TYPE(t1) x1
    TYPE(t2) x2
    TYPE(t3) x3
    ...
    ! Returning from this subroutine will effectively do
    ! ! Nothing to x1; it is not finalizable
    ! CALL t2f(x2)
    ! CALL t3f(x3)
    ! CALL t2f(x3%t2)
   END SUBROUTINE
<b>C.4</b> <b>Clause</b> <b>8</b> <b>notes:</b> <b>The</b> <b>VOLATILE</b> <b>attribute</b> <b>(8.5.20)</b>
The following example shows the use of a variable with the VOLATILE attribute to communicate with an
asynchronous process, in this case the operating system. The program detects a user keystroke on the terminal
and reacts at a convenient point in its processing.
TheVOLATILEattributeisnecessarytoprevent an optimizing compiler from storing the communicationvariable
in a register or from doing flow analysis and deciding that the EXIT statement can never be executed.
   SUBROUTINE TERMINATE_ITERATIONS
    LOGICAL, VOLATILE :: USER_HIT_ANY_KEY
    ! Have the OS start to look for a user keystroke and set the variable
    ! "USER_HIT_ANY_KEY" to TRUE as soon as it detects a keystroke.
    ! This call is operating system dependent.
    CALL OS_BEGIN_DETECT_USER_KEYSTROKE( USER_HIT_ANY_KEY )
    USER_HIT_ANY_KEY = .FALSE. ! This will ignore any recent keystrokes.
    PRINT *, " Hit any key to terminate iterations!"
    DO I = 1,100
      ... <i>Compute</i> <i>a</i> <i>value</i> <i>for</i> <i>R.</i>
      PRINT *, I, R
      IF (USER_HIT_ANY_KEY) EXIT
    ENDDO
    ! Have the OS stop looking for user keystrokes.
    CALL OS_STOP_DETECT_USER_KEYSTROKE
   END SUBROUTINE TERMINATE_ITERATIONS
<b>C.5</b> <b>Clause</b> <b>9</b> <b>notes</b>
<b>C.5.1</b> <b>Structure</b> <b>components</b> <b>(9.4.2)</b>
Components of a structure are referenced by writing the components of successive levels of the structure hierarchy
until the desired component is described. For example,
   TYPE ID_NUMBERS
     INTEGER SSN
     INTEGER EMPLOYEE_NUMBER
   END TYPE ID_NUMBERS
   TYPE PERSON_ID
     CHARACTER (LEN=30) LAST_NAME
     CHARACTER (LEN=1) MIDDLE_INITIAL
     CHARACTER (LEN=30) FIRST_NAME
     TYPE (ID_NUMBERS) NUMBER
   END TYPE PERSON_ID
   TYPE PERSON
     INTEGER AGE
     TYPE (PERSON_ID) ID
   END TYPE PERSON
   TYPE (PERSON) GEORGE, MARY
   PRINT *, GEORGE % AGE ! Print the AGE component
   PRINT *, MARY % ID % LAST_NAME ! Print LAST_NAME of MARY
   PRINT *, MARY % ID % NUMBER % SSN ! Print SSN of MARY
   PRINT *, GEORGE % ID % NUMBER ! Print SSN and EMPLOYEE_NUMBER of GEORGE
A structure component can be a data object of intrinsic type as in the case of GEORGE % AGE or it can be
of derived type as in the case of GEORGE % ID % NUMBER. The resultant component can be a scalar or an
array of intrinsic or derived type.
   TYPE LARGE
     INTEGER ELT (10)
     INTEGER VAL
   END TYPE LARGE
   TYPE (LARGE) A (5) ! 5 element array, each of whose elements
                ! includes a 10 element array ELT and
                ! a scalar VAL.
   PRINT *, A (1) ! Prints 10 element array ELT and scalar VAL.
   PRINT *, A (1) % ELT (3) ! Prints scalar element 3
                ! of array element 1 of A.
   PRINT *, A (2:4) % VAL ! Prints scalar VAL for array elements
                ! 2 to 4 of A.
Components of an object of extensible type that are inherited from the parent type can be accessed as a whole
by using the parent component name, or individually, either with or without qualifying them by the parent
component name. For example:
   TYPE POINT ! A base type
    REAL :: X, Y
   END TYPE POINT
   TYPE, EXTENDS(POINT) :: COLOR_POINT ! An extension of TYPE(POINT)
    ! Components X and Y, and component name POINT, inherited from parent
    INTEGER :: COLOR
   END TYPE COLOR_POINT
   TYPE(POINT), PARAMETER :: PV = POINT(1.0, 2.0)
   TYPE(COLOR_POINT) :: CPV = COLOR_POINT(POINT=PV, COLOR=3)
   PRINT *, CPV%POINT ! Prints 1.0 and 2.0
   PRINT *, CPV%POINT%X, CPV%POINT%Y ! And this does, too
   PRINT *, CPV%X, CPV%Y ! And this does, too
<b>C.5.2</b> <b>Allocation</b> <b>with</b> <b>dynamic</b> <b>type</b> <b>(9.7.1)</b>
The following example illustrates the use of allocation with the value and dynamic type of the allocated object
given by another object. The example copies a list of objects of any type. It copies the list starting at IN_LIST.
After copying, each element of the list starting at LIST_COPY has a polymorphic component, ITEM, for which
both the value and type are taken from the ITEM component of the corresponding element of the list starting at
IN_LIST.
   TYPE :: LIST ! A list of anything
    TYPE(LIST), POINTER :: NEXT => NULL()
    CLASS(*), ALLOCATABLE :: ITEM
   END TYPE LIST
   ...
   TYPE(LIST), POINTER :: IN_LIST, LIST_COPY => NULL()
   TYPE(LIST), POINTER :: IN_WALK, NEW_TAIL
   ! Copy IN_LIST to LIST_COPY
   IF (ASSOCIATED(IN_LIST)) THEN
    IN_WALK => IN_LIST
    ALLOCATE(LIST_COPY)
    NEW_TAIL => LIST_COPY
    DO
     ALLOCATE(NEW_TAIL%ITEM, SOURCE=IN_WALK%ITEM)
     IN_WALK => IN_WALK%NEXT
     IF (.NOT. ASSOCIATED(IN_WALK)) EXIT
     ALLOCATE(NEW_TAIL%NEXT)
     NEW_TAIL => NEW_TAIL%NEXT
    END DO
   END IF
<b>C.6</b> <b>Clause</b> <b>10</b> <b>notes</b>
<b>C.6.1</b> <b>Evaluation</b> <b>of</b> <b>function</b> <b>references</b> <b>(10.1.7)</b>
If more than one function reference appears in a statement, they can be executed in any order (subject to a
function result being evaluated after the evaluation of its arguments) and their values cannot depend on the order
of execution. This lack of dependence on order of evaluation enables parallel execution of the function references.
<b>C.6.2</b> <b>Pointers</b> <b>in</b> <b>expressions</b> <b>(10.1.9.2)</b>
A data pointer is considered to be like any other variable when it is used as a primary in an expression. If a
pointer is used as an operand to an operator that expects a value, the pointer will automatically deliver the value
stored in the space described by the pointer, that is, the value of the target object associated with the pointer.
<b>C.6.3</b> <b>Pointers</b> <b>in</b> <b>variable</b> <b>definition</b> <b>contexts</b> <b>(10.2.1.3,</b> <b>19.6.7)</b>
The appearance of a data pointer in a context that requires its value is a reference to its target. Similarly, where
a pointer appears in a variable definition context the variable that is defined is the target of the pointer.
Executing the program fragment
   REAL, POINTER :: A
   REAL, TARGET :: B = 10.0
   A => B
   A = 42.0
   PRINT '(F4.1)', B
produces "42.0" as output.
<b>C.7</b> <b>Clause</b> <b>11</b> <b>notes</b>
<b>C.7.1</b> <b>The</b> <b>SELECT</b> <b>CASE</b> <b>construct</b> <b>(11.1.9)</b>
At most one case block is selected for execution within a SELECT CASE construct, and there is no fall-through
from one block into another block within a SELECT CASE construct. Thus there is no requirement for the user
to exit explicitly from a block.
<b>C.7.2</b> <b>Loop</b> <b>control</b> <b>(11.1.7)</b>
Fortran provides several forms of loop control:
  (1) With an iteration count and a DO variable. This is the classic Fortran DO loop.
  (2) Test a logical condition before each execution of the loop (DO WHILE).
  (3) DO "forever".
<b>C.7.3</b> <b>Examples</b> <b>of</b> <b>DO</b> <b>constructs</b> <b>(11.1.7)</b>
The following are all valid examples of DO constructs.
<b>Example</b> <b>1:</b>
   SUM = 0.0
   READ (IUN) N
   OUTER: DO L = 1, N ! A DO with a construct name
     READ (IUN) IQUAL, M, ARRAY (1:M)
     IF (IQUAL < IQUAL_MIN) CYCLE OUTER ! Skip inner loop
     INNER: DO 40 I = 1, M ! A DO with a label and a name
      CALL CALCULATE (ARRAY (I), RESULT)
      IF (RESULT < 0.0) CYCLE
      SUM = SUM + RESULT
      IF (SUM > SUM_MAX) EXIT OUTER
 40 END DO INNER
   END DO OUTER
The outer loop has an iteration count of MAX (N, 0), and will execute that number of times or until SUM exceeds
SUM_MAX, in which case the EXIT OUTER statement terminates both loops. The inner loop is skipped by
the first CYCLE statement if the quality flag, IQUAL, is too low. If CALCULATE returns a negative RESULT,
the second CYCLE statement prevents it from being summed. Both loops have construct names and the inner
loop also has a label. A construct name is required in the EXIT statement in order to terminate both loops, but
is optional in the CYCLE statements because each belongs to its innermost loop.
<b>Example</b> <b>2:</b>
   N = 0
   DO 50, I = 1, 10
     J = I
     DO K = 1, 5
      L = K
      N = N + 1 ! This statement executes 50 times
     END DO ! Nonlabeled DO inside a labeled DO
 50 CONTINUE
After execution of the above program fragment, I = 11, J = 10, K = 6, L = 5, and N = 50.
<b>Example</b> <b>3:</b>
   N = 0
   DO I = 1, 10
     J = I
     DO 60, K = 5, 1 ! This inner loop is never executed
      L = K
      N = N + 1
 60 CONTINUE ! Labeled DO inside a nonlabeled DO
   END DO
After execution of the above program fragment, I = 11, J = 10, K = 5, N = 0, and L is not defined by these
statements.
<b>C.7.4</b> <b>Examples</b> <b>of</b> <b>invalid</b> <b>DO</b> <b>constructs</b> <b>(11.1.7)</b>
The following are all examples of invalid skeleton DO constructs:
<b>Example</b> <b>1:</b>
   DO I = 1, 10
     ...
   END DO LOOP ! No matching construct name
<b>Example</b> <b>2:</b>
   LOOP: DO 1000 I = 1, 10 ! No matching construct name
     ...
   1000 CONTINUE
<b>Example</b> <b>3:</b>
   LOOP1: DO
     ...
   END DO LOOP2 ! Construct names don't match
<b>Example</b> <b>4:</b>
   DO I = 1, 10 ! Label required or ...
     ...
   1010 CONTINUE ! ... END DO required
<b>Example</b> <b>5:</b>
   DO 1020 I = 1, 10
     ...
   1021 END DO ! Labels don't match
<b>Example</b> <b>6:</b>
   FIRST: DO I = 1, 10
     SECOND: DO J = 1, 5
      ...
     END DO FIRST ! Improperly nested DOs
   END DO SECOND
<b>C.7.5</b> <b>Simple</b> <b>example</b> <b>using</b> <b>events</b>
A tree is a graph in which every node except one has a single "parent" node to which it is connected by an edge.
The node without a parent is the "root" of the tree. The nodes that have a particular node as their parent are
the "children" of that node. The root is at level 1, its children are at level 2, and so on.
A multifrontal code to solve a sparse set of linear equations involves a tree. Work at a node can start after all of
its children's work is complete and their data have been passed to it.
Here we assume that each node has been assigned to an image. Each image has a list of its nodes and these
are ordered in decreasing tree level (all those at level <i>L</i> preceding those at level <i>L</i>- 1). For each node, array
elements hold the number of children, details about the parent, and an event variable. This allows the processing
to proceed asynchronously subject to the rule that a parent has to wait for all its children.
<b>Outline</b> <b>of</b> <b>example</b> <b>code:</b>
   PROGRAM TREE
    USE, INTRINSIC :: ISO_FORTRAN_ENV
    INTEGER, ALLOCATABLE :: NODE (:) ! Tree nodes that this image handles.
    INTEGER, ALLOCATABLE :: NC (:) ! NODE(I) has NC(I) children.
    INTEGER, ALLOCATABLE :: PARENT (:), SUB (:)
      ! The parent of NODE (I) is NODE (SUB (I)) [PARENT (I)].
    TYPE (EVENT_TYPE), ALLOCATABLE :: DONE (:) [:]
    INTEGER :: I, J, STATUS
    ! Set up the tree, including allocation of all arrays.
    DO I = 1, SIZE (NODE)
     ! Wait for children to complete
     IF (NC (I) > 0) THEN
      EVENT WAIT (DONE (I), UNTIL_COUNT=NC (I), STAT=STATUS)
      IF (STATUS/=0) EXIT
     END IF
     ! Process node, using data from children.
     IF (PARENT (I)>0) THEN
      ! Node is not the root.
      ! Place result on image PARENT (I) for node NODE (SUB) [PARENT (I)]
      ! Tell PARENT (I) that this has been done.
      EVENT POST (DONE (SUB (I)) [PARENT (I)], STAT=STATUS)
      IF (STATUS/=0) EXIT
     END IF
    END DO
   END PROGRAM TREE
<b>C.7.6</b> <b>Example</b> <b>using</b> <b>three</b> <b>teams</b>
The following example illustrates the structure of a routine that will compute fluxes based on surface properties
over land, sea, and ice, each in a different team. Each image will deal with areas containing exactly one of the
three surface types.
   SUBROUTINE COMPUTE_FLUXES (FLUX_MOM, FLUX_SENS, FLUX_LAT)
   USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: TEAM_TYPE
   REAL, INTENT (OUT) :: FLUX_MOM (:,:), FLUX_SENS (:,:), FLUX_LAT (:,:)
   INTEGER, PARAMETER :: LAND = 1, SEA = 2, ICE = 3
   CHARACTER (LEN=10) :: SURFACE_TYPE
   INTEGER :: MY_SURFACE_TYPE, N_IMAGE
   TYPE (TEAM_TYPE) :: TEAM_SURFACE_TYPE
     CALL GET_SURFACE_TYPE(THIS_IMAGE (), SURFACE_TYPE)
     SELECT CASE (SURFACE_TYPE)
     CASE ("LAND")
      MY_SURFACE_TYPE = LAND
     CASE ("SEA")
      MY_SURFACE_TYPE = SEA
     CASE ("ICE")
      MY_SURFACE_TYPE = ICE
     CASE DEFAULT
      ERROR STOP
     END SELECT
     FORM TEAM (MY_SURFACE_TYPE, TEAM_SURFACE_TYPE)
     CHANGE TEAM (TEAM_SURFACE_TYPE)
      SELECT CASE (TEAM_NUMBER ( ))
      CASE (LAND) ! Compute fluxes over land surface
        CALL COMPUTE_FLUXES_LAND (FLUX_MOM, FLUX_SENS, FLUX_LAT)
      CASE (SEA) ! Compute fluxes over sea surface
        CALL COMPUTE_FLUXES_SEA (FLUX_MOM, FLUX_SENS, FLUX_LAT)
      CASE (ICE) ! Compute fluxes over ice surface
        CALL COMPUTE_FLUXES_ICE (FLUX_MOM, FLUX_SENS, FLUX_LAT)
      CASE DEFAULT
        ERROR STOP
      END SELECT
     END TEAM
   END SUBROUTINE COMPUTE_FLUXES
<b>C.7.7</b> <b>Accessing</b> <b>coarrays</b> <b>in</b> <b>sibling</b> <b>teams</b>
The following program illustrates subdividing a 4x 4 grid into 2x 2 teams, and the denotation of sibling teams.
   PROGRAM DEMO
    ! Initial team : 16 images. Algorithm design is a 4 by 4 grid.
    ! Desire 4 teams, for the upper left (UL), upper right (UR),
    ! lower left (LL), lower right (LR)
    USE,INTRINSIC :: ISO_FORTRAN_ENV, ONLY: TEAM_TYPE
    TYPE (TEAM_TYPE) :: T
    INTEGER, PARAMETER :: UL=11, UR=22, LL=33, LR=44
    REAL :: A(10,10)[4,*]
    INTEGER :: MYPE, TEAMNUM, NEWPE
    TYPE TRANS_T
     INTEGER :: NEW_TEAM (16), NEW_INDEX (16)
    END TYPE
    TYPE (TRANS_T) :: TRANS
    TRANS = TRANS_T ([UL, UL, LL, LL, UL, UL, LL, LL, UR, UR, LR, LR, UR, UR, LR, LR], &
             [1, 2, 1, 2, 3, 4, 3, 4, 1, 2, 1, 2, 3, 4, 3, 4])
    MYPE = THIS_IMAGE ()
    FORM TEAM (TRANS%NEW_TEAM(MYPE), T, NEW_INDEX=TRANS%NEW_INDEX(MYPE))
    A = 3.14
    CHANGE TEAM (T, B[2,*] => A)
     ! Inside change team, image pattern for B is a 2 by 2 grid.
     B (5, 5) = B (1, 1)[2, 1]
     ! Outside the team addressing:
     NEWPE = THIS_IMAGE ()
     SELECT CASE (TEAM_NUMBER ())
     CASE (UL)
       IF (NEWPE==3) THEN
        ! Right column of UL gets left column of UR.
        B (:, 10) = B (:, 1)[1, 1, TEAM_NUMBER=UR]
       ELSE IF (NEWPE==4) THEN
        B (:, 10) = B (:, 1)[2, 1, TEAM_NUMBER=UR]
       END IF
     CASE (LL)
       ! Similar to complete column exchange across middle of the original grid.
       ...
     END SELECT
     END TEAM
   END PROGRAM DEMO
<b>C.7.8</b> <b>Example</b> <b>involving</b> <b>failed</b> <b>images</b>
Parallel algorithms often use work sharing schemes based on a specific mapping between image indices and global
data addressing. To allow such programs to continue when one or more images fail, spare images can be used
to re-establish execution of the algorithm with the failed images replaced by spare images, while retaining the
previous image mapping for nonfailed images.
The following example illustrates how this might be done. In this example, failure cannot be tolerated for image
one in the initial team.
   PROGRAM possibly_recoverable_simulation
    USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY:TEAM_TYPE, STAT_FAILED_IMAGE
    IMPLICIT NONE
    INTEGER :: images_spare ! Number of spare images.
    INTEGER :: images_used ! Number of images used.
    INTEGER :: j, k ! Temporaries
    INTEGER :: status ! STAT= value
    INTEGER :: team_number [*] ! 1 if in working team; 2 otherwise.
    INTEGER :: local_index [*] ! Index of the image in the team.
    TYPE (TEAM_TYPE) :: simulation_team
    LOGICAL :: done [*] ! True if computation finished on the image.
    ! Keep 1% spare images if we have a lot, just 1 if 10-199 images,
    ! 0 if <10.
    images_spare = MAX(NUM_IMAGES()/100,0,MIN(NUM_IMAGES()-9,1))
    images_used = NUM_IMAGES () - images_spare
    SYNC ALL (STAT=status)
    outer : DO
     IF (status/=0 .AND. status/=STAT_FAILED_IMAGE) EXIT outer
     IF (IMAGE_STATUS (1) == STAT_FAILED_IMAGE) ERROR STOP "cannot recover"
     IF (THIS_IMAGE () == 1) THEN
      j = 0
      DO k = 1, NUM_IMAGES ()
       IF (IMAGE_STATUS (k) == 0) THEN
        j = j+1
        IF (j<=images_used) THEN
         local_index[k] = j
         team_number [k] = 1
        ELSE
         local_index[k] = j - images_used
         team_number [k] = 2
        END IF
       END IF
      END DO
      IF (j<images_used) ERROR STOP "cannot recover"
     END IF
     SYNC ALL (STAT = status)
     IF (status/=0 .AND. status/=STAT_FAILED_IMAGE) EXIT outer
     ! Set up a simulation team of constant size.
     ! Team 2 is the set of spares, so does not participate.
     FORM TEAM (team_number, simulation_team, NEW_INDEX=local_index, STAT=status)
     IF (status/=0 .AND. status/=STAT_FAILED_IMAGE) EXIT outer
     simulation : CHANGE TEAM (simulation_team, STAT=status)
      IF (status == STAT_FAILED_IMAGE) EXIT simulation
      IF (team_number == 1) THEN
       ! Each working image reads checkpoint data for itself if available.
       iter : DO
        CALL simulation_procedure (status, done)
        ! The simulation_procedure:
        ! - sets up and performs some part of the simulation;
        ! - stores checkpoint data for all images from time to time;
        ! - sets status from its internal synchronizations so it has
        ! the value STAT_FAILED_IMAGE on all active images of the
        ! team if any image of the team has failed;
        ! - sets done to .TRUE. when the simulation has completed.
        IF (status == STAT_FAILED_IMAGE) THEN
         EXIT simulation
        ELSE IF (done) THEN
         EXIT iter
        END IF
       END DO iter
      END IF
     END TEAM (STAT=status) simulation
     IF (status/=0 .AND. status/=STAT_FAILED_IMAGE) EXIT outer
     SYNC ALL (STAT=status)
     IF (team_number == 2) done = done[1]
     IF (done) EXIT outer
    END DO outer
    IF (status/=0 .AND. status/=STAT_FAILED_IMAGE) PRINT *,'Unexpected failure',status
   END PROGRAM possibly_recoverable_simulation
Supporting fault-tolerant execution imposes obligations on library writers who use the parallel language facilities.
Every synchronization statement, allocation or deallocation of coarrays, or invocation of a collective procedure
will need to be prepared to handle error conditions, and implicit deallocation of coarrays will need to be avoided.
Also, coarray module variables that are allocated inside the team execution context are not persistent.
<b>C.7.9</b> <b>EVENT_QUERY</b> <b>example</b> <b>that</b> <b>tolerates</b> <b>image</b> <b>failure</b>
This example is an adaptation of the later EVENT_QUERY example of C.12.2 to make it able to execute in
the presence of the failure of one or more of the worker images. The function create_work_item now accepts an
integer argument to indicate which work item is required. It is assumed that the work items are indexed 1, 2, and
so on. It is also assumed that if an image fails while processing a work item, that work item can subsequently be
processed by another image.
   PROGRAM work_share
     USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: EVENT_TYPE
     USE :: mod_work, ONLY: & ! Module that creates work items
        work, & ! Type for holding a work item
        create_work_item, & ! Function that creates work item
        process_item, & ! Function that processes an item
        work_done ! Logical function that returns true
                  ! if all work done
     TYPE :: worker_type
      TYPE (EVENT_TYPE), ALLOCATABLE :: free (:)
     END TYPE
     TYPE (EVENT_TYPE) :: submit [*] ! Whether work ready for a worker
     TYPE (worker_type) :: worker [*] ! Whether worker is free
     TYPE (work) :: work_item [*] ! Holds the data for a work item
     INTEGER :: count, i, k, kk, nbusy [*], np, status
     INTEGER, ALLOCATABLE :: working (:) ! Items being worked on
     INTEGER, ALLOCATABLE :: pending (:) ! Items pending after image failure
     IF (THIS_IMAGE () == 1) THEN
      ! Get started
      ALLOCATE (worker%free (2:NUM_IMAGES ()))
      ALLOCATE (working (2: NUM_IMAGES ()), pending(NUM_IMAGES ()-1))
      nbusy = 0 ! This holds the number of workers working
      k = 1 ! Index of next work item
      np = 0 ! Number of work items in array pending
      DO i = 2, NUM_IMAGES () ! Start the workers working
        IF (work_done ()) EXIT
        working (i) = 0
        IF (IMAGE_STATUS (i) == STAT_FAILED_IMAGE) CYCLE
        work_item [i] = create_work_item (k)
        working (i) = k
        k = k + 1
        nbusy = nbusy + 1
        EVENT POST (submit [i], STAT=status)
      END DO
      ! Main work distribution loop
      main : DO
        image : DO i = 2, NUM_IMAGES ()
         IF (IMAGE_STATUS (i) == STAT_FAILED_IMAGE) THEN
          IF (working (i)>0) THEN ! It failed while working
            np = np + 1
            pending (np) = working (i)
            working (i) = 0
          END IF
          CYCLE image
         END IF
         CALL EVENT_QUERY (worker%free (i), count)
         IF (count == 0) CYCLE image ! Worker is not free
         EVENT WAIT (worker%free (i))
         nbusy = nbusy - 1
         IF (np>0) THEN
          kk = pending (np)
          np = np - 1
         ELSE
          IF (work_done ()) CYCLE image
          kk = k
          k = k + 1
         END IF
         nbusy = nbusy + 1
         working (i) = kk
         work_item [i] = create_work_item (kk)
         EVENT POST (submit [i], STAT=status)
         ! If image i has failed, the failure will be handled on
         ! the next iteration of the main loop.
        END DO image
        IF ( nbusy==0 ) THEN ! All done. Exit on all images.
         DO i = 2, NUM_IMAGES ()
          EVENT POST (submit [i], STAT=status)
          IF (status == STAT_FAILED_IMAGE) CYCLE
         END DO
         EXIT main
        END IF
      END DO main
     ELSE
      ! Work processing loop
      worker : DO
        EVENT WAIT (submit)
        IF (nbusy [1] == 0) EXIT worker
        CALL process_item(work_item)
        EVENT POST (worker[1]%free (THIS_IMAGE ()))
      END DO worker
     END IF
   END PROGRAM work_share
<b>C.8</b> <b>Clause</b> <b>12</b> <b>notes</b>
<b>C.8.1</b> <b>External</b> <b>files</b> <b>(12.3)</b>
<b>C.8.1.1</b> <b>File</b> <b>cataloging</b>
This document accommodates, but does not require, file cataloging. To do this, several concepts are introduced.
<b>C.8.1.2</b> <b>File</b> <b>existence</b> <b>(12.3.2)</b>
Totally independent of the connection state is the property of existence, this being a file property. The processor
"knows" of a set of files that exist at a given time for a given program. This set would include tapes ready to
read, files in a catalog, a keyboard, a printer, etc. The set might exclude files inaccessible to the program because
of security, because they are already in use by another program, etc. This document does not specify which
files exist, hence wide latitude is available to a processor to implement security, locks, privilege techniques, etc.
Existence is a convenient concept to designate all of the files that a program can potentially process.
All four combinations of connection and existence can occur:
         Connect Exist Examples
         Yes Yes A card reader loaded and ready to be read
         Yes No A printer before the first line is written
         No Yes A file named 'JOAN' in the catalog
         No No A file on a reel of tape, not known to the processor
Means are provided to create, delete, connect, and disconnect files.
<b>C.8.1.3</b> <b>File</b> <b>access</b> <b>(12.3.3)</b>
This document does not address problems of security, protection, locking, and many other concepts that might
be part of the concept of "right of access". Such concepts are considered to be in the province of an operating
system.
The OPEN and INQUIRE statements can be extended naturally to consider these things.
Possible access methods for a file are: sequential, stream and direct. The processor might implement three
different types of files, each with its own access method. It might instead implement one type of file with three
different access methods.
Direct access to files is of a simple and commonly available type, that is, fixed-length records. The key is a
positive integer.
<b>C.8.1.4</b> <b>File</b> <b>connection</b> <b>(12.5)</b>
Before any input/output can be performed on a file, it needs to be connected to a unit. The unit then serves as a
designator for that file as long as it is connected. To be connected does not imply that "buffers" have or have not
been allocated, that "file-control tables" have or have not been filled, or that any other method of implementation
has been used. Connection means that (barring some other fault) a READ or WRITE statement can be executed
on the unit, hence on the file. Without a connection, a READ or WRITE statement cannot be executed.
<b>C.8.1.5</b> <b>File</b> <b>names</b> <b>(12.5.6.10)</b>
A file can have a name. The form of a file name is not specified. If a system does not have some form of cataloging
or tape labeling for at least some of its files, all file names disappear at the termination of execution. This is a
valid implementation. Nowhere does this document require names to survive for any period of time longer than
the execution time span of a program. Therefore, this document does not impose cataloging as a prerequisite.
The naming feature is intended to enable use of a cataloging system where one exists.
<b>C.8.2</b> <b>Nonadvancing</b> <b>input/output</b> <b>(12.3.4.2)</b>
Data transfer statements affect the positioning of an external file. In Fortran 77, if no error or end-of-file
condition exists, the file is positioned after the record just read or written and that record becomes the preceding
record. This document contains the ADVANCE= specifier in a data transfer statement that provides the capab-
ility of maintaining a position within the current record from one formatted data transfer statement to the next
data transfer statement. The value NO provides this capability. The value YES positions the file after the record
just read or written. The default is YES.
The tab edit descriptor and the slash are still appropriate for use with this type of record access but the tab
cannot reposition before the left tab limit.
A BACKSPACE of a file that is positioned within a record causes the specified unit to be positioned before the
current record.
If the next input/output operation on a file after a nonadvancing write is a rewind, backspace, end file or close
operation, the file is positioned implicitly after the current record before an ENDFILE record is written to the
file, that is, a REWIND, BACKSPACE, or ENDFILE statement following a nonadvancing WRITE statement
causes the file to be positioned at the end of the current output record before the endfile record is written to the
file.
This document provides a SIZE= specifier to be used with formatted data transfer statements. The variable in
the SIZE= specifier is assigned the count of the number of characters that make up the sequence of values read
by the data edit descriptors in the input statement. The count is especially helpful if there is only one effective
item in the input list because it is the number of characters that appeared for the item.
The EOR= specifier is provided to indicate when an EOR condition is encountered during nonadvancing input.
The EOR condition is not an error condition. If this specifier appears, an effective item that requires more
characters than the record contained is padded with blanks if PAD= 'YES' is in effect. This means that input of
the effective item completed successfully. The file is positioned after the current record. If the IOSTAT= specifier
appears, the specified variable is defined with the value of the named constant IOSTAT_EOR from the intrinsic
module ISO_FORTRAN_ENV and the data transfer statement is terminated. Program execution continues
with the statement specified in the EOR= specifier. The EOR= specifier gives the capability of taking control
of execution when the EOR condition is encountered. The <i>do-variable</i>s in <i>io-implied-do</i>s retain their last defined
value and any remaining items in the <i>input-item-list</i> retain their definition status when an EOR condition occurs.
If the SIZE= specifier appears, the specified variable is assigned the number of characters read with the data edit
descriptors during the READ statement.
For nonadvancing input, the processor is not required to read partial records. The processor could read the entire
record into an internal buffer and make successive portions of the record available to successive input statements.
In an implementation of nonadvancing input/output in which a nonadvancing write to a terminal device causes
immediate display of the output, such a write can be used as a mechanism to output a prompt. In this case, the
statement
   WRITE (*, FMT='(A)', ADVANCE='NO') 'CONTINUE?(Y/N): '
would result in the prompt
   CONTINUE?(Y/N):
being displayed with no subsequent line feed.
The response, which might be read by a statement of the form
   READ (*, FMT='(A)') ANSWER
can then be entered on the same line as the prompt as in
   CONTINUE?(Y/N): Y
This document does not require that an implementation of nonadvancing input/output operate in this manner.
For example, an implementation of nonadvancing output in which the display of the output is deferred until
the current record is complete is also standard-conforming. Such an implementation will not, however, allow a
prompting mechanism of this kind to operate.
<b>C.8.3</b> <b>OPEN</b> <b>statement</b> <b>(12.5.6)</b>
A file can become connected to a unit either by preconnection or by execution of an OPEN statement. Precon-
nection is performed prior to the beginning of execution of a program by means external to Fortran. For example,
it could be done by job control action or by processor-established defaults. Execution of an OPEN statement is
not required in order to access preconnected files (12.5.5).
The OPEN statement provides a means to access existing files that are not preconnected. An OPEN statement
can be used in either of two ways: with a file name (open-by-name) and without a file name (open-by-unit). A
unit is given in either case. Open-by-name connects the specified file to the specified unit. Open-by-unit connects
a processor-dependent default file to the specified unit. (The default file might or might not have a name.)
Therefore, there are three ways a file can become connected and hence processed: preconnection, open-by-name,
and open-by-unit. Once a file is connected, there is no means in standard Fortran to determine how it became
connected.
An OPEN statement can also be used to create a new file. In fact, any of the foregoing three connection methods
can be performed on a file that does not exist. When a unit is preconnected, writing the first record creates the
file. With the other two methods, execution of the OPEN statement creates the file.
When an OPEN statement is executed, the unit specified in the OPEN statement might or might not already be
connected to a file. If it is already connected to a file (either through preconnection or by prior execution of an
OPEN statement), then omitting the FILE= specifier in the OPEN statement implies that the file is to remain
connected to the unit. Such an OPEN statement can be used to change the values of the blank interpretation
mode, decimal edit mode, pad mode, input/output rounding mode, delimiter mode, and sign mode.
If the value of the ACTION= specifier is WRITE, then a READ statement cannot refer to the connection.
ACTION = 'WRITE' does not restrict positioning by a BACKSPACE statement or positioning specified by the
POSITION= specifier with the value APPEND. However, a BACKSPACE statement or an OPEN statement
containing POSITION = 'APPEND' might fail if the processor needs to read the file to achieve the positioning.
The following examples illustrate these rules. In the first example, unit 10 is preconnected to a SCRATCH file;
the OPEN statement changes the value of PAD= to YES.
   CHARACTER (LEN = 20) CH1
   WRITE (10, '(A)') 'THIS IS RECORD 1'
   OPEN (UNIT = 10, STATUS = 'OLD', PAD = 'YES')
   REWIND 10
   READ (10, '(A20)') CH1 ! CH1 now has the value
                ! 'THIS IS RECORD 1 '
In the next example, unit 12 is first connected to a file named FRED, with a status of OLD. The second OPEN
statement then opens unit 12 again, retaining the connection to the file FRED, but changing the value of the
DELIM= specifier to QUOTE.
   CHARACTER (LEN = 25) CH2, CH3
   OPEN (12, FILE = 'FRED', STATUS = 'OLD', DELIM = 'NONE')
   CH2 = '"THIS STRING HAS QUOTES."'
          ! Quotes in string CH2
   WRITE (12, *) CH2 ! Written with no delimiters
   OPEN (12, DELIM = 'QUOTE') ! Now quote is the delimiter
   REWIND 12
   READ (12, *) CH3 ! CH3 now has the value
            ! 'THIS STRING HAS QUOTES. '
The next example is invalid because it attempts to change the value of the STATUS= specifier.
   OPEN (10, FILE = 'FRED', STATUS = 'OLD')
   WRITE (10, *) A, B, C
   OPEN (10, STATUS = 'SCRATCH') ! Attempts to make FRED a SCRATCH file
The previous example could be made valid by closing the unit first, as in the next example.
   OPEN (10, FILE = 'FRED', STATUS = 'OLD')
   WRITE (10, *) A, B, C
   CLOSE (10)
   OPEN (10, STATUS = 'SCRATCH') ! Opens a different SCRATCH file
<b>C.8.4</b> <b>Connection</b> <b>properties</b> <b>(12.5.4)</b>
When a unit becomes connected to a file, either by execution of an OPEN statement or by preconnection, the
following connection properties, among others, are established.
  (1) An access method, which is sequential, direct, or stream, is established for the connection (12.5.6.3).
  (2) A form, which is formatted or unformatted, is established for a connection to a file that exists or
     is created by the connection. For a connection that results from execution of an OPEN statement,
     a default form (which depends on the access method, as described in 12.3.3) is established if no
     form is specified. For a preconnected file that exists, a form is established by preconnection. For a
     preconnected file that does not exist, a form might be established, or the establishment of a form
     might be delayed until the file is created (for example, by execution of a formatted or unformatted
     WRITE statement) (12.5.6.11).
  (3) A record length might be established. If the access method is direct, the connection establishes a
     record length that specifies the length of each record of the file. A direct access file can only contain
     records that are all of equal length.
  (4) A sequential file can contain records of varying lengths. In this case, the record length established
     specifies the maximum length of a record in the file (12.5.6.16).
A processor has wide latitude in adapting these concepts and actions to its own cataloging and job control
conventions. Some processors might need job control action to specify the set of files that exist or that will
be created by a program. Some processors might not need any job control action prior to execution. This
document enables processors to perform dynamic open, close, or file creation operations, but it does not require
such capabilities of the processor.
The meaning of "open" in contexts other than Fortran might include such things as mounting a tape, console
messages, spooling, label checking, security checking, etc. These actions might occur upon job control action
external to Fortran, upon execution of an OPEN statement, or upon execution of the first read or write of the
file. The OPEN statement describes properties of the connection to the file and might or might not cause physical
activities to take place.
<b>C.8.5</b> <b>Asynchronous</b> <b>input/output</b> <b>(12.6.2.5)</b>
Rather than limit support for asynchronous input/output to what has been traditionally provided by facilities
such as BUFFERIN/BUFFEROUT, this document builds upon existing Fortran syntax. This permits alternative
approaches for implementing asynchronous input/output, and simplifies the task of adapting existing standard-
conforming programs to use asynchronous input/output.
Not all processors actually perform input/output asynchronously, nor will every processor that does be able to
handle data transfer statements with complicated input/output item lists in an asynchronous manner. Such
processors can still be standard-conforming.
This document allows for at least two different conceptual models for asynchronous input/output.
Model 1: the processor performs asynchronous input/output when the item list is simple (perhaps one contiguous
named array) and the input/output is unformatted. The implementation cost is reduced, and this is the scenario
most likely to be beneficial on traditional "big-iron" machines.
Model 2: The processor is free to do any of the following:
  (1) on output, create a buffer inside the input/output library, completely formatted, and then start an
     asynchronous write of the buffer, and immediately return to the next statement in the program. The
     processor is free to wait for previously issued WRITEs, or not, or
  (2) pass the input/output list addresses to another processor/process, which processes the list items
     independently of the processor that executes the user's code. The addresses of the list items will
     need to be computed before the asynchronous READ/WRITE statement completes. There is still
     an ordering requirement on list item processing to handle things like READ (...) N,(a(i),i=1,N).
A program can issue a large number of asynchronous input/output requests, without waiting for any of them to
complete, and then wait for any or all of them. That does not constitute a requirement for the processor to keep
track of each individual request separately.
It is not necessary for all requests to be tracked by the runtime library. If an ID= specifier does not appear in on a
READ or WRITE statement, the runtime library can forget about this particular request once it has successfully
completed. If an error or end-of-file condition occurs for a request, the processor can report this during any
input/output operation to that unit. If an ID= specifier appears, the processor's runtime input/output library
will need to keep track of any end-of-file or error conditions for that particular input/output request. However, if
the input/output request succeeds without any exceptional conditions occurring, then the runtime can forget that
ID= value. A runtime library might only keep track of the last request made, or perhaps a very few. Then, when
a user WAITs for a particular request, either the library will know about it (and does the right thing with respect
to error handling, etc.), or can assume it is a request that successfully completed and was forgotten about (and
will just return without signaling any end-of-file or error condition). A standard-conforming program can only
pass valid ID= values, but there is no requirement on the processor to detect invalid ID= values. There might
be a processor dependent limit on how many outstanding input/output requests that generate an end-of-file or
error condition can be handled before the processor runs out of memory to keep track of such conditions. The
restrictions on the SIZE= variables are designed to enable the processor to update such variables at any time
(after the request has been processed, but before the wait operation), and then forget about them. Only error and
end-of-file conditions are expected to be tracked by individual request by the runtime, and then only if an ID=
specifier appears. The END= and EOR= specifiers have not been added to all statements that can perform wait
operations. Instead, the IOSTAT variable can be queried after a wait operation to handle this situation. This
choice was made because the WAIT statement is expected to be the usual method of waiting for input/output
to complete (and WAIT does support the END= and EOR= specifiers). This particular choice is philosophical,
and was not based on significant technical difficulties.
The requirement to set the IOSTAT variable correctly means that a processor will need to remember which
input/output requests encountered an end-of-record condition, so that a subsequent wait operation can return
the correct IOSTAT value. Therefor there might be a processor defined limit on the number of outstanding
nonadvancing input/output requests that have encountered an end-of-record condition (constrained by available
memory to keep track of this information, similar to end-of-file and error conditions).
<b>C.9</b> <b>Clause</b> <b>13</b> <b>notes</b>
<b>C.9.1</b> <b>Number</b> <b>of</b> <b>records</b> <b>(13.4,</b> <b>13.5,</b> <b>13.8.2)</b>
The number of records read by an explicitly formatted advancing input statement can be determined from the
following rule: a record is read at the beginning of the format scan (even if the input list is empty unless the most
recently previous operation on the unit was not a nonadvancing read operation), at each slash edit descriptor
encountered in the format, and when a format rescan occurs at the end of the format.
The number of records written by an explicitly formatted advancing output statement can be determined from
the following rule: a record is written when a slash edit descriptor is encountered in the format, when a format
rescan occurs at the end of the format, and at completion of execution of an advancing output statement (even if
the output list is empty). Thus, the occurrence of <i>n</i> successive slashes between two other edit descriptors causes
<i>n</i>- 1 blank lines if the records are printed. The occurrence of <i>n</i> slashes at the beginning or end of a complete
format specification causes <i>n</i> blank lines if the records are printed. However, a complete format specification
containing <i>n</i> slashes (<i>n></i> 0) and no other edit descriptors causes <i>n</i> + 1 blank lines if the records are printed. For
example, the statements
  PRINT 3
 3 FORMAT (/)
will write two records that cause two blank lines if the records are printed.
<b>C.9.2</b> <b>List-directed</b> <b>input</b> <b>(13.10.3)</b>
The following examples illustrate list-directed input. A blank character is represented by b.
<b>Example</b> <b>1:</b>
<b>Program:</b>
   J = 3
   READ *, I
   READ *, J
<b>Sequential</b> <b>input</b> <b>file:</b>
   record 1: b1b,4bbbbb
   record 2: ,2bbbbbbbb
Result: I = 1, J = 3.
Explanation: The second READ statement reads the second record. The initial comma in the record designates
a null value; therefore, J is not redefined.
<b>Example</b> <b>2:</b>
<b>Program:</b>
  CHARACTER A *8, B *1
  READ *, A, B
<b>Sequential</b> <b>input</b> <b>file:</b>
  record 1: 'bbbbbbbb'
  record 2: 'QXY'b'Z'
Result: A = 'bbbbbbbb', B = 'Q'
Explanation: In the first record, the rightmost apostrophe is interpreted as delimiting the constant (it cannot
be the first of a pair of embedded apostrophes representing a single apostrophe because this would involve
the prohibited "splitting" of the pair by the end of a record); therefore, A is assigned the character constant
'bbbbbbbb'. The end of a record acts as a blank, which in this case is a value separator because it occurs between
two constants.
<b>C.10</b> <b>Clause</b> <b>14</b> <b>notes</b>
<b>C.10.1</b> <b>Main</b> <b>program</b> <b>and</b> <b>block</b> <b>data</b> <b>program</b> <b>unit</b> <b>(14.1,</b> <b>14.3)</b>
The name of the main program or of a block data program unit has no explicit use within the Fortran language.
It is available for documentation and for possible use by a processor.
A processor might implement an unnamed program unit by assigning it a global identifier that is not used
elsewhere in the program. This could be done by using a default name that does not satisfy the rules for Fortran
names.
<b>C.10.2</b> <b>Dependent</b> <b>compilation</b> <b>(14.2)</b>
<b>C.10.2.1</b> <b>Separate</b> <b>translation</b>
This document, like its predecessors, is intended to enable the implementation of conforming processors in which
a program can be broken into multiple units, each of which can be separately translated in preparation for
execution. Such processors are commonly described as supporting separate compilation. There is an important
difference between the way separate compilation can be implemented under this document and the way it could be
implemented under the Fortran 77 International Standard. Under the Fortran 77 standard, any information
required to translate a program unit was specified in that program unit. Each translation was thus totally
independent of all others. Under this document, a program unit can use information that was specified in a
separate module and thus can be dependent on that module. The implementation of this dependency in a
processor might be that the translation of a program unit depends on the results of translating one or more
modules. Processors implementing the dependency this way are commonly described as supporting dependent
compilation.
The dependencies involved here are new only in the sense that the Fortran processor is now aware of them. The
same information dependencies existed under the Fortran 77 International Standard, but it was the program-
mer's responsibility to transport the information necessary to resolve them by making redundant specifications of
the information in multiple program units. The availability of separate but dependent compilation offers several
potential advantages over the redundant textual specification of information.
  (1) Specifyinginformationatasingleplaceintheprogramensuresthatdifferentprogramunitsusingthat
     information are translated consistently. Redundant specification leaves the possibility that different
     information can be erroneously be specified. Even if an INCLUDE line is used to ensure that the
     text of the specifications is identical in all involved program units, the presence of other specifications
     (for example, an IMPLICIT statement) could change the interpretation of that text.
  (2) During the revision of a program, it is possible for a processor to assist in determining whether differ-
     ent program units have been translated using different (incompatible) versions of a module, although
     there is no requirement that a processor provide such assistance. Inconsistencies in redundant textual
     specification of information, on the other hand, tend to be much more difficult to detect.
  (3) Putting information in a module provides a way of packaging it. Without modules, redundant spe-
     cifications frequently are interleaved with other specifications in a program unit, making convenient
     packaging of such information difficult.
  (4) Because a processor can be implemented such that the specifications in a module are translated once
     and then repeatedly referenced, there is the potential for greater efficiency than when the processor
     translates redundant specifications of information in multiple program units.
The exact meaning of the requirement that the public portions of a module be available at the time of reference
is processor dependent. For example, a processor could consider a module to be available only after it has been
compiled and require that if the module has been compiled separately, the result of that compilation be identified
to the compiler when compiling program units that use it.
<b>C.10.2.2</b> <b>USE</b> <b>statement</b> <b>and</b> <b>dependent</b> <b>compilation</b> <b>(14.2.2)</b>
Another benefit of the USE statement is its enhanced facilities for name management. If one needs to use only
selected entities in a module, one can do so without having to worry about the names of all the other entities
in that module. If one needs to use two different modules that happen to contain entities with the same name,
there are several ways to deal with the conflict. If none of the entities with the same name are to be used, they
can simply be ignored. If the name happens to refer to the same entity in both modules (for example, if both
modules obtained it from a third module), then there is no confusion about what the name denotes and the name
can be freely used. If the entities are different and one or both is to be used, the local renaming facility in the
USE statement makes it possible to give those entities different names in the program unit containing the USE
statements.
A benefit of using the ONLY option consistently, as compared to USE without it, is that the module from which
each accessed entity is accessed is explicitly specified in each program unit. This means that one need not search
other program units to find where each one is defined. This reduces maintenance costs.
A typical implementation of dependent but separate compilation might involve storing the result of translating a
module in a file whose name is derived from the name of the module. Note, however, that the name of a module
is limited only by the Fortran rules and not by the names allowed in the file system. Thus the processor might
have to provide a mapping between Fortran names and file system names.
The result of translating a module could reasonably either contain only the information textually specified in the
module (with "pointers" to information originally textually specified in other modules) or contain all information
specifiedinthemodule(includingcopiesofinformationoriginallyspecifiedinothermodules). Althoughtheformer
approach would appear to save on storage space, the latter approach can greatly simplify the logic necessary to
process a USE statement and can avoid the necessity of imposing a limit on the logical "nesting" of modules via
the USE statement.
There is an increased potential for undetected errors in a scoping unit that uses both implicit typing and the
USE statement. For example, in the program fragment
   SUBROUTINE SUB
     USE MY_MODULE
     IMPLICIT INTEGER (I-N), REAL (A-H, O-Z)
     X = F (B)
     A = G (X) + H (X + 1)
   END SUBROUTINE SUB
X could be either an implicitly typed real variable or a variable obtained from the module MY_MODULE and
might change from one to the other because of changes in MY_MODULE unrelated to the action performed by
SUB. Logic errors resulting from this kind of situation can be extremely difficult to locate. Thus, the use of these
features together is discouraged.
<b>C.10.2.3</b> <b>Accessibility</b> <b>attributes</b> <b>(8.5.2)</b>
The PUBLIC and PRIVATE attributes, which can be declared only in modules, divide the entities in a module
into those that are actually relevant to a scoping unit referencing the module and those that are not. This
information might be used to improve the performance of a Fortran processor. For example, it might be possible
to discard much of the information about the private entities once a module has been translated, thus saving on
both storage and the time to search it. Similarly, it might be possible to recognize that two versions of a module
differ only in the private entities they contain and avoid retranslating program units that use that module when
switching from one version of the module to the other.
<b>C.10.3</b> <b>Examples</b> <b>of</b> <b>the</b> <b>use</b> <b>of</b> <b>modules</b> <b>(14.2.1)</b>
<b>C.10.3.1</b> <b>Global</b> <b>data</b> <b>(14.2.1)</b>
A module could contain only data objects, for example:
   MODULE DATA_MODULE
     SAVE
     REAL A (10), B, C (20,20)
     INTEGER :: I=0
     INTEGER, PARAMETER :: J=10
     COMPLEX D (J,J)
   END MODULE DATA_MODULE
Data objects made global in this manner can have any combination of data types.
Access to some of these can be made by a USE statement with the ONLY option, such as:
   USE DATA_MODULE, ONLY: A, B, D
and access to all of them can be made by the following USE statement:
   USE DATA_MODULE
Access to all of them with some renaming to avoid name conflicts can be made by, for example:
 USE DATA_MODULE, AMODULE => A, DMODULE => D
<b>C.10.3.2</b> <b>Derived</b> <b>types</b> <b>(14.2.1)</b>
A derived type can be defined in a module and accessed in a number of program units. For example,
   MODULE SPARSE
     TYPE NONZERO
      REAL A
      INTEGER I, J
     END TYPE NONZERO
   END MODULE SPARSE
defines a type consisting of a real component and two integer components for holding the numerical value of a
nonzero matrix element and its row and column indices.
<b>C.10.3.3</b> <b>Global</b> <b>allocatable</b> <b>arrays</b> <b>(14.2.1)</b>
Many programs need large global allocatable arrays whose sizes are not known before program execution. A
simple form for such a program is:
   PROGRAM GLOBAL_WORK
     CALL CONFIGURE_ARRAYS ! Perform the appropriate allocations
     CALL COMPUTE ! Use the arrays in computations
   END PROGRAM GLOBAL_WORK
   MODULE WORK_ARRAYS ! An example set of work arrays
     INTEGER N
     REAL, ALLOCATABLE :: A (:), B (:, :), C (:, :, :)
   END MODULE WORK_ARRAYS
   SUBROUTINE CONFIGURE_ARRAYS ! Process to set up work arrays
     USE WORK_ARRAYS
     READ (*, *) N
     ALLOCATE (A (N), B (N, N), C (N, N, 2 * N))
   END SUBROUTINE CONFIGURE_ARRAYS
   SUBROUTINE COMPUTE
     USE WORK_ARRAYS
     ... <i>Computations</i> <i>involving</i> <i>arrays</i> <i>A,</i> <i>B,</i> <i>and</i> <i>C.</i>
   END SUBROUTINE COMPUTE
Typically, many subprograms need access to the work arrays, and all such subprograms would contain the
statement
   USE WORK_ARRAYS
<b>C.10.3.4</b> <b>Procedure</b> <b>libraries</b> <b>(14.2.2)</b>
Interface bodies for external procedures in a library can be gathered into a module. An interface body specifies
an explicit interface (15.4.2.2).
An example is the following library module:
   MODULE LIBRARY_LLS
     INTERFACE
      SUBROUTINE LLS (X, A, F, FLAG)
        REAL X (:, :)
        ! The SIZE in the next statement is an intrinsic function
        REAL, DIMENSION (SIZE (X, 2)) :: A, F
        INTEGER FLAG
      END SUBROUTINE LLS
      ...
     END INTERFACE
     ...
   END MODULE LIBRARY_LLS
This module provides an explicit interface that is necessary for the subroutine LLS to be invoked. for example:
   USE LIBRARY_LLS
   ...
   CALL LLS (X = ABC, A = D, F = XX, FLAG = IFLAG)
   ...
Because dummy argument names in an interface body for an external procedure are not required to be the same
as in the procedure definition, different versions can be constructed for different applications using argument
keywords appropriate to each application.
<b>C.10.3.5</b> <b>Operator</b> <b>extensions</b> <b>(14.2.2)</b>
In order to extend an intrinsic operator symbol to have an additional meaning, an interface block specifying that
operator symbol in the OPERATOR option of the INTERFACE statement could be placed in a module.
For example, // can be extended to perform concatenation of two derived-type objects serving as varying length
character strings and + can be extended to specify matrix addition for type MATRIX or interval arithmetic
addition for type INTERVAL.
A module might contain several such interface blocks. An operator can be defined by an external function (either
in Fortran or some other language) and its procedure interface placed in the module.
<b>C.10.3.6</b> <b>Data</b> <b>abstraction</b> <b>(14.2.2)</b>
In addition to providing a portable means of avoiding the redundant specification of information in multiple
program units, a module provides a convenient means of "packaging" related entities, such as the definitions of
the representation and operations of an abstract data type. The following example of a module defines a data
abstraction for a SET type where the elements of each set are of type integer. The usual set operations of UNION,
INTERSECTION, and DIFFERENCE are provided. The CARDINALITY function returns the cardinality of
(number of elements in) its set argument. Two functions returning logical values are included, ELEMENT and
SUBSET. ELEMENT defines the operator .IN. and SUBSET extends the operator <i><</i>=. ELEMENT determines
if a given scalar integer value is an element of a given set, and SUBSET determines if a given set is a subset of
another given set. (Two sets can be checked for equality by comparing cardinality and checking that one is a
subset of the other, or checking to see if each is a subset of the other.)
The transfer function SETF converts a vector of integer values to the corresponding set, with duplicate values
removed. Thus, a vector of constant values can be used as set constants. An inverse transfer function VECTOR
returns the elements of a set as a vector of values in ascending order. In this SET implementation, set data
objects have a maximum cardinality of 200.
Here is the example module:
   MODULE INTEGER_SETS
   ! This module is intended to illustrate use of the module facility
   ! to define a new type, along with suitable operators.
   INTEGER, PARAMETER :: MAX_SET_CARD = 200
   TYPE SET ! Define SET type
     PRIVATE
     INTEGER CARD
     INTEGER ELEMENT (MAX_SET_CARD)
   END TYPE SET
   INTERFACE OPERATOR (.IN.)
     MODULE PROCEDURE ELEMENT
   END INTERFACE OPERATOR (.IN.)
   INTERFACE OPERATOR (<=)
     MODULE PROCEDURE SUBSET
   END INTERFACE OPERATOR (<=)
   INTERFACE OPERATOR (+)
     MODULE PROCEDURE UNION
   END INTERFACE OPERATOR (+)
   INTERFACE OPERATOR (-)
     MODULE PROCEDURE DIFFERENCE
   END INTERFACE OPERATOR (-)
   INTERFACE OPERATOR (*)
     MODULE PROCEDURE INTERSECTION
   END INTERFACE OPERATOR (*)
   CONTAINS
   INTEGER FUNCTION CARDINALITY (A) ! Returns cardinality of set A
     TYPE (SET), INTENT (IN) :: A
     CARDINALITY = A % CARD
   END FUNCTION CARDINALITY
   LOGICAL FUNCTION ELEMENT (X, A) ! Determines if
     INTEGER, INTENT(IN) :: X ! element X is in set A
     TYPE (SET), INTENT(IN) :: A
     ELEMENT = ANY (A % ELEMENT (1 : A % CARD) == X)
   END FUNCTION ELEMENT
   FUNCTION UNION (A, B) ! Union of sets A and B
     TYPE (SET) UNION
     TYPE (SET), INTENT(IN) :: A, B
     INTEGER J
     UNION = A
     DO J = 1, B % CARD
      IF (.NOT. (B % ELEMENT (J) .IN. A)) THEN
        IF (UNION % CARD < MAX_SET_CARD) THEN
         UNION % CARD = UNION % CARD + 1
         UNION % ELEMENT (UNION % CARD) = B % ELEMENT (J)
        ELSE
         ! Maximum set size exceeded . . .
        END IF
      END IF
     END DO
   END FUNCTION UNION
   FUNCTION DIFFERENCE (A, B) ! Difference of sets A and B
     TYPE (SET) DIFFERENCE
     TYPE (SET), INTENT(IN) :: A, B
     INTEGER J, X
     DIFFERENCE % CARD = 0 ! The empty set
     DO J = 1, A % CARD
      X = A % ELEMENT (J)
      IF (.NOT. (X .IN. B)) DIFFERENCE = DIFFERENCE + SET (1, X)
     END DO
   END FUNCTION DIFFERENCE
   FUNCTION INTERSECTION (A, B) ! Intersection of sets A and B
     TYPE (SET) INTERSECTION
     TYPE (SET), INTENT(IN) :: A, B
     INTERSECTION = A - (A - B)
   END FUNCTION INTERSECTION
   LOGICAL FUNCTION SUBSET (A, B) ! Determines if set A is
     TYPE (SET), INTENT(IN) :: A, B ! a subset of set B
     INTEGER I
     SUBSET = A % CARD <= B % CARD
     IF (.NOT. SUBSET) RETURN ! For efficiency
     DO I = 1, A % CARD
      SUBSET = SUBSET .AND. (A % ELEMENT (I) .IN. B)
     END DO
   END FUNCTION SUBSET
   TYPE (SET) FUNCTION SETF (V) ! Transfer function between a vector
     INTEGER V (:) ! of elements and a set of elements
     INTEGER J ! removing duplicate elements
     SETF % CARD = 0
     DO J = 1, SIZE (V)
      IF (.NOT. (V (J) .IN. SETF)) THEN
        IF (SETF % CARD < MAX_SET_CARD) THEN
         SETF % CARD = SETF % CARD + 1
         SETF % ELEMENT (SETF % CARD) = V (J)
        ELSE
         ! Maximum set size exceeded . . .
        END IF
      END IF
     END DO
   END FUNCTION SETF
   FUNCTION VECTOR (A) ! Transfer the values of set A
     TYPE (SET), INTENT (IN) :: A ! into a vector in ascending order
     INTEGER, POINTER :: VECTOR (:)
     INTEGER I, J, K
     ALLOCATE (VECTOR (A % CARD))
     VECTOR = A % ELEMENT (1 : A % CARD)
     DO I = 1, A % CARD - 1 ! Use a better sort if
      DO J = I + 1, A % CARD ! A % CARD is large
        IF (VECTOR (I) > VECTOR (J)) THEN
         K = VECTOR (J); VECTOR (J) = VECTOR (I); VECTOR (I) = K
        END IF
      END DO
     END DO
   END FUNCTION VECTOR
   END MODULE INTEGER_SETS
Examples of using INTEGER_SETS (A, B, and C are variables of type SET; X is an integer variable):
   ! Check to see if A has more than 10 elements
   IF (CARDINALITY (A) > 10) ...
   ! Check for X an element of A but not of B
   IF (X .IN. (A - B)) ...
   ! C is the union of A and the result of B intersected
   ! with the integers 1 to 100
   C = A + B * SETF ([(I, I = 1, 100)])
   ! Does A have any even numbers in the range 1:100?
   IF (CARDINALITY (A * SETF ([(I, I = 2, 100, 2)])) > 0) ...
   PRINT *, VECTOR (B) ! Print out the elements of set B, in ascending order
<b>C.10.3.7</b> <b>Public</b> <b>entities</b> <b>renamed</b> <b>(14.2.2)</b>
At times it might be necessary to rename entities that are accessed with USE statements.
The following example illustrates renaming features of the USE statement.
   MODULE J; REAL JX, JY, JZ; END MODULE J
   MODULE K
     USE J, ONLY : KX => JX, KY => JY
     ! KX and KY are local names to module K
     REAL KZ ! KZ is local name to module K
     REAL JZ ! JZ is local name to module K
   END MODULE K
   PROGRAM RENAME
     USE J; USE K
     ! Module J's entity JX is accessible under names JX and KX
     ! Module J's entity JY is accessible under names JY and KY
     ! Module K's entity KZ is accessible under name KZ
     ! Module J's entity JZ and K's entity JZ are different entities
     ! and cannot be referenced
     ...
   END PROGRAM RENAME
<b>C.10.4</b> <b>Modules</b> <b>with</b> <b>submodules</b> <b>(14.2.3)</b>
Each submodule specifies that it is the child of exactly one parent module or submodule. Therefore, a module
and all of its descendant submodules stand in a tree-like relationship one to another.
A separate module procedure that is declared in a module to have public accessibility can be accessed by use
association even if it is defined in a submodule. No other entity in a submodule can be accessed by use association.
Each program unit that references a module by use association depends on it, and each submodule depends on
its ancestor module. Therefore, if one changes a separate module procedure body in a submodule but does not
change its corresponding module procedure interface, a tool for automatic program translation would not need
to reprocess program units that reference the module by use association. This is so even if the tool exploits the
relative modification times of files as opposed to comparing the result of translating the module to the result of
a previous translation.
By constructing taller trees, one can put entities at intermediate levels that are shared by submodules at lower
levels; changing these entities cannot change the interpretation of anything that is accessible from the module
by use association. Developers of modules that embody large complicated concepts can exploit this possibility
to organize components of the concept into submodules, while preserving the privacy of entities that are shared
by the submodules and that ought not to be exposed to users of the module. Putting these shared entities at an
intermediate level also prevents cascades of reprocessing and testing if some of them are changed.
The following example illustrates a module, color_points, with a submodule, color_points_a, that in turn has
a submodule, color_points_b. Public entities declared within color_points can be accessed by use association.
The submodules color_points_a and color_points_b can be changed without causing retranslation of program
units that reference the module color_points.
The module color_points does not have a <i>module-subprogram-part</i>, but a <i>module-subprogram-part</i> is not pro-
hibited. The module could be published as definitive specification of the interface, without revealing trade secrets
contained within color_points_a or color_points_b. Of course, a similar module without the module prefix in
theinterface bodieswould serveequallywellas documentation - but the procedures would be external procedures.
It would make little difference to the consumer, but the developer would forfeit all of the advantages of modules.
   module color_points
    type color_point
     private
     real :: x, y
     integer :: color
    end type color_point
    interface ! Interfaces for procedures with separate
                ! bodies in the submodule color_points_a
     module subroutine color_point_del ( p ) ! Destroy a color_point object
      type(color_point), allocatable :: p
     end subroutine color_point_del
     ! Distance between two color_point objects
     real module function color_point_dist ( a, b )
      type(color_point), intent(in) :: a, b
     end function color_point_dist
     module subroutine color_point_draw ( p ) ! Draw a color_point object
      type(color_point), intent(in) :: p
     end subroutine color_point_draw
     module subroutine color_point_new ( p ) ! Create a color_point object
      type(color_point), allocatable :: p
     end subroutine color_point_new
    end interface
   end module color_points
The only entities within color_points_a that can be accessed by use association are the separate module
procedures that were declared in color_points. If the procedures are changed but their interfaces are not, the
interface from program units that access them by use association is unchanged. If the module and submodule are
in separate files, utilities that examine the time of modification of a file would notice that changes in the module
could affect the translation of its submodules or of program units that reference the module by use association,
but that changes in submodules could not affect the translation of the parent module or program units that
reference it by use association.
The variable instance_count in the following example is not accessible by use association of color_points, but
is accessible within color_points_a, and its submodules.
   submodule ( color_points ) color_points_a ! Submodule of color_points
    integer :: instance_count = 0
    interface ! Interface for a procedure with a separate
                  ! body in submodule color_points_b
     module subroutine inquire_palette ( pt, pal )
      use palette_stuff ! palette_stuff, especially submodules thereof,
                  ! can reference color_points by use association
                  ! without causing a circular dependence during
                  ! translation because this use is not in the module.
                  ! Furthermore, changes in the module palette_stuff
                  ! do not affect the translation of color_points.
      type(color_point), intent(in) :: pt
      type(palette), intent(out) :: pal
     end subroutine inquire_palette
    end interface
   contains ! Invisible bodies for public separate module procedures
        ! declared in the module
    module subroutine color_point_del ( p )
     type(color_point), allocatable :: p
     instance_count = instance_count - 1
     deallocate ( p )
    end subroutine color_point_del
    real module function color_point_dist ( a, b ) result ( dist )
     type(color_point), intent(in) :: a, b
     dist = SQRT ( (b%x - a%x)**2 + (b%y - a%y)**2 )
    end function color_point_dist
    module subroutine color_point_new ( p )
     type(color_point), allocatable :: p
     instance_count = instance_count + 1
     allocate ( p )
    end subroutine color_point_new
   end submodule color_points_a
The subroutine inquire_palette is accessible within color_points_a because its interface is declared therein.
It is not, however, accessible by use association, because its interface is not declared in the module, color_points.
Since the interface is not declared in the module, changes in the interface cannot affect the translation of program
units that reference the module by use association.
   module palette_stuff
    type :: palette ; ... ; end type palette
   contains
    subroutine test_palette ( p )
    ! Draw a color wheel using procedures from the color_points module
     use color_points ! This does not cause a circular dependency because
              ! the "use palette_stuff" that is logically within
              ! color_points is in the color_points_a submodule.
     type(palette), intent(in) :: p
     ...
    end subroutine test_palette
   end module palette_stuff
   submodule ( color_points:color_points_a ) color_points_b ! Subsidiary**2 submodule
   contains
    ! Invisible body for interface declared in the ancestor module
    module subroutine color_point_draw ( p )
     use palette_stuff, only: palette
     type(color_point), intent(in) :: p
     type(palette) :: MyPalette
     ...; call inquire_palette ( p, MyPalette ); ...
    end subroutine color_point_draw
    ! Invisible body for interface declared in the parent submodule
    module procedure inquire_palette
     ... <i>Implementation</i> <i>of</i> <i>inquire_palette.</i>
    end procedure inquire_palette
    subroutine private_stuff ! not accessible from color_points_a
     ...
    end subroutine private_stuff
   end submodule color_points_b
There is a use palette_stuff in color_points_a, and a use color_points in palette_stuff. The use
palette_stuff would cause a circular reference if it appeared in color_points. In this case, it does not cause
a circular dependence because it is in a submodule. Submodules cannot be referenced by use association, and
therefore what would be a circular appearance of use palette_stuff is not accessed.
   program main
    use color_points
    ! "instance_count" and "inquire_palette" are not accessible here
    ! because they are not declared in the "color_points" module.
    ! "color_points_a" and "color_points_b" cannot be referenced by
    ! use association.
    interface draw ! just to demonstrate it's possible
     module procedure color_point_draw
    end interface
    type(color_point) :: C_1, C_2
    real :: RC
    ...
    call color_point_new (c_1) ! body in color_points_a, interface in color_points
    ...
    call draw (c_1) ! body in color_points_b, specific interface
                     ! in color_points, generic interface here.
    ...
    rc = color_point_dist (c_1, c_2) ! body in color_points_a, interface in color_points
    ...
    call color_point_del (c_1) ! body in color_points_a, interface in color_points
    ...
   end program main
A multilevel submodule system can be used to package and organize a large and interconnected concept without
exposing entities of one subsystem to other subsystems.
Consider a Plasma module from a Tokomak simulator. A plasma simulation requires attention at least to fluid
flow, thermodynamics, and electromagnetism. Fluid flow simulation requires simulation of subsonic, supersonic,
and hypersonic flow. This problem decomposition can be reflected in the submodule structure of the Plasma
module:
                     Plasma module
         Flow submodule Thermal submodule Electromagnetics submodule
    Subsonic Supersonic Hypersonic
    submodule submodule submodule
Entities can be shared among the Subsonic, Supersonic, and Hypersonic submodules by putting them within
the Flow submodule. One then need not worry about accidental use of these entities by use association or by the
Thermal or Electromagnetics submodules, or the development of a dependency of correct operation of those
subsystems upon the representation of entities of the Flow subsystem as a consequence of maintenance. Since
these entities are not accessible by use association, if any of them are changed, the new values cannot be accessed
in program units that reference the Plasma module by use association; the answer to the question "where are
these entities used" is therefore confined to the set of descendant submodules of the Flow submodule.
<b>C.11</b> <b>Clause</b> <b>15</b> <b>notes</b>
<b>C.11.1</b> <b>Portability</b> <b>problems</b> <b>with</b> <b>external</b> <b>procedures</b> <b>(15.4.3.5)</b>
There is a potential portability problem in a scoping unit that references an external procedure without explicitly
declaring it to have the EXTERNAL attribute (8.5.9). On a different processor, the name of that procedure
might be the name of a nonstandard intrinsic procedure and in such a case the processor would interpret those
procedure references as references to that intrinsic procedure. (On that processor, the program would also be
viewed as not conforming to this document because of the references to the nonstandard intrinsic procedure.)
Declaration of the EXTERNAL attribute causes the references to be to the external procedure regardless of the
availability of an intrinsic procedure with the same name. Note that declaration of the type of a procedure is not
enough to make it external, even if the type is inconsistent with the type of the result of an intrinsic procedure
of the same name.
<b>C.11.2</b> <b>Procedures</b> <b>defined</b> <b>by</b> <b>means</b> <b>other</b> <b>than</b> <b>Fortran</b> <b>(15.6.3)</b>
A processor is not required to provide any means other than Fortran for defining external procedures. Among the
means that might be supported are the machine assembly language, other high level languages, the Fortran lan-
guage extended with nonstandard features, and the Fortran language as supported by another Fortran processor
(for example, a previously existing Fortran 77 processor). The means other than Fortran for defining external
procedures, including any restrictions on the structure or organization of those procedures, are not specified by
this document.
A Fortran processor might limit its support of procedures defined by means other than Fortran such that these
procedures can affect entities in the Fortran environment only on the same basis as procedures written in Fortran.
For example, it might not support the value of a local variable from being changed by a procedure reference unless
that variable were one of the arguments to the procedure.
<b>C.11.3</b> <b>Abstract</b> <b>interfaces</b> <b>and</b> <b>procedure</b> <b>pointer</b> <b>components</b> <b>(15.4,</b> <b>7.5)</b>
This is an example of a library module providing lists of callbacks that the user can register and invoke.
   MODULE callback_list_module
    !
    ! Type for users to extend with their own data, if they so desire
    !
    TYPE callback_data
    END TYPE
    !
    ! Abstract interface for the callback procedures
    !
    ABSTRACT INTERFACE
     SUBROUTINE callback_procedure(data)
      IMPORT callback_data
      CLASS(callback_data),OPTIONAL :: data
     END SUBROUTINE
    END INTERFACE
    !
    ! The callback list type.
    !
    TYPE callback_list
     PRIVATE
     TYPE(callback_record),POINTER :: first => NULL()
    END TYPE
    !
    ! Internal: each callback registration creates one of these
    !
    TYPE,PRIVATE :: callback_record
     PROCEDURE(callback_procedure),POINTER,NOPASS :: proc
     TYPE(callback_record),POINTER :: next
     CLASS(callback_data),POINTER :: data => NULL();
    END TYPE
    PRIVATE invoke,forward_invoke
   CONTAINS
    !
    ! Register a callback procedure with optional data
    !
    SUBROUTINE register_callback(list, entry, data)
     TYPE(callback_list),INTENT(INOUT) :: list
     PROCEDURE(callback_procedure) :: entry
     CLASS(callback_data),OPTIONAL :: data
     TYPE(callback_record),POINTER :: new
     ALLOCATE(new)
     new%proc => entry
     IF (PRESENT(data)) ALLOCATE(new%data,SOURCE=data)
     new%next => list%first
     list%first => new
    END SUBROUTINE
    !
    ! Internal: Invoke a single callback and destroy its record
    !
    SUBROUTINE invoke(callback)
     TYPE(callback_record),POINTER :: callback
     IF (ASSOCIATED(callback%data)) THEN
      CALL callback%proc(callback%data)
      DEALLOCATE(callback%data)
     ELSE
      CALL callback%proc
     END IF
     DEALLOCATE(callback)
    END SUBROUTINE
    !
    ! Call the procedures in reverse order of registration
    !
    SUBROUTINE invoke_callback_reverse(list)
     TYPE(callback_list),INTENT(INOUT) :: list
     TYPE(callback_record),POINTER :: next,current
     current => list%first
     NULLIFY(list%first)
     DO WHILE (ASSOCIATED(current))
      next => current%next
      CALL invoke(current)
      current => next
     END DO
    END SUBROUTINE
    !
    ! Internal: Forward mode invocation
    !
    SUBROUTINE forward_invoke(callback)
     TYPE(callback_record),POINTER :: callback
     IF (ASSOCIATED(callback%next)) CALL forward_invoke(callback%next)
     CALL invoke(callback)
    END SUBROUTINE
    !
    ! Call the procedures in forward order of registration
    !
    SUBROUTINE invoke_callback_forward(list)
     TYPE(callback_list),INTENT(INOUT) :: list
     IF (ASSOCIATED(list%first)) CALL forward_invoke(list%first)
    END SUBROUTINE
   END
<b>C.11.4</b> <b>Pointers</b> <b>and</b> <b>targets</b> <b>as</b> <b>arguments</b> <b>(15.5.2.5,</b> <b>15.5.2.7,</b> <b>15.5.2.8)</b>
If a dummy argument is declared to be a pointer, the corresponding actual argument could be a pointer or could
be a nonpointer variable or procedure. Consider the two cases separately.
<i>Case</i> <i>(i):</i> The actual argument is a pointer. When procedure execution commences the pointer association
     status of the dummy argument becomes the same as that of the actual argument. If the pointer
     association status of the dummy argument is changed, the pointer association status of the actual
     argument changes in the same way.
<i>Case</i> <i>(ii):</i> The actual argument is not a pointer. This only occurs when the actual argument has the TARGET
     attribute or is a procedure, and the dummy argument has the INTENT (IN) attribute. The dummy
     argument becomes pointer associated with the actual argument.
When execution of a procedure completes, any data pointer that remains defined and that is associated with a
dummy argument that has the TARGET attribute and is either a scalar or an assumed-shape array, remains
associated with the corresponding actual argument if the actual argument has the TARGET attribute and is not
an array section with a vector subscript.
For example, consider:
   REAL, POINTER :: PBEST
   REAL, TARGET :: B (10000)
   CALL BEST (PBEST, B) ! On return PBEST is associated with the `best' element of B.
   ...
   CONTAINS
    SUBROUTINE BEST (P, A)
     REAL, POINTER, INTENT (OUT) :: P
     REAL, TARGET, INTENT (IN) :: A (:)
     ... <i>Find</i> <i>the</i> <i>``best''</i> <i>element</i> <i>A(I).</i>
     P => A (I)
    END SUBROUTINE BEST
   END
When procedure BEST completes, the pointer PBEST is associated with an element of B.
An actual argument without the TARGET attribute can become associated with a dummy argument with the
TARGET attribute. This enables a pointer to become associated with the dummy argument during execution of
the procedure that contains the dummy argument. For example:
   INTEGER LARGE(100,100)
   CALL SUB (LARGE)
   ...
   CALL SUB ()
   CONTAINS
    SUBROUTINE SUB(ARG)
     INTEGER, TARGET, OPTIONAL :: ARG(100,100)
     INTEGER, POINTER, DIMENSION(:,:) :: PARG
     IF (PRESENT(ARG)) THEN
      PARG => ARG
     ELSE
      ALLOCATE (PARG(100,100))
      PARG = 0
     ENDIF
     ... <i>Code</i> <i>with</i> <i>lots</i> <i>of</i> <i>references</i> <i>to</i> <i>PARG.</i>
     IF (.NOT. PRESENT(ARG)) DEALLOCATE(PARG)
    END SUBROUTINE SUB
   END
Within subroutine SUB the pointer PARG is either associated with the dummy argument ARG or it is associated
with an allocated target. The bulk of the code can reference PARG without further calls to the intrinsic function
PRESENT.
If a nonpointer dummy argument has the TARGET attribute and the corresponding actual argument does not,
any pointers that become associated with the dummy argument, and therefore with the actual argument, during
execution of the procedure, become undefined when execution of the procedure completes.
<b>C.11.5</b> <b>Polymorphic</b> <b>Argument</b> <b>Association</b> <b>(15.5.2.10)</b>
The following example illustrates the polymorphic argument association rules using the derived types defined in
7.5.7.2, NOTE 4.
   TYPE(POINT) :: T2
   TYPE(COLOR_POINT) :: T3
   CLASS(POINT) :: P2
   CLASS(COLOR_POINT) :: P3
   ! Dummy argument is polymorphic and actual argument is of fixed type
   SUBROUTINE SUB2 ( X2 ); CLASS(POINT) :: X2; ...
   SUBROUTINE SUB3 ( X3 ); CLASS(COLOR_POINT) :: X3; ...
   CALL SUB2 ( T2 ) ! Valid -- The declared type of T2 is the same as the
            ! declared type of X2.
   CALL SUB2 ( T3 ) ! Valid -- The declared type of T3 is extended from
            ! the declared type of X2.
   CALL SUB3 ( T2 ) ! Invalid -- The declared type of T2 is neither the
            ! same as nor extended from the declared type
            ! type of X3.
   CALL SUB3 ( T3 ) ! Valid -- The declared type of T3 is the same as the
            ! declared type of X3.
   ! Actual argument is polymorphic and dummy argument is of fixed type
   SUBROUTINE TUB2 ( D2 ); TYPE(POINT) :: D2; ...
   SUBROUTINE TUB3 ( D3 ); TYPE(COLOR_POINT) :: D3; ...
   CALL TUB2 ( P2 ) ! Valid -- The declared type of P2 is the same as the
            ! declared type of D2.
   CALL TUB2 ( P3 ) ! Invalid -- The declared type of P3 differs from the
            ! declared type of D2.
   CALL TUB2 ( P3%POINT ) ! Valid alternative to the above
   CALL TUB3 ( P2 ) ! Invalid -- The declared type of P2 differs from the
            ! declared type of D3.
   SELECT TYPE ( P2 ) ! Valid conditional alternative to the above
   CLASS IS ( COLOR_POINT ) ! Works if the dynamic type of P2 is the same
    CALL TUB3 ( P2 ) ! as the declared type of D3, or a type
                ! extended therefrom.
   CLASS DEFAULT
                ! Cannot work if not.
   END SELECT
   CALL TUB3 ( P3 ) ! Valid -- The declared type of P3 is the same as the
            ! declared type of D3.
   ! Both the actual and dummy arguments are of polymorphic type.
   CALL SUB2 ( P2 ) ! Valid -- The declared type of P2 is the same as the
            ! declared type of X2.
   CALL SUB2 ( P3 ) ! Valid -- The declared type of P3 is extended from
            ! the declared type of X2.
   CALL SUB3 ( P2 ) ! Invalid -- The declared type of P2 is neither the
            ! same as nor extended from the declared
            ! type of X3.
   SELECT TYPE ( P2 ) ! Valid conditional alternative to the above
   CLASS IS ( COLOR_POINT ) ! Works if the dynamic type of P2 is the
    CALL SUB3 ( P2 ) ! same as the declared type of X3, or a
                ! type extended therefrom.
   CLASS DEFAULT
                ! Cannot work if not.
   END SELECT
   CALL SUB3 ( P3 ) ! Valid -- The declared type of P3 is the same as the
            ! declared type of X3.
<b>C.11.6</b> <b>Rules</b> <b>ensuring</b> <b>unambiguous</b> <b>generics</b> <b>(15.4.3.4.5)</b>
The rules in 15.4.3.4.5 are intended to ensure
 that it is possible to reference each specific procedure or binding in the generic collection,
 that for any valid generic procedure reference, the determination of the specific procedure referenced is
  unambiguous, and
 that the determination of the specific procedure or binding referenced can be made before execution of the
  program begins (during compilation).
Interfaces of specific procedures or bindings are distinguished by fixed properties of their arguments, specifically
type, kind type parameters, rank, and whether the dummy argument has the POINTER or ALLOCATABLE
attribute. A valid reference to one procedure in a generic collection will differ from another because it has an
argument that the other cannot accept, because it is missing an argument that the other requires, or because one
of these fixed properties is different.
Although the declared type of a data entity is a fixed property, polymorphic variables allow for a limited degree
of type mismatch between dummy arguments and actual arguments, so the requirement for distinguishing two
dummy arguments is type incompatibility, not merely different types. (This is illustrated in the BAD6 example
later in this subclause.)
That same limited type mismatch means that two dummy arguments that are not type incompatible can be
distinguished on the basis of the values of the kind type parameters they have in common; if one of them has a
kind type parameter that the other does not, that is irrelevant in distinguishing them.
Rank is a fixed property, but some forms of array dummy arguments allow rank mismatches when a procedure is
referenced by its specific name. In order to allow rank to always be usable in distinguishing generics, such rank
mismatches are disallowed for those arguments when the procedure is referenced as part of a generic. Additionally,
thefactthatelementalprocedurescanacceptarrayargumentsisnottakenintoaccountwhenapplyingtheserules,
so apparent ambiguity between elemental and nonelemental procedures is possible; in such cases, the reference is
interpreted as being to the nonelemental procedure.
For procedures referenced as operators or defined-assignment, syntactically distinguished arguments are mapped
to specific positions in the argument list, so the rule for distinguishing such procedures is that it be possible to
distinguish the arguments at one of the argument positions.
For defined input/output procedures, only the dtv argument corresponds to something explicitly written in the
program, so it is the dtv that is required to be distinguished. Because dtv arguments are required to be scalar,
they cannot differ in rank. Thus this rule effectively involves only type and kind type parameters.
For generic procedure names, the rules are more complicated because optional arguments can be omitted and
because arguments can be specified either positionally or by name.
In the special case of type-bound procedures with passed-object dummy arguments, the passed-object argument
is syntactically distinguished in the reference, so rule (3) in 15.4.3.4.5 can be applied. The type of passed-object
arguments is constrained in ways that prevent passed-object arguments in the same scoping unit from being type
incompatible. Thus this rule effectively involves only kind type parameters and rank.
The primary means of distinguishing named generics is rule (4). The most common application of that rule is a
single argument satisfying both (4a) and (4b):
   INTERFACE GOOD1
    FUNCTION F1A(X)
     REAL :: F1A,X
    END FUNCTION F1A
    FUNCTION F1B(X)
     INTEGER :: F1B,X
    END FUNCTION F1B
   END INTERFACE GOOD1
Whether one writes GOOD1(1.0) or GOOD1(X=1.0), the reference is to F1A because F1B would require an integer
argument whereas these references provide the real constant 1.0.
This example and those that follow are expressed using interface bodies, with type as the distinguishing property.
This was done to make it easier to write and describe the examples. The principles being illustrated are equally
applicable when the procedures get their explicit interfaces in some other way or when kind type parameters or
rank are the distinguishing property.
Another common variant is the argument that satisfies (4a) and (4b) by being required in one specific and
completely missing in the other:
   INTERFACE GOOD2
    FUNCTION F2A(X)
     REAL :: F2A,X
    END FUNCTION F2A
    FUNCTION F2B(X,Y)
     COMPLEX :: F2B
     REAL :: X,Y
    END FUNCTION F2B
   END INTERFACE GOOD2
Whether one writes GOOD2(0.0,1.0), GOOD2(0.0,Y=1.0), or GOOD2(Y=1.0,X=0.0), the reference is to F2B,
because F2A has no argument in the second position or with the name Y. This approach is used as an alternative
to optional arguments when one wants a function to have different result type, kind type parameters, or rank,
depending on whether the argument is present. In many of the intrinsic functions, the DIM argument works this
way.
It is possible to construct cases where different arguments are used to distinguish positionally and by name:
   INTERFACE GOOD3
    SUBROUTINE S3A(W,X,Y,Z)
     REAL :: W,Y
     INTEGER :: X,Z
    END SUBROUTINE S3A
    SUBROUTINE S3B(X,W,Z,Y)
     REAL :: W,Z
     INTEGER :: X,Y
    END SUBROUTINE S3B
   END INTERFACE GOOD3
If one writes GOOD3(1.0,2,3.0,4) to reference S3A, then the third and fourth arguments are consistent with a
reference to S3B, but the first and second are not. If one switches to writing the first two arguments as keyword
arguments in order for them to be consistent with a reference to S3B, the latter two arguments will also need
to be written as keyword arguments, GOOD3(X=2,W=1.0,Z=4,Y=3.0), and the named arguments Y and Z are
distinguished.
The ordering requirement in rule (4) is critical:
   INTERFACE BAD4 ! this interface is invalid !
    SUBROUTINE S4A(W,X,Y,Z)
     REAL :: W,Y
     INTEGER :: X,Z
    END SUBROUTINE S4A
    SUBROUTINE S4B(X,W,Z,Y)
     REAL :: X,Y
     INTEGER :: W,Z
    END SUBROUTINE S4B
   END INTERFACE BAD4
In this example, the positionally distinguished arguments are Y and Z, and it is W and X that are distinguished by
name. In this order it is possible to write BAD4(1.0,2,Y=3.0,Z=4), which is a valid reference for both S4A and
S4B.
Rule (1) can be used to distinguish some cases that are not covered by rule (4):
   INTERFACE GOOD5
    SUBROUTINE S5A(X)
     REAL :: X
    END SUBROUTINE S5A
    SUBROUTINE S5B(Y,X)
     REAL :: Y,X
    END SUBROUTINE S5B
   END INTERFACE GOOD5
In attempting to apply rule (4), position 2 and name Y are distinguished, but they are in the wrong order, just like
theBAD4example. However, whenwetrytoconstructasimilarlyambiguousreference, weget GOOD5(1.0,X=2.0),
which can't be a reference to S5A because it would be attempting to associate two different actual arguments
with the dummy argument X. Rule (1) catches this case by recognizing that S5B requires two real arguments, and
S5A cannot possibly accept more than one.
Theapplicationofrule(1)becomesmorecomplicatedwhenextensibletypesareinvolved. If FRUITisanextensible
type, PEAR and APPLE are extensions of FRUIT, and BOSC is an extension of PEAR, then
   INTERFACE BAD6 ! this interface is invalid !
    SUBROUTINE S6A(X,Y)
     CLASS(PEAR) :: X,Y
    END SUBROUTINE S6A
    SUBROUTINE S6B(X,Y)
     CLASS(FRUIT) :: X
     CLASS(BOSC) :: Y
    END SUBROUTINE S6B
   END INTERFACE BAD6
might, at first glance, seem distinguishable this way, but because of the limited type mismatching allowed,
BAD6(A_PEAR,A_BOSC) is a valid reference to both S6A and S6B.
It is important to try rule (1) for each type that appears:
   INTERFACE GOOD7
    SUBROUTINE S7A(X,Y,Z)
     CLASS(PEAR) :: X,Y,Z
    END SUBROUTINE S7A
    SUBROUTINE S7B(X,Z,W)
     CLASS(FRUIT) :: X
     CLASS(BOSC) :: Z
     CLASS(APPLE),OPTIONAL :: W
    END SUBROUTINE S7B
   END INTERFACE GOOD7
Looking at the most general type, S7A has a minimum and maximum of 3 FRUIT arguments, while S7B has a
minimum of 2 and a maximum of three. Looking at the most specific, S7A has a minimum of 0 and a maximum
of 3 BOSC arguments, while S7B has a minimum of 1 and a maximum of 2. However, when we look at the
intermediate, S7A has a minimum and maximum of 3 PEAR arguments, while S7B has a minimum of 1 and a
maximum of 2. Because S7A's minimum exceeds S7B's maximum, they can be distinguished.
In identifying the minimum number of arguments with a particular set of properties, we exclude optional argu-
ments and test TKR compatibility, so the corresponding actual arguments are required to have those properties.
In identifying the maximum number of arguments with those properties, we include the optional arguments and
test not distinguishable, so we include actual arguments which could have those properties but are not required
to have them.
These rules are sufficient to ensure that references to procedures that meet them are unambiguous, but there
remain examples that fail to meet these rules but which can be shown to be unambiguous:
   INTERFACE BAD8 ! this interface is invalid !
    ! despite the fact that it is unambiguous !
    SUBROUTINE S8A(X,Y,Z)
     REAL,OPTIONAL :: X
     INTEGER :: Y
     REAL :: Z
    END SUBROUTINE S8A
    SUBROUTINE S8B(X,Z,Y)
     INTEGER,OPTIONAL :: X
     INTEGER :: Z
     REAL :: Y
    END SUBROUTINE S8B
   END INTERFACE BAD8
Thisinterfacefailsrule(4)becausetherearenorequiredargumentsthatcanbedistinguishedfromthepositionally
corresponding argument, but in order for the mismatch of the optional arguments not to be relevant, the later
arguments need to be specified as keyword arguments, so distinguishing by name does the trick. This interface is
nevertheless invalid so a standard-conforming Fortran processor is not required to do such reasoning. The rules
to cover all cases are too complicated to be useful.
If one dummy argument has the POINTER attribute and a corresponding argument in the other interface body
has the ALLOCATABLE attribute the generic interface is not ambiguous. If one dummy argument has either the
POINTER or ALLOCATABLE attribute and a corresponding argument in the other interface body has neither
attribute, the generic interface might be ambiguous.
<b>C.12</b> <b>Clause</b> <b>16</b> <b>notes</b>
<b>C.12.1</b> <b>Atomic</b> <b>memory</b> <b>consistency</b>
<b>C.12.1.1</b> <b>Relaxed</b> <b>memory</b> <b>model</b>
Parallel programs sometimes have apparently impossible behavior because data transfers and other messages can
be delayed, reordered and even repeated, by hardware, communication software, and caching and other forms
of optimization. Requiring processors to deliver globally consistent behavior is incompatible with performance
on many systems. This document specifies that all ordered actions will be consistent (5.3.5 and 11.7), but all
consistency between unordered segments is deliberately left processor dependent. Depending on the hardware,
this can be observed even when only two images and one mechanism are involved.
<b>C.12.1.2</b> <b>Examples</b> <b>with</b> <b>atomic</b> <b>operations</b>
When variables are being referenced (atomically) from segments that are unordered with respect to the segment
that is atomically defining or redefining the variables, the results are processor dependent. This supports use
of so-called "relaxed memory model" architectures, which can enable more efficient execution on some hardware
implementations.
The following examples assume these declarations:
   MODULE EXAMPLE
    USE,INTRINSIC :: ISO_FORTRAN_ENV
    INTEGER(ATOMIC_INT_KIND) :: X [*] = 0, Y [*] = 0, TMP
<b>Example</b> <b>1</b>
With X [<i>j</i>] and Y [<i>j</i>] still in their initial state (both zero), image <i>j</i> executes the following sequence of statements:
   CALL ATOMIC_DEFINE (X, 1)
   CALL ATOMIC_DEFINE (Y, 1)
and a different image, <i>k</i>, executes the following sequence of statements:
   DO
    CALL ATOMIC_REF (TMP, Y [<i>j</i>])
    IF (TMP==1) EXIT
   END DO
   CALL ATOMIC_REF (TMP, X [<i>j</i>])
   PRINT *, TMP
The final value of TMP on image <i>k</i> could be either 0 or 1. That is, even though image <i>j</i> thinks that it defined X
[<i>j</i>] before it defined Y [<i>j</i>], this ordering is not guaranteed to be observed on image <i>k</i>. There are many aspects of
hardware and software implementation that can cause this effect, but conceptually this example can be thought
of as the change in the value of Y propagating faster through the inter-image connections than the change in the
value of X.
Even if image <i>j</i> executed the sequence
   CALL ATOMIC_DEFINE (X, 1)
   SYNC MEMORY
   CALL ATOMIC_DEFINE (Y, 1)
the same effect could be seen. That is because even though X and Y are defined in ordered segments, the
references from image <i>k</i> are both from a segment that is unordered with respect to image <i>j</i>.
Only if the reference on image <i>k</i> to Y [<i>j</i>] is in a segment that is ordered after the segment on image <i>j</i> that defined
Y, will TMP be guaranteed to have the value 1.
<b>Example</b> <b>2:</b>
With the initial state of X and Y on image <i>j</i> (i.e. X [<i>j</i>] and Y [<i>j</i>]) still being zero, execution of
   CALL ATOMIC_REF (TMP, X [<i>j</i>])
   CALL ATOMIC_DEFINE (Y [<i>j</i>], 1)
   PRINT *, TMP
on image <i>k</i>
     1
     , and execution of
   CALL ATOMIC_REF (TMP, Y [<i>j</i>])
   CALL ATOMIC_DEFINE (X [<i>j</i>], 1)
   PRINT *, TMP
on image <i>k</i>
     2
     , in unordered segments, might print the value 1 both times.
This can happen by such mechanisms as "load buffering"; one might imagine that what is happening is that
the definitions (ATOMIC_DEFINE) are overtaking the references (ATOMIC_REF). On some processors it is
possible that insertion of SYNC MEMORY statements between the calls to ATOMIC_REF and ATOMIC_-
DEFINE might be sufficient to make the output print the value 1 at most one time (or even exactly one time),
butthisisstillprocessordependentunlesstheSYNCMEMORYstatementexecutionscausetherelevantsegments
on images <i>k</i>
      1
      and <i>k</i>
         2
         to be ordered.
<b>Example</b> <b>3:</b>
Because there are no segment boundaries implied by collective subroutines, with the initial state as before,
execution of
   IF (THIS_IMAGE ()==1) THEN
    CALL ATOMIC_DEFINE (X [3], 23)
    Y = 42
   END IF
   CALL CO_BROADCAST (Y, 1)
   IF (THIS_IMAGE ()==2) THEN
    CALL ATOMIC_REF (TMP, X [3])
    PRINT *, Y, TMP
   END IF
could print the values 42 and 0.
<b>Example</b> <b>4:</b>
Assuming the declarations
   INTEGER (ATOMIC_INT_KIND) :: X [*] = 0, Z = 0
the statements
   CALL ATOMIC_ADD (X [1], 1) ! (A)
   IF (THIS_IMAGE() == 2) THEN
    wait: DO
      CALL ATOMIC_REF (Z, X [1]) ! (B)
      IF (Z == NUM_IMAGES ()) EXIT wait
    END DO wait ! (C)
   END IF
will execute the "wait" loop on image 2 until all images have completed statement (A). The updates of X [1] are
performed by each image in the same manner, but in an arbitrary order. Because the result from the complete
set of updates will eventually become visible by execution of statement (B) for some loop iteration on image 2,
the termination condition is guaranteed to be eventually fulfilled, provided that no image failure occurs, every
image executes the above code, and no other code is executed in an unordered segment that performs an update
to X [1]. Furthermore, if two SYNC MEMORY statements are inserted in the above code before statement (A)
and after statement (C), respectively, the segment started by the second SYNC MEMORY on image 2 is ordered
after the segments on all images that end with the first SYNC MEMORY.
<b>C.12.2</b> <b>EVENT_QUERY</b> <b>example</b>
The following example illustrates the use of events via a program in which image one acts as the controlling image,
distributing work items to the other images. Only one work item at a time can be active on a worker image, and
each deals with the result (e.g. via input/output) without directly feeding data back to the controlling image.
Because the work items are not expected to be balanced, the controlling image keeps cycling through the other
images to find one that is waiting for work.
An event is posted by each worker to indicate that it has completed its work item. Since the corresponding
variables are needed only on the controlling image, we place them in an allocatable array component of a coarray.
An event on each worker is needed for the controlling image to post the fact that it has made a work item available
for it.
<b>Example</b> <b>code:</b>
   PROGRAM work_share
    USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY: EVENT_TYPE
    USE :: mod_work, ONLY: & ! Module that creates work items
             work, & ! Type for holding a work item
             create_work_item, & ! Function that creates work item
             process_item, & ! Function that processes an item
             work_done ! Logical function that returns true
                       ! if all work has been done.
    TYPE :: worker_type
     TYPE (EVENT_TYPE), ALLOCATABLE :: free (:)
    END TYPE
    TYPE (EVENT_TYPE) :: submit [*] ! Post when work ready for a worker
    TYPE (worker_type) :: worker [*] ! Post when worker is free
    TYPE (work) :: work_item [*] ! Holds the data for a work item
    INTEGER :: count, i, nbusy [*]
    IF (THIS_IMAGE ()==1) THEN
     ! Get started
     ALLOCATE (worker%free (2:NUM_IMAGES ()))
     nbusy = 0 ! This holds the number of workers working
     DO i = 2, NUM_IMAGES () ! Start the workers working
      IF (work_done ()) EXIT
      nbusy = nbusy + 1
      work_item [i] = create_work_item ()
      EVENT POST (submit [i])
     END DO
     ! Main work distribution loop
 main: DO
   image: DO i = 2, NUM_IMAGES ()
       CALL EVENT_QUERY (worker%free (i), count)
       IF (count==0) CYCLE image ! Worker is not free
       EVENT WAIT (worker%free (i))
       nbusy = nbusy - 1
       IF (work_done ()) CYCLE
       nbusy = nbusy + 1
       work_item [i] = create_work_item ()
       EVENT POST (submit [i])
      END DO image
      IF (nbusy==0) THEN
       ! All done. Exit on all images.
       DO i = 2, NUM_IMAGES ()
        EVENT POST (submit [i])
       END DO
       EXIT main
      END IF
     END DO main
    ELSE
     ! Work processing loop
 worker: DO
      EVENT WAIT (submit)
      IF (nbusy[1] == 0) EXIT
      CALL process_item (work_item)
      EVENT POST (worker [1]%free (THIS_IMAGE ()))
     END DO worker
    END IF
   END PROGRAM work_share
<b>C.12.3</b> <b>Collective</b> <b>subroutine</b> <b>examples</b>
The following example computes a dot product of two scalar coarrays using CO_SUM to store the result in a
noncoarray scalar variable.
   SUBROUTINE codot (x, y, x_dot_y)
     REAL :: x [*], y [*], x_dot_y
     x_dot_y = x*y
     CALL CO_SUM (x_dot_y)
   END SUBROUTINE codot
The function below demonstrates passing a noncoarray dummy argument to CO_MAX. The function uses CO_-
MAX to find the maximum value of the dummy argument across all images. Then the function flags all images
that hold values matching the maximum. The function then returns the maximum image index for an image that
holds the maximum value.
   FUNCTION find_max (j) RESULT (j_max_location)
    INTEGER, INTENT (IN) :: j
    INTEGER j_max, j_max_location
    j_max = j
    CALL CO_MAX (j_max)
    ! Flag images that hold the maximum j.
    IF (j==j_max) THEN
      j_max_location = THIS_IMAGE ()
    ELSE
      j_max_location = 0
    END IF
    ! Return highest image index associated with a maximal j.
    CALL CO_MAX(j_max_location)
   END FUNCTION find_max
<b>C.13</b> <b>Clause</b> <b>18</b> <b>notes</b>
<b>C.13.1</b> <b>Runtime</b> <b>environments</b> <b>(18.1)</b>
This document allows programs to contain procedures defined by means other than Fortran. That raises the
issues of initialization of and interaction between the runtime environments involved.
Implementations are free to solve these issues as they see fit, provided that
 heap allocation/deallocation (e.g., (DE)ALLOCATE in a Fortran subprogram and malloc/free in a C func-
  tion) can be performed without interference,
 input/output to and from external files can be performed without interference, as long as procedures defined
  by different means do not do input/output with the same external file,
 input/output preconnections exist as required by the respective standards, and
 initialized data are initialized according to the respective standards.
<b>C.13.2</b> <b>Example</b> <b>of</b> <b>Fortran</b> <b>calling</b> <b>C</b> <b>(18.3)</b>
<b>C</b> <b>Function</b> <b>Prototype:</b>
   int C_Library_Function(void* sendbuf, int sendcount, int *recvcounts);
<b>Fortran</b> <b>Module:</b>
   MODULE CLIBFUN_INTERFACE
     INTERFACE
      INTEGER (C_INT) FUNCTION C_LIBRARY_FUNCTION (SENDBUF, SENDCOUNT, RECVCOUNTS) &
              BIND(C, NAME='C_Library_Function')
        USE, INTRINSIC :: ISO_C_BINDING
        IMPLICIT NONE
        TYPE (C_PTR), VALUE :: SENDBUF
        INTEGER (C_INT), VALUE :: SENDCOUNT
        INTEGER (C_INT) :: RECVCOUNTS(*)
      END FUNCTION C_LIBRARY_FUNCTION
     END INTERFACE
   END MODULE CLIBFUN_INTERFACE
The module CLIBFUN_INTERFACE contains the declaration of the Fortran dummy arguments, which corres-
pond to the C formal parameters. The NAME= is used in the BIND attribute in order to handle the case-sensitive
name change between Fortran and C from "c_library_function" to "C_Library_Function".
The first C formal parameter is the pointer to void sendbuf, which corresponds to the Fortran dummy argument
SENDBUF, which has the type C_PTR and the VALUE attribute.
The second C formal parameter is the int sendcount, which corresponds to the Fortran dummy argument
SENDCOUNT, which has the type INTEGER (C_INT) and the VALUE attribute.
The third C formal parameter is the pointer to int recvcounts, which corresponds to the Fortran dummy
argument RECVCOUNTS, which is an assumed-size array of type INTEGER (C_INT).
This example shows how C_Library_Function might be referenced in a Fortran program unit:
   USE, INTRINSIC :: ISO_C_BINDING, ONLY: C_INT, C_FLOAT, C_LOC
   USE CLIBFUN_INTERFACE
   ...
   REAL (C_FLOAT), TARGET :: SEND(100)
   INTEGER (C_INT) :: SENDCOUNT, RET
   INTEGER (C_INT), ALLOCATABLE :: RECVCOUNTS(:)
   ...
   ALLOCATE( RECVCOUNTS(100) )
   ...
   RET = C_LIBRARY_FUNCTION(C_LOC(SEND), SENDCOUNT, RECVCOUNTS)
   ...
The first Fortran actual argument is a reference to the function C_LOC which returns the value of the C address
of its argument, SEND. This value becomes the value of the first formal parameter, the pointer sendbuf, in
C_Library_Function.
The second Fortran actual argument is SENDCOUNT of type INTEGER (C_INT). Its value becomes the initial
value of the second formal parameter, the int sendcount, in C_Library_Function.
The third Fortran actual argument is the allocatable array RECVCOUNTS of type INTEGER (C_INT). The
base C address of this array becomes the value of the third formal parameter, the pointer recvcounts, in
C_Library_Function. Note that interoperability is based on the characteristics of the dummy arguments in
the specified interface and not on those of the actual arguments. Thus, the fact that the actual argument is
allocatable is not relevant here.
<b>C.13.3</b> <b>Example</b> <b>of</b> <b>C</b> <b>calling</b> <b>Fortran</b> <b>(18.3)</b>
<b>Fortran</b> <b>Code:</b>
   SUBROUTINE SIMULATION(ALPHA, BETA, GAMMA, DELTA, ARRAYS) BIND(C)
     USE, INTRINSIC :: ISO_C_BINDING
     IMPLICIT NONE
     INTEGER (C_LONG), VALUE :: ALPHA
     REAL (C_DOUBLE), INTENT(INOUT) :: BETA
     INTEGER (C_LONG), INTENT(OUT) :: GAMMA
     REAL (C_DOUBLE),DIMENSION(*),INTENT(IN) :: DELTA
     TYPE, BIND(C) :: PASS
      INTEGER (C_INT) :: LENC, LENF
      TYPE (C_PTR) :: C, F
     END TYPE PASS
     TYPE (PASS), INTENT(INOUT) :: ARRAYS
     REAL (C_FLOAT), ALLOCATABLE, TARGET, SAVE :: ETA(:)
     REAL (C_FLOAT), POINTER :: C_ARRAY(:)
     ...
     ! Associate C_ARRAY with an array allocated in C
     CALL C_F_POINTER (ARRAYS%C, C_ARRAY, [ ARRAYS%LENC ])
     ...
     ! Allocate an array and make it available in C
     ARRAYS%LENF = 100
     ALLOCATE (ETA(ARRAYS%LENF))
     ARRAYS%F = C_LOC(ETA)
     ...
   END SUBROUTINE SIMULATION
<b>C</b> <b>Structure</b> <b>Declaration:</b>
   struct pass {
    int lenc, lenf;
    float *c, *f;
   };
<b>C</b> <b>Function</b> <b>Prototype:</b>
   void simulation(long alpha, double *beta, long *gamma, double delta[],
           struct pass *arrays);
<b>C</b> <b>Calling</b> <b>Sequence:</b>
   simulation(alpha, beta, gamma, delta, arrays);
The above-listed Fortran code specifies a subroutine SIMULATION. This subroutine corresponds to the C void
function simulation.
The Fortran subroutine references the intrinsic module ISO_C_BINDING.
The first Fortran dummy argument of the subroutine is ALPHA, which has the type INTEGER(C_LONG) and
the VALUE attribute. This dummy argument corresponds to the C formal parameter alpha, which is a long.
The C actual argument is also a long.
The second Fortran dummy argument of the subroutine is BETA, which has the type REAL(C_DOUBLE) and
the INTENT (INOUT) attribute. This dummy argument corresponds to the C formal parameter beta, which is
a pointer to double. An address is passed as the C actual argument.
The third Fortran dummy argument of the subroutine is GAMMA, which has the type INTEGER(C_LONG)
and the INTENT (OUT) attribute. This dummy argument corresponds to the C formal parameter gamma, which
is a pointer to long. An address is passed as the C actual argument.
ThefourthFortrandummyargumentistheassumed-sizearray DELTA, which hasthe type REAL(C_DOUBLE)
and the INTENT (IN) attribute. This dummy argument corresponds to the C formal parameter delta, which is
a double array. The C actual argument is also a double array.
The fifth Fortran dummy argument is ARRAYS, which is a structure for accessing an array allocated in C and
an array allocated in Fortran. The lengths of these arrays are held in the components LENC and LENF; their C
addresses are held in components C and F.
<b>C.13.4</b> <b>Example</b> <b>of</b> <b>calling</b> <b>C</b> <b>functions</b> <b>with</b> <b>noninteroperable</b> <b>data</b> <b>(18.10)</b>
Many Fortran processors support 16-byte real numbers, which might not be supported by the C processor.
Assume a Fortran programmer wants to use a C procedure from a message passing library for an array of these
reals. The C prototype of this procedure is
   void ProcessBuffer(void *buffer, int n_bytes);
with the corresponding Fortran interface
   USE, INTRINSIC :: ISO_C_BINDING
   INTERFACE
     SUBROUTINE PROCESS_BUFFER(BUFFER,N_BYTES) BIND(C,NAME="ProcessBuffer")
      IMPORT :: C_PTR, C_INT
      TYPE(C_PTR), VALUE :: BUFFER ! The ``C address'' of the array buffer
      INTEGER (C_INT), VALUE :: N_BYTES ! Number of bytes in buffer
     END SUBROUTINE PROCESS_BUFFER
   END INTERFACE
This can be done using C_LOC if the particular Fortran processor specifies that C_LOC returns an appropriate
address:
   REAL(R_QUAD), DIMENSION(:), ALLOCATABLE, TARGET :: QUAD_ARRAY
   ...
   CALL PROCESS_BUFFER(C_LOC(QUAD_ARRAY), INT(16*SIZE(QUAD_ARRAY),C_INT))
   ! One quad real takes 16 bytes on this processor
<b>C.13.5</b> <b>Example</b> <b>of</b> <b>opaque</b> <b>communication</b> <b>between</b> <b>C</b> <b>and</b> <b>Fortran</b> <b>(18.3)</b>
The following example demonstrates how a Fortran processor can make a modern object-oriented random number
generator written in Fortran available to a C program.
   USE, INTRINSIC :: ISO_C_BINDING
     ! Assume this code is inside a module
   TYPE RANDOM_STREAM
     ! A (uniform) random number generator (URNG)
   CONTAINS
     PROCEDURE(RANDOM_UNIFORM), DEFERRED, PASS(STREAM) :: NEXT
     ! Generates the next number from the stream
   END TYPE RANDOM_STREAM
   ABSTRACT INTERFACE
     ! Abstract interface of Fortran URNG
     SUBROUTINE RANDOM_UNIFORM(STREAM, NUMBER)
      IMPORT :: RANDOM_STREAM, C_DOUBLE
      CLASS(RANDOM_STREAM), INTENT(INOUT) :: STREAM
      REAL(C_DOUBLE), INTENT(OUT) :: NUMBER
     END SUBROUTINE RANDOM_UNIFORM
   END INTERFACE
A polymorphic object with declared type RANDOM_STREAM is not interoperable with C. However, we can
make such a random number generator available to C by packaging it inside another nonpolymorphic, nonpara-
meterized derived type:
   TYPE :: URNG_STATE ! No BIND(C), as this type is not interoperable
     CLASS(RANDOM_STREAM), ALLOCATABLE :: STREAM
   END TYPE URNG_STATE
The following two procedures will enable a C program to use our Fortran uniform random number generator:
   ! Initialize a uniform random number generator:
   SUBROUTINE INITIALIZE_URNG(STATE_HANDLE, METHOD) &
          BIND(C, NAME="InitializeURNG")
     TYPE(C_PTR), INTENT(OUT) :: STATE_HANDLE
      ! An opaque handle for the URNG
     CHARACTER(C_CHAR), DIMENSION(*), INTENT(IN) :: METHOD
      ! The algorithm to be used
     TYPE(URNG_STATE), POINTER :: STATE
      ! An actual URNG object
     ALLOCATE(STATE)
      ! There needs to be a corresponding finalization
      ! procedure to avoid memory leaks, not shown in this example
     ! Allocate STATE%STREAM with a dynamic type depending on METHOD
     ...
     STATE_HANDLE=C_LOC(STATE)
      ! Obtain an opaque handle to return to C
   END SUBROUTINE INITIALIZE_URNG
   ! Generate a random number:
   SUBROUTINE GENERATE_UNIFORM(STATE_HANDLE, NUMBER) &
         BIND(C, NAME="GenerateUniform")
     TYPE(C_PTR), INTENT(IN), VALUE :: STATE_HANDLE
      ! An opaque handle: Obtained via a call to INITIALIZE_URNG
     REAL(C_DOUBLE), INTENT(OUT) :: NUMBER
     TYPE(URNG_STATE), POINTER :: STATE
      ! A pointer to the actual URNG
     CALL C_F_POINTER(CPTR=STATE_HANDLE, FPTR=STATE)
       ! Convert the opaque handle into a usable pointer
     CALL STATE%STREAM%NEXT(NUMBER)
       ! Use the type-bound procedure NEXT to generate NUMBER
   END SUBROUTINE GENERATE_UNIFORM
<b>C.13.6</b> <b>Using</b> <b>assumed</b> <b>type</b> <b>to</b> <b>interoperate</b> <b>with</b> <b>C</b>
<b>C.13.6.1</b> <b>Overview</b>
The mechanism for handling unlimited polymorphic entities whose dynamic type is interoperable with C is
designed to handle the following two situations:
  (1) A formal parameter that is a C pointer to void. This is an address, and no further information
     about the entity is provided. The formal parameter corresponds to a dummy argument that is a
     nonallocatable nonpointer scalar or is an assumed-size array.
  (2) A formal parameter that is the address of a C descriptor. Additional information on the status, type,
     size, and shape is implicitly provided. The formal parameter corresponds to a dummy argument that
     is assumed-shape or assumed-rank.
In the first situation, it is the programmer's responsibility to explicitly provide any information needed on the
status, type, size, and shape of the entity.
<b>C.13.6.2</b> <b>Mapping</b> <b>of</b> <b>interfaces</b> <b>with</b> <b>void</b> <b>*</b> <b>C</b> <b>parameters</b> <b>to</b> <b>Fortran</b>
A C interface for message passing or input/output functionality could be provided in the form
   int EXAMPLE_send(const void *buffer, size_t buffer_size, const HANDLE_t *handle);
where the buffer_size argument is given in units of bytes, and the handle argument (which is of a type aliased
to int) provides information about the target the buffer is to be transferred to. In this example, type resolution
is not required.
The first method provides a thin binding; a call to EXAMPLE_send from Fortran directly invokes the C function.
   INTERFACE
     INTEGER (C_INT) FUNCTION example_send(buffer, buffer_size, handle) &
     BIND(C, NAME='EXAMPLE_send')
      USE, INTRINSIC :: ISO_C_BINDING
      TYPE(*), INTENT (IN) :: buffer(*)
      INTEGER (C_SIZE_T), VALUE :: buffer_size
      INTEGER (C_INT), INTENT (IN) :: handle
     END FUNCTION
   END INTERFACE
It is assumed that this interface is declared in the specification part of the module MOD_EXAMPLE_OLD. An
example of its use follows:
   USE, INTRINSIC :: ISO_C_BINDING
   USE MOD_EXAMPLE_OLD
   REAL(C_FLOAT) :: x(100)
   INTEGER(C_INT) :: y(10,10)
   REAL(C_DOUBLE) :: z
   INTEGER(C_INT) :: status, handle
   ...
   ! Assign values to x, y, z and initialize handle.
   ...
   ! Send values in x, y, and z using EXAMPLE_send.
   status = example_send(x, C_SIZEOF(x), handle)
   status = example_send(y, C_SIZEOF(y), handle)
   status = example_send([ z ], C_SIZEOF(z), handle)
In those invocations, x and y are passed directly with sequence association, but it is necessary to make an array
expression containing the value of z to pass it.
The second method provides a Fortran interface which is easier to use, but requires writing a separate C wrapper
routine. With this method, a C descriptor is created because the buffer is assumed-rank in the Fortran interface;
the use of an optional argument is also demonstrated.
   INTERFACE
     SUBROUTINE example_send(buffer, handle, status) BIND(C, NAME="EG_send_fortran")
      USE, INTRINSIC :: ISO_C_BINDING
      TYPE(*), CONTIGUOUS, INTENT (IN) :: buffer(..)
      INTEGER (C_INT), INTENT (IN) :: handle
      INTEGER (C_INT), INTENT(OUT), OPTIONAL :: status
     END SUBROUTINE
   END INTERFACE
It is assumed that this interface is declared in the specification part of a module MOD_EXAMPLE_NEW.
Example invocations from Fortran are then
   USE, INTRINSIC :: iso_c_binding
   USE mod_example_new
   TYPE, BIND(C) :: my_derived
     INTEGER(C_INT) :: len_used
     REAL(C_FLOAT) :: stuff(100)
   END TYPE
   TYPE(my_derived) :: w(3)
   REAL(C_FLOAT) :: x(100)
   INTEGER(C_INT) :: y(10,10)
   REAL(C_DOUBLE) :: z
   INTEGER(C_INT) :: status, handle
   ...
   ! Assign values to w, x, y, z and initialize handle.
   ...
   ! Send values in w, x, y, and z using example_send.
   CALL example_send(w, handle, status)
   CALL example_send(x, handle)
   CALL example_send(y, handle)
   CALL example_send(z, handle)
   CALL example_send(y(:,5), handle) ! Fifth column of y.
   CALL example_send(y(1,5), handle) ! Scalar y(1,5) passed by descriptor.
The wrapper routine can be written in C as follows.
   #include "ISO_Fortran_binding.h"
   void EG_send_fortran(const CFI_cdesc_t *buffer, const HANDLE_t *handle,int *status)
   {
    int status_local;
    size_t buffer_size;
    int i;
    buffer_size = buffer->elem_len;
    for (i=0; i<buffer->rank; i++) {
     buffer_size *= buffer->dim[i].extent;
    }
    status_local = EXAMPLE_send(buffer->base_addr,buffer_size, handle);
    if (status != NULL) *status = status_local;
   }
<b>C.13.7</b> <b>Using</b> <b>assumed-type</b> <b>variables</b> <b>in</b> <b>Fortran</b>
Anassumed-typedummyargumentinaFortranprocedurecanbeusedasanactualargumentcorrespondingtoan
assumed-type dummy in a call to another procedure. In the following example, the Fortran subroutine SIMPLE_-
SEND serves as a wrapper to hide the complications associated with calls to a C function named ACTUAL_Send.
Module COMM_INFO contains node and address information for the current data transfer operations.
   SUBROUTINE SIMPLE_SEND(buffer, nbytes)
    USE comm_info, ONLY: my_node, r_node, r_addr
    USE, INTRINSIC :: ISO_C_BINDING
    IMPLICIT NONE
    TYPE(*), INTENT (IN) :: buffer(*)
    INTEGER :: nbytes, ierr
    INTERFACE
      SUBROUTINE actual_Send(buffer, nbytes, node, addr, ierr) &
      BIND(C, NAME="ACTUAL_Send")
       IMPORT :: C_SIZE_T, C_INT, C_INTPTR_T
       TYPE(*), INTENT (IN) :: buffer(*)
       INTEGER(C_SIZE_T), VALUE :: nbytes
       INTEGER(C_INT), VALUE :: node
       INTEGER(C_INTPTR_T), VALUE :: addr
       INTEGER(C_INT), INTENT(OUT) :: ierr
      END SUBROUTINE actual_Send
    END INTERFACE
    CALL actual_Send(buffer, INT(nbytes, C_SIZE_T), r_node, r_addr, ierr)
    IF (ierr /= 0) THEN
      PRINT *, "Error sending from node", my_node, "to node", r_node
      PRINT *, "Program Aborting" ! Or call a recovery procedure
      ERROR STOP ! Omit in the recovery case
    END IF
   END SUBROUTINE simple_Send
<b>C.13.8</b> <b>Simplifying</b> <b>interfaces</b> <b>for</b> <b>arbitrary</b> <b>rank</b> <b>procedures</b>
There are situations where an assumed-rank dummy argument can be useful in Fortran, although a Fortran
procedure cannot itself access its value. For example, the IEEE inquiry functions in Clause 14 could be written
using an assumed-rank dummy argument instead of writing 16 separate specific routines, one for each possible
rank.
In particular, the specific procedures for the IEEE_SUPPORT_DIVIDE function could possibly be implemented
in Fortran as follows:
   INTERFACE ieee_support_divide
     MODULE PROCEDURE ieee_support_divide_noarg, ieee_support_divide_onearg_r, &
             ieee_support_divide_onearg_d
   END INTERFACE ieee_support_divide
   ...
   LOGICAL FUNCTION ieee_support_divide_noarg ()
     ieee_support_divide_noarg = .TRUE.
   END FUNCTION ieee_support_divide_noarg
   LOGICAL FUNCTION ieee_support_divide_onearg_r (x)
     REAL, INTENT (IN) :: x(..)
     ieee_support_divide_onearg_r4 = .TRUE.
   END FUNCTION ieee_support_divide_onearg_r
   LOGICAL FUNCTION ieee_support_divide_onearg_d (x)
     DOUBLE PRECISION, INTENT (IN) :: x(..)
     ieee_support_divide_onearg_r8 = .TRUE.
   END FUNCTION ieee_support_divide_onearg_d
<b>C.13.9</b> <b>Processing</b> <b>assumed-rank</b> <b>in</b> <b>C</b>
The example shown below calculates the product of individual elements of arrays B and C and returns the result
in array A. The Fortran interface of elemental_mult will accept arguments of any type and rank. However, the
C function will return an error code if any argument is not a two-dimensional int array. Note that the arguments
are permitted to be array sections, so the C function does not assume that any argument is contiguous.
This demonstrates runtime error detection even though these specific errors could have been detected at compile-
time, if the interface declared the arrays as "INTEGER (C_INT), DIMENSION (:, :)".
The Fortran interface is:
   INTERFACE
     FUNCTION elemental_mult(a, b, c) BIND(C, NAME="elemental_mult_c") RESULT(err)
      USE, INTRINSIC :: ISO_C_BINDING
      INTEGER(C_INT) :: err
      TYPE(*), DIMENSION(..) :: a, b, c
     END FUNCTION elemental_mult
   END INTERFACE
The definition of the C function is:
   #include "ISO_Fortran_binding.h"
   int elemental_mult_c(CFI_cdesc_t * a_desc, CFI_cdesc_t * b_desc, CFI_cdesc_t * c_desc)
   {
    size_t i, j, ni, nj;
    int err = 1; /* this error code represents all errors */
    char * a_col = (char*) a_desc->base_addr;
    char * b_col = (char*) b_desc->base_addr;
    char * c_col = (char*) c_desc->base_addr;
    char *a_elt, *b_elt, *c_elt;
    /* Only support int. */
    if (a_desc->type != CFI_type_int || b_desc->type != CFI_type_int ||
      c_desc->type != CFI_type_int) {
      return err;
    }
    /* Only support two dimensions. */
    if (a_desc->rank != 2 || b_desc->rank != 2 || c_desc->rank != 2) {
      return err;
    }
    ni = a_desc->dim[0].extent;
    nj = a_desc->dim[1].extent;
    /* Ensure the shapes conform. */
    if (ni != b_desc->dim[0].extent || ni != c_desc->dim[0].extent) return err;
    if (nj != b_desc->dim[1].extent || nj != c_desc->dim[1].extent) return err;
    /* Multiply the elements of the two arrays. */
    for (j = 0; j < nj; j++) {
     a_elt = a_col;
     b_elt = b_col;
     c_elt = c_col;
     for (i = 0; i < ni; i++) {
      *(int*)a_elt = *(int*)b_elt * *(int*)c_elt;
      a_elt += a_desc->dim[0].sm;
      b_elt += b_desc->dim[0].sm;
      c_elt += c_desc->dim[0].sm;
     }
     a_col += a_desc->dim[1].sm;
     b_col += b_desc->dim[1].sm;
     c_col += c_desc->dim[1].sm;
    }
    return 0;
   }
<b>C.13.10</b> <b>Creating</b> <b>a</b> <b>contiguous</b> <b>copy</b> <b>of</b> <b>an</b> <b>array</b>
A C function might need to create a contiguous copy of an array section, for example, to pass the array section
as an actual argument corresponding to a dummy argument with the CONTIGUOUS attribute. The following
example provides functions that can be used to copy an array described by a CFI_cdesc_t descriptor to a
contiguous buffer. The input array need not be contiguous.
The C functions are:
   #include "ISO_Fortran_binding.h"
   /* Other necessary includes omitted. */
   /*
    * Returns the number of elements in the object described by desc.
    * If it is an array, it need not be contiguous.
    * (The number of elements could be zero).
    */
   size_t numElements(const CFI_cdesc_t * desc)
   {
     CFI_rank_t r;
     size_t num = 1;
     for (r = 0; r < desc->rank; r++) {
      num *= desc->dim[r].extent;
     }
     return num;
   }
   /*
    * Auxiliary recursive function to copy an array of a given rank.
    * Recursion is useful because an array of rank n is composed of an
    * ordered set of arrays of rank n-1.
    */
   static void *_copyToContiguous (const CFI_cdesc_t *vald, void *output,
                   const void *input, CFI_rank_t rank)
   {
     CFI_index_t e;
     if (rank == 0) {
      /* Copy scalar element. */
      memcpy (output, input, vald->elem_len);
      output = (void *)((char *)output + vald->elem_len);
     }
     else {
      for (e = 0; e < vald->dim[rank-1].extent; e++) {
        /* Recurse on subarrays of lesser rank. */
        output = _copyToContiguous (vald, output, input, rank-1);
        input = (void *) ((char *)input + vald->dim[rank].sm);
      }
     }
     return output;
   }
   /*
    * General routine to copy the elements in the array described by vald
    * to buffer, as done by sequence association. The array itself can
    * be non-contiguous. This is not the most efficient approach.
    */
   void copyToContiguous (void * buffer, const CFI_cdesc_t * vald) {
     _copyToContiguous (vald, buffer, vald->base_addr, vald->rank);
   }
<b>C.13.11</b> <b>Changing</b> <b>the</b> <b>attributes</b> <b>of</b> <b>an</b> <b>array</b>
A C programmer might want to call more than one Fortran procedure and the attributes of an array involved
might differ between the procedures. In this case, it is necessary to set up more than one C descriptor for the
array. For example, this code fragment initializes the first C descriptor for an allocatable entity of rank 2, calls
a procedure that allocates the array described by the first C descriptor, constructs the second C descriptor by
invoking CFI_establish with the value CFI_attribute_other for the attribute parameter, then calls a procedure
that expects an assumed-shape array.
   CFI_CDESC_T(2) loc_alloc, loc_assum;
   CFI_cdesc_t * desc_alloc = (CFI_cdesc_t *)&loc_alloc,
         * desc_assum = (CFI_cdesc_t *)&loc_assum;
   CFI_index_t extents[2];
   CFI_rank_t rank = 2;
   int flag;
   flag = CFI_establish(desc_alloc,
              NULL,
              CFI_attribute_allocatable,
              CFI_type_double,
              sizeof(double),
              rank,
              NULL);
   Fortran_factor (desc_alloc, ...); /* Allocates array described by desc_alloc. */
   /* Extract extents from descriptor. */
   extents[0] = desc_alloc->dim[0].extent;
   extents[1] = desc_alloc->dim[1].extent;
   flag = CFI_establish(desc_assum,
              desc_alloc->base_addr,
              CFI_attribute_other,
              CFI_type_double,
              sizeof(double),
              rank,
              extents);
   Fortran_solve (desc_assum, ...); /* Uses array allocated in Fortran_factor. */
After invocation of the second CFI_establish, the lower bounds stored in the dim member of desc_assum will
have the value zero even if the corresponding entries in desc_alloc have different values.
<b>C.13.12</b> <b>Creating</b> <b>an</b> <b>array</b> <b>section</b> <b>in</b> <b>C</b> <b>using</b> <b>CFI_section</b>
The C function set_odd sets every second element of an array to a specific value, beginning with the first element.
It does this by making an array section descriptor for the elements to be set, and calling a Fortran subroutine
SET_ALL that sets every element of an assumed-shape array to a specific value. An interface block for set_odd
permits it to be also called from Fortran.
   SUBROUTINE set_all(int_array, val) BIND(C)
    INTEGER(C_INT) :: int_array(:)
    INTEGER(C_INT), VALUE :: val
    int_array = val
   END SUBROUTINE
   INTERFACE
    SUBROUTINE set_odd(int_array, val) BIND(C)
     USE, INTRINSIC :: ISO_C_BINDING, ONLY : C_INT
     INTEGER(C_INT) :: int_array(:)
     INTEGER(C_INT), VALUE :: val
    END SUBROUTINE
   END INTERFACE
   #include "ISO_Fortran_binding.h"
   void set_odd(CFI_cdesc_t *int_array, int val)
   {
     CFI_index_t lower_bound[1], upper_bound[1], stride[1];
     CFI_CDESC_T(1) array;
     int status;
     /* Create a new descriptor which will contain the section. */
     status = CFI_establish((CFI_cdesc_t *)&array,
                NULL,
                CFI_attribute_other,
                int_array->type,
                int_array->elem_len,
                /* rank */ 1,
                /* extents is ignored */NULL);
     lower_bound[0] = int_array->dim[0].lower_bound;
     upper_bound[0] = lower_bound[0] + (int_array->dim[0].extent - 1);
     stride[0] = 2;
     status = CFI_section((CFI_cdesc_t *)&array,
               int_array,
               lower_bound,
               upper_bound,
               stride);
     set_all( (CFI_cdesc_t *) &array, val);
     /* Here one could make use of int_array and access all its data. */
   }
The set_odd procedure can be called from Fortran as follows:
   INTEGER(C_INT) :: d(5)
   d = (/ 1, 2, 3, 4, 5 /)
   CALL set_odd(d, -1)
   PRINT *, d
This program will print something like:
    -1 2 -1 4 -1
During execution of the subroutine SET_ALL, its dummy argument INT_ARRAY would have size (and upper
bound) 3.
It is also possible to invoke set_odd() from C. However, it would be the C programmer's responsibility to make
sure that all members of the C descriptor have the correct value on entry to the function. Inserting additional
checking into the function could alleviate this problem.
Following is an example C function that dynamically generates a C descriptor for an assumed-shape array and
calls set_odd.
   #include <stdio.h>
   #include <stdlib.h>
   #include "ISO_Fortran_binding.h"
   #define ARRAY_SIZE 5
   void example_of_calling_set_odd(void)
   {
    CFI_CDESC_T(1) d;
    CFI_index_t extent[1];
    CFI_index_t subscripts[1];
    void *base;
    int i, status;
    base = malloc(ARRAY_SIZE*sizeof(int));
    extent[0] = ARRAY_SIZE;
    status = CFI_establish((CFI_cdesc_t *)&d,
                base,
                CFI_attribute_other,
                CFI_type_int,
                /* element length is ignored */ 0,
                /* rank */ 1,
                extent);
    set_odd((CFI_cdesc_t *)&d, -1);
    for (i=0; i<ARRAY_SIZE; i++) {
     subscripts[0] = i;
     printf(" %d",*((int *)CFI_address((CFI_cdesc_t *)&d, subscripts)));
    }
    putc('\n', stdout);
    free(base);
   }
The above C function will print similar output to that of the preceding Fortran program.
<b>C.13.13</b> <b>Use</b> <b>of</b> <b>CFI_setpointer</b>
The C function change_target modifies a pointer to an integer variable to become associated with a global
variable defined inside C:
   #include "ISO_Fortran_binding.h"
   int y = 2;
   void change_target(CFI_cdesc_t *ip) {
     CFI_CDESC_T(0) yp;
     int status;
     /* Make local yp point at y. */
     status = CFI_establish((CFI_cdesc_t *)&yp,
                &y,
                CFI_attribute_pointer,
                CFI_type_int,
                /* elem_len is ignored */ sizeof(int),
                /* rank */ 0,
                /* extents are ignored */ NULL);
     /* Pointer-associate ip with (the target of) yp. */
     status = CFI_setpointer(ip, (CFI_cdesc_t *)&yp, NULL);
     if (status != CFI_SUCCESS) {
      ... <i>Report</i> <i>run</i> <i>time</i> <i>error.</i>
     }
   }
The restrictions on the use of CFI_establish prohibit direct modification of the incoming pointer entity ip by
invoking that function on it.
The following program illustrates the usage of change_target from Fortran.
   PROGRAM change_target_example
    USE, INTRINSIC :: ISO_C_BINDING
    INTERFACE
     SUBROUTINE change_target(ip) BIND(C)
      IMPORT :: C_INT
      INTEGER(C_INT), POINTER :: ip
     END SUBROUTINE
    END INTERFACE
    INTEGER(C_INT), TARGET :: it = 1
    INTEGER(C_INT), POINTER :: it_ptr
    it_ptr => it
    WRITE (*,*) it_ptr
    CALL change_target(it_ptr)
    WRITE (*,*) it_ptr
This will print something similar to
    1
    2
<b>C.13.14</b> <b>Mapping</b> <b>of</b> <b>MPI</b> <b>interfaces</b> <b>to</b> <b>Fortran</b>
The Message Passing Interface (MPI) specifies procedures for exchanging data between MPI processes. This
example shows the usage of MPI_Send and is similar to the second variant of EXAMPLE_Send in C.13.6.2. It also
shows the usage of assumed-length character dummy arguments and optional dummy arguments.
MPI_Send has the C prototype:
   int MPI_Send(void *buf, int count, MPI_Datatype datatype, int dest, int tag,
          MPI_Comm comm);
where MPI_Datatype and MPI_Comm are opaque handles. Most MPI C functions return an error code, which in
Fortran is the last dummy argument to the corresponding subroutine and can be made optional. Thus, the use
of a Fortran subroutine requires a wrapper function, declared as
   void MPI_Send_f(CFI_cdesc_t *buf, int count, MPI_Datatype_f datatype, int dest,
           int tag, MPI_Datatype_f comm, int *ierror);
This wrapper function will convert MPI_Datatype_f and MPI_Comm_f to MPI_Datatype and MPI_Comm, and pro-
duce a contiguous void * buffer from CFI_cdesc_t *buf (if necessary).
Similarly, the wrapper function for MPI_Comm_set_name could have the C prototype:
   void MPI_Comm_set_name_f(MPI_Comm comm, CFI_cdesc_t *comm_name, int *ierror);
The Fortran handle types and interfaces are defined in the module MPI_F08. For example,
   MODULE mpi_f08
    ...
    TYPE, BIND(C) :: mpi_comm
     PRIVATE
     INTEGER(C_INT) :: mpi_val
    END TYPE mpi_comm
    INTERFACE
     SUBROUTINE MPI_SEND(buf,count,datatype,dest,tag,comm,ierror) &
     BIND(C, NAME='MPI_Send_f')
      USE, INTRINSIC :: ISO_C_BINDING
      IMPORT :: MPI_Datatype, MPI_Comm
      TYPE(*), DIMENSION(..), INTENT (IN) :: buf
      INTEGER(C_INT), VALUE, INTENT (IN) :: count, dest, tag
      TYPE(mpi_datatype), INTENT (IN) :: datatype
      TYPE(mpi_comm), INTENT (IN) :: comm
      INTEGER(C_INT), OPTIONAL, INTENT (OUT) :: ierror
     END SUBROUTINE mpi_send
     SUBROUTINE mpi_comm_set_name(comm,comm_name,ierror) &
     BIND(C, NAME='MPI_Comm_set_name_f')
      USE, INTRINSIC :: ISO_C_BINDING
      IMPORT :: mpi_comm
      TYPE(mpi_comm), INTENT (IN) :: comm
      CHARACTER(KIND=C_CHAR, LEN=*), INTENT (IN) :: comm_name
      INTEGER(C_INT), OPTIONAL, INTENT (OUT) :: ierror
     END SUBROUTINE mpi_comm_set_name
    END INTERFACE
    ...
   END MODULE mpi_f08
Some examples of invocation from Fortran are:
   USE, INTRINSIC :: ISO_C_BINDING
   USE :: MPI_f08
   TYPE(mpi_comm) :: comm
   REAL :: x(100)
   INTEGER :: y(10,10)
   REAL(KIND(1.0d0)) :: z
   INTEGER :: dest, tag, ierror
   ...
   ! Assign values to x, y, z and initialize MPI variables.
   ...
   ! Set the name of the communicator.
   CALL mpi_comm_set_name(comm, "Communicator Name", ierror)
   ! Send values in x, y, and z.
   CALL mpi_send(x, 100, MPI_REAL, dest, tag, comm, ierror)
   IF (ierror/=0) PRINT *, 'WARNING: X send error', ierror
   CALL mpi_send(y(3,:), 10, MPI_INTEGER, dest, tag, comm)
   CALL mpi_send(z, 1, MPI_DOUBLE_PRECISION, dest, tag, comm)
The first example sends the entire array X and includes the optional error argument return value. The second
example sends a noncontiguous subarray (the third row of Y) and the third example sends a scalar Z. Note the
differences between the calls in this example and those in C.13.6.2.
<b>C.14</b> <b>Clause</b> <b>19</b> <b>notes</b>
<b>C.14.1</b> <b>Examples</b> <b>of</b> <b>global</b> <b>identifiers</b> <b>and</b> <b>binding</b> <b>labels</b> <b>(19.2)</b>
<b>Example</b> <b>1:</b>
   MODULE M1
     INTERFACE
       SUBROUTINE S() BIND(C,NAME='X')
       END
     END INTERFACE
   END MODULE
   MODULE M2
     INTERFACE
       SUBROUTINE S() BIND(C,NAME='Y')
       END
     END INTERFACE
   END MODULE
The name S in each module is a local identifier. The two interfaces declare two different external procedures, one
with the global identifier "X", the other with the global identifier "Y".
<b>Example</b> <b>2:</b>
   MODULE M1
     INTERFACE
       SUBROUTINE S1() BIND(C,NAME='X')
       END
     END INTERFACE
   END MODULE
   MODULE M2
     INTERFACE
       SUBROUTINE S2() BIND(C,NAME='X')
       END
     END INTERFACE
   END MODULE
The names S1 and S2 are local identifiers. The interfaces declare the same external procedure, which has the
global identifier "X".
<b>C.14.2</b> <b>Examples</b> <b>of</b> <b>host</b> <b>association</b> <b>(19.5.1.4)</b>
The first two examples are examples of valid host association. The third example is an example of invalid host
association.
<b>Example</b> <b>1:</b>
   PROGRAM A
     INTEGER I, J
     ...
   CONTAINS
     SUBROUTINE B
      INTEGER I ! Declaration of I hides
            ! program A's declaration of I
      ...
      I = J ! Use of variable J from program A
            ! through host association
     END SUBROUTINE B
   END PROGRAM A
<b>Example</b> <b>2:</b>
   PROGRAM A
     TYPE T
      ...
     END TYPE T
     ...
   CONTAINS
     SUBROUTINE B
      IMPLICIT TYPE (T) (C) ! Refers to type T declared below
                  ! in subroutine B, not type T
                  ! declared above in program A
      ...
      TYPE T
        ...
      END TYPE T
      ...
     END SUBROUTINE B
   END PROGRAM A
<b>Example</b> <b>3:</b>
   PROGRAM Q
     REAL (KIND = 1) :: C
     ...
   CONTAINS
     SUBROUTINE R
      REAL (KIND = KIND (C)) :: D ! Invalid declaration
                     ! See below
      REAL (KIND = 2) :: C
      ...
     END SUBROUTINE R
   END PROGRAM Q
In the declaration of D in subroutine R, the use of C would refer to the declaration of C in subroutine R, not
program Q. However, it is invalid because the declaration of C is required to occur before it is used in the
declaration of D (10.1.12).
           <b>Index</b>
In the index, entries in <i>italics</i> denote BNF terms, and page numbers in <b>bold</b> <b>face</b> denote primary text or
definitions.
<b>Symbols</b>
-, 161
<i><</i>, 165, 467
<i><</i>=, 165
<i>></i>, 165
<i>></i>=, 165
*, 58, 61, 63, 64, 69, 107, 111, 122, 145, 161, 251, 280,
    293, 298, 320, 340
**, 161
+, 161
.. assumed-rank specifier, 112
.AND., 156, 157, 160, <b>164</b>, 164, 364
.EQ., 155, 157, 160, <b>165</b>, 165-167, 311, 467
.EQV., 156, 157, 160, <b>164</b>, 164
.FALSE., <b>72</b>, 501
.GE., 155, 157, 160, <b>165</b>, 165, 167, 311, 467
.GT., 155, 157, 160, <b>165</b>, 165, 167, 311, 467
.LE., 155, 157, 160, <b>165</b>, 165, 167, 311, 467
.LT., 155, 157, 160, <b>165</b>, 165, 167, 311, 467
.NE., 155, 157, 160, <b>165</b>, 165-167, 311, 467
.NEQV., 156, 157, 160, <b>164</b>, 164, 429
.NIL., 53, <b>321</b>, 321, 323
.NOT., 156, 157, 160, <b>164</b>, 164
.OR., 156, 157, 160, <b>164</b>, 164, 365
.TRUE., <b>72</b>, 501
/, 161
/ edit descriptor, 290
//, 163
/=, 165, 467
: edit descriptor, 291
;, 57
<=, 467
==, 165, 467
>, 467
>=, 467
                         &, 57, 297
          <b>A</b>
                         A edit descriptor, 287
                         ABS, <b>361</b>, 470
                         ABSTRACT, <b>73</b>, 73, 89, <b>311</b>, 312
                         ABSTRACT attribute, 73, <b>89</b>
                         abstract interface, <b>15</b>, 303, <b>310</b>, 312, 318, 338, 534, 538
                         abstract interface block, <b>16</b>, 312
                         abstract type, <b>25</b>, 62, 86, <b>89</b>, 89, 92, 137, 145
                        <i>ac-do-variable</i> (R784), <b>100</b>, 100, 171, 172, 536
                        <i>ac-implied-do</i> (R782), <b>100</b>, 100, 159, 536
                        <i>ac-implied-do-control</i> (R783), <b>100</b>, 100, 159, 170-172,
                             536
                        <i>ac-spec</i> (R778), <b>99</b>, 99
                        <i>ac-value</i> (R781), 99, <b>100</b>, 100
                        <i>access-id</i> (R831), <b>119</b>, 119
                        <i>access-name</i>, 119
                        <i>access-spec</i> (R807), 73, 78, 79, 84-86, 96, 97, 102, <b>105</b>,
                             105, 119, 120, 313, 317
                        <i>access-stmt</i> (R830), 39, 97, 105, <b>119</b>, 119, 120
                         ACCESS= specifier, <b>237</b>, 237, 264, <b>265</b>
                         accessibility attribute, <b>105</b>, 119, 303
                         accessibility statement, 119
                         ACHAR, 72, 176, <b>362</b>
                         ACOS, <b>362</b>
                         ACOSD, <b>362</b>
                         ACOSH, 33, <b>362</b>
                         ACOSPI, <b>363</b>
                         ACQUIRED_LOCK= specifier, <b>222</b>, 549, 552
                         action, 228
                        <i>action-stmt</i> (R515), <b>40</b>, 40, 159, 204, 212
                         ACTION= specifier, 237, <b>238</b>, 264, <b>265</b>, 590
                         active image, <b>14</b>, 44, 147, 148, 151, 152, 192, 193, 222,
                             225, 353, 423
                         actual argument, <b>3</b>, 33, 34, 44, 48-50, 63, 66, 76, 87,
    88, 109, 111-115, 137, 139, 148, 150, 159, 169,
    201, 256, 314-316, 319-332, 334, 335, 343-345,
    347-350, 354, 359, 361, 385, 410, 426, 427, 436,
    453-455, 458, 470, 506-509, 511, 513, 515, 516,
    537, 541-543, 546, 551-553, 563, 568, 609-612,
    615, 616
<i>actual-arg</i> (R1524), <b>320</b>, 320, 321, 323
<i>actual-arg-spec</i> (R1523), 92, <b>320</b>, 320
<i>add-op</i> (R1010), 54, 154, <b>155</b>, 155
<i>add-operand</i> (R1006), <b>154</b>, 154, 155, 158
ADJUSTL, <b>363</b>
ADJUSTR, <b>363</b>
ADVANCE= specifier, 242, 243, <b>244</b>, 244, 256, 589
advancing input/output statement, 231
AIMAG, 138, <b>363</b>
AINT, <b>364</b>
ALL, <b>128</b>, <b>364</b>
<i>alloc-opt</i> (R930), <b>145</b>, 145, 146, 152
allocatable, <b>3</b>, 33, 48, 49, 61, 64, 74, 75, 80, 81, 83, 88,
    91-93, 103, 107, 111, 113, 114, 118, 121, 131,
    133, 137, 138, 145, 148-151, 169, 172, 174-
    177, 179, 180, 201, 216, 248, 249, 253, 294,
    309, 310, 320, 321, 325, 327, 328, 331, 339,
    345, 349, 365, 384, 394, 410, 411, 422, 423,
    426, 427, 437, 441, 444, 447, 450, 454, 455,
    465, 471, 501, 508, 511-513, 517, 524, 526-
    528, 540, 541, 550
ALLOCATABLE attribute, 61-63, 72, 78, <b>105</b>, 105,
    107, 111, 112, 116-118, 120, 137, 140, 190,
    196, 200, 207, 208, 307, 310, 315, 316, 321,
    323, 327, 331, 338, 347, 512, 540, 546, 547,
    612, 616
ALLOCATABLE statement, <b>120</b>
<i>allocatable-decl</i> (R833), <b>120</b>, 120
<i>allocatable-stmt</i> (R832), 39, <b>120</b>, 538
ALLOCATE statement, 61, 63, 69, 70, 108, 111, <b>145</b>,
    148, 152, 179, 215, 458, 461, 522, 541, 542,
    549-551, 555, 568
<i>allocate-coarray-spec</i> (R940), <b>145</b>, 145, 146
<i>allocate-coshape-spec</i> (R941), <b>145</b>, 145, 146
<i>allocate-object</i> (R934), 69, 70, <b>145</b>, 145-148, 150-152,
    215, 458, 460, 461, 552, 553, 555
<i>allocate-shape-spec</i> (R935), <b>145</b>, 145-148
<i>allocate-stmt</i> (R929), 40, <b>145</b>, 553
ALLOCATED, 148, 152, 172, <b>364</b>
<i>allocation</i> (R933), <b>145</b>, 145-148
                         allocation status, <b>49</b>, 91-93, 114, 117, 118, <b>148</b>, 149-
                             152, 201, 216, 219, 328, 332, 364, 422, 426,
                             528, 546, 550
                        <i>alphanumeric-character</i> (R601), <b>52</b>, 52, 53
                        <i>alt-return-spec</i> (R1525), 212, <b>320</b>, 320
                         ancestor component, <b>89</b>
                        <i>ancestor-module-name</i>, 306
                        <i>and-op</i> (R1020), 54, <b>156</b>, 156
                        <i>and-operand</i> (R1015), <b>156</b>, 156
                         ANINT, <b>365</b>
                         ANY, <b>365</b>
                        <i>arg-name</i>, 79, 81, 85
                         argument
                           dummy, 325
                         argument association, <b>4</b>, 61, 70, 80, 81, 107, 111, 118,
                             119, 150, 151, 308, 322, 324, 334, 341, 517,
                             537, 543, 545, 546, 562, 611
                         argument keyword, <b>17</b>, 50, 310, 313, 322, 349, 354, 470,
                             534, <b>535,</b> <b>536</b>, 598
                         arithmetic IF statement, <b>562</b>
                         array, <b>3</b>, 49, 109-112, 139-142
                           assumed-shape, <b>3</b>, 63, 108-111, 117, 130, 143, 310,
                             325-327, 329, 332, 338, 501, 514, 528, 610, 626,
                             633, 635
                           assumed-size, <b>4</b>, 109, 111-113, 118, 131, 139, 140,
                             153, 170, 173, 196, 208, 209, 247, 325-327, 330,
                             331, 410, 441, 444, 454, 506, 509, 513-517, 521,
                             524-528, 622, 624, 626
                           deferred-shape, <b>4</b>, 111, 117
                           explicit-shape, <b>4</b>, 63, 80, 107, 109, 110, 173, 325,
                             327, 330, 513-516
                         array bound, <b>6</b>, 79, 81, 104, 171
                         array constructor, 60, <b>99</b>, 99
                         array element, <b>3</b>, 48, 140
                         array element order, 141
                         array pointer, <b>3</b>, 108, 111, 169, 367, 513
                         array section, <b>3</b>, 108, 121, 122, 138, 140-143, 190, 233,
                             234, 325, 326, 332, 540, 543
                        <i>array-constructor</i> (R777), <b>99</b>, 100, 153
                        <i>array-element</i> (R917), 121, 122, 131, 135, 136, <b>139</b>, 200
                        <i>array-name</i>, 123, 538
                        <i>array-section</i> (R918), 135, <b>139</b>, 140, 141, 200
                        <i>array-spec</i> (R814), 30, 102, 103, 105,<b>109</b>, 109, 111, 112,
                             120, 123, 125, 133
                         ASCIIcharacter,<b>4</b>,<b>69</b>,<b>72</b>, 174, 233, 234, 249, 279, 293,
                             294, 362, 379, 401, 404, 412, 413, 424, 439
ASCII collating sequence, <b>72</b>, 362, 379, 401, 404, 412,
    413, 424
ASIN, <b>366</b>
ASIND, <b>366</b>
ASINH, <b>366</b>
ASINPI, <b>366</b>
ASSIGN statement, <b>561</b>
assigned format, <b>561</b>
assigned GO TO statement, <b>561</b>
ASSIGNMENT, 85, 177, 178, <b>311</b>, 315, 316
assignment, 173-187
  defined, 85, 177, 315
  elemental, <b>12</b>, 178
  elemental array (FORALL), 185
  masked array (WHERE), 182
  pointer, <b>178</b>
assignment statement, 33, 47, 61, 88, <b>173</b>, 186, 215,
    216, 461, 498, 548, 550
<i>assignment-stmt</i> (R1033), 40, <b>173</b>, 174, 183, 185, 186,
    552
ASSOCIATE construct, 49, <b>189</b>, 192, 331, 536, 537,
    540, 552
associate name, <b>4</b>, 61, 64, 91, 107, 112, 150, 189, 190,
    192, 210, 537, 540, 541, 546, 552
ASSOCIATE statement, 49, <b>189</b>, 540
<i>associate-construct</i> (R1102), 40, <b>189</b>, 189
<i>associate-construct-name</i>, 189
<i>associate-name</i>, 189, 207-210, 212, 536
<i>associate-stmt</i> (R1103), <b>189</b>, 189, 212
ASSOCIATED, 32, 34, 35, 149, 152, 172, 350, <b>367</b>
associating entity, <b>4</b>, 49, 70, 144, 189, 190, 192, 193,
    211, 341, <b>546</b>, 546
association, <b>4</b>
  argument, <b>4</b>, 61, 70, 80, 81, 107, 111, 118, 119,
    150, 151, 308, 322, 324, 334, 341, 517, 537,
    543, 545, 546, 562, 611
  common, 134
  construct, <b>4</b>, 150, 151, 537, <b>540</b>, 543, 546
  equivalence, 132
  host, <b>4</b>, 42, 63, 64, 70, 106, 119, 121, 126, 134, 170,
    171, 180, 306, 308, 331, 344-347, 535, 537, 539,
    540, 543, 546, 639
  inheritance, <b>5</b>, 50, 89, 92, 543, 546
  linkage, <b>5</b>, 530, 537, <b>540</b>, 540
  name, <b>5</b>, 50, <b>537</b>, 543
  pointer, <b>5</b>, 47, 50, 88, 91, 93, 108, 114, 116, 118,
                             119, 137, 150, 152, 178, 180, 181, 200, 201,
                             216, 219, 250, 309, 324, 325, 328, 330, 331,
                             339, 341, 355, 367, 422, 426, 503, 505, 506,
                             517, 528, 532, 541-610
                           sequence, 330
                           storage, <b>5</b>, 50, 131-133, 342, 345, 447, 543-546
                           use, <b>5</b>, 33, 42, 50, 64, 70, 89, 105, 106, 116, 119,
                             126, 131-133, 170, 171, 180, <b>303</b>, 302-306,
                             312, 341, 345, 347, 535-538, 541
                        <i>association</i> (R1104), <b>189</b>, 189
                         association status, <i>see</i> pointer association status
                         assumed type parameter, <b>26</b>, 61, 63, 325, 328
                        <i>assumed-implied-spec</i> (R823), <b>111</b>, 111, 112
                         assumed-rank dummy data object, <b>5</b>, 48, 63, 87, 108,
                             109, 143, 207, 208, 309, 310, 316, 321, 325-
                             328, 332, 338, 367, 409, 410, 426, 434, 441,
                             444, 454, 455, 501, 509, 514, 626, 627, 629
                        <i>assumed-rank-spec</i> (R827), 109, <b>112</b>
                         assumed-shapearray,<b>3</b>, 63, 108-111, 117, 130, 143, 310,
                             325-327, 329, 332, 338, 501, 514, 528, 610, 626,
                             633, 635
                        <i>assumed-shape-bounds-spec</i> (R821), 109, <b>110</b>, 111
                        <i>assumed-shape-spec</i> (R820), 109, <b>110</b>, 111
                         assumed-size array, <b>4</b>, 109, 111-113, 118, 131, 139, 140,
                             153, 170, 173, 196, 208, 209, 247, 325-327, 330,
                             331, 410, 441, 444, 454, 506, 509, 513-517, 521,
                             524-528, 622, 624, 626
                        <i>assumed-size-spec</i> (R824), 109, <b>111</b>, 111
                         assumed-type, <b>5</b>, 63, 325, 326, 338, 508, 514, 628
                         ASYNCHRONOUS attribute, <b>105</b>, 105, 106, 120, 190,
                             196, 200, 245, 303, 305, 309, 310, 326, 327,
                             382, 435, 528, 529, 532, 538, 539
                         asynchronous communication, 105, <b>532</b>
                         asynchronous input/output, 105, 236, 238, 240, 245-
                             247, 250, 257, 260-263, 265, 268
                         ASYNCHRONOUS statement, <b>120</b>, 191, 306, 536, 539
                        <i>asynchronous-stmt</i> (R834), 40, <b>120</b>
                         ASYNCHRONOUS=specifier, 237,<b>238</b>, 242-244,<b>245</b>,
                             264, <b>265</b>
                         AT edit descriptor, 287
                         ATAN, <b>368</b>
                         ATAN2, 35, <b>368</b>
                         ATAN2D, <b>368</b>
                         ATAN2PI, <b>369</b>
                         ATAND, <b>369</b>
                         ATANH, <b>370</b>
ATANPI, <b>370</b>
atomic subroutine, <b>24</b>, 44, 216, 217, 349, 352, 354, 370-
    374, 392, 457, 462, 552
ATOMIC_ADD, <b>370</b>, 458, 461
ATOMIC_AND, <b>371</b>
ATOMIC_CAS, <b>371</b>
ATOMIC_DEFINE, <b>371</b>, 617, 618
ATOMIC_FETCH_ADD, <b>372</b>
ATOMIC_FETCH_AND, <b>372</b>
ATOMIC_FETCH_OR, <b>373</b>
ATOMIC_FETCH_XOR, <b>373</b>
ATOMIC_INT_KIND, 370-374, <b>457</b>
ATOMIC_LOGICAL_KIND, 371, 372, 374, <b>457</b>
ATOMIC_OR, <b>373</b>
ATOMIC_REF, <b>374</b>, 617, 618
ATOMIC_XOR, <b>374</b>
<i>attr-spec</i> (R802), <b>102</b>, 102-104, 125
attribute, <b>5</b>, 62, 72, 76, 102-119, 305
  ABSTRACT, 73, <b>89</b>
  accessibility, <b>105</b>, 119, 303
  ALLOCATABLE, 61-63, 72, 78, <b>105</b>, 105, 107,
    111, 112, 116-118, 120, 137, 140, 190, 196,
    200, 207, 208, 307, 310, 315, 316, 321, 323,
    327, 331, 338, 347, 512, 540, 546, 547, 612,
    616
  ASYNCHRONOUS, <b>105</b>, 105, 106, 120, 190, 196,
    200, 245, 303, 305, 309, 310, 326, 327, 382,
    435, 528, 529, 532, 538, 539
  BIND, 5, 6, 47, 73-75, 89, <b>94</b>, <b>106</b>, 106, 118, 120,
    131, 133, 179, 180, 200, 210, 307, 309, 310,
    338, 340, 511-514, 528-531, 540, 547, 622
  CODIMENSION, 63, 79, 103, <b>106</b>, 106, 112, 121
  CONTIGUOUS, 78, 81, <b>108</b>, 108, 109, 121, 143,
    180, 200, 309, 325, 327-329, 332, 514-516, 544
  DEFERRED, <b>84</b>, 86, 89
  DIMENSION, 79, 103, <b>109</b>, 109, 117, 123, 133
  EXTENDS, <b>89</b>, 89, 511
  EXTERNAL, 31, 32, <b>113</b>, 113, 116, 125, 126, 128,
    180, 303, 307, 312, 317, 330, 335, 336, 538,
    539, 607
  INTENT, <b>113</b>, 113-115, 124, 200, 568
  INTENT (IN), <b>113</b>, 113-115, 119, 196, 314-316,
    325, 328, 330, 332, 344-346, 350, 370-374,
    380-383, 392, 393, 398, 399, 423, 424, 432, 433,
    472, 503-506, 528, 552, 568, 610, 624
  INTENT (INOUT), 33, <b>113</b>, 114, 115, 118, 201,
                             315, 321, 326, 328, 335, 346-348, 361, 370-374,
                             380-383, 393, 398, 399, 422, 423, 458, 460, 461,
                             552, 553, 624
                           INTENT (OUT), 33-35, 63, 87, 88, 111, <b>113</b>, 113-
                             115, 118, 150, 170, 315, 321, 326, 328, 335,
                             344-348, 361, 370-374, 380-383, 385, 387, 392,
                             393, 397-399, 422, 423, 425, 430, 432, 433, 448,
                             474-476, 503, 505, 506, 528, 542, 543, 548, 549,
                             551-553, 624
                           INTRINSIC,113,<b>115</b>, 115, 116, 303, 319, 335, 336,
                             539
                           NON_OVERRIDABLE, <b>84</b>, 86
                           NON_RECURSIVE, 310, <b>337</b>, 337, 338, 341, 342
                           OPTIONAL, 63, <b>115</b>, 115, 118, 124, 170, 190, 196,
                             310
                           PARAMETER, 47, 95, 104, <b>115</b>, 115, 116, 124,
                             136
                           PASS, 79, <b>81</b>, 85, 320
                           POINTER, 61-63, 72, 78, 103, 111, 112, <b>116</b>, 116-
                             118, 123, 125, 137, 140, 149, 179, 190, 200, 207,
                             208, 308-310, 312, 315, 316, 318, 321, 323, 327,
                             330-333, 338, 345, 347, 508, 512, 528, 540, 543,
                             546, 547, 568, 612, 616
                           PRIVATE, 75, 90, <b>105</b>, 105, 119, 345, 596
                           PROTECTED, 33, <b>116</b>, 116, 117, 125, 132, 200,
                             304, 568
                           PUBLIC, 90, <b>105</b>, 105, 119, 596
                           SAVE, 36, 49, 81, 82, 88, 104, 106, 107, <b>117</b>, 117,
                             121, 125, 132, 134, 151, 200, 318, 345, 542
                           SEQUENCE, 73, <b>74</b>, 74-76, 89, 133, 179, 180, 210,
                             511
                           TARGET, 5, 33, 81, 116, <b>118</b>, 118, 125, 132, 134,
                             149, 150, 179, 190, 200, 208, 310, 316, 325,
                             326, 328, 332, 333, 382, 422, 435, 503, 506,
                             508, 528, 529, 541-543, 551, 568, 610, 611
                           VALUE, 63, 81, 87, 112, <b>118</b>, 118, 125, 200, 250,
                             309, 310, 312, 314, 315, 324-328, 339, 344, 347,
                             382, 435, 514, 515, 532, 543, 568, 622, 623
                           VOLATILE, 33, 34, <b>118</b>, 118, 119, 126, 179, 180,
                             190, 196, 200, 303, 305, 309, 310, 326, 327,
                             329, 344, 345, 538, 539, 543, 549, 552, 575
                         attribute specification statements, 119-134
                         automatic data object, <b>6</b>, 35, 36, 103, 104, 107, 117,
                             121, 131, 133, 549, 563
          <b>B</b>
                         B edit descriptor, 286
BACKSPACE statement, 228, 231, 257, 260, <b>262</b>, 262,
    589, 590
<i>backspace-stmt</i> (R1224), 40, <b>261</b>, 345
base object, <b>6</b>, 105, 108, 131, <b>137</b>, 143, 170, 245, 331,
    345, 347
BESSEL_J0, <b>375</b>
BESSEL_J1, <b>375</b>
BESSEL_JN, <b>375</b>
BESSEL_Y0, <b>376</b>
BESSEL_Y1, <b>376</b>
BESSEL_YN, <b>376</b>
BGE, <b>377</b>
BGT, <b>377</b>
<i>binary-constant</i> (R773), <b>99</b>, 99
<i>binary-reduce-op</i> (R1132), <b>196</b>, 196, 201
BIND (C), <i>see</i> BIND attribute
BIND attribute, 5, 6, 47, 73-75, 89, <b>94</b>, <b>106</b>, 106, 118,
    120, 131, 133, 179, 180, 200, 210, 307, 309,
    310, 338, 340, 511-514, 528-531, 540, 547, 622
BIND statement, <b>120</b>, 306, 529, 535
<i>bind-entity</i> (R836), <b>120</b>, 120
<i>bind-stmt</i> (R835), 40, <b>120</b>
binding, <b>6</b>, 85, <b>86</b>, 86, 89, 90, 166, 167, 178, 254, 259,
    316, 337, 534, 535
binding label, <b>6</b>, 106, 310, 318, 338, 340, 529-531, 533,
    534, 568
binding name, <b>6</b>, 85, <b>86</b>, 90, 320, 535
<i>binding-attr</i> (R752), <b>85</b>, 85
<i>binding-name</i>, 85, 86, 320, 337, 535
<i>binding-private-stmt</i> (R747), <b>84</b>, 84, 86
bit model, 350
BIT_SIZE, 351, <b>377</b>, 423, 424
blank common, <b>8</b>, 103, 121, 133, 134, 542, 545
blank interpretation mode, 238
<i>blank-interp-edit-desc</i> (R1317), 276, <b>277</b>
BLANK= specifier, 237, <b>238</b>, 242-244, <b>245</b>, 257, 264,
   <b>266</b>, 292
BLE, <b>378</b>
block, <b>6</b>
  interface, 304
<i>block</i> (R1101), <b>188</b>, 189-192, 194, 195, 197, 198, 200,
    202-204, 207, 209
BLOCKconstruct, 32-34, 44, 47, 88, 104, 106, 108, 110,
    116, 117, 119, 126, 128-130, 150, 170, <b>190</b>,
    345, 536, 542, 543, 549, 551, 555
block data program unit, <b>306</b>
                         BLOCK DATA statement, 56, 302, <b>306</b>
                         block scoping unit, <b>21</b>
                         BLOCK statement, 104, 108, 110, <b>190</b>, 549
                        <i>block-construct</i> (R1107), 40, <b>190</b>, 191
                        <i>block-construct-name</i>, 190, 191
                        <i>block-data</i> (R1420), 38, 128, <b>306</b>, 306, 307
                        <i>block-data-name</i>, 306
                        <i>block-data-stmt</i> (R1421), 38, <b>306</b>, 306
                        <i>block-specification-part</i> (R1109), 190, <b>191</b>, 191
                        <i>block-stmt</i> (R1108), <b>190</b>, 190, 191, 212
                         BLT, <b>378</b>
                         BN edit descriptor, 292
                         bound, <b>6</b>, 48, 49, 78, 79, 91, 93, 110, 145, 146, 152, 181,
                             216, 422, 537
                         bounds, 110-112, 139-142
                        <i>bounds-remapping</i> (R1037), 178, <b>179</b>, 179, 181
                        <i>bounds-spec</i> (R1036), 178, <b>179</b>, 179, 181
                        <i>boz-literal-constant</i> (R772), 54, 95, 98, <b>99</b>, 99, 100, 123,
                             174, 176, 249, 286, 351, 377-379, 388-390, 402,
                             404-407, 419, 434, 435
                         branch, <b>212</b>, 343, 561
                         branch target statement, <b>6</b>, 43, 55, 183, 199, <b>212</b>, 212,
                             213, 237, 241, 243, 261, 263, 265, 321, 343
                         BTEST, <b>378</b>
                         BZ edit descriptor, 292
          <b>C</b>
                         C address,<b>6</b>, 503-509, 511, 512, 517, 521, 523, 550, 551,
                             624
                         C descriptor, <b>7</b>, 150, 514-518, 520-529
                         C_ALERT, <b>502</b>
                         C_ASSOCIATED, <b>503</b>
                         C_BACKSPACE, <b>502</b>
                         C_BOOL, <b>501,</b> <b>502</b>
                         C_CARRIAGE_RETURN, <b>502</b>
                         C_CHAR, <b>502</b>, 506, 509, 568
                         C_DOUBLE, <b>502</b>
                         C_DOUBLE_COMPLEX, <b>502</b>
                         C_F_POINTER, 502, <b>503</b>, 508
                         C_F_PROCPOINTER, 502, <b>505</b>, 507
                         C_F_STRPOINTER, 502, <b>506</b>
                         C_FLOAT, <b>502</b>
                         C_FLOAT_COMPLEX, <b>502</b>
                         C_FORM_FEED, <b>502</b>
                         C_FUNLOC, 346, 505, <b>507</b>, 530, 531
                         C_FUNPTR, 78, 89, 106, 137, 145-147, 177, 501-503,
                             505, 507, <b>511</b>, 512, 551
C_HORIZONTAL_TAB, <b>502</b>
C_INT, <b>501</b>
C_INT16_T, <b>501</b>
C_INT32_T, <b>501</b>
C_INT64_T, <b>501</b>
C_INT8_T, <b>501</b>
C_INT_FAST16_T, <b>501</b>
C_INT_FAST32_T, <b>501</b>
C_INT_FAST64_T, <b>501</b>
C_INT_FAST8_T, <b>501</b>
C_INT_LEAST16_T, <b>501</b>
C_INT_LEAST32_T, <b>501</b>
C_INT_LEAST64_T, <b>501</b>
C_INT_LEAST8_T, <b>501</b>
C_INTMAX_T, <b>501</b>
C_INTPTR_T, <b>501</b>
C_LOC, 63, 113, 345, 503, <b>508</b>, 568
C_LONG, <b>501</b>
C_LONG_DOUBLE, <b>502</b>
C_LONG_DOUBLE_COMPLEX, <b>502</b>
C_LONG_LONG, <b>501</b>
C_NEW_LINE, <b>502</b>
C_NULL_CHAR, <b>502</b>, 509
C_NULL_FUNPTR, 501, <b>502</b>
C_NULL_PTR, 501, <b>502</b>, 503
C_PTR, 78, 89, 106, 137, 145-147, 177, 501-503, 506,
    508, <b>511</b>, 512, 515, 550, 551, 622
C_PTRDIFF_T, <b>501</b>
C_SHORT, <b>501</b>
C_SIGNED_CHAR, <b>501</b>
C_SIZE_T, <b>501</b>
C_SIZEOF, 113, 171, <b>509</b>
C_VERTICAL_TAB, <b>502</b>
CALL statement, 212, 215, 308, <b>320</b>, 334, 335, 343, 423
<i>call-stmt</i> (R1521), 40, <b>320</b>, 321, 323
CASE statement, <b>205</b>
<i>case-construct</i> (R1142), 40, <b>204</b>, 205
<i>case-construct-name</i>, 205
<i>case-expr</i> (R1146), <b>205</b>, 205
<i>case-selector</i> (R1147), <b>205</b>, 205
<i>case-stmt</i> (R1144), 204, <b>205</b>, 205
<i>case-value</i> (R1149), <b>205</b>, 205
<i>case-value-range</i> (R1148), <b>205</b>, 205
CEILING, <b>379</b>
CFI_address, <b>521</b>
CFI_allocate, <b>521</b>, 528
                         CFI_cdesc_t, 514, 516, <b>517</b>, 517, 518, 521-528
                         CFI_deallocate, 518, <b>522</b>, 528
                         CFI_establish, <b>523</b>, 567, 633-636
                         CFI_is_contiguous, <b>524</b>
                         CFI_section, <b>524</b>, 634
                         CFI_select_part, <b>526</b>
                         CFI_setpointer, <b>527</b>, 636
                         CHANGE TEAM construct, 49, 144, 189, 190, <b>192</b>,
                             199, 212, 331, 536, 537, 552
                         CHANGETEAMstatement, 43, 49,<b>192</b>, 215, 225, 353,
                             540
                        <i>change-team-construct</i> (R1111), 40, <b>192</b>, 192
                        <i>change-team-stmt</i> (R1112), <b>192</b>, 192
                         changeable mode, 234
                         CHAR, 71, <b>379</b>
                        <i>char-length</i> (R723), <b>69</b>, 69, 70, 78, 79, 102-104, 564
                        <i>char-length</i>, 565
                        <i>char-literal-constant</i> (R724), 54, 58, 59, <b>70</b>, 256, 276,
                             277, 554
                        <i>char-selector</i> (R721), 65, <b>69</b>, 70
                        <i>char-string-edit-desc</i> (R1322), 275, <b>277</b>
                        <i>char-variable</i> (R905), <b>135</b>, 135, 233, 234
                         character context, <b>7</b>, 52, 56-58, 71
                         character literal constant, <b>70</b>
                         character sequence type, <b>21</b>, <b>75</b>, 132-134, 545, 548
                         character set, 52
                         character storage unit, <b>23</b>, 112, 132, 134, 457, 544, 548,
                             550
                         character string edit descriptor, <b>275</b>, 292
                         character type, 69-72
                         CHARACTER_KINDS, <b>457</b>
                         CHARACTER_STORAGE_SIZE, <b>457</b>
                         characteristics, <b>7</b>, 90, 181, 253-255, 309, 310, 312, 318,
                             319, 329, 334, 338, 339, 342, 361, 367, 426
                           dummy argument, 309
                           procedure, 309
                         child data transfer statement, 232, 233, 244, 246, 249,
                         <b>255</b>, 253-257, 273, 296
                         CLASS, <b>62</b>, 62, 64, 254
                         CLASS DEFAULT statement, <b>210</b>
                         CLASS IS statement, <b>210</b>, 394
                         CLASSOF, <b>62</b>, 62
                         CLOSE statement, 228, 229, 233, 235, 236, <b>240</b>, 240,
                             257, 260, 589
                        <i>close-spec</i> (R1209), <b>241</b>, 241
                        <i>close-stmt</i> (R1208), 40, <b>241</b>, 345
CMPLX, 176, 351, <b>379</b>, 466
CO_BROADCAST, <b>380</b>
CO_MAX, <b>380</b>
CO_MIN, <b>381</b>
CO_REDUCE, <b>381</b>, 558
CO_SUM, <b>382</b>, 558
coarray, <b>7</b>, 33, 44, 48, 49, 73, 78, 80, 88, 106-108, 113,
    115, 116, 118, 119, 131, 133, 138, 144-148, 151,
    152, 174, 177, 179, 180, 190, 192, 193, 196,
    215-217, 303, 310, 320, 321, 326, 329, 332, 334,
    339, 353, 354, 357, 359, 370-374, 384, 405, 410,
    422, 423, 450-452, 455, 460, 512, 513
  established, <b>7</b>, 49, 193, 405
<i>coarray-association</i> (R1113), 49, <b>192</b>, 192
<i>coarray-name</i>, 121, 192, 536, 538
<i>coarray-spec</i> (R809), 78-80, 102, 103, <b>106</b>, 106, 107,
    120, 121, 125
cobound, <b>7</b>, 48, 49, 106-108, 144, 147, 171, 190, 193,
    329, 357, 359, 410, 422, 455, 537
codimension, <b>7</b>, 48, 108, 144, 190, 309, 384, 410, 455
CODIMENSION attribute, 63, 79, 103, <b>106</b>, 106, 112,
    121
<i>codimension-decl</i> (R838), <b>121</b>, 121, 190, 192, 193, 536
<i>codimension-stmt</i> (R837), 40, <b>121</b>, 538
coindexed object, <b>7</b>, 33, 44, 48, 49, 81, 121, 137, 143,
    144, 146, 174, 177, 179, 180, 189, 214, 217, 221,
    320, 321, 325-328, 332, 345, 370-374, 380-382,
    392, 422, 452, 462, 503, 505, 507, 508
<i>coindexed-named-object</i> (R914), 135, 136, <b>138</b>, 138
collating sequence, <b>7</b>, 71, 72, 166, 279, 362, 379, 401,
    404, 412, 413, 416-421, 424
collective subroutine, <b>24</b>, 349, 353, 354, 380-382, 395,
    447, 462, 552
COMMAND_ARGUMENT_COUNT, 172, <b>383</b>, 398
comment, <b>57,</b> <b>58</b>, 299
common association, <b>134</b>
common block, <b>7</b>, 36, 41, 47, 103, 104, 106, 116, 117,
    120, 121, 131, 133, 134, 170, 306, 307, 529,
    530, 533-537, 540, 543-545, 550, 564
common block storage sequence, <b>133</b>
COMMONstatement,<b>133</b>,133-134,191,305,306,535,
    545, 562
<i>common-block-name</i>, 120, 125, 133, 191, 305
<i>common-block-object</i> (R877), <b>133</b>, 133, 305, 538
<i>common-stmt</i> (R876), 40, <b>133</b>, 538
companion processor, <b>8</b>, 45, 51, 73, 94, 95, 106, 502,
                             509, 530, 531
                         compatibility
                    Fortran 77, 36
                           Fortran 2003, 34
                           Fortran 2008, 33
                           Fortran 2018, 32
                           Fortran 90, 35
                           Fortran 95, 35
                         COMPILER_OPTIONS, 171, <b>457</b>
                         COMPILER_VERSION, 171, <b>457</b>
                         completion step, 45, 241
                         complex part designator, <b>11</b>, 46, 138
                         complex type, 68
                        <i>complex-literal-constant</i> (R718), 54, <b>68</b>
                        <i>complex-part-designator</i> (R915),135,<b>138</b>,138,139,143
                         component, <b>8</b>, 48, 72, 74, <b>78</b>, 92, 126, 535
                           direct, <b>8</b>, 72, 73, 82, 326, 465, 511
                           parent, <b>8</b>, 83, 87, 89, 92, 546, 577
                           potential subobject,<b>8</b>, 33, 72-74, 78, 106, 107, 118,
                             119, 146, 147, 151, 152, 174, 326, 332, 334, 345,
                             380, 458, 460, 461
                           ultimate, <b>8</b>, 33, 34, 72, 73, 108, 111, 113, 131, 133,
                             147, 149, 172, 174, 196, 253, 321, 325, 344,
                             345, 381, 544
                         component definition statement, 62, <b>78</b>
                         component keyword, <b>17</b>, 50, 83, 92, 535
                         component order, <b>8</b>, 83, 92, 248
                         component specification expression, <b>22</b>, 78, <b>171,</b> <b>172</b>
                        <i>component-array-spec</i> (R740), <b>78</b>, 78, 79
                        <i>component-attr-spec</i> (R738), <b>78</b>, 78-81
                        <i>component-data-source</i> (R758), <b>92</b>, 92, 93
                        <i>component-decl</i> (R739), 70, <b>78</b>, 78-81
                        <i>component-def-stmt</i> (R736), <b>78</b>, 78
                        <i>component-initialization</i> (R743), 78, <b>81</b>, 81, 82
                        <i>component-name</i>, 78, 81
                        <i>component-part</i> (R735), 73, <b>78</b>, 84, 86
                        <i>component-spec</i> (R757), 91, <b>92</b>, 92, 172
                         computed GO TO statement, 212, <b>213</b>, 562, 563
                        <i>computed-goto-stmt</i> (R1160), 41, <b>213</b>, 213
                        <i>concat-op</i> (R1012), 54, <b>155</b>, 155
                         CONCURRENT, <b>195</b>
                        <i>concurrent-control</i> (R1126), 185, 186, <b>195</b>, 195, 196,
                             198
                        <i>concurrent-header</i> (R1125), 185-187, <b>195</b>, 195, 196,
                             536, 537
                        <i>concurrent-limit</i> (R1127), 159, 186, <b>195</b>, 195, 196, 198
<i>concurrent-locality</i> (R1129), 195, <b>196</b>, 196
<i>concurrent-step</i> (R1128), 159, 186, <b>195</b>, 195, 196, 198
<i>conditional-arg</i> (R1526), 320, <b>321</b>, 321, 323
<i>conditional-expr</i> (R1002), 153, <b>154</b>, 154, 159
conformable, <b>8</b>, 48, 148, 160, 167, 174, 178, 335, 347,
    395, 402, 403, 407, 417, 418, 420, 421, 428,
    431, 448, 455, 488
CONJG, <b>383</b>
<i>connect-spec</i> (R1205), 236, <b>237</b>, 237
connected, <b>9</b>, 228-232, 235, 236, 238, 239, 241, 246,
    251-253
connection mode, 234
<i>consequent</i> (R1527), <b>321</b>, 321, 323
<i>consequent-arg</i> (R1528), <b>321</b>, 321, 323
constant, <b>9</b>, 47, 54, 60
  integer, 65
  named, 124
<i>constant</i> (R604), <b>54</b>, 54, 122, 136, 153
constant expression, <b>9</b>, 26, 35, 36, 60, 61, 70, 77, 80,
    81, 100, 104, 108, 110, 112, 121, 122, 124, 132,
    170, <b>172</b>, 172, <b>173</b>, 173, 245, 309, 310, 331,
    350, 362, 364, 365, 379, 384, 385, 395, 396,
    401, 404, 406, 410, 411, 414, 415, 417, 420,
    425, 434, 436, 438, 441, 444, 446, 447, 454-
    456, 512, 513
<i>constant-expr</i> (R1030), 61, 81, 82, 103, 104, 112, 115,
    124, <b>173</b>, 173, 205
<i>constant-subobject</i> (R850), <b>122</b>, 122
construct
  ASSOCIATE, 49, <b>189</b>, 192, 331, 536, 537, 540, 552
  BLOCK, 32-34, 44, 47, 88, 104, 106, 108, 110, 116,
    117, 119, 126, 128-130, 150, 170, <b>190</b>, 345,
    536, 542, 543, 549, 551, 555
  CHANGETEAM,49, 144, 189, 190,<b>192</b>, 199, 212,
    331, 536, 537, 552
  CRITICAL, <b>194</b>, 199, 212
  DO, 44, 55, 100, 122, <b>195</b>, 212, 249, 561, 579, 580
  DO CONCURRENT, 33, <b>195</b>, 199, 203, 212, 346,
    536, 537, 543, 549, 551, 555, 564
  FORALL, <b>185</b>, 346, 536, 537, 549, 562, 564
  IF, 44, <b>203</b>, 561
  nonblock DO, <b>562</b>
  SELECT CASE, 44, <b>204</b>, 563, 578
  SELECT RANK, 44, 49, 111, 112, 190, <b>207</b>, 331,
    536, 537, 552
  SELECT TYPE, 44, 49, 61, 63, 189, 190, <b>209</b>, 331,
                             536, 537, 540, 552
                           WHERE, <b>182</b>
                         construct association, <b>4</b>, 150, 151, 537, <b>540</b>, 543, 546
                         construct entity, <b>9</b>, 119, 129, 189, 191, 192, 197, 200,
                             209, 533, 534, 536, 543
                        <i>construct-name</i>, 212
                         constructor
                           array, 99
                           derived-type, 91
                           structure, 91
                         CONTAINS statement, 42, 43, <b>84</b>, <b>343</b>
                        <i>contains-stmt</i> (R1546), 39, 84, 303, <b>343</b>
                         contiguous, <b>9</b>, 33, 75, 81, <b>108</b>, 136, 143, 180, 182, 190,
                             201, 245, 252, 409, 508, 544, 568
                         CONTIGUOUS attribute, 78, 81, <b>108</b>, 108, 109, 121,
                             143, 180, 200, 309, 325, 327-329, 332, 514-516,
                             544
                         CONTIGUOUS statement, <b>121</b>
                        <i>contiguous-stmt</i> (R839), 40, <b>121</b>
                         continuation, 57, 58
                         CONTINUE statement, <b>213</b>, 561
                        <i>continue-stmt</i> (R1161), 40, 197, <b>213</b>
                         control character, 52, 70, 227, 230
                         control edit descriptor, <b>275</b>, 289-292
                         control information list, <b>242</b>
                         control mask, 183
                        <i>control-edit-desc</i> (R1313), 275, <b>276</b>
                         conversion
                           numeric, 176
                         corank, <b>9</b>, 48, 49, 80, 106-109, 137, 144, 146, 153, 190,
                             193, 309, 321, 323, 328, 384, 405, 410, 422,
                             450, 451, 455, 537
                         COS, <b>383</b>
                         COSD, <b>384</b>
                         COSH, <b>384</b>
                         COSHAPE, <b>384</b>
                         COSPI, <b>385</b>
                         cosubscript, <b>9</b>, 48, 49, 108, 144, 359, 405, 450, 451, 455
                        <i>cosubscript</i> (R927), 137, <b>144</b>, 144
                         COUNT, 350, <b>385</b>
                         CPU_TIME, <b>385</b>
                         CRITICAL construct, <b>194</b>, 199, 212
                         CRITICAL statement, 168, <b>194</b>, 215, 225
                        <i>critical-construct</i> (R1116), 40, <b>194</b>, 194
                        <i>critical-construct-name</i>, 194
                        <i>critical-stmt</i> (R1117), <b>194</b>, 194, 212
CSHIFT, <b>386</b>
current record, <b>231</b>
current team, <b>24</b>, 88, 144, 147, 148, 151, 152, 192, 193,
    217, 218, 220-222, 225, 353, 380, 395, 400, 405,
    406, 423, 427, 446, 447, 450, 451, 455, 458, 462
CURRENT_TEAM, 400, <b>458</b>
CYCLE statement, 188, 195, <b>198</b>, 199, 564
<i>cycle-stmt</i> (R1135), 40, <b>198</b>, 199
<b>D</b>
<i>d</i> (R1310), <b>276</b>, 276, 281-285, 288, 289, 296
D edit descriptor, 282
data edit descriptor, <b>275</b>, 279-289
data entity, <b>10</b>, 46, 47, 509
data object, <b>10</b>, 41-43, 46, 48, 50
data object designator, <b>11</b>, 48, 135
data object reference, <b>20</b>, 47-49
data pointer, <b>18</b>, 49, 80, 82, 92, 93, 116, 134, 135, 145,
    179, 328, 339, 503, 517, 523, 527, 541, 543,
    544, 578, 610
DATA statement, 32, 34, 36, 43, 99, 104, <b>121</b>, 134, 191,
    306, 427, 536, 539, 547, 562, 563
data transfer, 251
data transfer input statement, <b>242</b>
data transfer output statement, <b>242</b>
data transfer statement, 36, 55, 227-233, 235, <b>242</b>,
    247, 250-252, 256, 260, 262, 270-275, 286, 291,
    293-298, 300, 459, 460, 548, 550, 557, 589, 592,
    593
data type, <b>25</b>, <i>see</i> type
<i>data-component-def-stmt</i> (R737), <b>78</b>, 78-80
<i>data-edit-desc</i> (R1307), <b>275</b>, 275
<i>data-i-do-object</i> (R844), <b>121</b>, 121, 122
<i>data-i-do-variable</i> (R845), <b>121</b>, 121, 122, 172, 536
<i>data-implied-do</i> (R843), <b>121</b>, 121-123, 172, 536
<i>data-pointer-component-name</i>, 179
data-pointer-initialization compatible, <b>81</b>
<i>data-pointer-object</i> (R1035), 178, <b>179</b>, 179, 180, 186,
    553
<i>data-ref</i> (R911), 62, 63, <b>136</b>, 137-139, 179, 245, 320,
    323, 332, 337
<i>data-stmt</i> (R840), 39, <b>121</b>, 312, 345, 538
<i>data-stmt-constant</i> (R848), 99, <b>122</b>, 122, 123
<i>data-stmt-object</i> (R842), <b>121</b>, 121-123
<i>data-stmt-repeat</i> (R847), <b>122</b>, 122
<i>data-stmt-set</i> (R841), <b>121</b>, 121
<i>data-stmt-value</i> (R846), 121, <b>122</b>, 122
                        <i>data-target</i> (R1038), 92, 93, 116, 178, <b>179</b>, 179, 180,
                             186, 331, 345
                         DATE_AND_TIME, <b>387</b>
                         DBLE, 351, <b>388</b>
                         DC edit descriptor, 292
                        <i>dealloc-opt</i> (R945), <b>150</b>, 150-152
                         DEALLOCATE statement, <b>149</b>, 152, 215, 458, 461,
                             522, 555
                        <i>deallocate-stmt</i> (R944), 40, <b>150</b>, 553
                         decimal edit descriptor, 292
                         decimal edit mode, 238
                         decimal symbol, <b>10</b>, 238, 245, 266, 279-285, 292, 294
                        <i>decimal-edit-desc</i> (R1318), 276, <b>277</b>
                         DECIMAL= specifier, 237, <b>238</b>, 242-244, <b>245</b>, 257,
                             264, <b>266</b>, 292
                         declaration, <b>10</b>, 42, 102-134
                        <i>declaration-construct</i> (R507), <b>39</b>, 39, 191
                        <i>declaration-type-spec</i> (R703),<b>62</b>, 62, 63, 70, 78, 79, 102,
                             104, 126, 170, 317, 318, 337, 340
                         declared type, <b>25</b>, 63, 64, 81, 92, 93, 100, 102, 136, 138,
                             146, 147, 149, 154, 166-168, 174, 177, 178, 180,
                             189, 208, 210, 211, 259, 315, 320, 321, 323, 324,
                             327, 337, 344, 394, 418, 422, 437, 458, 460, 537
                         DEFAULT, <b>196</b>, <b>205</b>, <b>210</b>
                         default character, <b>69</b>
                         default complex, <b>68</b>
                         default initialization, <b>10</b>, 80-83, 92, 93, 104, 111, 113,
                             121, 132-134, 326, 427, 541, 545, 546, 550
                         default real, <b>67</b>
                        <i>default-char-constant-expr</i> (R1031), 106, <b>173</b>, 173, 242,
                             243
                        <i>default-char-expr</i> (R1026), <b>168</b>, 168, 173, 213, 237-247
                        <i>default-char-variable</i> (R906), <b>135</b>, 135, 145, 237, 264-
                             270
                         default-initialized, <b>10</b>, 82, 114, 338, 541-543, 547, 549,
                             551
                         DEFERRED attribute, <b>84</b>, 86, 89
                         deferred type parameter, xiii, <b>26</b>, 33, 61, 63, 70, 93,
                             116, 134, 138, 145, 146, 149, 152, 174, 175,
                             180, 201, 216, 294, 309, 328, 338, 361, 411,
                             426, 447, 503, 504, 514, 541, 546
                        <i>deferred-coshape-spec</i> (R810), 78, 106, <b>107</b>, 107
                         deferred-shape array, <b>4</b>, 111, 117
                        <i>deferred-shape-spec</i> (R822), 78, 109, <b>111</b>, 111, 124
                         definable, <b>10</b>, 114-116, 142, 174, 190, 247, 324, 326,
                             328, 333, 334, 543, 553
defined, <b>10</b>, 47, 49
defined assignment, <b>10</b>, 174, 177, 178, 183, 186, 308,
    315, 320, 326, 345, 346
defined assignment statement, 34, <b>178</b>, 334, 335, 552
defined input/output, <b>10</b>, 234, 239, 248, 249, <b>253</b>, <b>254</b>,
   <b>255</b>, <b>255</b>, <b>255</b>, <b>256</b>, <b>257</b>, 253-259, 270, 289,
    296, 300, 301, 308, 314, 316, 320, 334, 345,
    460, 613
defined operation, <b>11</b>, 157, <b>166,</b> <b>167</b>, 167-170, 196,
    308, 314, 320, 334, 345
<i>defined-binary-op</i> (R1024), 55, <b>156</b>, 156, 157, 167, 304
<i>defined-io-generic-spec</i> (R1509), 85, 253-255, 259, <b>311</b>,
    311, 314, 316
<i>defined-operator</i> (R609), <b>55</b>, 85, 305, 311, 568
<i>defined-unary-op</i> (R1004), 55, <b>154</b>, 154, 157, 166, 304
definition, <b>11</b>
definition of variables, 547
deleted features, 31, 32, 35, 36, 561, 562
DELIM= specifier, 237, <b>238</b>, 242-244, <b>246</b>, 257, 264,
   <b>266</b>, 299, 300, 591
delimiter mode, 238
derived type, <b>25</b>, 46, 60, 72-94, 100, 511, 512
derived type definition statement, <i>see</i> TYPE statement
derived type determination, 75
derived-type type specifier, 63
<i>derived-type-def</i> (R726), 39, 64, <b>73</b>, 74, 76, 77, 511
<i>derived-type-spec</i> (R754), 62-64, 70, <b>91</b>, 91, 92, 210,
    254, 535
<i>derived-type-stmt</i> (R727), <b>73</b>, 73, 74, 76, 77, 105, 538
descendant, <b>11</b>, 42, 74, 84, 86, 116, 306, 534
designator, <b>11</b>, 50, 112, 113, 118, 121, 131, 133, <b>139</b>,
    139, 169, 170, 172, 297, 298, 330, 331, 345, 347
  data object, 135
<i>designator</i> (R901), 81, 121, 122, <b>135</b>, 135, 137, 138,
    153, 179, 189, 200, 297, 344, 345, 384, 405,
    410, 450, 455
<i>designator</i>, 153
<i>digit</i>, 29, <b>52</b>, 52, 55, 66, 99, 294
<i>digit-string</i> (R711), 29, 65, <b>66</b>, 66, 67, 280, 281, 287
<i>digit-string</i>, 66
DIGITS, <b>388</b>
DIM, <b>388</b>
DIMENSIONattribute, 79, 103,<b>109</b>, 109, 117, 123, 133
DIMENSION statement, <b>123</b>, 306
<i>dimension-stmt</i> (R851), 40, <b>123</b>, 538
direct access, <b>229</b>
                         direct access data transfer statement, <b>246</b>
                         direct component, <b>8</b>, 72, 73, 82, 326, 465, 511
                         DIRECT= specifier, 264, <b>266</b>
                         disassociated, <b>11,</b> <b>12</b>, 49, 64, 81-83, 104, 111, 123, 149,
                             151, 152, 169, 178, 180, 181, 318, 331, 349,
                             394, 426, 427, 437, 447, 471, 541, 542, 551
                         distinguishable, <b>316</b>
                         DO CONCURRENT construct, 33, <b>195</b>, 199, 203, 212,
                             346, 536, 537, 543, 549, 551, 555, 564
                         DO CONCURRENT statement, 63, 185, 186, <b>195</b>
                         DO construct, 44, 55, 100, 122, <b>195</b>, 212, 249, 561, 579,
                             580
                         DO statement, <b>195</b>, 548, 562, 564
                         DO WHILE statement, <b>195</b>
                        <i>do-construct</i> (R1119), 40, <b>195</b>, 197, 199, 212
                        <i>do-construct-name</i>, 195, 197-199
                        <i>do-stmt</i> (R1120), <b>195</b>, 195, 197, 212, 552
                        <i>do-variable</i> (R1124), 100, 121, <b>195</b>, 195, 197, 247, 248,
                             271-273, 295, 548, 550, 552, 589
                         DOT_PRODUCT, <b>389</b>
                         DOUBLE PRECISION, 56, 65, <b>67</b>, 73
                         DP edit descriptor, 292
                         DPROD, <b>389</b>
                         DSHIFTL, <b>389</b>
                         DSHIFTR, <b>390</b>
                         DT edit descriptor, 289
                        <i>dtv-type-spec</i> (R1221), <b>254</b>
                         dummy argument, <b>12</b>, 33, 44, 49, 50, 53, 61-64, 69,
                             70, 76, 79, 81, 85, 87, 88, 90, 91, 103, 105,
                             107, 109-111, 113-115, 117-119, 121, 124, 125,
                             130, 131, 133, 145, 147, 148, 150, 151, 166, 167,
                             169, 170, 178, 181, 196, 201, 216, 250, 255-257,
                             308-317, 319-331, 338, 342, 344, 345, 347, 348,
                             426, 458, 514-516, 535-537, 543, 552, 553, 568,
                             598, 610
                           characteristics of, 309
                           restrictions, 332
                         dummy data object, <b>12</b>, 63, 81, 104, 111-113, 117, 118,
                             309, 314-316
                           assumed-rank, <b>5</b>, 48, 63, 87, 108, 109, 143, 207,
                             208, 309, 310, 316, 321, 325-328, 332, 338,
                             367, 409, 410, 426, 434, 441, 444, 454, 455,
                             501, 509, 514, 626, 627, 629
                         dummy function, <b>12</b>, 70, 103
                         dummyprocedure,<b>19</b>, 113, 126, 130, 171, 180, 308, 309,
                             311, 312, 317, 318, 321, 329, 330, 336-338, 341,
    344-347, 531, 534, 539
<i>dummy-arg</i> (R1539), <b>340</b>, 340-342
<i>dummy-arg-name</i> (R1534), 124, 125, 308,<b>339</b>, 339, 340,
    343, 344, 538
dynamic type, <b>25</b>, 63, 64, 87, 89, 91, 93, 100, 118, 147,
    149, 151, 166-168, 175, 177, 178, 180, 190, 209,
    210, 216, 219, 259, 320, 327, 337, 394, 418, 422,
    437, 447, 514, 537, 541, 546, 577, 626
<b>E</b>
<i>e</i> (R1311), <b>276</b>, 276, 282-285, 288, 289, 296
E edit descriptor, 282
edit descriptor, <b>275</b>
  /, 290
  :, 291
  A, 287
  AT, 287
  B, 286
  BN, 292
  BZ, 292
  character string, <b>275</b>, 292
  control, <b>275</b>, 289-292
  D, 282
  data, <b>275</b>, 279-289
  DC, 292
  decimal, 292
  DP, 292
  DT, 289
  E, 282
  EN, 283
  ES, 284
  EX, 285
  F, 281
  G, 287, 288
  H, <b>561</b>
  I, 280
  L, 287
  LZ, 291
  LZP, 291
  LZS, 291
  O, 286
  P, 291
  position, 289
  RC, 292
  RD, 292
  RN, 292
  round, 292
                           RP, 292
                           RU, 292
                           RZ, 292
                           S, 291
                           SP, 291
                           SS, 291
                           T, 290
                           TL, 290
                           TR, 290
                           X, 290
                           Z, 286
                         effectiveargument,<b>12</b>,61,63,64,70,108-112,114,115,
                             216, 324-330, 333, 336, 337, 434, 503, 514, 515,
                             537, 543, 546, 548, 551
                         effectiveitem,<b>12</b>, 248, 249, 251, 253, 256, 257, 259, 271,
                             272, 277, 278, 291, 293-295, 298, 299, 335
                         effective position, <b>317</b>
                         element sequence, <b>330</b>
                         ELEMENTAL, 13, <b>337</b>, 338, 342, 344, 347
                         elemental, <b>12</b>, 48, 70, 87, 90, 166, 167, 172, 178, 181,
                             183, 184, 308-310, 318, 326, 330, 334-336, 342,
                             347, 349, 354, 375, 376, 423, 471, 472, 474
                         elemental array assignment (FORALL), 185
                         elemental assignment, <b>12</b>, 178
                         elemental operation, <b>12</b>, 159, 170, 184
                         elemental operator, <b>12</b>, 159, 465
                         elemental procedure, <b>12</b>, 48, 170, 180, 318, 321, 331,
                             335, 338, 346, <b>347</b>, 347, 349, 350
                         elemental reference, <b>12</b>, 184, 326, 334-337, 348
                         elemental subprogram, <b>13</b>, 337, 338, 347
                         ELSE IF statement, 56, <b>203</b>
                         ELSE statement, <b>203</b>
                        <i>else-if-stmt</i> (R1138), <b>203</b>, 203
                        <i>else-stmt</i> (R1139), <b>203</b>, 203
                         ELSEWHERE statement, 56, <b>183</b>
                        <i>elsewhere-stmt</i> (R1049), 182, <b>183</b>, 183
                         EN edit descriptor, 283
                         ENCODING= specifier, 237, <b>238</b>, 264, <b>266</b>, 556
                         END ASSOCIATE statement, 56, <b>189</b>
                         END BLOCK DATA statement, 56, <b>306</b>
                         END BLOCK statement, 56, 151, <b>191</b>
                         END CRITICAL statement, 56, 168, <b>194</b>, 215
                         END DO statement, 56, <b>197</b>
                         END ENUM statement, 56, <b>94</b>
                         END ENUMERATION TYPE statement, <b>97</b>
                         END FORALL statement, 56, <b>185</b>
END FUNCTION statement, 56, <b>339</b>
END IF statement, 56, <b>203</b>, 561
END INTERFACE statement, 56, <b>311</b>
END MODULE statement, 56, <b>303</b>
END PROCEDURE statement, 56, <b>341</b>
END PROGRAM statement, 56, <b>302</b>
END SELECT statement, 56, <b>205</b>, <b>210</b>
END statement, <b>13</b>, <b>43</b>, 43, 44, 56, 58, 88, 116, 117,
    134, 150, 151, 215, 503, 551
END SUBMODULE statement, 56, <b>306</b>
END SUBROUTINE statement, 56, <b>340</b>
END TEAM statement, 43, 56, <b>192</b>, 212, 215, 225, 353
END TYPE statement, 56, <b>74</b>
END WHERE statement, 56, <b>183</b>
<i>end-associate-stmt</i> (R1106), <b>189</b>, 189, 212
<i>end-block-data-stmt</i> (R1422), 38, 43, <b>306</b>, 306
<i>end-block-stmt</i> (R1110), 190, <b>191</b>, 191, 212
<i>end-change-team-stmt</i> (R1114), <b>192</b>, 192, 193
<i>end-critical-stmt</i> (R1118), <b>194</b>, 194, 212
<i>end-do</i> (R1133), 195, <b>197</b>, 197, 199
<i>end-do-stmt</i> (R1134), <b>197</b>, 197, 212
<i>end-enum-stmt</i> (R763), <b>94</b>, 94
<i>end-enumeration-type-stmt</i> (R769), 96, <b>97</b>
<i>end-forall-stmt</i> (R1055), <b>185</b>, 185
<i>end-function-stmt</i> (R1536), 38, 43, 212, 311, <b>339</b>, 339,
    343
<i>end-if-stmt</i> (R1140), <b>203</b>, 203, 212
<i>end-interface-stmt</i> (R1504), <b>311</b>, 311
<i>end-module-stmt</i> (R1406), 38, 43, <b>303</b>, 303
<i>end-mp-subprogram-stmt</i> (R1543), 39, 43, 212, <b>341</b>,
    341, 343
<i>end-program-stmt</i> (R1403), 38, 43, 45, 88, 212, 213,
   <b>302</b>, 302
<i>end-select-rank-stmt</i> (R1153), <b>207</b>, 207, 208, 212
<i>end-select-stmt</i> (R1145), 204, <b>205</b>, 205, 212
<i>end-select-type-stmt</i> (R1157), 209, <b>210</b>, 210-212
<i>end-submodule-stmt</i> (R1419), 38, 43, <b>306</b>, 306
<i>end-subroutine-stmt</i> (R1540), 38, 43, 212, 311, <b>340</b>,
    340, 343
<i>end-type-stmt</i> (R730), 73, <b>74</b>
<i>end-where-stmt</i> (R1050), 182, <b>183</b>, 183
END= specifier, 6, 242, 243, 260, 261, <b>271</b>
endfile record, <b>228</b>
ENDFILE statement, 56, 228, 229, 231, 238, 257, 260,
   <b>262</b>, 589
<i>endfile-stmt</i> (R1225), 40, <b>261</b>, 345
                        <i>entity-decl</i> (R803), 70, 79, 102, <b>103</b>, 103, 104, 171, 173,
                             538
                        <i>entity-name</i>, 120, 125
                         ENTRY statement, 43, 166, 167, 178, 303, 308, 312,
                             337, 339, <b>341</b>, 347, 535, 545, 562, 564
                        <i>entry-name</i>, 339, 341, 342, 535
                        <i>entry-stmt</i> (R1544), 39, 303, 306, 312, <b>341</b>, 342, 535,
                             538
                         enum constructor, 60, 95, 99, 122, 169, 170, 172
                         ENUM statement, <b>94</b>
                         enum type, 60, 61, 63, 64, 78, 94, 134, 161, 205, 280,
                             281, 286, 288, 294, 299, 406, 407, 511
                        <i>enum-constructor</i> (R765), <b>95</b>, 95, 122, 153
                        <i>enum-def</i> (R759), 39, <b>94</b>, 94, 95, 538
                        <i>enum-def-stmt</i> (R760), <b>94</b>, 94
                        <i>enum-type-name</i>, 94, 177, 538
                        <i>enum-type-spec</i> (R764), 62, 63, <b>94</b>, 94, 95
                         enumeration, 94
                         enumeration constructor, 60, <b>97</b>, 122, 169, 170, 172
                         enumeration type, 60, 61, 63, 78, <b>96</b>, 105, 131, 133, 161,
                             166, 205, 248, 280, 286, 401, 406, 407, 425, 430
                         ENUMERATION TYPE statement, <b>96</b>
                        <i>enumeration-constructor</i> (R771), <b>97</b>, 122, 153
                        <i>enumeration-enumerator-stmt</i> (R768), 96, <b>97</b>
                        <i>enumeration-type-def</i> (R766), 39, <b>96</b>
                        <i>enumeration-type-name</i>, 96, 97, 538
                        <i>enumeration-type-spec</i> (R770), 62, 63, <b>97</b>, 97
                        <i>enumeration-type-stmt</i> (R767), <b>96</b>, 96, 97, 105, 538
                         enumerator, 94
                        <i>enumerator</i> (R762), <b>94</b>, 94
                         ENUMERATOR statement, <b>94</b>
                        <i>enumerator-def-stmt</i> (R761), <b>94</b>, 94
                         EOR= specifier, 6, 242, 243, 261, <b>272</b>, 272, 589
                         EOSHIFT, <b>390</b>
                         EPSILON, <b>391</b>
                        <i>equiv-op</i> (R1022), 54, <b>156</b>, 156
                        <i>equiv-operand</i> (R1017), <b>156</b>, 156
                         equivalence association, 132
                         EQUIVALENCE statement, <b>131</b>, 131-134, 191, 305,
                             306, 545, 562, 564
                        <i>equivalence-object</i> (R875), <b>131</b>, 131-133, 305
                        <i>equivalence-set</i> (R874), <b>131</b>, 131, 132
                        <i>equivalence-stmt</i> (R873), 40, <b>131</b>, 538
                         ERF, <b>391</b>
                         ERFC, <b>392</b>
                         ERFC_SCALED, <b>392</b>
ERR= specifier, 6, 237, 241, 242, 261, 263-265, <b>271</b>
<i>errmsg-variable</i> (R931), <b>145</b>, 145, 146, 150, 152, 212,
    214, 215, 217, 218, 221, 223-225, 552, 555
ERRMSG= specifier, 145, 148, 150, <b>152</b>, 194, 215, 217,
   <b>224</b>, 549, 555, 567
error indicator, <b>520</b>
ERROR STOP statement, 44, 45, <b>213</b>, 555
error termination, <b>45</b>, 88, 148, 150, 213, 215, 257, 271,
    272, 353, 370-374, 392, 393, 423, 425, 431, 435,
    554, 557
<i>error-stop-stmt</i> (R1163), 40, 88, <b>213</b>
ERROR_UNIT, 234, 235, 239, <b>458</b>
ES edit descriptor, 284
established coarray, <b>7</b>, 49, 144, 193, 405
evaluation
  operations, 159
  optional, 167
  parentheses, 168
EVENT POST statement, 215, <b>221</b>, 221, 225, 392, 458,
    459, 549, 552, 556
event variable, <b>28</b>, 44, 216, 221, 225, 392, 393, 458, 459,
    549
EVENT WAIT statement, 215, <b>221</b>, 221, 224, 458, 459,
    549, 552, 556
<i>event-post-stmt</i> (R1174), 40, <b>221</b>
<i>event-variable</i> (R1175), <b>221</b>, 221, 224, 458, 552
<i>event-wait-spec</i> (R1177), 214, <b>221</b>, 221
<i>event-wait-stmt</i> (R1176), 40, <b>221</b>, 221
EVENT_QUERY, <b>392</b>, 567, 585, 620
EVENT_TYPE, 74, 113, 146, 147, 221, <b>458</b>
EX edit descriptor, 285
executable construct, 188
executable statement, <b>22</b>, 42
<i>executable-construct</i> (R514), 39, <b>40</b>, 342
EXECUTE_COMMAND_LINE, 359, <b>393</b>
execution control, 188
<i>execution-part</i> (R509), 38, <b>39</b>, 39, 302, 339-341
<i>execution-part-construct</i> (R510), <b>39</b>, 39, 188
exist, 228, 235
EXIST= specifier, 264, <b>266</b>
EXIT statement, 188, 199, <b>212</b>
<i>exit-stmt</i> (R1158), 40, <b>212</b>, 212
EXP, <b>393</b>
explicit formatting, 274-292
explicit initialization, <b>13</b>, 82, 83, 103, 104, 121, 541,
    545, 547
                         explicit interface,<b>15</b>, 34, 80, 85, 126, 130, 181, 309-313,
                             318-320, 323, 329, 330, 343, 345, 534, 535, 552,
                             568, 598
                        <i>explicit-bounds-expr</i> (R819), <b>110</b>, 110, 111
                        <i>explicit-coshape-spec</i> (R811), 106, <b>107</b>, 107
                         explicit-shape array, <b>4</b>, 63, 80, 107, 109, 110, 173, 325,
                             327, 330, 513-516
                        <i>explicit-shape-bounds-spec</i> (R818), 109, <b>110</b>, 110
                        <i>explicit-shape-spec</i> (R815), 78, 79, 105, 109, <b>110</b>, 110-
                             112, 133
                         EXPONENT, <b>394</b>, 478
                        <i>exponent</i> (R717), <b>67</b>, 67
                        <i>exponent-letter</i> (R716), <b>67</b>, 67
                        <i>expr</i> (R1023), 30, 88, 92, 95, 99, 100, 145, 153, 154,<b>156</b>,
                             156, 157, 159, 168-170, 172-180, 184, 186, 189,
                             192, 201, 205, 247, 320, 321, 323, 343-345, 498,
                             551
                         expression, <b>153</b>, 153-173
                           component specification, <b>22</b>, 78, <b>171,</b> <b>172</b>
                           constant, <b>9</b>, 26, 35, 36, 60, 61, 70, 77, 80, 81, 100,
                             104, 108, 110, 112, 121, 122, 124, 132, 170,
                         <b>172</b>, 172, <b>173</b>, 173, 245, 309, 310, 331, 350,
                             362, 364, 365, 379, 384, 385, 395, 396, 401,
                             404, 406, 410, 411, 414, 415, 417, 420, 425, 434,
                             436, 438, 441, 444, 446, 447, 454-456, 512, 513
                           specification, <b>22</b>, 44, 77, 88, 105, 139, <b>170,</b> <b>171</b>,
                             171, 172, 191, 342, 466, 563
                         extended real model, 352
                         extended type, <b>25</b>, 77, 83, 87, 89, 90, 546, 569, 574
                        <i>extended-intrinsic-op</i> (R610), <b>55</b>, 55
                         EXTENDS attribute, <b>89</b>, 89, 511
                         EXTENDS_TYPE_OF, 172, <b>394</b>
                         extensible type, <b>26</b>, 62, 73, 81, 89, 254, 394, 437, 577,
                             615
                         extension operation, 157
                         extension type, <b>26</b>, 64, 89, 90, 210, 327, 394, 615
                         extent, <b>13</b>, 48, 326
                         EXTERNAL attribute, 31, 32, <b>113</b>, 113, 116, 125, 126,
                             128, 180, 303, 307, 312, 317, 330, 335, 336,
                             538, 539, 607
                         external file, <b>13</b>, 35, 227-232, 234-236, 240, 245, 263,
                             279, 289, 299, 346, 531, 589, 621
                         external input/output unit, <b>13</b>, 533
                         external linkage, 106, <b>501</b>, 529-531
                         external procedure, <b>19</b>, 31, 41, 85, 113, 126, 180, 220,
                             308, 309, 311-313, 317, 318, 321, 330, 336, 337,
    533, 534, 538, 539, 568, 598, 603, 607
EXTERNAL statement, 113, <b>317</b>
external subprogram, <b>24</b>, 41, 308
external unit, <b>13</b>, 234-236, 251, 256, 257, 267, 273, 458,
    459, 461
<i>external-name</i>, 317
<i>external-stmt</i> (R1511), 40, <b>317</b>
<i>external-subprogram</i> (R503), <b>38</b>, 38, 128, 342
<b>F</b>
F edit descriptor, 281
F_C_STRING, <b>509</b>
FAIL IMAGE statement, <b>214</b>
<i>fail-image-stmt</i> (R1165), 40, <b>214</b>
failed image, <b>14</b>, 44, 144, 147, 151, 152, 193, 223, 353,
    423
FAILED_IMAGES, <b>395</b>
field, <b>277</b>
file
  connected, 235
  external, <b>13</b>, 35, 227-232, 234-236, 240, 245, 263,
    279, 289, 299, 346, 531, 589, 621
  internal, <b>16</b>, 227, 233-236, 245, 249, 251-253, 256,
    257, 271, 272, 289, 290, 548, 550
file access method, 228-230
file connection, 233-241
file inquiry statement, <b>263</b>
file position, 228, 231
file positioning statement, 228, <b>261</b>
file storage unit, <b>13</b>, 227, 230-233, 240, 245, 246, 252,
    262, 268-270, 459, 544
<i>file-name-expr</i> (R1206), <b>237</b>, 237, 238, 264, 265, 267
<i>file-unit-number</i> (R1202), <b>233</b>, 233, 234, 237, 241, 243,
    256, 260, 261, 263-267, 269, 270, 346, 460
FILE= specifier, 236, 237,<b>238</b>, 239, 240, 264,<b>265</b>, 265,
    552, 590
FILE_STORAGE_SIZE, <b>459</b>
FINAL statement, <b>87</b>
final subroutine, <b>13</b>, 34, 86-88, 142, 325, 573, 574
<i>final-procedure-stmt</i> (R753), 85, <b>87</b>
<i>final-subroutine-name</i>, 87
finalizable, <b>13</b>, 34, 87, 111, 113, 151, 196
finalization, <b>13</b>, 87, 88, 142, 185, 308, 320, 334, 335,
    344, 345
FINDLOC, <b>395</b>
fixed source form, <b>57</b>, 57
FLOOR, <b>396</b>
                         FLUSH statement, 229, 260, <b>263</b>, 272
                        <i>flush-spec</i> (R1229), <b>263</b>, 263
                        <i>flush-stmt</i> (R1228), 40, <b>263</b>, 345
                         FMT= specifier, 242, <b>244</b>
                         FORALL construct, <b>185</b>, 346, 536, 537, 549, 562, 564
                         FORALL statement, 63, 159, <b>186</b>, 536, 537, 548
                        <i>forall-assignment-stmt</i> (R1054), 159,<b>185</b>, 185, 186, 346
                        <i>forall-body-construct</i> (R1053), <b>185</b>, 185, 186
                        <i>forall-construct</i> (R1051), 40, <b>185</b>, 185, 186
                        <i>forall-construct-name</i>, 185
                        <i>forall-construct-stmt</i> (R1052), <b>185</b>, 185, 212
                        <i>forall-stmt</i> (R1056), 41, 185, <b>186</b>, 186, 212
                         FORM TEAM statement, 43, 192, 215, <b>221</b>, 225, 549,
                             552, 556
                        <i>form-team-spec</i> (R1182), 221, <b>222</b>, 222
                        <i>form-team-stmt</i> (R1179), 40, <b>221</b>
                         FORM= specifier, 237, <b>239</b>, 264, <b>266</b>
                        <i>format</i> (R1215), 242, 243, <b>244</b>, 244, 251, 274, 275
                         format control, <b>277</b>
                         format descriptor, <i>see</i> edit descriptor
                         FORMAT statement, 31, 43, 55, 191, 244, <b>274</b>, 274,
                             303
                        <i>format-item</i> (R1304), <b>275</b>, 275
                        <i>format-items</i> (R1303), 274, <b>275</b>, 275
                        <i>format-specification</i> (R1302), <b>274</b>, 274
                        <i>format-stmt</i> (R1301), 39, <b>274</b>, 274, 303, 306, 312
                         FORMATTED, 254, <b>311</b>
                         formatted data transfer, 252
                         formatted input/output statement, 227, <b>244</b>
                         formatted record, <b>227</b>
                         FORMATTED= specifier, 264, <b>266</b>
                         formatting
                           explicit, 274-292
                           list-directed, 253, 293-296
                           namelist, 253, 297-301
                         forms, 228
                         Fortran 2003 compatibility, 34
                         Fortran 2008 compatibility, 33
                         Fortran 2018 compatibility, 32
                   Fortran 77 compatibility, 36
                         Fortran 90 compatibility, 35
                         Fortran 95 compatibility, 35
                         Fortran character set, <b>52</b>, 69
                         FRACTION, <b>397</b>
                         free source form, <b>56</b>, 56
                         function, <b>14</b>
  intrinsic, 349
  intrinsic elemental, 349
  intrinsic inquiry, 349
function reference, <b>20</b>, 46, 47, 334
function result, <b>14</b>, 34, 70, 102, 126, 131, 133, 150, 309,
    339, 340, 342, 347, 514, 535, 545, 551
FUNCTION statement, 63, 64, 126, 166, 167, 170, 302,
    337, <b>339</b>, 341, 342, 535
<i>function-name</i>, 103, 312, 339, 342-344, 535, 538
<i>function-reference</i> (R1520), 92, 103, 135, 153, <b>320</b>, 323,
    334
<i>function-stmt</i> (R1533), 38, 311, 312, 338,<b>339</b>, 339, 535,
    538
<i>function-subprogram</i> (R1532), 24, 38, 39, 303, <b>339</b>, 341
<b>G</b>
G edit descriptor, 287, 288
GAMMA, <b>397</b>
generic identifier, <b>14</b>, 303, 312-314, 316, 336, 349, 533,
    538
generic interface, <b>15</b>, 86, 89, 94, 115, 166, 167, 177, 178,
    259, 304, 305, <b>313</b>, 313-315, 335, 534, 616
generic interface block, <b>16</b>, 312, 313, 316, 568
generic procedure reference, 316
GENERIC statement, <b>85,</b> <b>86</b>, <b>313</b>, 313, 316, 335
<i>generic-name</i>, 85, 86, 311, 535, 538
<i>generic-spec</i> (R1508), 85, 86, 89, 119, 166, 167, 178,
    304, 305, <b>311</b>, 311-313, 335, 535, 538
<i>generic-stmt</i> (R1510), 39, <b>313</b>
GET_COMMAND, <b>397</b>
GET_COMMAND_ARGUMENT, <b>398</b>
GET_ENVIRONMENT_VARIABLE, <b>399</b>, 558
GET_TEAM, 172, <b>400</b>, 458, 459, 461
global entity, <b>533</b>
global identifier, <b>533</b>
GO TO statement, 56, <b>212</b>, 212
<i>goto-stmt</i> (R1159), 40, <b>212</b>, 213
graphic character, 52, 70, 299
<b>H</b>
halting mode, 464, <b>469</b>, 469, 472, 474, 488, 494, 531,
    559
<i>hex-constant</i> (R775), <b>99</b>, 99
<i>hex-digit</i> (R776), <b>99</b>, 99, 287
<i>hex-digit-string</i> (R1323), <b>287</b>, 287
host, <b>14</b>, 41, 306, 344, 535, 538, 539
                         host association, <b>4</b>, 18, 42, 63, 64, 70, 106, 119, 121,
                             126, 134, 170, 171, 180, 306, 308, 331, 344-
                             347, 535, 537, 539, 540, 543, 546, 639
                         host instance,<b>14</b>, 181, 321, 322, 330, 341, 367, 538, 542,
                             546, 551
                         host scoping unit, <b>14</b>, 41, 126, 129, 335, 336, 539, 546
                         HUGE, <b>401</b>
                         HYPOT, <b>401</b>
          <b>I</b>
                         I edit descriptor, 280
                         IACHAR, 72, 176, <b>401</b>
                         IALL, <b>402</b>
                         IAND, 196, 200, 371, <b>402</b>
                         IANY, <b>403</b>
                         IBCLR, <b>403</b>
                         IBITS, <b>403</b>
                         IBSET, <b>404</b>
                         ICHAR, 71, <b>404</b>
                        <i>id-variable</i> (R1214), 242, <b>243</b>
                         ID= specifier, 242, 243, <b>246</b>, <b>260</b>, 264, 265, <b>267</b>, 552,
                             592, 593
                         IEEE infinity, <b>14</b>
                         IEEE NaN, <b>14</b>, 166, 466, 467, 490
                         IEEE_ALL, <b>465</b>
                         IEEE_ARITHMETIC, 171, 172, 199, 361, 464-498
                         IEEE_AWAY, <b>468</b>, 475
                         IEEE_CLASS, 471, <b>473</b>, 473
                         IEEE_CLASS_TYPE, <b>465</b>, 473, 498
                         IEEE_COPY_SIGN, 470, 471, <b>473</b>
                         IEEE_DATATYPE, <b>465</b>
                         IEEE_DENORMAL, <b>465</b>
                         IEEE_DIVIDE, <b>465</b>
                         IEEE_DIVIDE_BY_ZERO, <b>465</b>
                         IEEE_DOWN, <b>465</b>, <b>468</b>
                         IEEE_EXCEPTIONS, 171, 172, 199, 464-498
                         IEEE_FEATURES, 464-465
                         IEEE_FEATURES_TYPE, <b>465</b>
                         IEEE_FLAG_TYPE, <b>465</b>, 474, 488, 494
                         IEEE_FMA, 471, <b>474</b>
                         IEEE_GET_FLAG, 199, 467, 472, <b>474</b>, 499, 500, 559
                         IEEE_GET_HALTING_MODE, 199, 472, <b>474</b>, 475
                         IEEE_GET_MODES, 469, 472, <b>475</b>, 475, 488
                         IEEE_GET_ROUNDING_MODE, 468, 471, <b>475</b>,
                             475, 489
                         IEEE_GET_STATUS, 199, 467, 472, <b>476</b>, 476, 489,
                             499, 559
IEEE_GET_UNDERFLOW_MODE, 471, <b>476</b>, 490
IEEE_HALTING, <b>465</b>
IEEE_INEXACT, <b>465</b>
IEEE_INEXACT_FLAG, <b>465</b>
IEEE_INF, <b>465</b>
IEEE_INT, 471, <b>476</b>
IEEE_INVALID, <b>465</b>
IEEE_INVALID_FLAG, <b>465</b>
IEEE_IS_FINITE, 471, <b>477</b>
IEEE_IS_NAN, 471, <b>477</b>
IEEE_IS_NEGATIVE, 471, <b>477</b>
IEEE_IS_NORMAL, 471, <b>478</b>
IEEE_LOGB, 470, 471, <b>478</b>
IEEE_MAX, 471, <b>478</b>
IEEE_MAX_MAG, 471, <b>479</b>
IEEE_MAX_NUM, 33, 471, <b>479</b>
IEEE_MAX_NUM_MAG, 33, 471, <b>480</b>
IEEE_MIN, 471, <b>480</b>
IEEE_MIN_MAG, 471, <b>481</b>
IEEE_MIN_NUM, 33, 471, <b>481</b>
IEEE_MIN_NUM_MAG, 33, 471, <b>482</b>
IEEE_MODES_TYPE, <b>465</b>, 469, 475, 488
IEEE_NAN, <b>465</b>
IEEE_NEAREST, <b>465</b>, <b>468</b>
IEEE_NEGATIVE_DENORMAL, <b>465</b>
IEEE_NEGATIVE_INF, <b>465</b>
IEEE_NEGATIVE_NORMAL, <b>465</b>
IEEE_NEGATIVE_SUBNORMAL, <b>465</b>, 465, 473,
    477
IEEE_NEGATIVE_ZERO, <b>465</b>
IEEE_NEXT_AFTER, 471, <b>482</b>
IEEE_NEXT_DOWN, 471, <b>482</b>, 483
IEEE_NEXT_UP, 471, <b>483</b>
IEEE_OTHER, <b>465</b>, <b>468</b>
IEEE_OTHER_VALUE, <b>465</b>
IEEE_OVERFLOW, <b>465</b>
IEEE_POSITIVE_DENORMAL, <b>465</b>
IEEE_POSITIVE_INF, <b>465</b>
IEEE_POSITIVE_NORMAL, <b>465</b>
IEEE_POSITIVE_SUBNORMAL, <b>465</b>, 465, 473, 477
IEEE_POSITIVE_ZERO, <b>465</b>
IEEE_QUIET_EQ, 471, <b>483</b>
IEEE_QUIET_GE, 471, <b>483</b>
IEEE_QUIET_GT, 471, <b>484</b>
IEEE_QUIET_LE, 471, <b>484</b>
IEEE_QUIET_LT, 471, <b>485</b>
                         IEEE_QUIET_NAN, <b>465</b>
                         IEEE_QUIET_NE, 471, <b>485</b>
                         IEEE_REAL, 471, <b>485</b>
                         IEEE_REM, 470, 471, <b>486</b>
                         IEEE_RINT, 470, 471, <b>486</b>
                         IEEE_ROUND_TYPE, <b>465</b>, 475, 476, 486, 489, 495
                         IEEE_ROUNDING, <b>465</b>
                         IEEE_SCALB, 471, <b>487</b>
                         IEEE_SELECTED_REAL_KIND, 471, <b>487</b>
                         IEEE_SET_FLAG, 467, 472, 476, <b>488</b>, 489, 499, 500,
                             559
                         IEEE_SET_HALTING_MODE, 199, 467, 472, 475,
                         <b>488</b>, 494, 499, 500, 559
                         IEEE_SET_MODES, 199, 469, 472, 475, <b>488</b>, 488
                         IEEE_SET_ROUNDING_MODE, 199, 468, 471, 475,
                             488, <b>489</b>, 489
                         IEEE_SET_STATUS, 199, 467, 468, 472, 476, <b>489</b>,
                             489, 500, 559
                         IEEE_SET_UNDERFLOW_MODE, 199, 471, 475,
                             476, 488, <b>490</b>
                         IEEE_SIGNALING_EQ, 471, <b>490</b>
                         IEEE_SIGNALING_GE, 471, <b>490</b>
                         IEEE_SIGNALING_GT, 471, <b>491</b>
                         IEEE_SIGNALING_LE, 472, <b>491</b>
                         IEEE_SIGNALING_LT, 472, <b>491</b>
                         IEEE_SIGNALING_NAN, <b>465</b>
                         IEEE_SIGNALING_NE, 472, <b>492</b>
                         IEEE_SIGNBIT, 472, <b>492</b>
                         IEEE_SQRT, <b>465</b>
                         IEEE_STATUS_TYPE, <b>465</b>, 469, 476, 489, 499
                         IEEE_SUBNORMAL, <b>465</b>
                         IEEE_SUPPORT_DATATYPE, 464-466, 472-474,
                             476, 478-486, 489-492, <b>493</b>, 493, 496-498
                         IEEE_SUPPORT_DENORMAL, 472, <b>493</b>
                         IEEE_SUPPORT_DIVIDE, 472, <b>493</b>, 496
                         IEEE_SUPPORT_FLAG, 472, <b>494</b>, 496
                         IEEE_SUPPORT_HALTING, 472, <b>494</b>, 496
                         IEEE_SUPPORT_INF, 469, 470, 472, 482, 483, <b>494</b>,
                             496, 498
                         IEEE_SUPPORT_IO, 472, <b>495</b>
                         IEEE_SUPPORT_NAN, 466, 467, 469, 472, <b>495</b>, 496,
                             498
                         IEEE_SUPPORT_ROUNDING, 472, 489, <b>495</b>, 496
                         IEEE_SUPPORT_SQRT, 472, <b>496</b>, 496
                         IEEE_SUPPORT_STANDARD, 470, 472, <b>496</b>
                         IEEE_SUPPORT_SUBNORMAL, 469, 470, 472, 473,
    483, 493, 496, <b>497</b>, 498
IEEE_SUPPORT_UNDERFLOW_CONTROL, 472,
   <b>497</b>
IEEE_TO_ZERO, <b>465</b>, <b>468</b>
IEEE_UNDERFLOW, <b>465</b>
IEEE_UNDERFLOW_FLAG, <b>465</b>
IEEE_UNORDERED, 470, 472, <b>497</b>
IEEE_UP, <b>465</b>, <b>468</b>
IEEE_USUAL, <b>465</b>
IEEE_VALUE, 472, <b>498</b>
IEOR, 196, 200, 374, <b>404</b>
IF construct, 44, <b>203</b>, 561
IF statement, 159, <b>204</b>
<i>if-construct</i> (R1136), 40, <b>203</b>, 203
<i>if-construct-name</i>, 203
<i>if-stmt</i> (R1141), 40, <b>204</b>, 204
<i>if-then-stmt</i> (R1137), <b>203</b>, 203, 212
<i>imag-part</i> (R720), <b>68</b>, 68
image, 1, <b>14</b>, 33, 43-45, 48, 49, 88, 107, 144, 146-148,
    151, 177, 179, 180, 193, 194, 213, 215-220,
    222-225, 228, 229, 234, 235, 267, 320, 325, 329,
    332, 334, 349, 353, 358, 359, 370-374, 385, 387,
    399, 405, 406, 423, 427, 432, 433, 448, 450, 451,
    455, 459, 462, 469, 533, 541, 542, 549, 551, 552
  active, <b>14</b>, 152
  failed, <b>14</b>, 147, 151, 152, 223, 423
  stopped, <b>14</b>, 147, 151, 152, 423
image control statement, <b>15</b>, 44, 168, 194, 199, 214,
   <b>215</b>, 215-217, 220, 224-226, 334, 346, 353,
    354, 395, 447, 462
image index, <b>15</b>, 43, 48, 49, 143, 144, 218, 222, 228,
    329, 359, 405, 432, 451, 455, 533
<i>image-selector</i> (R926), 43, 136-138, <b>144</b>, 144, 297
<i>image-selector-spec</i> (R928), <b>144</b>, 144
<i>image-set</i> (R1171), <b>218</b>, 218
IMAGE_INDEX, <b>405</b>
IMAGE_STATUS, <b>405</b>
imaginary part, <b>68</b>
implicit interface, <b>15</b>, 79, 181, 303, 318-320, 330, 507,
    539
IMPLICIT NONE statement, <b>126</b>
IMPLICIT statement, 43, <b>126</b>, 131, 306
<i>implicit-none-spec</i> (R869), <b>126</b>, 126
<i>implicit-part</i> (R505), <b>39</b>, 39
<i>implicit-part-stmt</i> (R506), <b>39</b>, 39
<i>implicit-spec</i> (R867), <b>126</b>, 126
                        <i>implicit-stmt</i> (R866), 39, <b>126</b>, 126
                         implied-shape array, <b>112</b>
                        <i>implied-shape-or-assumed-size-spec</i> (R825), 109, <b>111</b>,
                             111, 112
                        <i>implied-shape-spec</i> (R826), 109, <b>112</b>, 112
                         IMPORT statement, 43, <b>128</b>, 191, 533, 536, 539
                        <i>import-name</i>, 128, 129
                        <i>import-stmt</i> (R870), 39, <b>128</b>, 191
                         IMPURE, <b>337</b>, 338, 342, 344, 347
                         IN, <b>113</b>
                         INCLUDE line, 56, <b>58</b>
                         inclusive scope, <b>15</b>, 191, 212, 213, 237, 241, 243, 244,
                             261, 263, 265, 321, 343, 533, 534
                         INDEX, <b>406</b>
                        <i>index-name</i>, 185-187, 195, 196, 198, 536, 537, 549
                         inherit, <b>15</b>, 73, 85-87, 89, 90, 546, 577
                         inheritance association, <b>5</b>, 50, 89, 92, 543, 546
                         initial team, <b>24</b>, 49, 144, 234, 359, 400, 405, 427, 432,
                             450, 459
                        <i>initial-data-target</i> (R744), 33, <b>81</b>, 81, 82, 103, 104, 116,
                             122, 123
                        <i>initial-proc-target</i> (R1518), 82, <b>318</b>, 318, 319
                         INITIAL_TEAM, 400, <b>459</b>
                         initialization, 104
                           default, <b>10</b>, 80-83, 92, 93, 104, 111, 113, 121, 132-
                             134, 326, 541, 545, 546, 550
                           explicit, <b>13</b>, 82, 83, 103, 104, 121, 541, 545, 547
                        <i>initialization</i> (R805), 99, <b>103</b>, 103, 104, 173
                         INOUT, 56, <b>113</b>
                         input statement, <b>242</b>, 243, 589
                        <i>input-item</i> (R1216), 242, 243, <b>247</b>, 247, 248, 260, 273,
                             552
                         input/output editing, 274-301
                         input/output list, 247
                         input/output statement, 548
                         input/output statements, 227-273
                         input/output unit, <b>27</b>, 43
                         INPUT_UNIT, 234, 235, 239, 256, <b>459</b>
                         INQUIRE statement, 35, 229, 230, 232, 233, 235, 236,
                             246, 256, 257, 260, <b>263</b>, 272, 273, 460, 548,
                             550-552, 557, 588
                        <i>inquire-spec</i> (R1231), <b>264</b>, 264, 265, 273
                        <i>inquire-stmt</i> (R1230), 40, <b>264</b>, 345
                         inquiry function, <b>15</b>, 107, 111, 113, 137, 148, 171, 324,
                             325, 349-351, 354, 364, 367, 377, 384, 388, 391,
                             394, 401, 409-411, 416, 419, 424, 430, 431,
    434, 437, 441, 444, 447, 451, 454, 455, 468-
    471, 493-497, 509
inquiry, type parameter, 138
instance, 341
INT, 123, 176, 351, 390, 402, 405, <b>406</b>, 407, 419
<i>int-constant</i> (R607), <b>54</b>, 54, 122
<i>int-constant-expr</i> (R1032), 65, 69, 76, 77, 94, 95, 117,
    121, <b>173</b>, 173, 207, 208
<i>int-constant-name</i>, 65, 66
<i>int-constant-subobject</i> (R849), <b>122</b>, 122
<i>int-expr</i> (R1027), 43, 61, 97, 100, 110, 136, 139, 140,
    144, 145, 159, <b>168</b>, 168, 170-173, 195, 197,
    213, 214, 218, 221, 222, 233, 234, 237, 242,
    247, 250, 261, 264, 343
<i>int-literal-constant</i> (R708), 54, <b>65</b>, 65, 69, 275, 276
<i>int-variable</i> (R907), <b>135</b>, 135, 151, 237, 243, 244, 264,
    265, 267-272, 557
<i>int-variable-name</i>, 195
INT16, <b>459</b>
INT32, <b>459</b>
INT64, <b>459</b>
INT8, <b>459</b>
integer constant, 65
integer editing, 280
integer model, 352
integer type, 65-66
<i>integer-type-spec</i> (R705), 63, <b>65</b>, 65, 76, 100, 121, 195,
    536, 537
INTEGER_KINDS, <b>459</b>
INTENT (IN) attribute, <b>113</b>, 113-115, 119, 196, 314-
    316, 325, 328, 330, 332, 344-346, 350, 370-374,
    380-383, 392, 393, 398, 399, 423, 424, 432, 433,
    472, 503-506, 528, 552, 568, 610, 624
INTENT (INOUT) attribute, 33, <b>113</b>, 114, 115, 118,
    201, 315, 321, 326, 328, 335, 346-348, 361,
    370-374, 380-383, 393, 398, 399, 422, 423, 458,
    460, 461, 552, 553, 624
INTENT (OUT) attribute, 33-35, 63, 87, 88, 111, <b>113</b>,
    113-115, 118, 150, 170, 315, 321, 326, 328, 335,
    344-348, 361, 370-374, 380-383, 385, 387, 392,
    393, 397-399, 422, 423, 425, 430, 432, 433, 448,
    474-476, 503, 505, 506, 528, 542, 543, 548, 549,
    551-553, 624
INTENT attribute, <b>113</b>, 113-115, 124, 200, 568
INTENT statement, <b>124</b>, 191
<i>intent-spec</i> (R828), 102, <b>113</b>, 124, 318
                        <i>intent-stmt</i> (R852), 40, <b>124</b>
                         interface, <b>15</b>, 42, 47, 50, 79, 85, 86, 115, 254, 255, 289,
                             309, <b>310</b>, 320, 329, 330, 334-336, 341, 343,
                             345, 513-516, 530, 531, 599
                           abstract, <b>15</b>, 303, <b>310</b>, 312, 318, 338, 534, 538
                           explicit, <b>15</b>, 34, 80, 85, 126, 130, 181, 309-313,
                             318-320, 323, 329, 330, 343, 345, 534, 535, 552,
                             568, 598
                           generic,<b>15</b>, 86, 89, 94, 115, 166, 167, 177, 178, 259,
                             304, 305, <b>313</b>, 313-315, 335, 534
                           implicit, <b>15</b>, 79, 181, 303, 318-320, 330, 507, 539
                           procedure, 310
                           specific, <b>15</b>, 259, <b>312</b>, 312, 313, 318, 335, 568
                         interface block, <b>16</b>, 42, 254, 259, 304, 311-313, 335, 599
                         interface body, 16, 21, 42, 108, 110, 113, 126, 170, <b>311</b>,
                             311, 338, 341, 343, 516, 535, 538, 598
                         INTERFACE statement, <b>311</b>, 599
                        <i>interface-block</i> (R1501), 39, <b>311</b>, 311
                        <i>interface-body</i> (R1505), <b>311</b>, 311, 312
                        <i>interface-name</i> (R1516), 85, 86, 317, <b>318</b>, 318
                        <i>interface-specification</i> (R1502), <b>311</b>, 311, 312
                        <i>interface-stmt</i> (R1503), <b>311</b>, 311-314, 538
                         internal file, <b>16</b>, 227, 233-236, 245, 249, 251-253, 256,
                             257, 271, 272, 289, 290, 548, 550
                         internal procedure, <b>19</b>, 41, 180, 308-311, 321, 322, 330,
                             336, 338, 341, 367, 531, 534, 535, 539, 568
                         internal subprogram, <b>24</b>, 41, 43, 126, 129, 308, 335, 538
                         internal unit, <b>16</b>, 234, 236, 251, 256, 265, 273, 460
                        <i>internal-file-variable</i> (R1203), <b>233</b>, 233, 234, 243, 273,
                             552
                        <i>internal-subprogram</i> (R512), <b>39</b>, 39
                        <i>internal-subprogram-part</i> (R511), 38, <b>39</b>, 39, 302, 339-
                             341
                         interoperable, <b>16</b>, 94, 95, 106, 338, 343, 501, 503, 505,
                             508-516, 529, 530
                         interoperable enumeration, 94, 501
                         interoperate, <b>501</b>
                         intrinsic,<b>16</b>, 45, 46, 48-51, 61, 63, 88, 99, 113, 309, 310,
                             328, 336, 347, 457, 534, 536
                         intrinsic assignment statement, 34, 92, 144, 150, 152,
                             169, <b>174</b>, 178, 180, 200, 225, 233, 264, 273,
                             299, 345, 350, 354, 361, 380, 452, 548, 555
                         INTRINSIC attribute, 113, <b>115</b>, 115, 116, 303, 319,
                             335, 336, 539
                         intrinsic function, 349
                         INTRINSIC module nature, <b>304</b>
intrinsic operation, 159-166
intrinsic procedure, 349-456
INTRINSIC statement, 306, <b>319</b>
intrinsic subroutines, 349
intrinsic type, <b>26</b>, 45, 46, 60, 65-72, 514, 519
<i>intrinsic-operator</i> (R608), <b>54</b>, 55, 154, 156, 160, 166,
    167, 314
<i>intrinsic-procedure-name</i>, 319, 538
<i>intrinsic-stmt</i> (R1519), 40, <b>319</b>, 538
<i>intrinsic-type-spec</i> (R704), 62, 63, <b>65</b>, 70
<i>io-control-spec</i> (R1213), 234, <b>242</b>, 242, 243, 246, 256,
    273
<i>io-implied-do</i> (R1218), <b>247</b>, 247-249, 252, 273, 548,
    550, 552, 589
<i>io-implied-do-control</i> (R1220), <b>247</b>, 247, 250
<i>io-implied-do-object</i> (R1219), <b>247</b>, 247, 252
<i>io-unit</i> (R1201), <b>233</b>, 233, 234, 242, 243, 346
IOLENGTH= specifier, 232, 264, <b>270</b>
<i>iomsg-variable</i> (R1207), <b>237</b>, 237, 241, 242, 261, 263,
    264, 271-273, 548
IOMSG= specifier, 237, 241, 242, 261, 263, 264, 271,
    272, <b>273</b>, 548
IOR, 196, 200, 374, <b>407</b>
IOSTAT= specifier, 237, 241, 242, 256, 261, 263, 264,
    271, <b>272</b>, 272, 409, 459, 460, 548, 557, 589
IOSTAT_END, 256, 272, <b>459</b>
IOSTAT_EOR, 256, 272, <b>459</b>
IOSTAT_INQUIRE_INTERNAL_UNIT, 256, 272,
   <b>460</b>, 463
IPARITY, <b>407</b>
IS_CONTIGUOUS, 63, <b>409</b>
IS_IOSTAT_END, <b>409</b>
IS_IOSTAT_EOR, <b>409</b>
ISHFT, <b>408</b>
ISHFTC, <b>408</b>
ISO 10646 character, <b>16</b>, <b>69</b>, <b>72</b>, 174, 233, 234, 238,
    249, 279, 293, 294, 424, 439
ISO_C_BINDING, 63, 78, 89, 106, 113, 137, 145-147,
    171, 177, 345, 346, 456, 501-511, 550, 551, 568
ISO_Fortran_binding.h, 516
ISO_FORTRAN_ENV, 33, 74, 78, 106, 113, 137, 144-
    147, 152, 171, 177, 192, 213-215, 221-225, 232,
    234, 239, 251, 256, 272, 353, 370-374, 395, 400,
    405, 406, 423, 427, 446, 447, 450, 451, 457-462,
    549, 551, 552, 559, 589
          <b>K</b>
                        <i>k</i> (R1314), <b>276</b>, 276, 283, 288, 289, 291
                         keyword, <b>16</b>
                           argument,<b>17</b>, 50, 310, 313, 322, 349, 354, 470, 534,
                         <b>535,</b> <b>536</b>, 598
                           component, <b>17</b>, 50, 83, 92, 535
                           statement, <b>17</b>, 50
                           type parameter, <b>17</b>, 50, 91
                        <i>keyword</i> (R516), <b>50</b>, 50, 91, 92, 320
                         KIND, 65-69, 72, 77, 95, 138, 139, 176, <b>409</b>
                         kind type parameter, <b>26</b>, 31, 45, 61, 65-70, 72, 77, 87,
                             95, 100, 154, 172, 174-176, 297, 315, 321, 323,
                             325, 338, 389, 394, 437, 459, 460, 462, 501,
                             502, 510, 568
                        <i>kind-param</i> (R709), <b>65</b>, 65-67, 69, 70, 72
                        <i>kind-selector</i> (R706), 30, <b>65</b>, 65, 72
          <b>L</b>
                         L edit descriptor, 287
                         label, <i>see</i> statement label
                        <i>label</i> (R611), <b>55</b>, 55, 195, 197, 212, 213, 237, 241-244,
                             260, 261, 263-265, 271, 272, 320, 321
                        <i>label-do-stmt</i> (R1121), <b>195</b>, 195, 197
                        <i>language-binding-spec</i> (R808), 102, <b>106</b>, 120, 338
                         LBOUND, 63, 175, 181, 189, 208, <b>409</b>
                        <i>lbracket</i> (R779), 78,<b>99</b>, 99, 102, 103, 120, 121, 125, 144,
                             145
                         LCOBOUND, <b>410</b>
                         leading zero mode, 239, 246, <b>291</b>
                        <i>leading-zero-edit-desc</i> (R1319), 276, <b>277</b>
                         LEADING_ZERO= specifier, 237, <b>239</b>, 242-244, <b>246</b>,
                             264, <b>267</b>, 291
                         LEADZ, <b>411</b>
                         left tab limit, <b>290</b>
                         LEN, 138, 139, <b>411</b>
                         LEN_TRIM, <b>411</b>
                         length type parameter, <b>27</b>, 45, 61, 72, 81, 100, 115, 148,
                             174, 175, 325, 411, 508, 510, 568
                        <i>length-selector</i> (R722), 30, <b>69</b>, 69, 70
                        <i>letter</i>, <b>52</b>, 52, 53, 55, 126, 154, 156
                        <i>letter-spec</i> (R868), <b>126</b>, 126
                        <i>level-1-expr</i> (R1003), <b>154</b>, 154, 155, 158
                        <i>level-2-expr</i> (R1007), <b>154</b>, 154, 155, 158
                        <i>level-3-expr</i> (R1011), <b>155</b>, 155, 156
                        <i>level-4-expr</i> (R1013), <b>155</b>, 156
                        <i>level-5-expr</i> (R1018), <b>156</b>, 156, 157
                         lexical token, <b>17</b>, 29, 53, 55
LGE, 72, <b>412</b>
LGT, 72, <b>412</b>
line, <b>17</b>, 56-59
linkage association, <b>5</b>, 530, 537, <b>540</b>, 540
list-directed formatting, 253, 293-296
list-directed input/output statement, <b>244</b>
literal constant, <b>9</b>, 47, 136, 169
<i>literal-constant</i> (R605), <b>54</b>, 54, 153
LLE, 72, <b>412</b>
LLT, 72, <b>413</b>
LOCAL, <b>196</b>, 200, 203, 536, 543, 551
local identifier, <b>533</b>, 534
local procedure pointer, <b>18</b>, 341
local variable, <b>28</b>, 33, 34, 47, 48, 104, 106, 108, 110,
    117, 119, 147, 149, 150, 322, 341, 345
<i>local-defined-operator</i> (R1414), <b>304</b>, 304, 305
<i>local-name</i>, 304, 305
LOCAL_INIT, <b>196</b>, 200, 536, 543, 549, 551
locality, <b>200,</b> <b>201</b>, 536, 543, 549, 551
<i>locality-spec</i> (R1130), <b>196</b>, 196, 197
LOCK statement, 215, <b>222</b>, 225, 460, 462, 549, 552
lock variable, <b>28</b>, 44, 225, 460, 462, 549, 552
<i>lock-stat</i> (R1184), 222, <b>223</b>, 223
<i>lock-stmt</i> (R1183), 40, <b>222</b>
<i>lock-variable</i> (R1186), 222, <b>223</b>, 223, 224, 460, 552
LOCK_TYPE, 33, 74, 113, 146, 147, 223, <b>460</b>
LOG, 35, <b>413</b>
LOG10, <b>414</b>
LOG_GAMMA, <b>414</b>
LOGICAL, <b>414</b>
logical intrinsic operation, 164
logical type, 72
<i>logical-expr</i> (R1025), 154, 159, <b>168</b>, 168, 183, 195, 197-
    199, 203, 204, 213, 321, 323
<i>logical-literal-constant</i> (R725), 54, <b>72</b>, 154, 156
<i>logical-variable</i> (R904), <b>135</b>, 135, 223, 224, 264, 266-
    268, 552
LOGICAL16, <b>460</b>
LOGICAL32, <b>460</b>
LOGICAL64, <b>460</b>
LOGICAL8, <b>460</b>
LOGICAL_KINDS, <b>460</b>
<i>loop-control</i> (R1123), <b>195</b>, 195, 197, 198, 202
<i>lower-bound</i> (R816), <b>110</b>, 110-112
<i>lower-bound-expr</i> (R936), <b>145</b>, 145, 179
<i>lower-bounds-expr</i> (R937), <b>145</b>, 145-147, 178, 179, 181
                        <i>lower-cobound</i> (R812), 107, <b>108</b>, 108
                         LZ edit descriptor, 291
                         LZP edit descriptor, 291
                         LZS edit descriptor, 291
          <b>M</b>
                        <i>m</i> (R1309), 275, <b>276</b>, 276, 280, 281, 286, 287
                         main program, <b>17</b>, 41, 44, 47
                        <i>main-program</i> (R1401), 38, 41, 128, <b>302</b>, 302
                        <i>mask-expr</i> (R1047), 182, <b>183</b>, 183-186, 195, 196, 198
                         masked array assignment, <b>17</b>, <b>182</b>, 548
                         masked array assignment (WHERE), 182
                        <i>masked-elsewhere-stmt</i> (R1048), 182, <b>183</b>, 183, 186
                         MASKL, <b>414</b>
                         MASKR, <b>415</b>
                         MATMUL, <b>415</b>
                         MAX, 196, 200, 348, 350, <b>416</b>
                         MAXEXPONENT, <b>416</b>
                         MAXLOC, 350, <b>416</b>
                         MAXVAL, <b>417</b>
                         MERGE, <b>418</b>
                         MERGE_BITS, <b>419</b>
                         MIN, 196, 200, <b>419</b>
                         MINEXPONENT, <b>419</b>
                         MINLOC, <b>420</b>
                         MINVAL, <b>421</b>
                         MOD, 35, <b>421</b>
                         mode
                           blank interpretation, 238
                           changeable, 234
                           connection, 234
                           decimal edit, 238
                           delimiter, 238
                           halting, 464, <b>469</b>, 469, 472, 474, 488, 494, 531, 559
                           IEEE rounding, 464, 465, <b>468</b>, 469, 470
                           input/output rounding, 234, 240, 247, 269, <b>286</b>,
                             291, 292, 495
                           leading zero, 239, 246, 291
                           pad, 239
                           sign, 240, 291
                           underflow, <b>468</b>, 469, 471, 476, 490, 497, 559
                         model
                           bit, 350
                           extended real, 352
                           integer, 352
                           real, 352
                         MODULE, <b>311</b>, 312, <b>337</b>, 338, <b>341</b>
module, <b>17</b>, 41, 42, 47, <b>302</b>
<i>module</i> (R1404), 38, 128, <b>303</b>
module procedure, <b>19</b>, 85, 130, 180, 308-312, 318, 321,
    330, 336, 338, 341, 342, 344, 346, 347, 456,
    534, 535
module procedure interface body, 129, <b>312</b>
module reference, <b>20</b>, 303
MODULE statement, 302, <b>303</b>
module subprogram, <b>24</b>, 41, 43, 126, 129, 335, 538
<i>module-name</i>, 303, 304, 538
<i>module-nature</i> (R1410), <b>304</b>, 304
<i>module-stmt</i> (R1405), 38, <b>303</b>, 303
<i>module-subprogram</i> (R1408), 39, <b>303</b>, 303, 342
<i>module-subprogram-part</i> (R1407), 38, 86, 90, <b>303</b>, 303,
    306, 603
MODULO, 35, <b>422</b>
MOLD= specifier, <b>145</b>
MOVE_ALLOC, 148, 215, 349, <b>422</b>
<i>mp-subprogram-stmt</i> (R1542), 39, <b>341</b>, 341
<i>mult-op</i> (R1009), 54, <b>154</b>, 154, 155
<i>mult-operand</i> (R1005), <b>154</b>, 154, 155, 158
<i>multiple-subscript</i> (R920), <b>139</b>, 139, 140
<i>multiple-subscript-triplet</i> (R923), 139, <b>140</b>, 140
MVBITS, 349, 350, <b>423</b>
<b>N</b>
<i>n</i> (R1316), <b>276</b>, 276, 277, 290
name, <b>17</b>, 50, 53, 533
<i>name</i> (R603), 30, 50, <b>53</b>, 53, 54, 103, 125, 135, 196,
    201, 210, 252, 318, 339
name association, <b>5</b>, 50, <b>537</b>, 543
name-value subsequence, <b>297</b>, 297
NAME= specifier, 102, <b>106</b>, 120, 264, 265, <b>267</b>, <b>318</b>,
    318, 338, <b>530</b>
named constant, <b>9</b>, 33, 47, 50, 53, 61, 66, 68-70, 95, 97,
    112, 115, 116, 119, 122, 124, 131, 136, 344
<i>named-constant</i> (R606), <b>54</b>, 54, 58, 68, 94, 124, 538
<i>named-constant-def</i> (R855), <b>124</b>, 124, 538
NAMED= specifier, 264, <b>267</b>
namelist formatting, 253, 297-301
namelist input/output statement, <b>244</b>
NAMELIST statement, <b>130</b>, 191, 297, 305
<i>namelist-group-name</i>, 131, 242-244, 251, 253, 274, 297,
    301, 305, 538, 552
<i>namelist-group-object</i> (R872), <b>131</b>, 131, 251-253, 260,
    273, 297, 301, 305
<i>namelist-stmt</i> (R871), 40, <b>131</b>, 538, 552
                         NaN, <b>14</b>, 281-285, 288, 361, 394, 397, 437, 441, 444,
                             466, 469, 470, 472, 473, 477, 495
                         NEAREST, <b>424</b>
                         NEW_INDEX= specifier, <b>222</b>, 556
                         NEW_LINE, 288, <b>424</b>
                         NEWUNIT= specifier, 234, 237, <b>239</b>, 256, 549, 552
                         NEXT, <b>425</b>
                         NEXTREC= specifier, 264, <b>267</b>
                         NINT, <b>425</b>
                         NML= specifier, 242, <b>244</b>, 552
                         NON_INTRINSIC module nature, <b>304</b>
                         NON_OVERRIDABLE attribute, <b>84</b>, 86
                         NON_RECURSIVE attribute, 310, <b>337</b>, 337, 338, 341,
                             342
                         nonadvancing input/output statement, 231
                         nonblock DO construct, <b>562</b>
                         NONE, <b>126</b>, <b>128</b>, <b>196</b>
                         nonexecutable statement, <b>22</b>, 42
                        <i>nonlabel-do-stmt</i> (R1122), <b>195</b>, 195, 197
                         NOPASS, <b>79</b>, 81, <b>85</b>
                         NOPASS attribute, <i>see</i> PASS attribute
                         NORM2, <b>425</b>
                         normal number, <b>469</b>
                         normal termination, 14, 43, 44, <b>45</b>, 88, 213, 228, 240,
                             241, 406, 447, 462
                         NOT, <b>426</b>
                        <i>not-op</i> (R1019), 54, <b>156</b>, 156
                         notify variable, <b>28</b>, 44, 216, 461
                         NOTIFYWAITstatement, 144,<b>214</b>, 216, 461, 550, 555
                        <i>notify-variable</i> (R1167), 144, <b>214</b>, 214, 461, 552
                        <i>notify-wait-stmt</i> (R1166), 40, <b>214</b>
                         NOTIFY= specifier, <b>144</b>, 215, 216, 461, 550
                         NOTIFY_TYPE, 74, 113, 146, 147, 214, <b>461</b>
                         NULL, 93, 103, 169, 172, 330, 350, <b>426</b>, 541, 542
                        <i>null-init</i> (R806), 81, 82, <b>103</b>, 103, 104, 122, 123, 318
                         NULLIFY statement, <b>149</b>
                        <i>nullify-stmt</i> (R942), 40, <b>149</b>, 553
                         NUM_IMAGES, 172, <b>427</b>, 455
                         NUMBER= specifier, 264, <b>267</b>
                         numeric conversion, 176
                         numeric editing, 280
                         numeric intrinsic operation, 161
                         numeric sequence type, <b>21</b>, <b>74,</b> <b>75</b>, 132-134, 545, 548
                         numeric storage unit, <b>23</b>, 134, 461, 544, 548, 550
                         numeric type, <b>26</b>, 65-68, 160-162, 165, 168, 176, 389,
                             415, 416, 431, 447
<i>numeric-expr</i> (R1028), <b>169</b>, 169
NUMERIC_STORAGE_SIZE, <b>461</b>
<b>O</b>
O edit descriptor, 286
object, <b>10</b>, 46-48
object designator, <b>11</b>, 46, 47, 118, 122, 136, 170, 297
<i>object-name</i> (R804), <b>103</b>, 103, 120, 121, 124-126, 135,
    143, 200, 538
obsolescent feature, 31, 32, 36, 37, 562-564
<i>octal-constant</i> (R774), <b>99</b>, 99
ONLY, <b>128</b>, 129, 130, <b>304</b>, 304, 305, 540, 596, 597
<i>only</i> (R1412), <b>304</b>, 304, 305
<i>only-use-name</i> (R1413), <b>304</b>, 304, 305
OPEN statement, 36, 228, 229, 233-235, <b>236</b>, 236, 240,
    245, 252, 253, 257, 267, 270, 286, 299, 549,
    552, 556, 557, 588, 590-592
<i>open-stmt</i> (R1204), 40, <b>236</b>, 345
OPENED= specifier, 264, <b>267</b>
operand, <b>18</b>
operation, 60
  defined, <b>11</b>, 85, 157, <b>166,</b> <b>167</b>, 167-170, 196, 308,
    314, 320, 334, 345
  elemental, <b>12</b>, 159, 170, 184
  intrinsic, 159-166
   logical, 164
   numeric , 161
   relational, 165
OPERATOR, 60, 85, 166, 167, 304, <b>311</b>, 314, 599
operator, <b>18</b>, 54
  character, 155
  defined binary, 156
  defined unary, 154
  elemental, <b>12</b>, 159, 465
  logical, 156
  numeric, 154
  relational, 155
operator precedence, 157
OPTIONAL attribute, 63, <b>115</b>, 115, 118, 124, 170, 190,
    196, 310
optional dummy argument, 331
OPTIONAL statement, <b>124</b>, 191
<i>optional-stmt</i> (R853), 40, <b>124</b>
<i>or-op</i> (R1021), 54, <b>156</b>, 156
<i>or-operand</i> (R1016), <b>156</b>, 156
<i>other-specification-stmt</i> (R513), <b>39</b>, 39
OUT, <b>113</b>
                         OUT_OF_RANGE, <b>428</b>
                         output statement, <b>242</b>, 287
                        <i>output-item</i> (R1217), 242, 243, <b>247</b>, 247, 260, 264
                         OUTPUT_UNIT, 234, 235, 239, 256, <b>461</b>
                         override, 82, 90, 102, 103, 126, 253, 280, 545
          <b>P</b>
                         P edit descriptor, 291
                         PACK, <b>428</b>
                         pad mode, 239
                         PAD= specifier, 35, 36, 237, <b>239</b>, 242-244, <b>246</b>, 257,
                             264, <b>268</b>
                         padding, <b>351</b>, 351, 407, 435
                         PARAMETER attribute, 47, 95, 104, <b>115</b>, 115, 116,
                             124, 136
                         PARAMETER statement, 43, <b>124</b>, 126, 306
                        <i>parameter-stmt</i> (R854), 39, <b>124</b>, 538
                         parent component, <b>8</b>, 83, 87, 89, 92, 546, 577
                         parent data transfer statement, 246, <b>255</b>, 253-257, 273,
                             296
                         parent team, <b>25</b>, 49, 144, 193, 220, 221, 395, 400, 405,
                             406, 427, 446, 450, 451, 461
                         parent type, <b>26</b>, 73, 74, 77, 83, 87, 89, 90, 316, 577
                        <i>parent-identifier</i> (R1418), <b>306</b>, 306
                        <i>parent-string</i> (R909), 108, <b>136</b>, 136
                        <i>parent-submodule-name</i>, 306
                        <i>parent-type-name</i>, 73
                         PARENT_TEAM, 400, <b>461</b>
                         parentheses, 168
                         PARITY, <b>429</b>
                        <i>part-name</i>, 136-138, 143
                        <i>part-ref</i> (R912), 108, 122, 131, <b>136</b>, 136-139, 141, 143,
                             384, 405, 410, 450, 455
                         partially associated, <b>545</b>
                         PASS attribute, 79, <b>81</b>, 85, 320
                         passed-object dummy argument, <b>18</b>, 81, 85, 86, 90, 317,
                             322, 323, 613
                         PAUSE statement, <b>561</b>
                         pending affector, 105, 245, 250, 532
                         PENDING= specifier, 264, 265, <b>268</b>
                         POINTER, <b>78,</b> <b>79</b>, 80
                         pointer,<b>18</b>, 49, 74, 80, 143, 149-151, 172, 309, 310, 326,
                             345, 447, 501, 526, 541, 609
                           procedure, 505
                         pointer assignment, <b>18</b>, 111, 113, 149, 177, <b>178,</b> <b>179</b>,
                             331, 542
pointer assignment statement, 61, 80, 93, 169, <b>178</b>, 180,
    186, 359
pointer association, <b>5</b>, 47, 50, 88, 91, 93, 108, 114, 116,
    118, 119, 137, 150, 152, 178, 180, 181, 200,
    201, 216, 219, 250, 309, 324, 325, 328, 330,
    331, 339, 341, 355, 367, 422, 426, 503, 505,
    506, 517, 528, 532, 541-610
pointer association context, 113, 116, 345, <b>553</b>
pointer association status, <b>541</b>
POINTER attribute, 61-63, 72, 78, 103, 111, 112, <b>116</b>,
    116-118, 123, 125, 137, 140, 149, 179, 190, 200,
    207, 208, 308-310, 312, 315, 316, 318, 321, 323,
    327, 330-333, 338, 345, 347, 508, 512, 528, 540,
    543, 546, 547, 568, 612, 616
POINTER statement, <b>124</b>, 306
<i>pointer-assignment-stmt</i> (R1034), 40, <b>178</b>, 179, 185,
    186, 345, 553
<i>pointer-decl</i> (R857), <b>124</b>, 124
<i>pointer-object</i> (R943), <b>149</b>, 149, 553
<i>pointer-stmt</i> (R856), 40, <b>124</b>, 538
polymorphic, <b>18</b>, 33, 34, 64, 81, 93, 111, 113, 137, 149,
    168, 174, 175, 180, 189, 190, 196, 199, 208, 210,
    211, 248, 253, 309, 310, 320, 323-327, 344, 345,
    380, 394, 418, 422, 437, 447, 541, 546
POPCNT, <b>429</b>
POPPAR, <b>430</b>
POS= specifier, 230-232, 242, 243, <b>246</b>, 246, 264, <b>268</b>,
    557
position edit descriptor, 289
<i>position-edit-desc</i> (R1315), <b>276</b>, 276
<i>position-spec</i> (R1227), <b>261</b>, 261
POSITION= specifier, 236, 237, <b>239</b>, 264, <b>268</b>, 590
positional arguments, 349
potential subobject component, <b>8</b>, 33, 72-74, 78, 106,
    107, 118, 119, 146, 147, 151, 152, 174, 326,
    332, 334, 345, 380, 458, 460, 461
<i>power-op</i> (R1008), 54, <b>154</b>, 154, 155
pre-existing, <b>546</b>
precedence of operators, 157
PRECISION, 66, <b>430</b>, 487
preconnected,<b>18</b>, 229, 234-236, 239, 245, 251, 458, 459,
    461
preconnection, <b>236</b>
<i>prefix</i> (R1529), <b>337</b>, 337-340
<i>prefix-spec</i> (R1530), <b>337</b>, 337, 338, 344, 346, 347
PRESENT, 63, 115, 170-172, 331, 350, <b>430</b>, 611
                         present, <b>331</b>
                         PREVIOUS, <b>430</b>
                         primary, 153
                        <i>primary</i> (R1001), <b>153</b>, 153-155, 343
                         PRINT statement, 229, 234, 238, <b>242</b>, 251, 256, 257,
                             260
                        <i>print-stmt</i> (R1212), 41, <b>242</b>, 345
                         PRIVATE attribute, 75, 90, <b>105</b>, 105, 119, 345, 596
                         PRIVATE statement, <b>84</b>, 86, <b>119</b>, 305
                        <i>private-components-stmt</i> (R745), 74, <b>84</b>, 84
                        <i>private-or-sequence</i> (R729), 73, <b>74</b>, 74
                        <i>proc-attr-spec</i> (R1514), <b>317</b>, 317, 318
                        <i>proc-component-attr-spec</i> (R742), <b>79</b>, 79, 80
                        <i>proc-component-def-stmt</i> (R741), 78, <b>79</b>, 79
                        <i>proc-component-ref</i> (R1040), <b>179</b>, 179, 180, 320, 332
                        <i>proc-decl</i> (R1515), 79, 82, 317, <b>318</b>, 318
                        <i>proc-interface</i> (R1513), 79, <b>317</b>, 317, 318
                        <i>proc-language-binding-spec</i> (R1531), 317, 318, <b>338</b>,
                             338-340, 343, 513
                        <i>proc-pointer-init</i> (R1517), <b>318</b>, 318
                        <i>proc-pointer-name</i> (R861), <b>125</b>, 125, 149, 179
                        <i>proc-pointer-object</i> (R1039), 178, <b>179</b>, 180, 186, 553
                        <i>proc-target</i> (R1041), 92, 93, 178, <b>180</b>, 180, 186, 331
                         PROCEDURE, <b>79</b>, <b>85</b>, <b>317</b>, <b>341</b>
                         procedure, <b>19</b>, 51, 115, 311
                           characteristics of, 309
                           dummy, <b>19</b>, 113, 126, 130, 171, 180, 308, 309, 311,
                             312, 317, 318, 321, 329, 330, 336-338, 344-347,
                             531, 534, 539
                           elemental,<b>12</b>, 48, 170, 180, 318, 321, 331, 335, 338,
                             346, <b>347</b>, 347, 349, 350
                           external, <b>19</b>, 31, 41, 85, 113, 126, 180, 220, 308,
                             309, 311-313, 317, 318, 321, 330, 336, 337, 533,
                             534, 538, 539, 568, 598, 603, 607
                           internal, <b>19</b>, 41, 180, 308-311, 321, 322, 330, 336,
                             338, 341, 367, 531, 534, 535, 539, 568
                           intrinsic, 349-456
                           module, <b>19</b>, 85, 130, 180, 308-312, 318, 321, 330,
                             336, 338, 341, 342, 344, 346, 347, 456, 534, 535
                           non-Fortran, 343
                           pure, <b>19</b>, 33, 34, 90, 181, 185, 196, 309, 310, 312,
                             318, 329, 330, 337, 338, 342, <b>344</b>, <b>346</b>, 346,
                             349, 435
                           simple, <b>19</b>, 90, 181, 309, 310, 312, 318, 330, 338,
                             344, <b>346</b>, 349, 354, 422, 423, 445, 451, 456,
                             465, 471, 472, 502
  type-bound, <b>19</b>, 72-74, 81, <b>86</b>, 86, 87, 89, 90, 177,
    259, 304, 314, 320, 323, 325, 337, 344, 346,
    347, 534, 535
proceduredeclarationstatement,43,113,310,312,<b>317</b>,
    343, 359, 535, 568
procedure designator, <b>11</b>, 48
procedure interface, 310
procedure pointer, <b>18</b>, 41, 43, 61, 79-82, 92, 93, 103,
    113, 114, 116, 117, 125, 133, 153, 180, 181,
    189, 247, 308, 309, 312, 317, 321, 323, 330,
    331, 336, 340, 341, 344, 346, 347, 367, 426,
    505, 507, 531, 535, 538, 542, 568, 609
procedure reference, <b>20</b>, 34, 48, 115, 139, 256, 308, 314,
    320, 322
  generic, 316
  resolving, 335
  type-bound, 337
PROCEDURE statement, 311, <b>313</b>, 568
<i>procedure-component-name</i>, 179, 180
<i>procedure-declaration-stmt</i> (R1512), 39, <b>317</b>, 318
<i>procedure-designator</i> (R1522), <b>320</b>, 320, 332, 337
<i>procedure-entity-name</i>, 318, 319
<i>procedure-name</i>, 85, 86, 180, 181, 311, 312, 318, 320,
    321, 341
<i>procedure-stmt</i> (R1506), <b>311</b>, 311, 312, 568
processor, <b>19</b>, 31, 32, 51
processor dependent, <b>19</b>, 32, 51, 554-560
<i>procptr-entity-name</i>, 124, 125
PRODUCT, <b>431</b>
program, <b>20</b>, 31, 32, 41
<i>program</i> (R501), <b>38</b>
PROGRAM statement, <b>302</b>
program unit, <b>20</b>, 31, 38, 41-43, 45, 50, 52, 53, 55-58,
    76, 117, 126, 234, 240, 302, 306, 400, 529, 533,
    541, 563, 569, 595-597, 599, 603-605, 607, 622
<i>program-name</i>, 302
<i>program-stmt</i> (R1402), 38, <b>302</b>, 302
<i>program-unit</i> (R502), 30, <b>38</b>, 38, 41
PROTECTED attribute, 33, <b>116</b>, 116, 117, 125, 132,
    200, 304, 568
PROTECTED statement, <b>125</b>
<i>protected-stmt</i> (R858), 40, <b>125</b>
PUBLIC attribute, 90, <b>105</b>, 105, 119, 596
PUBLIC statement, <b>119</b>, 305
PURE, <b>337</b>, 338, 342, 344
pure procedure, <b>19</b>, 33, 34, 90, 181, 185, 196, 309, 310,
                             312, 318, 329, 330, 337, 338, 342, <b>344</b>, <b>346</b>,
                             346, 349, 435, 568
          <b>Q</b>
                         QUIET= specifier, <b>213</b>
          <b>R</b>
                        <i>r</i> (R1306), <b>275</b>, 275-278
                         RADIX, 66, <b>431</b>, 464, 487
                         RANDOM_INIT, <b>432</b>, 433, 558
                         RANDOM_NUMBER, <b>432</b>, 433
                         RANDOM_SEED, 350, 432, <b>433</b>
                         RANGE, 65, 66, <b>434</b>, 487
                         RANK, 63, 109, 111, <b>117</b>, 117, <b>434</b>
                         rank, <b>20</b>, 46-49, 79, 81, 87, 92, 93, 102, 106, 108, 109,
                             111, 112, 124, 134, 137-141, 143, 146, 148,
                             166, 167, 169, 174-176, 178, 179, 181, 182, 189,
                             218, 309, 314-316, 323, 326, 328, 331, 336, 347,
                             359, 364, 365, 384-387, 390, 391, 395, 396, 402,
                             403, 407, 408, 410, 415, 417, 418, 420-422, 425,
                             426, 429, 431, 433, 435, 441, 444, 446-448, 451,
                             453-455, 499, 504, 513, 537, 544, 612-614
                         RANK ( * ), 111, <b>207</b>
                         RANK DEFAULT, 112, <b>207</b>
                        <i>rank-clause</i> (R829), 102, 111, <b>117</b>, 117
                        <i>rbracket</i> (R780), 78, <b>99</b>, 99, 102, 103, 120, 121, 125,
                             144, 145
                         RC edit descriptor, 292
                         RD edit descriptor, 292
                         READ (FORMATTED), 254, <b>311</b>
                         READ (UNFORMATTED), 254, <b>311</b>
                         READ statement, 36, 47, 230, 234, 238, <b>242</b>, 251, 256,
                             257, 260, 263, 271, 551, 588-590, 592, 594
                        <i>read-stmt</i> (R1210), 41, <b>242</b>, 243, 346, 552
                         READ= specifier, 265, <b>269</b>
                         READWRITE= specifier, 265, <b>269</b>
                         REAL, 138, 176, 351, <b>434</b>, 465
                         real and complex editing, 281
                         real model, 352
                         real part, <b>68</b>
                         real type, 66-67, 68
                        <i>real-literal-constant</i> (R714), 54, <b>67</b>, 67
                        <i>real-part</i> (R719), <b>68</b>, 68
                         REAL128, <b>462</b>
                         REAL16, <b>462</b>
                         REAL32, <b>462</b>
                         REAL64, <b>462</b>
REAL_KINDS, <b>461</b>
REC= specifier, 231, 242, 243, <b>246</b>
RECL= specifier, 237, <b>239</b>, 252, 253, 265, <b>269</b>, 270,
    550, 557
record, <b>20</b>, 227
record file, <b>20</b>, <b>227</b>, 229, 231-233
record number, <b>229</b>
RECURSIVE, 70, <b>337</b>, 338, 342
recursive input/output statement, <b>273</b>
REDUCE, <b>196</b>, 200, 201, <b>435</b>
<i>reduce-operation</i> (R1131), <b>196</b>, 196, 200, 201
reference, <b>20</b>, 48
  procedure, 34
<i>rel-op</i> (R1014), 54, <b>155</b>, 155, 165, 466
relational intrinsic operation, 165
<i>rename</i> (R1411), <b>304</b>, 304, 305, 534
<i>rep-char</i>, <b>70</b>, 70, 277, 294, 299
REPEAT, <b>436</b>
repeat specification, <b>275</b>
representation method, 65, 66, 69, 72
RESHAPE, 101, <b>436</b>
resolving procedure reference, 335
resolving procedure references
  defined input/output, 259
restricted expression, <b>170</b>
RESULT, <b>339</b>, 339, 342
<i>result-name</i>, 339, 342, 538
RETURN statement, 44, 88, 116, 117, 134, 150, 151,
    192, 194, 199, <b>343</b>, 503, 551
<i>return-stmt</i> (R1545), 41, 43, <b>343</b>, 343
REWIND statement, 228, 229, 231, 257, 260, <b>262</b>, 262,
    589
<i>rewind-stmt</i> (R1226), 41, <b>261</b>, 345
RN edit descriptor, 292
round edit descriptor, 292
<i>round-edit-desc</i> (R1320), 276, <b>277</b>
ROUND= specifier, 237, <b>240</b>, 242-244, <b>247</b>, 257, 265,
   <b>269</b>, 292
rounding mode
  IEEE, 464, 465, <b>468</b>, 469, 470, 475, 486, 489, 495
  input/output, 234, 240, 247, 269, <b>286</b>, 291, 292,
    495
RP edit descriptor, 292
RRSPACING, <b>437</b>
RU edit descriptor, 292
RZ edit descriptor, 292
          <b>S</b>
                         S edit descriptor, 291
                         SAME_TYPE_AS, 172, <b>437</b>
                         SAVE attribute, 36, 49, 81, 82, 88, 104, 106, 107, <b>117</b>,
                             117, 121, 125, 132, 134, 151, 200, 318, 345, 542
                         SAVE statement, <b>125</b>, 191, 306, 535
                        <i>save-stmt</i> (R859), 40, <b>125</b>, 538
                         saved, <b>21</b>, 541, 547
                        <i>saved-entity</i> (R860), <b>125</b>, 125, 191
                         scalar, <b>21</b>, 347
                        <i>scalar-expr</i>, 99
                        <i>scalar-xyz</i> (R403), <b>30</b>, 30
                         SCALE, <b>438</b>
                         scale factor, <b>276</b>, 291
                         SCAN, <b>438</b>
                         scoping unit, <b>21</b>, 41, 43, 44, 47, 50, 70, 75, 76, 84, 88,
                             92, 104-106, 113, 115, 117, 119, 125, 126, 128-
                             131, 133, 134, 147, 150, 171, 180, 191, 192, 196,
                             197, 200, 201, 245, 248, 249, 303-305, 310, 312,
                             316, 335-339, 342-344, 464, 466, 529, 534-540,
                             543, 545, 546, 550, 596, 607, 613
                         section subscript, 142
                        <i>section-subscript</i> (R921), 136, 137, <b>139</b>, 139-141, 143
                         segment,<b>21</b>, 147, 148, 151, 193, 194, 215,<b>216</b>, 216-223,
                             352, 353, 393, 423, 458, 459, 461
                         SELECT CASE construct, 44, <b>204</b>, 563, 578
                         SELECT CASE statement, 56, <b>204</b>
                         SELECT RANK construct, 44, 49, 111, 112, 190, <b>207</b>,
                             331, 536, 537, 552
                         SELECT RANK statement, 49, 113, <b>207</b>, 540
                         SELECTTYPEconstruct, 44, 49, 61, 63, 189, 190,<b>209</b>,
                             331, 536, 537, 540, 552
                         SELECT TYPE statement, 49, 56, <b>209</b>, 540
                        <i>select-case-stmt</i> (R1143), 204, <b>205</b>, 205, 212
                        <i>select-construct-name</i>, 207-210
                        <i>select-rank-case-stmt</i> (R1152), <b>207</b>, 207, 208
                        <i>select-rank-construct</i> (R1150), 40, <b>207</b>, 207, 208
                        <i>select-rank-stmt</i> (R1151), <b>207</b>, 207, 208, 212
                        <i>select-type-construct</i> (R1154), 40, <b>209</b>, 210
                        <i>select-type-stmt</i> (R1155), <b>209</b>, 209, 210, 212
                         SELECTED_CHAR_KIND, 69, <b>439</b>
                         SELECTED_INT_KIND, 65, 77, <b>439</b>
                         SELECTED_LOGICAL_KIND, <b>440</b>
                         SELECTED_REAL_KIND, 66, 350, <b>440</b>, 569
                         selector, 189
                        <i>selector</i> (R1105),<b>189</b>, 189, 190, 192, 193, 207, 209-211,
    331, 541, 552
separate module procedure, <b>341</b>
separate module subprogram statement, <b>341</b>
<i>separate-module-subprogram</i> (R1541), 39, 303, <b>341</b>, 341
sequence, <b>21</b>
sequence association, 330
SEQUENCE attribute, 73,<b>74</b>, 74-76, 89, 133, 179, 180,
    210, 511
SEQUENCE statement, <b>74</b>
sequence structure, <b>21</b>
sequence type, <b>21</b>, 34, 73, <b>74</b>, 74, 131, 132, 512, 544
  character, <b>21</b>, <b>75</b>, 132-134, 545, 548
  numeric, <b>21</b>, <b>74,</b> <b>75</b>, 132-134, 545, 548
<i>sequence-stmt</i> (R731), <b>74</b>, 74
sequential access, <b>229</b>
sequential access data transfer statement, <b>246</b>
SEQUENTIAL= specifier, 265, <b>269</b>
SET_EXPONENT, <b>441</b>
SHAPE, 63, <b>441</b>
shape, <b>21</b>, 48, 216
SHARED, <b>196</b>, 200, 201
SHIFTA, <b>441</b>
SHIFTL, <b>442</b>
SHIFTR, <b>442</b>
sibling teams, <b>25</b>, 221, 405, 427, 450
SIGN, 36, 67, <b>442</b>
<i>sign</i> (R712), 65, <b>66</b>, 66, 67, 281
sign mode, 240, 280, <b>291</b>
<i>sign-edit-desc</i> (R1321), 276, <b>277</b>
SIGN= specifier, 237, <b>240</b>, 243, 244, <b>247</b>, 265, <b>269</b>,
    291
<i>signed-digit-string</i> (R710), <b>66</b>, 67, 280-282
<i>signed-int-literal-constant</i> (R707), <b>65</b>, 65, 68, 122, 276
<i>signed-real-literal-constant</i> (R713), <b>67</b>, 68, 122
<i>significand</i> (R715), <b>67</b>, 67
SIMPLE, <b>337</b>, 338, 344
simple procedure, <b>19</b>, 90, 181, 309, 310, 312, 318, 330,
    338, 344, <b>346</b>, 349, 354, 422, 423, 445, 451,
    456, 465, 471, 472, 502
simply contiguous,<b>22</b>,<b>143</b>, 143, 181, 323, 325-330, 506
SIN, <b>443</b>
SIND, <b>443</b>
SINH, <b>443</b>
SINPI, <b>443</b>
SIZE, 63, <b>444</b>
size, <b>22</b>, 48
                         size of a common block, <b>134</b>
                         SIZE= specifier, 243, <b>247</b>, 265, <b>269</b>, 271, 272, 548, 551,
                             589
                        <i>source-expr</i> (R932), <b>145</b>, 145-149, 345, 541-543
                         SOURCE= specifier, <b>145</b>, 147, 149, 345, 458, 461, 549-
                             551, 568
                         SP edit descriptor, 291
                         SPACING, <b>444</b>
                         special character, 52
                         specific interface, <b>15</b>, 259, <b>312</b>, 312, 313, 318, 335, 568
                         specific interface block, <b>16</b>, 312
                         specific name, <b>22</b>
                        <i>specific-procedure</i> (R1507), <b>311</b>, 311, 313
                         specification, 102-134
                         specification expression, <b>22</b>, 44, 77, 88, 105, 139, <b>170,</b>
                         <b>171</b>, 171, 172, 191, 342, 466, 563, 568
                         specification function, <b>171</b>
                         specification inquiry, <b>171</b>
                        <i>specification-construct</i> (R508), <b>39</b>, 39
                        <i>specification-expr</i> (R1029), 104, 108, 110, <b>170</b>, 170, 347
                        <i>specification-part</i> (R504), 38, <b>39</b>, 39, 44, 85, 105, 106,
                             119, 171, 173, 302, 303, 306, 307, 311, 339-341,
                             344-347
                         SPLIT, <b>445</b>
                         SPREAD, <b>446</b>
                         SQRT, 35, <b>446</b>, 470, 496
                         SS edit descriptor, 291
                         standard intrinsic, <b>16</b>, 31, 457, 566
                         standard-conforming program, <b>31</b>
                        <i>stat-variable</i> (R946), 44, 144-146, 150, <b>151</b>, 151, 152,
                             212, 214, 215, 217, 218, 221-225, 237, 241, 242,
                             261, 263, 264, 271, 272, 409, 549, 552, 555
                         STAT= specifier, <b>144</b>, 144, 145, 148, 150, <b>151</b>, 194,
                             215, 217, <b>224</b>, 462, 549, 552, 555, 567
                         STAT_FAILED_IMAGE, 44, 144, 152, 224, 225, 353,
                             395, 423, <b>462</b>, 463
                         STAT_LOCKED, 225, <b>462</b>, 463
                         STAT_LOCKED_OTHER_IMAGE, 225, <b>462</b>, 463
                         STAT_STOPPED_IMAGE, 152, 224, 225, 353, 423,
                             447, <b>462</b>, 463
                         STAT_UNLOCKED, 225, <b>462</b>, 463
                         STAT_UNLOCKED_FAILED_IMAGE, 225, <b>462</b>,
                             463
                         statement, <b>22</b>, 56
                           accessibility, 119
                           ALLOCATABLE, <b>120</b>
  ALLOCATE, 61, 63, 69, 70, 108, 111, <b>145</b>, 148,
    152, 179, 215, 458, 461, 522, 541, 542, 549-
    551, 555, 568
  arithmetic IF, <b>562</b>
  ASSIGN, <b>561</b>
  assigned GO TO, <b>561</b>
  assignment, 33, 47, 61, 88, <b>173</b>, 186, 215, 216, 461,
    498, 548, 550
  ASSOCIATE, 49, <b>189</b>, 540
  ASYNCHRONOUS, <b>120</b>, 191, 306, 536, 539
  attribute specification, 119-134
  BACKSPACE, 228, 231, 257, 260, <b>262</b>, 262, 589,
    590
  BIND, <b>120</b>, 306, 529, 535
  BLOCK, 104, 108, 110, <b>190</b>, 549
  BLOCK DATA, 56, 302, <b>306</b>
  CALL, 212, 215, 308, <b>320</b>, 334, 335, 343, 423
  CASE, <b>205</b>
  CHANGE TEAM, 43, 49, <b>192</b>, 215, 225, 353, 540
  CLASS DEFAULT, <b>210</b>
  CLASS IS, <b>210</b>, 394
  CLOSE, 228, 229, 233, 235, 236, <b>240</b>, 240, 257,
    260, 589
  COMMON, <b>133</b>, 133-134, 191, 305, 306, 535, 545,
    562
  component definition, 62, <b>78</b>
  computed GO TO, 212, <b>213</b>, 562, 563
  CONTAINS, 42, 43, <b>84</b>, <b>343</b>
  CONTIGUOUS, <b>121</b>
  CONTINUE, <b>213</b>, 561
  CRITICAL, 168, <b>194</b>, 215, 225
  CYCLE, 188, 195, <b>198</b>, 199, 564
  DATA, 32, 34, 36, 43, 99, 104, <b>121</b>, 134, 191, 306,
    427, 536, 539, 547, 562, 563
  data transfer, 36, 55, 227-233, 235, <b>242</b>, 247, 250-
    252, 256, 260, 262, 270-275, 286, 291, 293-298,
    300, 459, 460, 548, 550, 557, 589, 592, 593
  DEALLOCATE, <b>149</b>, 152, 215, 458, 461, 522, 555
  defined assignment, 34, 177, <b>178</b>, 334, 335, 552
  derived type definition, <i>see</i> statement, TYPE
  DIMENSION, <b>123</b>, 306
  DO, <b>195</b>, 548, 562, 564
  DO CONCURRENT, 63, 185, 186, <b>195</b>
  DO WHILE, <b>195</b>
  ELSE, <b>203</b>
  ELSE IF, 56, <b>203</b>
                           ELSEWHERE, 56, <b>183</b>
                           END,<b>13</b>,<b>43</b>, 116, 117, 134, 150, 151, 215, 503, 551
                           END ASSOCIATE, 56, <b>189</b>
                           END BLOCK, 56, 151, <b>191</b>
                           END BLOCK DATA, 56, <b>306</b>
                           END CRITICAL, 56, 168, <b>194</b>, 215
                           END DO, 56, <b>197</b>
                           END ENUM, 56, <b>94</b>
                           END ENUMERATION TYPE, <b>97</b>
                           END FORALL, 56, <b>185</b>
                           END FUNCTION, 56, <b>339</b>
                           END IF, 56, <b>203</b>, 561
                           END INTERFACE, 56, <b>311</b>
                           END MODULE, 56, <b>303</b>
                           END PROCEDURE, 56, <b>341</b>
                           END PROGRAM, 56, <b>302</b>
                           END SELECT, 56, <b>205</b>, <b>210</b>
                           END SUBMODULE, 56, <b>306</b>
                           END SUBROUTINE, 56, <b>340</b>
                           END TEAM, 43, 56, <b>192</b>, 212, 215, 225, 353
                           END TYPE, 56, <b>74</b>
                           END WHERE, 56, <b>183</b>
                           ENDFILE, 56, 228, 229, 231, 238, 257, 260, <b>262</b>,
                             589
                           ENTRY, 43, 166, 167, 178, 303, 308, 312, 337, 339,
                         <b>341</b>, 347, 535, 545, 562, 564
                           ENUM, <b>94</b>
                           ENUMERATION TYPE, <b>96</b>
                           ENUMERATOR, <b>94</b>
                           EQUIVALENCE,<b>131</b>,131-134,191,305,306,545,
                             562, 564
                           ERROR STOP, 44, 45, <b>213</b>, 555
                           EVENT POST, 215, <b>221</b>, 221, 225, 392, 458, 459,
                             549, 552, 556
                           EVENT WAIT, 215, <b>221</b>, 221, 224, 458, 459, 549,
                             552, 556
                           executable, <b>22</b>, 42
                           EXIT, 188, 199, <b>212</b>
                           EXTERNAL, 113, <b>317</b>
                           FAIL IMAGE, <b>214</b>
                           file inquiry, <b>263</b>
                           file positioning, 228, <b>261</b>
                           FINAL, <b>87</b>
                           FLUSH, 229, 260, <b>263</b>, 272
                           FORALL, 63, 159, <b>186</b>, 536, 537, 548
                           FORM TEAM, 25, 43, 192, 215, <b>221</b>, 225, 549,
    552, 556
  FORMAT, 31, 43, 55, 191, 244, <b>274</b>, 274, 303
  formatted input/output, 227, <b>244</b>
  FUNCTION, 63, 64, 126, 166, 167, 170, 302, 337,
   <b>339</b>, 341, 342, 535
  GENERIC, <b>85,</b> <b>86</b>, <b>313</b>, 313, 316, 335
  GO TO, 56, <b>212</b>, 212
  IF, 159, <b>204</b>
  IMPLICIT, 43, <b>126</b>, 131, 306
  IMPLICIT NONE, <b>126</b>
  IMPORT, 43, <b>128</b>, 191, 533, 536, 539
  input, <b>242</b>, 243, 589
  input/output, 227-273, 548
  INQUIRE, 35, 229, 230, 232, 233, 235, 236, 246,
    256, 257, 260, <b>263</b>, 272, 273, 460, 548, 550-
    552, 557, 588
  INTENT, <b>124</b>, 191
  INTERFACE, <b>311</b>, 599
  INTRINSIC, 306, <b>319</b>
  intrinsic assignment, 34, 92, 144, 150, 152, 169,
   <b>174</b>, 178, 180, 200, 225, 233, 264, 273, 299,
    345, 350, 354, 361, 380, 452, 548, 555
  list-directed input/output, <b>244</b>
  LOCK, 215, <b>222</b>, 225, 460, 462, 549, 552
  MODULE, 302, <b>303</b>
  NAMELIST, <b>130</b>, 191, 297, 305
  namelist input/output, <b>244</b>
  nonexecutable, <b>22</b>, 42
  NOTIFY WAIT, 144, <b>214</b>, 216, 461, 550, 555
  NULLIFY, <b>149</b>
  OPEN, 36, 228, 229, 233-235, <b>236</b>, 236, 240, 245,
    252, 253, 257, 267, 270, 286, 299, 549, 552,
    556, 557, 588, 590-592
  OPTIONAL, <b>124</b>, 191
  output, <b>242</b>, 287
  PARAMETER, 43, <b>124</b>, 126, 306
  PAUSE, <b>561</b>
  POINTER, <b>124</b>, 306
  pointer assignment, 61, 80, 93, 169, <b>178</b>, 180, 186,
    359
  PRINT, 229, 234, 238, <b>242</b>, 251, 256, 257, 260
  PRIVATE, <b>84</b>, 86, <b>119</b>, 305
  PROCEDURE, 311, <b>313</b>, 568
  procedure declaration, 43, 113, 310, 312, <b>317</b>, 343,
    359, 535, 568
  PROGRAM, <b>302</b>
                           PROTECTED, <b>125</b>
                           PUBLIC, <b>119</b>, 305
                           READ, 36, 47, 230, 234, 238, <b>242</b>, 251, 256, 257,
                             260, 263, 271, 551, 588-590, 592, 594
                           RETURN, 44, 88, 116, 117, 134, 150, 151, 192, 194,
                             199, <b>343</b>, 503, 551
                           REWIND, 228, 229, 231, 257, 260, <b>262</b>, 262, 589
                           SAVE, <b>125</b>, 191, 306, 535
                           SELECT CASE, 56, <b>204</b>
                           SELECT RANK, 49, 113, <b>207</b>, 540
                           SELECT TYPE, 49, 56, <b>209</b>, 540
                           separate module subprogram, <b>341</b>
                           SEQUENCE, <b>74</b>
                           statement function, 43, 70, 191, 303, 335, 342, <b>343</b>,
                             536, 537, 563
                           STOP, 44, 45, <b>213</b>, 215, 346, 555
                           SUBMODULE, 302, <b>306</b>
                           SUBROUTINE, 178, 302, 337, <b>340</b>, 342
                           SYNC ALL, 193, 215, <b>217</b>, 218, 219, 225
                           SYNC IMAGES, 215, <b>218</b>, 225, 226
                           SYNC MEMORY, 215, <b>219</b>, 224, 225, 618
                           SYNC TEAM, 193, 215, <b>220</b>, 225
                           TARGET, <b>125</b>, 306
                           TYPE, <b>73</b>, 76, 77, 105, 538
                           type declaration, 43, 62-64, 82, <b>102</b>, 102-104, 113,
                             126, 131, 134, 171, 303, 306, 307, 339, 342,
                             344, 547
                           type guard, 70, <b>210</b>
                           TYPE IS, <b>210</b>, 437
                           type parameter definition, <b>76</b>
                           type-bound procedure, <b>85,</b> <b>86</b>
                           unformatted input/output, 228, <b>244</b>
                           UNLOCK, 215, <b>222</b>, 225, 460, 462, 549, 552
                           USE, 43, 76, 119,<b>303</b>, 306, 335, 336, 534, 536, 538,
                             540, 595-597, 602
                           VALUE, <b>125</b>, 191
                           VOLATILE, <b>126</b>, 191, 306, 536, 539
                           WAIT, 235, 246, <b>260</b>, 260, 593
                           WHERE, 159, <b>182</b>
                           WRITE, 33-35, 229, 234, 238, <b>242</b>, 251, 256, 257,
                             260, 273, 548, 588, 589, 591, 592
                         statement entity, <b>22</b>, 200, 533, 534, 536
                         statement function, 343-344, 563
                         statement function statement, 43, 70, 191, 303, 335,
                             342, <b>343</b>, 536, 537, 563
                         statement keyword, <b>17</b>, 50
statement label, <b>22</b>, <b>55</b>, 55-58, 321, 533
statement order, 42
STATUS= specifier, 236-239, <b>240,</b> <b>241</b>, 241, 556, 557,
    591
<i>stmt-function-stmt</i> (R1547), 39, 303, 306, 312, <b>343</b>, 538
STOP statement, 44, 45, <b>213</b>, 215, 346, 555
<i>stop-code</i> (R1164), <b>213</b>, 213, 214
<i>stop-stmt</i> (R1162), 41, 88, <b>213</b>
stopped image, <b>14</b>, 44, 147, 151, 152, 353, 423
STOPPED_IMAGES, <b>446</b>
storage association, <b>5</b>, 50, 131-134, 342, 345, 447, 543-
    546
storage sequence, <b>23</b>, 73, 74, 132-134, 307, 367, 503-
    505, 523, <b>544</b>, 544, 545
storage unit, <b>23</b>, 131-134, 245, 250, 257, 260, 307, 331,
    367, 544-546
  character, <b>23</b>, 112, 132, 134, 457, 544, 548, 550
  file, <b>13</b>, 227, 230-233, 240, 245, 246, 252, 262, 268-
    270, 459, 544
  numeric, <b>23</b>, 134, 461, 544, 548, 550
  unspecified, <b>23</b>, 544, 548, 550
STORAGE_SIZE, 99, <b>447</b>
stream access, <b>230</b>
stream access data transfer statement, <b>246</b>
stream file, <b>23</b>, <b>227</b>, 230, 232, 270, 271
STREAM= specifier, 265, <b>270</b>
<i>stride</i> (R924), <b>140</b>, 140, 141, 143, 250
structure, <b>23</b>, 46, 73
structure component, <b>23</b>, 122, 136-138, 511, 576
structure constructor, <b>23</b>, 46, 50, 60, 83, 91-93, 122,
    123, 169, 170, 172, 427, 460, 535, 572
<i>structure-component</i> (R913), 121, 122, 135, 136, <b>137</b>,
    143, 145, 149
<i>structure-constructor</i> (R756), <b>91</b>, 92, 122, 153, 345
subcomponent, <b>8</b>, 82, 92, 179, 541-543, 547, 549-551
submodule, <b>23</b>, 41, 42, 47, 129, <b>306</b>, 538
<i>submodule</i> (R1416), 38, <b>306</b>
submodule identifier, <b>306</b>
SUBMODULE statement, 302, <b>306</b>
<i>submodule-name</i>, 306
<i>submodule-stmt</i> (R1417), 38, <b>306</b>, 306
subobject, <b>23</b>, 46-48, 113, <b>137</b>, 325, 541, 542
subprogram, <b>24</b>, 41-44, 47, 126
  elemental, <b>13</b>, 337, 338, 347
  external, <b>24</b>, 41, 308
  internal, <b>24</b>, 41, 43, 129, 308, 538
                           module, <b>24</b>, 41, 43, 129, 538
                         subroutine, <b>24</b>
                           atomic, <b>24</b>, 44, 216, 217, 349, 352, 354, 370-374,
                             392, 457, 462, 552
                           collective, <b>24</b>, 349, 353, 354, 380-382, 395, 447,
                             462, 552
                         subroutine reference, 334
                         SUBROUTINE statement, 178, 302, 337, <b>340</b>, 342
                        <i>subroutine-name</i>, 312, 340, 535
                        <i>subroutine-stmt</i> (R1538), 38, 311, 312, 338, <b>340</b>, 340,
                             535, 538
                        <i>subroutine-subprogram</i> (R1537), 24, 38, 39, 303, <b>340</b>,
                             341
                         subroutines
                           intrinsic, 349
                         subscript, 139
                           section, 142
                        <i>subscript</i> (R919), 122, 137, <b>139</b>, 139-141, 143, 250
                         subscript triplet, 142
                        <i>subscript-triplet</i> (R922), 139, <b>140</b>, 140, 143
                         substring, <b>136</b>
                        <i>substring</i> (R908), 131, 132, 135, <b>136</b>
                         substring ending point., <b>136</b>
                         substring starting point, <b>136</b>
                        <i>substring-range</i> (R910), 108, <b>136</b>, 136, 138-140, 143,
                             250
                        <i>suffix</i> (R1535), <b>339</b>, 339, 341
                         SUM, <b>447</b>
                         SYNC ALL statement, 193, 215, <b>217</b>, 218, 219, 225
                         SYNC IMAGES statement, 215, <b>218</b>, 225, 226
                         SYNC MEMORY statement, 215, <b>219</b>, 224, 225, 618
                         SYNC TEAM statement, 193, 215, <b>220</b>, 225
                        <i>sync-all-stmt</i> (R1168), 41, <b>217</b>
                        <i>sync-images-stmt</i> (R1170), 41, <b>218</b>
                        <i>sync-memory-stmt</i> (R1172), 41, <b>219</b>
                        <i>sync-stat</i> (R1169), 192, 194, <b>217</b>, 217-225
                        <i>sync-team-stmt</i> (R1173), 41, <b>220</b>
                         synchronous input/output, 238, 245, 247, 249
                         SYSTEM_CLOCK, 32-35, <b>448</b>
          <b>T</b>
                         T edit descriptor, 290
                         TAN, <b>449</b>
                         TAND, <b>449</b>
                         TANH, <b>449</b>
                         TANPI, <b>450</b>
target, <b>24</b>, 47, 49, 64, 80-83, 88, 93, 104, 107, 108, 111,
    113, 114, 116, 117, 123, 135, 137, 145, 148, 149,
    151, 169, 174, 175, 178, 179, 181, 186, 247, 248,
    252, 253, 318, 321, 324, 326, 328, 330, 367, 503,
    505, 508, 540-543, 546, 549, 551, 553
TARGET attribute, 5, 33, 81, 116, <b>118</b>, 118, 125, 132,
    134, 149, 150, 179, 190, 200, 208, 310, 316,
    325, 326, 328, 332, 333, 382, 422, 435, 503,
    506, 508, 528, 529, 541-543, 551, 568, 610, 611
TARGET statement, <b>125</b>, 306
<i>target-decl</i> (R863), <b>125</b>, 125
<i>target-stmt</i> (R862), 40, <b>125</b>, 538
team, <b>24</b>, 43, 48, 49, 144, 151, 193, 217, 218, 220, 222,
    225, 349, 353, 405, 406, 427, 447, 451
  current, 353
team number, <b>25</b>, 144, 222, 405
team variable, <b>28</b>, 192, 462, 549, 552
<i>team-construct-name</i>, 192
<i>team-number</i> (R1180), 221, <b>222</b>, 222
<i>team-value</i> (R1115), 144, <b>192</b>, 192, 193, 220
<i>team-variable</i> (R1181), 221, <b>222</b>, 222, 224, 552
TEAM= specifier, <b>144</b>, 144
TEAM_NUMBER, 172, <b>450</b>
TEAM_NUMBER= specifier, <b>144</b>, 144
TEAM_TYPE, 78, 106, 137, 145-147, 177, 192, 222,
    395, 400, 405, 406, 427, 446, 450, 451, <b>462</b>,
    551
THEN, <b>203</b>
THIS_IMAGE, 172, <b>450</b>
TINY, 444, <b>451</b>
TKR compatible, <b>316</b>
TL edit descriptor, 290
TOKENIZE, <b>451</b>
totally associated, <b>545</b>
TR edit descriptor, 290
TRAILZ, <b>452</b>
TRANSFER, 172, <b>453</b>
transfer of control, 188, 212, 271, 272
transformational function, <b>25</b>, 172, 343, <b>349</b>, 349, 350,
    354, 375, 376, 457, 458, 471
TRANSPOSE, <b>453</b>
TRIM, <b>454</b>
truncation, <b>351</b>, 407, 435
TYPE, <b>62</b>
type, <b>25</b>, 45, 60-100
  abstract, <b>25</b>, 62, 86, <b>89</b>, 89, 92, 137, 145
                           character, 69-72
                           complex, 68
                           declared, <b>25</b>, 63, 64, 81, 92, 93, 100, 102, 136, 138,
                             146, 147, 149, 166-168, 174, 177, 178, 180, 189,
                             208, 210, 211, 259, 315, 320, 321, 323, 324, 327,
                             337, 344, 394, 418, 422, 437, 458, 460, 537
                           derived, <b>25</b>, 46, 60, 72-94, 100, 511, 512
                           dynamic, <b>25</b>, 63, 64, 87, 89, 91, 93, 100, 118, 147,
                             149, 151, 166-168, 175, 177, 178, 180, 190, 209,
                             210, 216, 219, 259, 320, 327, 337, 394, 418, 422,
                             437, 447, 537, 541, 546, 577, 626
                           expression, 168
                           extended, <b>25</b>, 77, 83, 87, 89, 90, 546, 569, 574
                           extensible, <b>26</b>, 62, 73, 81, 89, 254, 394, 437, 577,
                             615
                           extension, <b>26</b>, 64, 89, 90, 210, 327, 394, 615
                           integer, 65-66
                           intrinsic, <b>26</b>, 45, 46, 60, 65-72
                           logical, 72
                           numeric, <b>26</b>, 65-68, 160-162, 165, 168, 176, 389,
                             415, 416, 431, 447
                           operation, 169
                           parent, <b>26</b>, 73, 74, 77, 83, 87, 89, 90, 316, 577
                           primary, 169
                           real, 66-67, 68
                         type compatible, <b>26</b>, 64, 81, 145, 146, 174, 179, 316,
                             325, 367, 422
                         type conformance, 174
                         type declaration statement, 43, 62-64, 82, <b>102</b>, 102-
                             104, 113, 126, 131, 134, 171, 303, 306, 307,
                             339, 342, 344, 547
                         type equality, 75
                         type guard statement, 70, <b>210</b>
                         TYPE IS statement, <b>210</b>, 437
                         type parameter, <b>26</b>, 34, 45, 61, 63, 65, 72, 74, 77, 81,
                             92, 100, 102-104, 124, 134, 169, 171, 174, 190,
                             192, 208, 216, 309, 325, 347, 418, 422, 453,
                             503, 511, 535, 537
                         type parameter definition statement, <b>76</b>
                         type parameter inquiry, <b>27</b>, 138, 169, 171
                         type parameter keyword, <b>17</b>, 50, 91
                         type parameter order, <b>27</b>, 77
                         type specifier, 62
                           CHARACTER, 69
                           CLASS, 64
                           COMPLEX, 68
  derived type, 63
  DOUBLE PRECISION, 67
  INTEGER, 65
  LOGICAL, 72
  REAL, 67
  TYPE, 63
TYPE statement, <b>73</b>, 76, 77, 105, 538
<i>type-attr-spec</i> (R728), <b>73</b>, 73, 89
type-bound procedure, <b>19</b>, 72-74, 81, <b>86</b>, 86, 87, 89,
    90, 177, 259, 304, 314, 320, 323, 325, 337, 344,
    346, 347, 534, 535
type-bound procedure statement, <b>85,</b> <b>86</b>
<i>type-bound-generic-stmt</i> (R751), <b>85</b>, 85, 314
<i>type-bound-proc-binding</i> (R748), 84, <b>85</b>
<i>type-bound-proc-decl</i> (R750), <b>85</b>, 85
<i>type-bound-procedure-part</i> (R746), 73, 74, <b>84</b>, 86, 511
<i>type-bound-procedure-stmt</i> (R749), <b>85</b>, 85
<i>type-declaration-stmt</i> (R801), 39, 70, <b>102</b>, 102, 345, 538
<i>type-guard-stmt</i> (R1156), 209, <b>210</b>, 210
<i>type-name</i>, 73, 74, 76, 85, 91
<i>type-param-attr-spec</i> (R734), 76, <b>77</b>, 77
<i>type-param-decl</i> (R733), <b>76</b>, 76, 77
<i>type-param-def-stmt</i> (R732), 73, <b>76</b>, 76
<i>type-param-inquiry</i> (R916), <b>138</b>, 138, 153, 154, 535
<i>type-param-name</i>, 73, 76, 77, 79, 138, 153, 154, 535, 538
<i>type-param-name-list</i>, 77
<i>type-param-spec</i> (R755), 50, <b>91</b>, 91
<i>type-param-value</i> (R701), <b>61</b>, 61, 62, 69, 70, 78, 79, 91,
    103, 145, 147, 338, 564
<i>type-spec</i> (R702), <b>62</b>, 62, 63, 69, 70, 99, 100, 145-148,
    210
TYPEOF, <b>62</b>
<b>U</b>
UBOUND, 63, 208, <b>454</b>
UCOBOUND, <b>455</b>
ultimate argument, <b>27</b>, 147, 151, 181, 324, 329, 330,
    332, 353
ultimate component, <b>8</b>, 33, 34, 72, 73, 108, 111, 113,
    131, 133, 147, 149, 172, 174, 196, 253, 321,
    325, 344, 345, 381, 544
ultimate entity, <b>305</b>
undefined, <b>27</b>, 47, 150, 541, 542, 547, 548
undefinition of variables, 547
underflow mode, <b>468</b>, 469, 471, 476, 490, 497, 559
<i>underscore</i> (R602), <b>52</b>, 52
UNFORMATTED, 254, 255, <b>311</b>
                         unformatted data transfer, 252
                         unformatted input/output statement, 228, <b>244</b>
                         unformatted record, <b>227</b>
                         UNFORMATTED= specifier, 265, <b>270</b>
                         Unicode file, <b>238</b>
                         unit, <b>27</b>, 228-230, <b>233</b>, 233-236, 238-241, 246, 249-
                             251, 255, 256, 260-270, 272, 273, 289, 295, 458,
                             459, 461, 548, 550, 588, 590-593
                         UNIT= specifier, 236, 241, 242, 260, 261, 263, 264
                         unlimited polymorphic, <b>27</b>, <b>63</b>, 63, <b>64</b>, 100, 133, 145-
                             147, 179, 210, 327, 367, 394, 437, 447, 626
                        <i>unlimited-format-item</i> (R1305), 274, <b>275</b>, 275, 278
                         UNLOCK statement, 215, <b>222</b>, 225, 460, 462, 549, 552
                        <i>unlock-stmt</i> (R1185), 41, <b>223</b>
                         unordered segments, <b>216</b>, 216, 217, 352, 359, 392
                         UNPACK, <b>455</b>
                         unsaved, <b>27</b>, 149, 150, 341, 542, 543, 549-551
                         unspecified storage unit, <b>23</b>, 544, 548, 550
                        <i>until-spec</i> (R1178), <b>221</b>, 221
                         UNTIL_COUNT= specifier, <b>221</b>, 393
                        <i>upper-bound</i> (R817), <b>110</b>, 110
                        <i>upper-bound-expr</i> (R938), <b>145</b>, 145, 179
                        <i>upper-bounds-expr</i> (R939), <b>145</b>, 145-148, 178, 179, 181
                        <i>upper-cobound</i> (R813), 107, <b>108</b>, 108
                         use association, <b>5</b>, 18, 33, 42, 50, 64, 70, 89, 105, 106,
                             116, 119, 120, 126, 131-133, 170, 171, 180,
                         <b>303</b>, 302-306, 312, 341, 345, 347, 535-538, 541
                         use path, 305
                         USE statement, 43, 76, 119, <b>303</b>, 306, 335, 336, 534,
                             536, 538, 540, 595-597, 602
                        <i>use-defined-operator</i> (R1415), <b>304</b>, 304, 305
                        <i>use-name</i>, 304, 305, 534
                        <i>use-stmt</i> (R1409), 39, 191, <b>304</b>, 304, 538
          <b>V</b>
                        <i>v</i> (R1312), 256, <b>276</b>, 276, 289
                         VALUE attribute, 63, 81, 87, 112, <b>118</b>, 118, 125, 200,
                             250, 309, 310, 312, 314, 315, 324-328, 339, 344,
                             347, 382, 435, 514, 515, 532, 543, 568, 622, 623
                         value separator, <b>293</b>
                         VALUE statement, <b>125</b>, 191
                        <i>value-stmt</i> (R864), 40, <b>125</b>
                         variable, <b>27</b>, 46-48, 50, 53, 115
                           definition & undefinition, 547
                        <i>variable</i> (R902), 92, 99, 121, 122, <b>135</b>, 135, 143, 173,
                             175, 176, 179, 180, 184, 186, 189, 200, 201, 209,
    210, 214, 221-223, 247, 320, 321, 323, 332, 498,
    552
variable definition, <b>11</b>
<i>variable-name</i> (R903),131,133,<b>135</b>,135,136,145,149,
    179, 196, 538, 552
vectorsubscript,<b>28</b>, 48, 81, 108, 137, 141-143, 189, 210,
    233, 234, 297, 325, 326, 332, 540, 543, 610
<i>vector-subscript</i> (R925), 139, <b>140</b>, 140, 141
VERIFY, <b>456</b>
VOLATILE attribute, 33, 34, <b>118</b>, 118, 119, 126, 179,
    180, 190, 196, 200, 303, 305, 309, 310, 326, 327,
    329, 344, 345, 538, 539, 543, 549, 552, 575
VOLATILE statement, <b>126</b>, 191, 306, 536, 539
<i>volatile-stmt</i> (R865), 40, <b>126</b>
<b>W</b>
<i>w</i> (R1308), 275, <b>276</b>, 276, 280-289, 294, 296, 299
wait operation, 236, 240, 247, 249, 250, <b>260</b>, 260-263,
    268, 271, 272
WAIT statement, 235, 246, <b>260</b>, 260, 593
<i>wait-spec</i> (R1223), <b>260</b>, 260, 261
<i>wait-stmt</i> (R1222), 41, <b>260</b>, 345
WHERE construct, <b>182</b>
WHERE statement, 159, <b>182</b>
                        <i>where-assignment-stmt</i> (R1046), 159, 182, <b>183</b>, 183,
                             184, 186
                        <i>where-body-construct</i> (R1045), 182, <b>183</b>, 183, 184
                        <i>where-construct</i> (R1043), 40, <b>182</b>, 183, 185, 186
                        <i>where-construct-name</i>, 183
                        <i>where-construct-stmt</i> (R1044), 182, <b>183</b>, 183, 186, 212
                        <i>where-stmt</i> (R1042), 41, <b>182</b>, 183, 185, 186
                         WHILE, <b>195</b>, 197, 198
                         whole array, <b>28</b>, <b>139</b>, 139, 140, 410, 454
                         WRITE (FORMATTED), 254, <b>311</b>
                         WRITE (UNFORMATTED), 254, 255, <b>311</b>
                         WRITE statement, 33-35, 229, 234, 238, <b>242</b>, 251, 256,
                             257, 260, 273, 548, 588, 589, 591, 592
                        <i>write-stmt</i> (R1211), 41, <b>242</b>, 243, 346, 552
                         WRITE= specifier, 265, <b>270</b>
          <b>X</b>
                         X edit descriptor, 290
                        <i>xyz</i>, 30
                        <i>xyz-list</i> (R401), <b>30</b>
                        <i>xyz-name</i> (R402), <b>30</b>
          <b>Z</b>
                         Z edit descriptor, 286
                         zero-size array, 48, 110, 122
